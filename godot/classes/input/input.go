//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package input

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/object"
)

func newSingletonInput() *input {
	obj := &input{}
	ptr := C.godot_global_get_singleton(C.CString("Input"))
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   A Singleton that deals with inputs. This includes key presses, mouse buttons and movement, joypads, and input actions. Actions and their events can be set in the Project Settings / Input Map tab. Or be set with [InputMap].
*/
var Input = newSingletonInput()

/*
   A Singleton that deals with inputs. This includes key presses, mouse buttons and movement, joypads, and input actions. Actions and their events can be set in the Project Settings / Input Map tab. Or be set with [InputMap].
*/
type input struct {
	object.Object
}

func (o *input) baseClass() string {
	return "Input"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *input) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *input) getOwner() *C.godot_object {
	return o.owner
}

/*
   This will simulate pressing the specificed action.
*/
func (o *input) ActionPress(action string) {
	log.Println("Calling Input.ActionPress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "action_press", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   If the specified action is already pressed, this will release it.
*/
func (o *input) ActionRelease(action string) {
	log.Println("Calling Input.ActionRelease()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "action_release", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Add a new mapping entry (in SDL2 format) to the mapping database. Optionally update already connected devices.
*/
func (o *input) AddJoyMapping(mapping string, updateExisting bool) {
	log.Println("Calling Input.AddJoyMapping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(mapping)
	goArguments[1] = reflect.ValueOf(updateExisting)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_joy_mapping", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   If the device has an accelerometer, this will return the movement.
*/
func (o *input) GetAccelerometer() *Vector3 {
	log.Println("Calling Input.GetAccelerometer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_accelerometer", goArguments, "*Vector3")

	returnValue := goRet.Interface().(*Vector3)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns an [Array] containing the device IDs of all currently connected joypads.
*/
func (o *input) GetConnectedJoypads() *Array {
	log.Println("Calling Input.GetConnectedJoypads()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_connected_joypads", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *input) GetGravity() *Vector3 {
	log.Println("Calling Input.GetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_gravity", goArguments, "*Vector3")

	returnValue := goRet.Interface().(*Vector3)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   If the device has a gyroscope, this will return the rate of rotation in rad/s around a device's x, y, and z axis.
*/
func (o *input) GetGyroscope() *Vector3 {
	log.Println("Calling Input.GetGyroscope()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_gyroscope", goArguments, "*Vector3")

	returnValue := goRet.Interface().(*Vector3)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the current value of the joypad axis at given index (see [code]JOY_*[/code] constants in [@Global Scope])
*/
func (o *input) GetJoyAxis(device int64, axis int64) float64 {
	log.Println("Calling Input.GetJoyAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(device)
	goArguments[1] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_joy_axis", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *input) GetJoyAxisIndexFromString(axis string) int64 {
	log.Println("Calling Input.GetJoyAxisIndexFromString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_joy_axis_index_from_string", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *input) GetJoyAxisString(axisIndex int64) string {
	log.Println("Calling Input.GetJoyAxisString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisIndex)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_joy_axis_string", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *input) GetJoyButtonIndexFromString(button string) int64 {
	log.Println("Calling Input.GetJoyButtonIndexFromString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(button)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_joy_button_index_from_string", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *input) GetJoyButtonString(buttonIndex int64) string {
	log.Println("Calling Input.GetJoyButtonString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buttonIndex)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_joy_button_string", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns a SDL2 compatible device guid on platforms that use gamepad remapping. Returns "Default Gamepad" otherwise.
*/
func (o *input) GetJoyGuid(device int64) string {
	log.Println("Calling Input.GetJoyGuid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_joy_guid", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the name of the joypad at the specified device index
*/
func (o *input) GetJoyName(device int64) string {
	log.Println("Calling Input.GetJoyName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_joy_name", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the duration of the current vibration effect in seconds.
*/
func (o *input) GetJoyVibrationDuration(device int64) float64 {
	log.Println("Calling Input.GetJoyVibrationDuration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_joy_vibration_duration", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the strength of the joypad vibration: x is the strength of the weak motor, and y is the strength of the strong motor.
*/
func (o *input) GetJoyVibrationStrength(device int64) *Vector2 {
	log.Println("Calling Input.GetJoyVibrationStrength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_joy_vibration_strength", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the mouse speed for the last time the cursor was moved, and this until the next frame where the mouse moves. This means that even if the mouse is not moving, this function will still return the value of the last motion.
*/
func (o *input) GetLastMouseSpeed() *Vector2 {
	log.Println("Calling Input.GetLastMouseSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_last_mouse_speed", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   If the device has a magnetometer, this will return the magnetic field strength in micro-Tesla for all axes.
*/
func (o *input) GetMagnetometer() *Vector3 {
	log.Println("Calling Input.GetMagnetometer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_magnetometer", goArguments, "*Vector3")

	returnValue := goRet.Interface().(*Vector3)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns mouse buttons as a bitmask. If multiple mouse buttons are pressed at the same time the bits are added together.
*/
func (o *input) GetMouseButtonMask() int64 {
	log.Println("Calling Input.GetMouseButtonMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_mouse_button_mask", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the mouse mode. See the constants for more information.
*/
func (o *input) GetMouseMode() int64 {
	log.Println("Calling Input.GetMouseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_mouse_mode", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] when you start pressing the action event.
*/
func (o *input) IsActionJustPressed(action string) bool {
	log.Println("Calling Input.IsActionJustPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_action_just_pressed", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] when you stop pressing the action event.
*/
func (o *input) IsActionJustReleased(action string) bool {
	log.Println("Calling Input.IsActionJustReleased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_action_just_released", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if you are pressing the action event.
*/
func (o *input) IsActionPressed(action string) bool {
	log.Println("Calling Input.IsActionPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_action_pressed", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if you are pressing the joypad button. (see [code]JOY_*[/code] constants in [@Global Scope])
*/
func (o *input) IsJoyButtonPressed(device int64, button int64) bool {
	log.Println("Calling Input.IsJoyButtonPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(device)
	goArguments[1] = reflect.ValueOf(button)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_joy_button_pressed", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the system knows the specified device. This means that it sets all button and axis indices exactly as defined in the [code]JOY_*[/code] constants (see [@Global Scope]). Unknown joypads are not expected to match these constants, but you can still retrieve events from them.
*/
func (o *input) IsJoyKnown(device int64) bool {
	log.Println("Calling Input.IsJoyKnown()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_joy_known", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if you are pressing the key. You can pass [code]KEY_*[/code], which are pre-defined constants listed in [@Global Scope].
*/
func (o *input) IsKeyPressed(scancode int64) bool {
	log.Println("Calling Input.IsKeyPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scancode)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_key_pressed", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if you are pressing the mouse button. You can pass [code]BUTTON_*[/code], which are pre-defined constants listed in [@Global Scope].
*/
func (o *input) IsMouseButtonPressed(button int64) bool {
	log.Println("Calling Input.IsMouseButtonPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(button)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_mouse_button_pressed", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *input) ParseInputEvent(event *InputEvent) {
	log.Println("Calling Input.ParseInputEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "parse_input_event", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Removes all mappings from the internal db that match the given uid.
*/
func (o *input) RemoveJoyMapping(guid string) {
	log.Println("Calling Input.RemoveJoyMapping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(guid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_joy_mapping", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *input) SetCustomMouseCursor(image *Resource, hotspot *Vector2) {
	log.Println("Calling Input.SetCustomMouseCursor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(image)
	goArguments[1] = reflect.ValueOf(hotspot)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_mouse_cursor", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the mouse mode. See the constants for more information.
*/
func (o *input) SetMouseMode(mode int64) {
	log.Println("Calling Input.SetMouseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mouse_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Starts to vibrate the joypad. Joypads usually come with two rumble motors, a strong and a weak one. weak_magnitude is the strength of the weak motor (between 0 and 1) and strong_magnitude is the strength of the strong motor (between 0 and 1). duration is the duration of the effect in seconds (a duration of 0 will try to play the vibration indefinitely). Note that not every hardware is compatible with long effect durations, it is recommended to restart an effect if in need to play it for more than a few seconds.
*/
func (o *input) StartJoyVibration(device int64, weakMagnitude float64, strongMagnitude float64, duration float64) {
	log.Println("Calling Input.StartJoyVibration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(device)
	goArguments[1] = reflect.ValueOf(weakMagnitude)
	goArguments[2] = reflect.ValueOf(strongMagnitude)
	goArguments[3] = reflect.ValueOf(duration)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "start_joy_vibration", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Stops the vibration of the joypad.
*/
func (o *input) StopJoyVibration(device int64) {
	log.Println("Calling Input.StopJoyVibration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop_joy_vibration", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets the mouse position to the specified vector.
*/
func (o *input) WarpMousePosition(to *Vector2) {
	log.Println("Calling Input.WarpMousePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(to)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "warp_mouse_position", goArguments, "")

	log.Println("  Function successfully completed.")

}
