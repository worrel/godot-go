//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package rigidbody

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/physicsbody"
)

/*
   This is the node that implements full 3D physics. This means that you do not control a RigidBody directly. Instead you can apply forces to it (gravity, impulses, etc.), and the physics simulation will calculate the resulting movement, collision, bouncing, rotating, etc. This node can use custom force integration, for writing complex physics motion behavior per node. This node can shift state between regular Rigid body, Kinematic, Character or Static. Character mode forbids this node from being rotated. As a warning, don't change RigidBody's position every frame or very often. Sporadic changes work fine, but physics runs at a different granularity (fixed hz) than usual rendering (process callback) and maybe even in a separate thread, so changing this from a process loop will yield strange behavior.
*/
type RigidBody struct {
	physicsbody.PhysicsBody
}

func (o *RigidBody) baseClass() string {
	return "RigidBody"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *RigidBody) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *RigidBody) getOwner() *C.godot_object {
	return o.owner
}

/*
   Undocumented
*/
func (o *RigidBody) X_BodyEnterTree(arg0 int64) {
	log.Println("Calling RigidBody.X_BodyEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_enter_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) X_BodyExitTree(arg0 int64) {
	log.Println("Calling RigidBody.X_BodyExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_exit_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) X_DirectStateChanged(arg0 *Object) {
	log.Println("Calling RigidBody.X_DirectStateChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_direct_state_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default it works in addition to the usual physics behavior, but [method set_use_custom_integrator] allows you to disable the default behavior and do fully custom force integration for a body.
*/
func (o *RigidBody) X_IntegrateForces(state *PhysicsDirectBodyState) {
	log.Println("Calling RigidBody.X_IntegrateForces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(state)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_integrate_forces", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Apply a positioned impulse (which will be affected by the body mass and shape). This is the equivalent of hitting a billiard ball with a cue: a force that is applied once, and only once. Both the impulse and the offset from the body origin are in global coordinates.
*/
func (o *RigidBody) ApplyImpulse(position *Vector3, impulse *Vector3) {
	log.Println("Calling RigidBody.ApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_impulse", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Return the current body angular damp. Default is -1.
*/
func (o *RigidBody) GetAngularDamp() float64 {
	log.Println("Calling RigidBody.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_angular_damp", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the current body angular velocity.
*/
func (o *RigidBody) GetAngularVelocity() *Vector3 {
	log.Println("Calling RigidBody.GetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_angular_velocity", goArguments, "*Vector3")

	returnValue := goRet.Interface().(*Vector3)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the current axis lock of the body. One of AXIS_LOCK_* enum.
*/
func (o *RigidBody) GetAxisLock() int64 {
	log.Println("Calling RigidBody.GetAxisLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_axis_lock", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the current body bounciness.
*/
func (o *RigidBody) GetBounce() float64 {
	log.Println("Calling RigidBody.GetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_bounce", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return a list of the bodies colliding with this one. By default, number of max contacts reported is at 0 , see [method set_max_contacts_reported] to increase it.
*/
func (o *RigidBody) GetCollidingBodies() *Array {
	log.Println("Calling RigidBody.GetCollidingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_colliding_bodies", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the current body friction, from 0 (frictionless) to 1 (max friction).
*/
func (o *RigidBody) GetFriction() float64 {
	log.Println("Calling RigidBody.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_friction", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the current body gravity scale.
*/
func (o *RigidBody) GetGravityScale() float64 {
	log.Println("Calling RigidBody.GetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_gravity_scale", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the current body linear damp. Default is -1.
*/
func (o *RigidBody) GetLinearDamp() float64 {
	log.Println("Calling RigidBody.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_linear_damp", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the current body linear velocity.
*/
func (o *RigidBody) GetLinearVelocity() *Vector3 {
	log.Println("Calling RigidBody.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_linear_velocity", goArguments, "*Vector3")

	returnValue := goRet.Interface().(*Vector3)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the current body mass.
*/
func (o *RigidBody) GetMass() float64 {
	log.Println("Calling RigidBody.GetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_mass", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the maximum contacts that can be reported. See [method set_max_contacts_reported].
*/
func (o *RigidBody) GetMaxContactsReported() int64 {
	log.Println("Calling RigidBody.GetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_max_contacts_reported", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the current body mode, see [method set_mode].
*/
func (o *RigidBody) GetMode() int64 {
	log.Println("Calling RigidBody.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_mode", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the current body weight, given standard earth-weight (gravity 9.8).
*/
func (o *RigidBody) GetWeight() float64 {
	log.Println("Calling RigidBody.GetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_weight", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether the body has the ability to fall asleep when not moving. See [method set_can_sleep].
*/
func (o *RigidBody) IsAbleToSleep() bool {
	log.Println("Calling RigidBody.IsAbleToSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_able_to_sleep", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether contact monitoring is enabled.
*/
func (o *RigidBody) IsContactMonitorEnabled() bool {
	log.Println("Calling RigidBody.IsContactMonitorEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_contact_monitor_enabled", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether the body is sleeping.
*/
func (o *RigidBody) IsSleeping() bool {
	log.Println("Calling RigidBody.IsSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_sleeping", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether this body is using continuous collision detection.
*/
func (o *RigidBody) IsUsingContinuousCollisionDetection() bool {
	log.Println("Calling RigidBody.IsUsingContinuousCollisionDetection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_using_continuous_collision_detection", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether the body is using a custom integrator.
*/
func (o *RigidBody) IsUsingCustomIntegrator() bool {
	log.Println("Calling RigidBody.IsUsingCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_using_custom_integrator", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Set the angular damp for this body. Default of -1, cannot be less than -1. If this value is different from -1, any angular damp derived from the world or areas will be overridden.
*/
func (o *RigidBody) SetAngularDamp(angularDamp float64) {
	log.Println("Calling RigidBody.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body angular velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody) SetAngularVelocity(angularVelocity *Vector3) {
	log.Println("Calling RigidBody.SetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_velocity", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the axis lock of the body, from the AXIS_LOCK_* enum. Axis lock stops the body from moving along the specified axis(X/Y/Z) and rotating along the other two axes.
*/
func (o *RigidBody) SetAxisLock(axisLock int64) {
	log.Println("Calling RigidBody.SetAxisLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisLock)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis_lock", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *RigidBody) SetAxisVelocity(axisVelocity *Vector3) {
	log.Println("Calling RigidBody.SetAxisVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis_velocity", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body bounciness, from 0 (no bounciness) to 1 (max bounciness).
*/
func (o *RigidBody) SetBounce(bounce float64) {
	log.Println("Calling RigidBody.SetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounce", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body ability to fall asleep when not moving. This saves an enormous amount of processor time when there are plenty of rigid bodies (non static) in a scene. Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] / [method set_applied_force] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody) SetCanSleep(ableToSleep bool) {
	log.Println("Calling RigidBody.SetCanSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ableToSleep)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_can_sleep", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Enable contact monitoring. This allows the body to emit signals when it collides with another.
*/
func (o *RigidBody) SetContactMonitor(enabled bool) {
	log.Println("Calling RigidBody.SetContactMonitor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_contact_monitor", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body friction, from 0 (frictionless) to 1 (max friction).
*/
func (o *RigidBody) SetFriction(friction float64) {
	log.Println("Calling RigidBody.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the gravity factor. This factor multiplies gravity intensity just for this body.
*/
func (o *RigidBody) SetGravityScale(gravityScale float64) {
	log.Println("Calling RigidBody.SetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravityScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_scale", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the linear damp for this body. Default of -1, cannot be less than -1. If this value is different from -1, any linear damp derived from the world or areas will be overridden.
*/
func (o *RigidBody) SetLinearDamp(linearDamp float64) {
	log.Println("Calling RigidBody.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body linear velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody) SetLinearVelocity(linearVelocity *Vector3) {
	log.Println("Calling RigidBody.SetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_velocity", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body mass.
*/
func (o *RigidBody) SetMass(mass float64) {
	log.Println("Calling RigidBody.SetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mass)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mass", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the maximum contacts to report. Bodies can keep a log of the contacts with other bodies, this is enabled by setting the maximum amount of contacts reported to a number greater than 0.
*/
func (o *RigidBody) SetMaxContactsReported(amount int64) {
	log.Println("Calling RigidBody.SetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_contacts_reported", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body mode, from the MODE_* enum. This allows to change to a static body or a character body.
*/
func (o *RigidBody) SetMode(mode int64) {
	log.Println("Calling RigidBody.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set whether a body is sleeping or not. Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody) SetSleeping(sleeping bool) {
	log.Println("Calling RigidBody.SetSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sleeping)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sleeping", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the continuous collision detection mode from the enum CCD_MODE_*. Continuous collision detection tries to predict where a moving body will collide, instead of moving it and correcting its movement if it collided. The first is more precise, and misses less impacts by small, fast-moving objects. The second is faster to compute, but can miss small, fast-moving objects.
*/
func (o *RigidBody) SetUseContinuousCollisionDetection(enable bool) {
	log.Println("Calling RigidBody.SetUseContinuousCollisionDetection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_continuous_collision_detection", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Pass true to disable the internal force integration (like gravity or air friction) for this body. Other than collision response, the body will only move as determined by the [method _integrate_forces] function, if defined.
*/
func (o *RigidBody) SetUseCustomIntegrator(enable bool) {
	log.Println("Calling RigidBody.SetUseCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_custom_integrator", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body weight given standard earth-weight (gravity 9.8).
*/
func (o *RigidBody) SetWeight(weight float64) {
	log.Println("Calling RigidBody.SetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(weight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_weight", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   RigidBodyImplementer is an interface for RigidBody objects.
*/
type RigidBodyImplementer interface {
	class.Class
}
