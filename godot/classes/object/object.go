//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package object

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"
)

/*
   Base class for all non built-in types. Everything not a built-in type starts the inheritance chain from this class. Objects do not manage memory, if inheriting from one the object will most likely have to be deleted manually (call the [method free] function from the script or delete from C++). Some derivatives add memory management, such as [Reference] (which keeps a reference count and deletes itself automatically when no longer referenced) and [Node], which deletes the children tree when deleted. Objects export properties, which are mainly useful for storage and editing, but not really so much in programming. Properties are exported in [method _get_property_list] and handled in [method _get] and [method _set]. However, scripting languages and C++ have simpler means to export them. Objects also receive notifications ([method _notification]). Notifications are a simple way to notify the object about simple events, so they can all be handled together.
*/
type Object struct {
	owner *C.godot_object
}

func (o *Object) baseClass() string {
	return "Object"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Object) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *Object) getOwner() *C.godot_object {
	return o.owner
}

/*
   Return a property, return null if the property does not exist.
*/
func (o *Object) X_Get(property string) {
	log.Println("Calling Object.X_Get()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_get", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Return the property list, array of dictionaries, dictionaries must contain: name:String, type:int (see TYPE_* enum in [@Global Scope]) and optionally: hint:int (see PROPERTY_HINT_* in [@Global Scope]), hint_string:String, usage:int (see PROPERTY_USAGE_* in [@Global Scope]).
*/
func (o *Object) X_GetPropertyList() *Array {
	log.Println("Calling Object.X_GetPropertyList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "_get_property_list", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Object) X_Init() {
	log.Println("Calling Object.X_Init()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_init", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Notification request, the notification id is received.
*/
func (o *Object) X_Notification(what int64) {
	log.Println("Calling Object.X_Notification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(what)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_notification", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set a property. Return true if the property was found.
*/
func (o *Object) X_Set(property string, value *Variant) bool {
	log.Println("Calling Object.X_Set()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "_set", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Add a user signal (can be added anytime). Arguments are optional, but can be added as an array of dictionaries, each containing "name" and "type" (from [@Global Scope] TYPE_*).
*/
func (o *Object) AddUserSignal(signal string, arguments *Array) {
	log.Println("Calling Object.AddUserSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(arguments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_user_signal", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Object) Call(method string) *Variant {
	log.Println("Calling Object.Call()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "call", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Object) CallDeferred(method string) *Variant {
	log.Println("Calling Object.CallDeferred()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "call_deferred", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Object) Callv(method string, argArray *Array) *Variant {
	log.Println("Calling Object.Callv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(argArray)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "callv", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return true if this object can translate strings.
*/
func (o *Object) CanTranslateMessages() bool {
	log.Println("Calling Object.CanTranslateMessages()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "can_translate_messages", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Connect a signal to a method at a target (member function). Binds are optional and are passed as extra arguments to the call. Flags specify optional deferred or one shot connections, see enum CONNECT_*. A signal can only be connected once to a method, and it will throw an error if already connected. If you want to avoid this, use [method is_connected] to check.
*/
func (o *Object) Connect(signal string, target *Object, method string, binds *Array, flags int64) int64 {
	log.Println("Calling Object.Connect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)
	goArguments[3] = reflect.ValueOf(binds)
	goArguments[4] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "connect", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Disconnect a signal from a method.
*/
func (o *Object) Disconnect(signal string, target *Object, method string) {
	log.Println("Calling Object.Disconnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Object) EmitSignal(signal string) *Variant {
	log.Println("Calling Object.EmitSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "emit_signal", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Object) Free() {
	log.Println("Calling Object.Free()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "free", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Get a property from the object.
*/
func (o *Object) Get(property string) *Variant {
	log.Println("Calling Object.Get()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the class of the object as a string.
*/
func (o *Object) GetClass() string {
	log.Println("Calling Object.GetClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_class", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns an [Array] of dictionaries with information about signals that are connected to this object. Inside each [Dictionary] there are 3 fields: - "source" is a reference to signal emitter. - "signal_name" is name of connected signal. - "method_name" is a name of method to which signal is connected.
*/
func (o *Object) GetIncomingConnections() *Array {
	log.Println("Calling Object.GetIncomingConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_incoming_connections", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the instance ID. All objects have a unique instance ID.
*/
func (o *Object) GetInstanceId() int64 {
	log.Println("Calling Object.GetInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_instance_id", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return a metadata from the object.
*/
func (o *Object) GetMeta(name string) *Variant {
	log.Println("Calling Object.GetMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_meta", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the list of metadata in the object.
*/
func (o *Object) GetMetaList() *PoolStringArray {
	log.Println("Calling Object.GetMetaList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_meta_list", goArguments, "*PoolStringArray")

	returnValue := goRet.Interface().(*PoolStringArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Object) GetMethodList() *Array {
	log.Println("Calling Object.GetMethodList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_method_list", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the list of properties as an array of dictionaries, dictionaries contain: name:String, type:int (see TYPE_* enum in [@Global Scope]) and optionally: hint:int (see PROPERTY_HINT_* in [@Global Scope]), hint_string:String, usage:int (see PROPERTY_USAGE_* in [@Global Scope]).
*/
func (o *Object) GetPropertyList() *Array {
	log.Println("Calling Object.GetPropertyList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_property_list", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the object script (or null if it doesn't have one).
*/
func (o *Object) GetScript() *Reference {
	log.Println("Calling Object.GetScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_script", goArguments, "*Reference")

	returnValue := goRet.Interface().(*Reference)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Object) GetSignalConnectionList(signal string) *Array {
	log.Println("Calling Object.GetSignalConnectionList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_signal_connection_list", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the list of signals as an array of dictionaries.
*/
func (o *Object) GetSignalList() *Array {
	log.Println("Calling Object.GetSignalList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_signal_list", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return true if a metadata is found with the requested name.
*/
func (o *Object) HasMeta(name string) bool {
	log.Println("Calling Object.HasMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_meta", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Object) HasMethod(method string) bool {
	log.Println("Calling Object.HasMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_method", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Object) HasUserSignal(signal string) bool {
	log.Println("Calling Object.HasUserSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_user_signal", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return true if signal emission blocking is enabled.
*/
func (o *Object) IsBlockingSignals() bool {
	log.Println("Calling Object.IsBlockingSignals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_blocking_signals", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Check the class of the object against a string (including inheritance).
*/
func (o *Object) IsClass(aType string) bool {
	log.Println("Calling Object.IsClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_class", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return true if a connection exists for a given signal and target/method.
*/
func (o *Object) IsConnected(signal string, target *Object, method string) bool {
	log.Println("Calling Object.IsConnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_connected", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Object) IsQueuedForDeletion() bool {
	log.Println("Calling Object.IsQueuedForDeletion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_queued_for_deletion", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Notify the object of something.
*/
func (o *Object) Notification(what int64, reversed bool) {
	log.Println("Calling Object.Notification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(what)
	goArguments[1] = reflect.ValueOf(reversed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "notification", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Object) PropertyListChangedNotify() {
	log.Println("Calling Object.PropertyListChangedNotify()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "property_list_changed_notify", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set property into the object.
*/
func (o *Object) Set(property string, value *Variant) {
	log.Println("Calling Object.Set()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   If set to true, signal emission is blocked.
*/
func (o *Object) SetBlockSignals(enable bool) {
	log.Println("Calling Object.SetBlockSignals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_block_signals", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Define whether this object can translate strings (with calls to [method tr]). Default is true.
*/
func (o *Object) SetMessageTranslation(enable bool) {
	log.Println("Calling Object.SetMessageTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_message_translation", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set a metadata into the object. Metadata is serialized. Metadata can be [i]anything[/i].
*/
func (o *Object) SetMeta(name string, value *Variant) {
	log.Println("Calling Object.SetMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_meta", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set a script into the object, scripts extend the object functionality.
*/
func (o *Object) SetScript(script *Reference) {
	log.Println("Calling Object.SetScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(script)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_script", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Translate a message. Only works if message translation is enabled (which it is by default). See [method set_message_translation].
*/
func (o *Object) Tr(message string) string {
	log.Println("Calling Object.Tr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(message)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "tr", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   ObjectImplementer is an interface for Object objects.
*/
type ObjectImplementer interface {
	class.Class
}
