//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package area

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/collisionobject"
)

/*
   3D area that detects [CollisionObject] nodes overlapping, entering, or exiting. Can also alter or override local physics parameters (gravity, damping).
*/
type Area struct {
	collisionobject.CollisionObject
}

func (o *Area) baseClass() string {
	return "Area"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Area) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *Area) getOwner() *C.godot_object {
	return o.owner
}

/*
   Undocumented
*/
func (o *Area) X_AreaEnterTree(id int64) {
	log.Println("Calling Area.X_AreaEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_enter_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) X_AreaExitTree(id int64) {
	log.Println("Calling Area.X_AreaExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_exit_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) X_AreaInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area.X_AreaInout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)
	goArguments[3] = reflect.ValueOf(arg3)
	goArguments[4] = reflect.ValueOf(arg4)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_inout", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) X_BodyEnterTree(id int64) {
	log.Println("Calling Area.X_BodyEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_enter_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) X_BodyExitTree(id int64) {
	log.Println("Calling Area.X_BodyExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_exit_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) X_BodyInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area.X_BodyInout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)
	goArguments[3] = reflect.ValueOf(arg3)
	goArguments[4] = reflect.ValueOf(arg4)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_inout", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Return the angular damp rate.
*/
func (o *Area) GetAngularDamp() float64 {
	log.Println("Calling Area.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_angular_damp", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Area) GetAudioBus() string {
	log.Println("Calling Area.GetAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_audio_bus", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the physics layer this area is in.
*/
func (o *Area) GetCollisionLayer() int64 {
	log.Println("Calling Area.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collision_layer", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return an individual bit on the layer mask.
*/
func (o *Area) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling Area.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collision_layer_bit", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the physics layers this area can scan for collisions.
*/
func (o *Area) GetCollisionMask() int64 {
	log.Println("Calling Area.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collision_mask", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return an individual bit on the collision mask.
*/
func (o *Area) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling Area.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collision_mask_bit", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the gravity intensity.
*/
func (o *Area) GetGravity() float64 {
	log.Println("Calling Area.GetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_gravity", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the falloff factor for point gravity.
*/
func (o *Area) GetGravityDistanceScale() float64 {
	log.Println("Calling Area.GetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_gravity_distance_scale", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the gravity vector. If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area) GetGravityVector() *Vector3 {
	log.Println("Calling Area.GetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_gravity_vector", goArguments, "*Vector3")

	returnValue := goRet.Interface().(*Vector3)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the linear damp rate.
*/
func (o *Area) GetLinearDamp() float64 {
	log.Println("Calling Area.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_linear_damp", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns a list of intersecting [Area]\ s.
*/
func (o *Area) GetOverlappingAreas() *Array {
	log.Println("Calling Area.GetOverlappingAreas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_overlapping_areas", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns a list of intersecting [PhysicsBody]\ s.
*/
func (o *Area) GetOverlappingBodies() *Array {
	log.Println("Calling Area.GetOverlappingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_overlapping_bodies", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the processing order of this area.
*/
func (o *Area) GetPriority() float64 {
	log.Println("Calling Area.GetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_priority", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Area) GetReverbAmount() float64 {
	log.Println("Calling Area.GetReverbAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_reverb_amount", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Area) GetReverbBus() string {
	log.Println("Calling Area.GetReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_reverb_bus", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Area) GetReverbUniformity() float64 {
	log.Println("Calling Area.GetReverbUniformity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_reverb_uniformity", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the space override mode.
*/
func (o *Area) GetSpaceOverrideMode() int64 {
	log.Println("Calling Area.GetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_space_override_mode", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether gravity is a point. A point gravity will attract objects towards it, as opposed to a gravity vector, which moves them in a given direction.
*/
func (o *Area) IsGravityAPoint() bool {
	log.Println("Calling Area.IsGravityAPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_gravity_a_point", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether this area can be detected by other, monitoring, areas.
*/
func (o *Area) IsMonitorable() bool {
	log.Println("Calling Area.IsMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_monitorable", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether this area detects bodies/areas entering/exiting it.
*/
func (o *Area) IsMonitoring() bool {
	log.Println("Calling Area.IsMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_monitoring", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Area) IsOverridingAudioBus() bool {
	log.Println("Calling Area.IsOverridingAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_overriding_audio_bus", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Area) IsUsingReverbBus() bool {
	log.Println("Calling Area.IsUsingReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_using_reverb_bus", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   If [code]true[/code] the given area overlaps the Area.
*/
func (o *Area) OverlapsArea(area *Object) bool {
	log.Println("Calling Area.OverlapsArea()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "overlaps_area", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   If [code]true[/code] the given body overlaps the Area.
*/
func (o *Area) OverlapsBody(body *Object) bool {
	log.Println("Calling Area.OverlapsBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "overlaps_body", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Set the rate at which objects stop spinning in this area, if there are not any other forces making it spin. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops. In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area) SetAngularDamp(angularDamp float64) {
	log.Println("Calling Area.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Area) SetAudioBus(name string) {
	log.Println("Calling Area.SetAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Area) SetAudioBusOverride(enable bool) {
	log.Println("Calling Area.SetAudioBusOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the physics layers this area is in. Collidable objects can exist in any of 32 different layers. These layers are not visual, but more of a tagging system instead. A collidable can use these layers/tags to select with which objects it can collide, using [method set_collision_mask]. A contact is detected if object A is in any of the layers that object B scans, or object B is in any layer scanned by object A.
*/
func (o *Area) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling Area.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionLayer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set/clear individual bits on the layer mask. This makes getting an area in/out of only one layer easier.
*/
func (o *Area) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling Area.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the physics layers this area can scan for collisions.
*/
func (o *Area) SetCollisionMask(collisionMask int64) {
	log.Println("Calling Area.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set/clear individual bits on the collision mask. This makes selecting the areas scanned easier.
*/
func (o *Area) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling Area.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the gravity intensity. This is useful to alter the force of gravity without altering its direction. This value multiplies the gravity vector, whether it is the given vector ([method set_gravity_vector]), or a calculated one (when using a center of gravity).
*/
func (o *Area) SetGravity(gravity float64) {
	log.Println("Calling Area.SetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the falloff factor for point gravity. The greater this value is, the faster the strength of gravity decreases with the square of distance.
*/
func (o *Area) SetGravityDistanceScale(distanceScale float64) {
	log.Println("Calling Area.SetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distanceScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_distance_scale", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   When overriding space parameters, this method sets whether this area has a center of gravity. To set/get the location of the center of gravity, use [method set_gravity_vector]/[method get_gravity_vector].
*/
func (o *Area) SetGravityIsPoint(enable bool) {
	log.Println("Calling Area.SetGravityIsPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_is_point", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the gravity vector. This vector does not have to be normalized. If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area) SetGravityVector(vector *Vector3) {
	log.Println("Calling Area.SetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vector)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_vector", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the rate at which objects stop moving in this area, if there are not any other forces moving it. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops. In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area) SetLinearDamp(linearDamp float64) {
	log.Println("Calling Area.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set whether this area can be detected by other, monitoring, areas. Only areas need to be marked as monitorable. Bodies are always so.
*/
func (o *Area) SetMonitorable(enable bool) {
	log.Println("Calling Area.SetMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitorable", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set whether this area can detect bodies/areas entering/exiting it.
*/
func (o *Area) SetMonitoring(enable bool) {
	log.Println("Calling Area.SetMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitoring", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the order in which the area is processed. Greater values mean the area gets processed first. This is useful for areas which have a space override different from AREA_SPACE_OVERRIDE_DISABLED or AREA_SPACE_OVERRIDE_COMBINE, as they replace values, and are thus order-dependent. Areas with the same priority value get evaluated in an unpredictable order, and should be differentiated if evaluation order is to be important.
*/
func (o *Area) SetPriority(priority float64) {
	log.Println("Calling Area.SetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_priority", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Area) SetReverbAmount(amount float64) {
	log.Println("Calling Area.SetReverbAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_reverb_amount", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Area) SetReverbBus(name string) {
	log.Println("Calling Area.SetReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_reverb_bus", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Area) SetReverbUniformity(amount float64) {
	log.Println("Calling Area.SetReverbUniformity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_reverb_uniformity", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the space override mode. This mode controls how an area affects gravity and damp. AREA_SPACE_OVERRIDE_DISABLED: This area does not affect gravity/damp. These are generally areas that exist only to detect collisions, and objects entering or exiting them. AREA_SPACE_OVERRIDE_COMBINE: This area adds its gravity/damp values to whatever has been calculated so far. This way, many overlapping areas can combine their physics to make interesting effects. AREA_SPACE_OVERRIDE_COMBINE_REPLACE: This area adds its gravity/damp values to whatever has been calculated so far. Then stops taking into account the rest of the areas, even the default one. AREA_SPACE_OVERRIDE_REPLACE: This area replaces any gravity/damp, even the default one, and stops taking into account the rest of the areas. AREA_SPACE_OVERRIDE_REPLACE_COMBINE: This area replaces any gravity/damp calculated so far, but keeps calculating the rest of the areas, down to the default one.
*/
func (o *Area) SetSpaceOverrideMode(enable int64) {
	log.Println("Calling Area.SetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_space_override_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Area) SetUseReverbBus(enable bool) {
	log.Println("Calling Area.SetUseReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_reverb_bus", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   AreaImplementer is an interface for Area objects.
*/
type AreaImplementer interface {
	class.Class
}
