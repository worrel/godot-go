//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package tween

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/node"
)

/*
   Node useful for animations with unknown start and end points, procedural animations, making one node follow another, and other simple behavior. Because it is easy to get it wrong, here is a quick usage example: [codeblock] var tween = get_node("Tween") tween.interpolate_property(get_node("Node2D_to_move"), "transform/origin", Vector2(0,0), Vector2(100,100), 1, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT) tween.start() [/codeblock] Some of the methods of this class require a property name. You can get the property name by hovering over the property in the inspector of the editor. Many of the methods accept [code]trans_type[/code] and [code]ease_type[/code]. The first accepts an TRANS_* constant, and refers to the way the timing of the animation is handled (you might want to see [code]http://easings.net/[/code] for some examples). The second accepts an EASE_* constant, and controls the where [code]trans_type[/code] is applied to the interpolation (in the beginning, the end, or both). If you don't know which transition and easing to pick, you can try different TRANS_* constants with EASE_IN_OUT, and use the one that looks best.
*/
type Tween struct {
	node.Node
}

func (o *Tween) baseClass() string {
	return "Tween"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Tween) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *Tween) getOwner() *C.godot_object {
	return o.owner
}

/*
   Undocumented
*/
func (o *Tween) X_Remove(object *Object, key string, firstOnly bool) {
	log.Println("Calling Tween.X_Remove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(firstOnly)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_remove", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Follow [code]method[/code] of [code]object[/code] and apply the returned value on [code]target_method[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] later. Methods are animated by calling them with consequitive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) FollowMethod(object *Object, method string, initialVal *Variant, target *Object, targetMethod string, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.FollowMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(target)
	goArguments[4] = reflect.ValueOf(targetMethod)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "follow_method", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Follow [code]property[/code] of [code]object[/code] and apply it on [code]target_property[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Note that [code]target:target_property[/code] would equal [code]object:property[/code] at the end of the tween. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) FollowProperty(object *Object, property string, initialVal *Variant, target *Object, targetProperty string, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.FollowProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(target)
	goArguments[4] = reflect.ValueOf(targetProperty)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "follow_property", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the time needed for all tweens to end in seconds, measured from the start. Thus, if you have two tweens, one ending 10 seconds after the start and the other - 20 seconds, it would return 20 seconds, as by that time all tweens would have finished.
*/
func (o *Tween) GetRuntime() float64 {
	log.Println("Calling Tween.GetRuntime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_runtime", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the speed that has been set from editor GUI or [method set_repeat].
*/
func (o *Tween) GetSpeedScale() float64 {
	log.Println("Calling Tween.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_speed_scale", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the process mode that has been set from editor GUI or [method set_tween_process_mode]
*/
func (o *Tween) GetTweenProcessMode() int64 {
	log.Println("Calling Tween.GetTweenProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_tween_process_mode", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Call [code]callback[/code] of [code]object[/code] after [code]duration[/code]. [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
*/
func (o *Tween) InterpolateCallback(object *Object, duration float64, callback string, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) bool {
	log.Println("Calling Tween.InterpolateCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(duration)
	goArguments[2] = reflect.ValueOf(callback)
	goArguments[3] = reflect.ValueOf(arg1)
	goArguments[4] = reflect.ValueOf(arg2)
	goArguments[5] = reflect.ValueOf(arg3)
	goArguments[6] = reflect.ValueOf(arg4)
	goArguments[7] = reflect.ValueOf(arg5)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "interpolate_callback", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Call [code]callback[/code] of [code]object[/code] after [code]duration[/code] on the main thread (similar to [method Object.call_deferred]). [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
*/
func (o *Tween) InterpolateDeferredCallback(object *Object, duration float64, callback string, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) bool {
	log.Println("Calling Tween.InterpolateDeferredCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(duration)
	goArguments[2] = reflect.ValueOf(callback)
	goArguments[3] = reflect.ValueOf(arg1)
	goArguments[4] = reflect.ValueOf(arg2)
	goArguments[5] = reflect.ValueOf(arg3)
	goArguments[6] = reflect.ValueOf(arg4)
	goArguments[7] = reflect.ValueOf(arg5)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "interpolate_deferred_callback", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Animate [code]method[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecutive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) InterpolateMethod(object *Object, method string, initialVal *Variant, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.InterpolateMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(finalVal)
	goArguments[4] = reflect.ValueOf(duration)
	goArguments[5] = reflect.ValueOf(transType)
	goArguments[6] = reflect.ValueOf(easeType)
	goArguments[7] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "interpolate_method", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Animate [code]property[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) InterpolateProperty(object *Object, property string, initialVal *Variant, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.InterpolateProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(finalVal)
	goArguments[4] = reflect.ValueOf(duration)
	goArguments[5] = reflect.ValueOf(transType)
	goArguments[6] = reflect.ValueOf(easeType)
	goArguments[7] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "interpolate_property", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns true if any tweens are currently running, and false otherwise. Note that this method doesn't consider tweens that have ended.
*/
func (o *Tween) IsActive() bool {
	log.Println("Calling Tween.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_active", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns true if repeat has been set from editor GUI or [method set_repeat].
*/
func (o *Tween) IsRepeat() bool {
	log.Println("Calling Tween.IsRepeat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_repeat", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Stop animating and completely remove a tween, given its object and property/method pair. Passing empty String as key will remove all tweens for given object.
*/
func (o *Tween) Remove(object *Object, key string) bool {
	log.Println("Calling Tween.Remove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "remove", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Stop animating and completely remove all tweens.
*/
func (o *Tween) RemoveAll() bool {
	log.Println("Calling Tween.RemoveAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "remove_all", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Resets a tween to the initial value (the one given, not the one before the tween), given its object and property/method pair. Passing empty String as key will reset all tweens for given object.
*/
func (o *Tween) Reset(object *Object, key string) bool {
	log.Println("Calling Tween.Reset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "reset", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Resets all tweens to their initial values (the ones given, not those before the tween).
*/
func (o *Tween) ResetAll() bool {
	log.Println("Calling Tween.ResetAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "reset_all", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Continue animating a stopped tween, given its object and property/method pair. Passing empty String as key will resume all tweens for given object.
*/
func (o *Tween) Resume(object *Object, key string) bool {
	log.Println("Calling Tween.Resume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "resume", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Continue animating all stopped tweens.
*/
func (o *Tween) ResumeAll() bool {
	log.Println("Calling Tween.ResumeAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "resume_all", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Seek the animation to the given [code]time[/code] in seconds.
*/
func (o *Tween) Seek(time float64) bool {
	log.Println("Calling Tween.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(time)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "seek", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Activate/deactivate the tween. You can use this for pausing animations, though [method stop_all] and [method resume_all] might be more fit for this.
*/
func (o *Tween) SetActive(active bool) {
	log.Println("Calling Tween.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Make the tween repeat after all tweens have finished.
*/
func (o *Tween) SetRepeat(repeat bool) {
	log.Println("Calling Tween.SetRepeat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(repeat)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_repeat", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the speed multiplier of the tween. Set it to 1 for normal speed, 2 for two times nromal speed, and 0.5 for half of the normal speed. Setting it to 0 would pause the animation, but you might consider using [method set_active] or [method stop_all] and [method resume_all] for this.
*/
func (o *Tween) SetSpeedScale(speed float64) {
	log.Println("Calling Tween.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed_scale", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set whether the Tween uses [code]_process[/code] or [code]_physics_process[/code] (accepts TWEEN_PROCESS_IDLE and TWEEN_PROCESS_PHYSICS constants, respectively).
*/
func (o *Tween) SetTweenProcessMode(mode int64) {
	log.Println("Calling Tween.SetTweenProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tween_process_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Start the tween node. You can define tweens both before and after this.
*/
func (o *Tween) Start() bool {
	log.Println("Calling Tween.Start()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "start", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Stop animating a tween, given its object and property/method pair. Passing empty String as key will stop all tweens for given object.
*/
func (o *Tween) Stop(object *Object, key string) bool {
	log.Println("Calling Tween.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "stop", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Stop animating all tweens.
*/
func (o *Tween) StopAll() bool {
	log.Println("Calling Tween.StopAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "stop_all", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Animate [code]method[/code] of [code]object[/code] from the value returned by [code]initial.initial_method[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecutive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) TargetingMethod(object *Object, method string, initial *Object, initialMethod string, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.TargetingMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initial)
	goArguments[3] = reflect.ValueOf(initialMethod)
	goArguments[4] = reflect.ValueOf(finalVal)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "targeting_method", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Animate [code]property[/code] of [code]object[/code] from the current value of the [code]initial_val[/code] property of [code]initial[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) TargetingProperty(object *Object, property string, initial *Object, initialVal string, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.TargetingProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initial)
	goArguments[3] = reflect.ValueOf(initialVal)
	goArguments[4] = reflect.ValueOf(finalVal)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "targeting_property", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the current time of the tween.
*/
func (o *Tween) Tell() float64 {
	log.Println("Calling Tween.Tell()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "tell", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   TweenImplementer is an interface for Tween objects.
*/
type TweenImplementer interface {
	class.Class
}
