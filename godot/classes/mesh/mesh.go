//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package mesh

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/resource"
)

/*
   Mesh is a type of [Resource] that contains vertex-array based geometry, divided in [i]surfaces[/i]. Each surface contains a completely separate array and a material used to draw it. Design wise, a mesh with multiple surfaces is preferred to a single surface, because objects created in 3D editing software commonly contain multiple materials.
*/
type Mesh struct {
	resource.Resource
}

func (o *Mesh) baseClass() string {
	return "Mesh"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Mesh) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *Mesh) getOwner() *C.godot_object {
	return o.owner
}

/*
   Calculate a [ConvexPolygonShape] from the mesh.
*/
func (o *Mesh) CreateConvexShape() *Shape {
	log.Println("Calling Mesh.CreateConvexShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "create_convex_shape", goArguments, "*Shape")

	returnValue := goRet.Interface().(*Shape)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Calculate an outline mesh at a defined offset (margin) from the original mesh. Note: Typically returns the vertices in reverse order (e.g. clockwise to anti-clockwise).
*/
func (o *Mesh) CreateOutline(margin float64) *Mesh {
	log.Println("Calling Mesh.CreateOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "create_outline", goArguments, "*Mesh")

	returnValue := goRet.Interface().(*Mesh)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Calculate a [ConcavePolygonShape] from the mesh.
*/
func (o *Mesh) CreateTrimeshShape() *Shape {
	log.Println("Calling Mesh.CreateTrimeshShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "create_trimesh_shape", goArguments, "*Shape")

	returnValue := goRet.Interface().(*Shape)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Generate a [TriangleMesh] from the mesh.
*/
func (o *Mesh) GenerateTriangleMesh() *TriangleMesh {
	log.Println("Calling Mesh.GenerateTriangleMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "generate_triangle_mesh", goArguments, "*TriangleMesh")

	returnValue := goRet.Interface().(*TriangleMesh)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns all the vertices that make up the faces of the mesh. Each three vertices represent one triangle.
*/
func (o *Mesh) GetFaces() *PoolVector3Array {
	log.Println("Calling Mesh.GetFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_faces", goArguments, "*PoolVector3Array")

	returnValue := goRet.Interface().(*PoolVector3Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   MeshImplementer is an interface for Mesh objects.
*/
type MeshImplementer interface {
	class.Class
}
