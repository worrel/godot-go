//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package shape2d

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/resource"
)

/*
   Base class for all 2D Shapes. All 2D shape types inherit from this.
*/
type Shape2D struct {
	resource.Resource
}

func (o *Shape2D) baseClass() string {
	return "Shape2D"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Shape2D) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *Shape2D) getOwner() *C.godot_object {
	return o.owner
}

/*
   Return whether this shape is colliding with another. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the shape to check collisions with ([code]with_shape[/code]), and the transformation matrix of that shape ([code]shape_xform[/code]).
*/
func (o *Shape2D) Collide(localXform *Transform2D, withShape *Shape2D, shapeXform *Transform2D) bool {
	log.Println("Calling Shape2D.Collide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(withShape)
	goArguments[2] = reflect.ValueOf(shapeXform)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "collide", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return a list of the points where this shape touches another. If there are no collisions, the list is empty. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the shape to check collisions with ([code]with_shape[/code]), and the transformation matrix of that shape ([code]shape_xform[/code]).
*/
func (o *Shape2D) CollideAndGetContacts(localXform *Transform2D, withShape *Shape2D, shapeXform *Transform2D) *Variant {
	log.Println("Calling Shape2D.CollideAndGetContacts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(withShape)
	goArguments[2] = reflect.ValueOf(shapeXform)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "collide_and_get_contacts", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether this shape would collide with another, if a given movement was applied. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the movement to test on this shape ([code]local_motion[/code]), the shape to check collisions with ([code]with_shape[/code]), the transformation matrix of that shape ([code]shape_xform[/code]), and the movement to test onto the other object ([code]shape_motion[/code]).
*/
func (o *Shape2D) CollideWithMotion(localXform *Transform2D, localMotion *Vector2, withShape *Shape2D, shapeXform *Transform2D, shapeMotion *Vector2) bool {
	log.Println("Calling Shape2D.CollideWithMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(localMotion)
	goArguments[2] = reflect.ValueOf(withShape)
	goArguments[3] = reflect.ValueOf(shapeXform)
	goArguments[4] = reflect.ValueOf(shapeMotion)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "collide_with_motion", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return a list of the points where this shape would touch another, if a given movement was applied. If there are no collisions, the list is empty. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the movement to test on this shape ([code]local_motion[/code]), the shape to check collisions with ([code]with_shape[/code]), the transformation matrix of that shape ([code]shape_xform[/code]), and the movement to test onto the other object ([code]shape_motion[/code]).
*/
func (o *Shape2D) CollideWithMotionAndGetContacts(localXform *Transform2D, localMotion *Vector2, withShape *Shape2D, shapeXform *Transform2D, shapeMotion *Vector2) *Variant {
	log.Println("Calling Shape2D.CollideWithMotionAndGetContacts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(localMotion)
	goArguments[2] = reflect.ValueOf(withShape)
	goArguments[3] = reflect.ValueOf(shapeXform)
	goArguments[4] = reflect.ValueOf(shapeMotion)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "collide_with_motion_and_get_contacts", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the custom solver bias.
*/
func (o *Shape2D) GetCustomSolverBias() float64 {
	log.Println("Calling Shape2D.GetCustomSolverBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_custom_solver_bias", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Use a custom solver bias. No need to change this unless you really know what you are doing. The solver bias is a factor controlling how much two objects "rebound" off each other, when colliding, to avoid them getting into each other because of numerical imprecision.
*/
func (o *Shape2D) SetCustomSolverBias(bias float64) {
	log.Println("Calling Shape2D.SetCustomSolverBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bias)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_solver_bias", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Shape2DImplementer is an interface for Shape2D objects.
*/
type Shape2DImplementer interface {
	class.Class
}
