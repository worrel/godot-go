//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package raycast2d

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/node2d"
)

/*
   A RayCast represents a line from its origin to its destination position, [code]cast_to[/code]. It is used to query the 2D space in order to find the closest object along the path of the ray. RayCast2D can ignore some objects by adding them to the exception list via [code]add_exception[/code], by setting proper filtering with collision layers, or by filtering object types with type masks. Only enabled raycasts will be able to query the space and report collisions. RayCast2D calculates intersection every physics frame (see [Node]), and the result is cached so it can be used later until the next frame. If multiple queries are required between physics frames (or during the same frame) use [method force_raycast_update] after adjusting the raycast.
*/
type RayCast2D struct {
	node2d.Node2D
}

func (o *RayCast2D) baseClass() string {
	return "RayCast2D"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *RayCast2D) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *RayCast2D) getOwner() *C.godot_object {
	return o.owner
}

/*
   Adds a collision exception so the ray does not report collisions with the specified node.
*/
func (o *RayCast2D) AddException(node *Object) {
	log.Println("Calling RayCast2D.AddException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_exception", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Adds a collision exception so the ray does not report collisions with the specified [RID].
*/
func (o *RayCast2D) AddExceptionRid(rid *RID) {
	log.Println("Calling RayCast2D.AddExceptionRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_exception_rid", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Removes all collision exceptions for this ray.
*/
func (o *RayCast2D) ClearExceptions() {
	log.Println("Calling RayCast2D.ClearExceptions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_exceptions", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Updates the collision information for the ray. Use this method to update the collision information immediately instead of waiting for the next [code]_physics_process[/code] call, for example if the ray or its parent has changed state. Note: [code]enabled == true[/code] is not required for this to work.
*/
func (o *RayCast2D) ForceRaycastUpdate() {
	log.Println("Calling RayCast2D.ForceRaycastUpdate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_raycast_update", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Return the destination point of this ray object.
*/
func (o *RayCast2D) GetCastTo() *Vector2 {
	log.Println("Calling RayCast2D.GetCastTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_cast_to", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the closest object the ray is pointing to. Note that this does not consider the length of the ray, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray. Example: [codeblock] if RayCast2D.is_colliding(): var collider = RayCast2D.get_collider() [/codeblock]
*/
func (o *RayCast2D) GetCollider() *Object {
	log.Println("Calling RayCast2D.GetCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collider", goArguments, "*Object")

	returnValue := goRet.Interface().(*Object)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the collision shape of the closest object the ray is pointing to. Note that this does not consider the length of the ray, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray. Example: [codeblock] if RayCast2D.is_colliding(): var shape = RayCast2D.get_collider_shape() [/codeblock]
*/
func (o *RayCast2D) GetColliderShape() int64 {
	log.Println("Calling RayCast2D.GetColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collider_shape", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the collision layer for this ray.
*/
func (o *RayCast2D) GetCollisionLayer() int64 {
	log.Println("Calling RayCast2D.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collision_layer", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the normal of the intersecting object's shape at the collision point.
*/
func (o *RayCast2D) GetCollisionNormal() *Vector2 {
	log.Println("Calling RayCast2D.GetCollisionNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collision_normal", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the collision point at which the ray intersects the closest object. Note: this point is in the [b]global[/b] coordinate system.
*/
func (o *RayCast2D) GetCollisionPoint() *Vector2 {
	log.Println("Calling RayCast2D.GetCollisionPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collision_point", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns whether this ray should hit your parent node, if it's a body.
*/
func (o *RayCast2D) GetExcludeParentBody() bool {
	log.Println("Calling RayCast2D.GetExcludeParentBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_exclude_parent_body", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the type mask (types of objects to detect) for this ray. The value is a sum (bitwise OR'd) of constants available for [Physics2DDirectSpaceState].
*/
func (o *RayCast2D) GetTypeMask() int64 {
	log.Println("Calling RayCast2D.GetTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_type_mask", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether the closest object the ray is pointing to is colliding with the vector (considering the vector length).
*/
func (o *RayCast2D) IsColliding() bool {
	log.Println("Calling RayCast2D.IsColliding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_colliding", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns whether this raycast is enabled or not.
*/
func (o *RayCast2D) IsEnabled() bool {
	log.Println("Calling RayCast2D.IsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_enabled", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Removes a collision exception so the ray does report collisions with the specified node.
*/
func (o *RayCast2D) RemoveException(node *Object) {
	log.Println("Calling RayCast2D.RemoveException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_exception", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Removes a collision exception so the ray does report collisions with the specified [RID].
*/
func (o *RayCast2D) RemoveExceptionRid(rid *RID) {
	log.Println("Calling RayCast2D.RemoveExceptionRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_exception_rid", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets the ray destination point, so that the ray will test from the ray's origin to [code]local_point[/code]
*/
func (o *RayCast2D) SetCastTo(localPoint *Vector2) {
	log.Println("Calling RayCast2D.SetCastTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localPoint)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cast_to", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the mask to filter objects. Only objects with at least the same mask element set will be detected.
*/
func (o *RayCast2D) SetCollisionLayer(layer int64) {
	log.Println("Calling RayCast2D.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Enables the RayCast2D. Only enabled raycasts will be able to query the space and report collisions.
*/
func (o *RayCast2D) SetEnabled(enabled bool) {
	log.Println("Calling RayCast2D.SetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Toggle whether this ray should hit your parent node, if it's a body.
*/
func (o *RayCast2D) SetExcludeParentBody(mask bool) {
	log.Println("Calling RayCast2D.SetExcludeParentBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclude_parent_body", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the types of objects to detect. For [code]mask[/code] use a logic sum (OR operation) of constants defined in [Physics2DDirectSpaceState], eg. [code]Physics2DDirectSpaceState.TYPE_MASK_STATIC_BODY | Physics2DDirectSpaceState.TYPE_MASK_KINEMATIC_BODY[/code] to detect only those two types.
*/
func (o *RayCast2D) SetTypeMask(mask int64) {
	log.Println("Calling RayCast2D.SetTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_type_mask", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   RayCast2DImplementer is an interface for RayCast2D objects.
*/
type RayCast2DImplementer interface {
	class.Class
}
