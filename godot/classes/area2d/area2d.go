//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package area2d

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/collisionobject2d"
)

/*
   2D area that detects [CollisionObject2D] nodes overlapping, entering, or exiting. Can also alter or override local physics parameters (gravity, damping).
*/
type Area2D struct {
	collisionobject2d.CollisionObject2D
}

func (o *Area2D) baseClass() string {
	return "Area2D"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Area2D) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *Area2D) getOwner() *C.godot_object {
	return o.owner
}

/*
   Undocumented
*/
func (o *Area2D) X_AreaEnterTree(id int64) {
	log.Println("Calling Area2D.X_AreaEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_enter_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) X_AreaExitTree(id int64) {
	log.Println("Calling Area2D.X_AreaExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_exit_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) X_AreaInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area2D.X_AreaInout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)
	goArguments[3] = reflect.ValueOf(arg3)
	goArguments[4] = reflect.ValueOf(arg4)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_area_inout", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) X_BodyEnterTree(id int64) {
	log.Println("Calling Area2D.X_BodyEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_enter_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) X_BodyExitTree(id int64) {
	log.Println("Calling Area2D.X_BodyExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_exit_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) X_BodyInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area2D.X_BodyInout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)
	goArguments[2] = reflect.ValueOf(arg2)
	goArguments[3] = reflect.ValueOf(arg3)
	goArguments[4] = reflect.ValueOf(arg4)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_inout", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Return the angular damp rate.
*/
func (o *Area2D) GetAngularDamp() float64 {
	log.Println("Calling Area2D.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_angular_damp", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Area2D) GetAudioBusName() string {
	log.Println("Calling Area2D.GetAudioBusName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_audio_bus_name", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the physics layer this area is in.
*/
func (o *Area2D) GetCollisionLayer() int64 {
	log.Println("Calling Area2D.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collision_layer", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return an individual bit on the layer mask. Describes whether other areas will collide with this one on the given layer.
*/
func (o *Area2D) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling Area2D.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collision_layer_bit", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the physics layers this area will scan to determine collisions.
*/
func (o *Area2D) GetCollisionMask() int64 {
	log.Println("Calling Area2D.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collision_mask", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return an individual bit on the collision mask. Describes whether this area will collide with others on the given layer.
*/
func (o *Area2D) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling Area2D.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_collision_mask_bit", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the gravity intensity.
*/
func (o *Area2D) GetGravity() float64 {
	log.Println("Calling Area2D.GetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_gravity", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the falloff factor for point gravity.
*/
func (o *Area2D) GetGravityDistanceScale() float64 {
	log.Println("Calling Area2D.GetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_gravity_distance_scale", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the gravity vector. If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area2D) GetGravityVector() *Vector2 {
	log.Println("Calling Area2D.GetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_gravity_vector", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the linear damp rate.
*/
func (o *Area2D) GetLinearDamp() float64 {
	log.Println("Calling Area2D.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_linear_damp", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns a list of intersecting [Area2D]\ s.
*/
func (o *Area2D) GetOverlappingAreas() *Array {
	log.Println("Calling Area2D.GetOverlappingAreas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_overlapping_areas", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns a list of intersecting [PhysicsBody2D]\ s.
*/
func (o *Area2D) GetOverlappingBodies() *Array {
	log.Println("Calling Area2D.GetOverlappingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_overlapping_bodies", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the processing order of this area.
*/
func (o *Area2D) GetPriority() float64 {
	log.Println("Calling Area2D.GetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_priority", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the space override mode.
*/
func (o *Area2D) GetSpaceOverrideMode() int64 {
	log.Println("Calling Area2D.GetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_space_override_mode", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether gravity is a point. A point gravity will attract objects towards it, as opposed to a gravity vector, which moves them in a given direction.
*/
func (o *Area2D) IsGravityAPoint() bool {
	log.Println("Calling Area2D.IsGravityAPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_gravity_a_point", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether this area can be detected by other, monitoring, areas.
*/
func (o *Area2D) IsMonitorable() bool {
	log.Println("Calling Area2D.IsMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_monitorable", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether this area detects bodies/areas entering/exiting it.
*/
func (o *Area2D) IsMonitoring() bool {
	log.Println("Calling Area2D.IsMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_monitoring", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Area2D) IsOverridingAudioBus() bool {
	log.Println("Calling Area2D.IsOverridingAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_overriding_audio_bus", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   If [code]true[/code] the given area overlaps the Area2D.
*/
func (o *Area2D) OverlapsArea(area *Object) bool {
	log.Println("Calling Area2D.OverlapsArea()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "overlaps_area", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   If [code]true[/code] the given body overlaps the Area2D.
*/
func (o *Area2D) OverlapsBody(body *Object) bool {
	log.Println("Calling Area2D.OverlapsBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "overlaps_body", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Set the rate at which objects stop spinning in this area, if there are not any other forces making it spin. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops. In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area2D) SetAngularDamp(angularDamp float64) {
	log.Println("Calling Area2D.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Area2D) SetAudioBusName(name string) {
	log.Println("Calling Area2D.SetAudioBusName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus_name", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Area2D) SetAudioBusOverride(enable bool) {
	log.Println("Calling Area2D.SetAudioBusOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the physics layers this area is in. Collidable objects can exist in any of 32 different layers. These layers are not visual, but more of a tagging system instead. A collidable can use these layers/tags to select with which objects it can collide, using [method set_collision_mask]. A contact is detected if object A is in any of the layers that object B scans, or object B is in any layer scanned by object A.
*/
func (o *Area2D) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling Area2D.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionLayer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set/clear individual bits on the layer mask. This makes getting an area in/out of only one layer easier.
*/
func (o *Area2D) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling Area2D.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the physics layers this area can scan for collisions.
*/
func (o *Area2D) SetCollisionMask(collisionMask int64) {
	log.Println("Calling Area2D.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set/clear individual bits on the collision mask. This makes selecting the areas scanned easier.
*/
func (o *Area2D) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling Area2D.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the gravity intensity. This is useful to alter the force of gravity without altering its direction. This value multiplies the gravity vector, whether it is the given vector ([method set_gravity_vector]), or a calculated one (when using a center of gravity).
*/
func (o *Area2D) SetGravity(gravity float64) {
	log.Println("Calling Area2D.SetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the falloff factor for point gravity. The greater this value is, the faster the strength of gravity decreases with the square of distance.
*/
func (o *Area2D) SetGravityDistanceScale(distanceScale float64) {
	log.Println("Calling Area2D.SetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distanceScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_distance_scale", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   When overriding space parameters, this method sets whether this area has a center of gravity. To set/get the location of the center of gravity, use [method set_gravity_vector]/[method get_gravity_vector].
*/
func (o *Area2D) SetGravityIsPoint(enable bool) {
	log.Println("Calling Area2D.SetGravityIsPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_is_point", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the gravity vector. This vector does not have to be normalized. If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area2D) SetGravityVector(vector *Vector2) {
	log.Println("Calling Area2D.SetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vector)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_vector", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the rate at which objects stop moving in this area, if there are not any other forces moving it. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops. In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area2D) SetLinearDamp(linearDamp float64) {
	log.Println("Calling Area2D.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set whether this area can be detected by other, monitoring, areas. Only areas need to be marked as monitorable. Bodies are always so.
*/
func (o *Area2D) SetMonitorable(enable bool) {
	log.Println("Calling Area2D.SetMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitorable", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set whether this area can detect bodies/areas entering/exiting it.
*/
func (o *Area2D) SetMonitoring(enable bool) {
	log.Println("Calling Area2D.SetMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitoring", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the order in which the area is processed. Greater values mean the area gets processed first. This is useful for areas which have a space override different from AREA_SPACE_OVERRIDE_DISABLED or AREA_SPACE_OVERRIDE_COMBINE, as they replace values, and are thus order-dependent. Areas with the same priority value get evaluated in an unpredictable order, and should be differentiated if evaluation order is to be important.
*/
func (o *Area2D) SetPriority(priority float64) {
	log.Println("Calling Area2D.SetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_priority", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the space override mode. This mode controls how an area affects gravity and damp. AREA_SPACE_OVERRIDE_DISABLED: This area does not affect gravity/damp. These are generally areas that exist only to detect collisions, and objects entering or exiting them. AREA_SPACE_OVERRIDE_COMBINE: This area adds its gravity/damp values to whatever has been calculated so far. This way, many overlapping areas can combine their physics to make interesting effects. AREA_SPACE_OVERRIDE_COMBINE_REPLACE: This area adds its gravity/damp values to whatever has been calculated so far. Then stops taking into account the rest of the areas, even the default one. AREA_SPACE_OVERRIDE_REPLACE: This area replaces any gravity/damp, even the default one, and stops taking into account the rest of the areas. AREA_SPACE_OVERRIDE_REPLACE_COMBINE: This area replaces any gravity/damp calculated so far, but keeps calculating the rest of the areas, down to the default one.
*/
func (o *Area2D) SetSpaceOverrideMode(spaceOverrideMode int64) {
	log.Println("Calling Area2D.SetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(spaceOverrideMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_space_override_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Area2DImplementer is an interface for Area2D objects.
*/
type Area2DImplementer interface {
	class.Class
}
