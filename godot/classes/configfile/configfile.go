//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package configfile

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/reference"
)

/*
   This helper class can be used to store [Variant] values on the filesystem using INI-style formatting. The stored values are indentified by a section and a key: [codeblock] [section] some_key=42 string_example="Hello World!" a_vector=Vector3( 1, 0, 2 ) [/codeblock] The stored data can be saved to or parsed from a file, though ConfigFile objects can also be used directly without accessing the filesystem. The following example shows how to parse an INI-style file from the system, read its contents and store new values in it: [codeblock] var config = ConfigFile.new() var err = config.load("user://settings.cfg") if err == OK: # if not, something went wrong with the file loading # Look for the display/width pair, and default to 1024 if missing var screen_width = get_value("display", "width", 1024) # Store a variable if and only if it hasn't been defined yet if not config.has_section_key("audio", "mute"): config.set_value("audio", "mute", false) # Save the changes by overwriting the previous file config.save("user://settings.cfg") [/codeblock]
*/
type ConfigFile struct {
	reference.Reference
}

func (o *ConfigFile) baseClass() string {
	return "ConfigFile"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *ConfigFile) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *ConfigFile) getOwner() *C.godot_object {
	return o.owner
}

/*
   Deletes the specified section along with all the key-value pairs inside.
*/
func (o *ConfigFile) EraseSection(section string) {
	log.Println("Calling ConfigFile.EraseSection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase_section", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Returns an array of all defined key identifiers in the specified section.
*/
func (o *ConfigFile) GetSectionKeys(section string) *PoolStringArray {
	log.Println("Calling ConfigFile.GetSectionKeys()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_section_keys", goArguments, "*PoolStringArray")

	returnValue := goRet.Interface().(*PoolStringArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns an array of all defined section identifiers.
*/
func (o *ConfigFile) GetSections() *PoolStringArray {
	log.Println("Calling ConfigFile.GetSections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_sections", goArguments, "*PoolStringArray")

	returnValue := goRet.Interface().(*PoolStringArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the current value for the specified section and key. If the section and/or the key do not exist, the method returns the value of the optional [code]default[/code] argument, or [code]null[/code] if it is omitted.
*/
func (o *ConfigFile) GetValue(section string, key string, aDefault *Variant) *Variant {
	log.Println("Calling ConfigFile.GetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(aDefault)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_value", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the specified section exists.
*/
func (o *ConfigFile) HasSection(section string) bool {
	log.Println("Calling ConfigFile.HasSection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_section", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the specified section-key pair exists.
*/
func (o *ConfigFile) HasSectionKey(section string, key string) bool {
	log.Println("Calling ConfigFile.HasSectionKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_section_key", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Loads the config file specified as a parameter. The file's contents are parsed and loaded in the ConfigFile object which the method was called on. Returns one of the [code]OK[/code], [code]FAILED[/code] or [code]ERR_*[/code] constants listed in [@Global Scope]. If the load was successful, the return value is [code]OK[/code].
*/
func (o *ConfigFile) Load(path string) int64 {
	log.Println("Calling ConfigFile.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "load", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Saves the contents of the ConfigFile object to the file specified as a parameter. The output file uses an INI-style structure. Returns one of the [code]OK[/code], [code]FAILED[/code] or [code]ERR_*[/code] constants listed in [@Global Scope]. If the load was successful, the return value is [code]OK[/code].
*/
func (o *ConfigFile) Save(path string) int64 {
	log.Println("Calling ConfigFile.Save()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "save", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Assigns a value to the specified key of the the specified section. If the section and/or the key do not exist, they are created. Passing a [code]null[/code] value deletes the specified key if it exists, and deletes the section if it ends up empty once the key has been removed.
*/
func (o *ConfigFile) SetValue(section string, key string, value *Variant) {
	log.Println("Calling ConfigFile.SetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_value", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   ConfigFileImplementer is an interface for ConfigFile objects.
*/
type ConfigFileImplementer interface {
	class.Class
}
