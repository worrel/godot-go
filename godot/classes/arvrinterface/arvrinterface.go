//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package arvrinterface

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/reference"
)

/*
   This class needs to be implemented to make an AR or VR platform available to Godot and these should be implemented as C++ modules or GDNative modules (note that for GDNative the subclass ARVRScriptInterface should be used). Part of the interface is exposed to GDScript so you can detect, enable and configure an AR or VR platform. Interfaces should be written in such a way that simply enabling them will give us a working setup. You can query the available interfaces through ARVRServer.
*/
type ARVRInterface struct {
	reference.Reference
}

func (o *ARVRInterface) baseClass() string {
	return "ARVRInterface"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *ARVRInterface) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *ARVRInterface) getOwner() *C.godot_object {
	return o.owner
}

/*
   Returns the name of this interface (OpenVR, OpenHMD, ARKit, etc).
*/
func (o *ARVRInterface) GetName() string {
	log.Println("Calling ARVRInterface.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_name", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the resolution at which we should render our intermediate results before things like lens distortion are applied by the VR platform.
*/
func (o *ARVRInterface) GetRecommendedRenderTargetsize() *Vector2 {
	log.Println("Calling ARVRInterface.GetRecommendedRenderTargetsize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_recommended_render_targetsize", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *ARVRInterface) HmdIsPresent() bool {
	log.Println("Calling ARVRInterface.HmdIsPresent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "hmd_is_present", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Call this to initialize this interface. The first interface that is initialized is identified as the primary interface and it will be used for rendering output. After initializing the interface you want to use you then need to enable the AR/VR mode of a viewport and rendering should commence. Note that you must enable the AR/VR mode on the main viewport for any device that uses the main output of Godot such as for mobile VR. If you do this for a platform that handles its own output (such as OpenVR) Godot will show just one eye without distortion on screen. Alternatively you can add a separate viewport node to your scene and enable AR/VR on that viewport and it will be used to output to the HMD leaving you free to do anything you like in the main window such as using a separate camera as a spectator camera or render out something completely different. While currently not used you can activate additional interfaces, you may wish to do this if you want to track controllers from other platforms. However at this point in time only one interface can render to an HMD.
*/
func (o *ARVRInterface) Initialize() bool {
	log.Println("Calling ARVRInterface.Initialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "initialize", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns true if this interface is active.
*/
func (o *ARVRInterface) IsInitialized() bool {
	log.Println("Calling ARVRInterface.IsInitialized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_initialized", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *ARVRInterface) IsInstalled() bool {
	log.Println("Calling ARVRInterface.IsInstalled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_installed", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns true if this interface is currently the primary interface (the interface responsible for showing the output).
*/
func (o *ARVRInterface) IsPrimary() bool {
	log.Println("Calling ARVRInterface.IsPrimary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_primary", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Set this interface to the primary interface (unset the old one).
*/
func (o *ARVRInterface) SetIsPrimary(enable bool) {
	log.Println("Calling ARVRInterface.SetIsPrimary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_is_primary", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ARVRInterface) SupportsHmd() bool {
	log.Println("Calling ARVRInterface.SupportsHmd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "supports_hmd", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Turns the interface off.
*/
func (o *ARVRInterface) Uninitialize() {
	log.Println("Calling ARVRInterface.Uninitialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "uninitialize", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   ARVRInterfaceImplementer is an interface for ARVRInterface objects.
*/
type ARVRInterfaceImplementer interface {
	class.Class
}
