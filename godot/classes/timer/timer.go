//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package timer

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/node"
)

/*
   Counts down a specified interval and emits a signal on reaching 0. Can be set to repeat or "one shot" mode.
*/
type Timer struct {
	node.Node
}

func (o *Timer) baseClass() string {
	return "Timer"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Timer) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *Timer) getOwner() *C.godot_object {
	return o.owner
}

/*
   Return the time left for timeout in seconds if the timer is active, 0 otherwise.
*/
func (o *Timer) GetTimeLeft() float64 {
	log.Println("Calling Timer.GetTimeLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_time_left", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the timer's processing mode.
*/
func (o *Timer) GetTimerProcessMode() int64 {
	log.Println("Calling Timer.GetTimerProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_timer_process_mode", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the wait time in seconds.
*/
func (o *Timer) GetWaitTime() float64 {
	log.Println("Calling Timer.GetWaitTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_wait_time", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return true if set to automatically start when entering the scene.
*/
func (o *Timer) HasAutostart() bool {
	log.Println("Calling Timer.HasAutostart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_autostart", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return true if configured as one-shot.
*/
func (o *Timer) IsOneShot() bool {
	log.Println("Calling Timer.IsOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_one_shot", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return if the timer is paused or not.
*/
func (o *Timer) IsPaused() bool {
	log.Println("Calling Timer.IsPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_paused", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Timer) IsStopped() bool {
	log.Println("Calling Timer.IsStopped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_stopped", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Set to automatically start when entering the scene.
*/
func (o *Timer) SetAutostart(enable bool) {
	log.Println("Calling Timer.SetAutostart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autostart", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set as one-shot. If enabled, the timer will stop after timeout, otherwise it will automatically restart.
*/
func (o *Timer) SetOneShot(enable bool) {
	log.Println("Calling Timer.SetOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_one_shot", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set whether the timer is paused or not. A paused timer will be inactive until it is unpaused again.
*/
func (o *Timer) SetPaused(paused bool) {
	log.Println("Calling Timer.SetPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(paused)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_paused", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the timer's processing mode (fixed or idle, use TIMER_PROCESS_* constants as argument).
*/
func (o *Timer) SetTimerProcessMode(mode int64) {
	log.Println("Calling Timer.SetTimerProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_timer_process_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set wait time in seconds. When the time is over, it will emit the timeout signal.
*/
func (o *Timer) SetWaitTime(timeSec float64) {
	log.Println("Calling Timer.SetWaitTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_wait_time", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Start the Timer.
*/
func (o *Timer) Start() {
	log.Println("Calling Timer.Start()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "start", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Stop (cancel) the Timer.
*/
func (o *Timer) Stop() {
	log.Println("Calling Timer.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   TimerImplementer is an interface for Timer objects.
*/
type TimerImplementer interface {
	class.Class
}
