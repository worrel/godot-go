//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package parallaxbackground

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/canvaslayer"
)

/*
   A ParallaxBackground will use one or more [ParallaxLayer] nodes to create a parallax scrolling background. Each [ParallaxLayer] can be set to move at different speeds relative to the camera movement, this can be used to create an illusion of depth in a 2D game.
*/
type ParallaxBackground struct {
	canvaslayer.CanvasLayer
}

func (o *ParallaxBackground) baseClass() string {
	return "ParallaxBackground"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *ParallaxBackground) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *ParallaxBackground) getOwner() *C.godot_object {
	return o.owner
}

/*
   Undocumented
*/
func (o *ParallaxBackground) X_CameraMoved(arg0 *Transform2D) {
	log.Println("Calling ParallaxBackground.X_CameraMoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_camera_moved", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Return the beginning limit.
*/
func (o *ParallaxBackground) GetLimitBegin() *Vector2 {
	log.Println("Calling ParallaxBackground.GetLimitBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_limit_begin", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the ending limit.
*/
func (o *ParallaxBackground) GetLimitEnd() *Vector2 {
	log.Println("Calling ParallaxBackground.GetLimitEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_limit_end", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the base offset.
*/
func (o *ParallaxBackground) GetScrollBaseOffset() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollBaseOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_scroll_base_offset", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the base motion scale.
*/
func (o *ParallaxBackground) GetScrollBaseScale() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollBaseScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_scroll_base_scale", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *ParallaxBackground) GetScrollOffset() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_scroll_offset", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return ignoring camera zoom.
*/
func (o *ParallaxBackground) IsIgnoreCameraZoom() bool {
	log.Println("Calling ParallaxBackground.IsIgnoreCameraZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_ignore_camera_zoom", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Set to true for all child [ParallaxLayer] nodes to not be affected by the zoom level of the camera.
*/
func (o *ParallaxBackground) SetIgnoreCameraZoom(ignore bool) {
	log.Println("Calling ParallaxBackground.SetIgnoreCameraZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ignore)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ignore_camera_zoom", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the left and top limits in pixels for scrolling to begin. If the camera is outside of this limit the background will not continue to scroll. If an axis is greater than or equal to the corresponding axis of limit_end, then it will not limit scrolling for that axis.
*/
func (o *ParallaxBackground) SetLimitBegin(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetLimitBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit_begin", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the right and bottom limits in pixels for scrolling to end. If the camera is outside of this limit the background will not continue to scroll. If an axis is less than or equal to the corresponding axis of limit_begin, then it will not limit scrolling for that axis.
*/
func (o *ParallaxBackground) SetLimitEnd(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetLimitEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit_end", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the base offset in pixels of all children [ParallaxLayer] nodes.
*/
func (o *ParallaxBackground) SetScrollBaseOffset(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollBaseOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_base_offset", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the base motion scale of all children [ParallaxLayer] nodes.
*/
func (o *ParallaxBackground) SetScrollBaseScale(scale *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollBaseScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_base_scale", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ParallaxBackground) SetScrollOffset(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_offset", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   ParallaxBackgroundImplementer is an interface for ParallaxBackground objects.
*/
type ParallaxBackgroundImplementer interface {
	class.Class
}
