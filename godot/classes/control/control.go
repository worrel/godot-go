//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package control

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/canvasitem"
)

/*
   Base class for all User Interface or [i]UI[/i] related nodes. [code]Control[/code] features a bounding rectangle that defines its extents, an anchor position relative to its parent and margins that represent an offset to the anchor. The margins update automatically when the node, any of its parents, or the screen size change. For more information on Godot's UI system, anchors, margins, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from [code]Control[/code] and [Container] nodes. [b]User Interface nodes and input[/b] Godot sends input events to the scene's root node first, by calling [method Node._input]. [method Node._input] forwards the event down the node tree to the nodes under the mouse cursor, or on keyboard focus. To do so, it calls [method MainLoop._input_event]. Call [method accept_event] so no other node receives the event. Once you accepted an input, it becomes handled so [method Node._unhandled_input] will not process it. Only one [code]Control[/code] node can be in keyboard focus. Only the node in focus will receive keyboard events. To get the foucs, call [method set_focus_mode]. [code]Control[/code] nodes lose focus when another node grabs it, or if you hide the node in focus. Call [method set_ignore_mouse] to tell a [code]Control[/code] node to ignore mouse or touch events. You'll need it if you place an icon on top of a button. [Theme] resources change the Control's appearance. If you change the [Theme] on a [code]Control[/code] node, it affects all of its children. To override some of the theme's parameters, call one of the [code]add_*_override[/code] methods, like [method add_font_override]. You can override the theme with the inspector.
*/
type Control struct {
	canvasitem.CanvasItem
}

func (o *Control) baseClass() string {
	return "Control"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Control) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *Control) getOwner() *C.godot_object {
	return o.owner
}

/*
   Undocumented
*/
func (o *Control) X_FontChanged() {
	log.Println("Calling Control.X_FontChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_font_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Returns the minimum size this Control can shrink to. The node can never be smaller than this minimum size.
*/
func (o *Control) X_GetMinimumSize() *Vector2 {
	log.Println("Calling Control.X_GetMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "_get_minimum_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) X_GetRotationDeg() float64 {
	log.Println("Calling Control.X_GetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "_get_rotation_deg", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) X_GetTooltip() string {
	log.Println("Calling Control.X_GetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "_get_tooltip", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   The node's parent forwards input events to this method. Use it to process and accept inputs on UI elements. See [method accept_event]. Replaces Godot 2's [code]_input_event[/code].
*/
func (o *Control) X_GuiInput(event *InputEvent) {
	log.Println("Calling Control.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_SetAnchor(margin int64, anchor float64) {
	log.Println("Calling Control.X_SetAnchor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(anchor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_anchor", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_SetRotationDeg(degrees float64) {
	log.Println("Calling Control.X_SetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_set_rotation_deg", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_SizeChanged() {
	log.Println("Calling Control.X_SizeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_size_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_ThemeChanged() {
	log.Println("Calling Control.X_ThemeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_theme_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_UpdateMinimumSize() {
	log.Println("Calling Control.X_UpdateMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_update_minimum_size", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Marks an input event as handled. Once you accept an input event, it stops propagating, even to nodes listening to [method Node._unhandled_input] or [method Node._unhandled_key_input].
*/
func (o *Control) AcceptEvent() {
	log.Println("Calling Control.AcceptEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "accept_event", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides the color in the [theme] resource the node uses.
*/
func (o *Control) AddColorOverride(name string, color *Color) {
	log.Println("Calling Control.AddColorOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_color_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides an integer constant in the [theme] resource the node uses. If the [code]constant[code] is invalid, Godot clears the override. See [member Theme.INVALID_CONSTANT] for more information.
*/
func (o *Control) AddConstantOverride(name string, constant int64) {
	log.Println("Calling Control.AddConstantOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(constant)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_constant_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] font in the [theme] resource the node uses. If [code]font[/code] is empty, Godot clears the override.
*/
func (o *Control) AddFontOverride(name string, font *Font) {
	log.Println("Calling Control.AddFontOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(font)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_font_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] icon in the [theme] resource the node uses. If [code]icon[/code] is empty, Godot clears the override.
*/
func (o *Control) AddIconOverride(name string, texture *Texture) {
	log.Println("Calling Control.AddIconOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] shader in the [theme] resource the node uses. If [code]shader[/code] is empty, Godot clears the override.
*/
func (o *Control) AddShaderOverride(name string, shader *Shader) {
	log.Println("Calling Control.AddShaderOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(shader)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_shader_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] [Stylebox] in the [theme] resource the node uses. If [code]stylebox[/code] is empty, Godot clears the override.
*/
func (o *Control) AddStyleOverride(name string, stylebox *StyleBox) {
	log.Println("Calling Control.AddStyleOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(stylebox)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_style_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) CanDropData(position *Vector2, data *Variant) bool {
	log.Println("Calling Control.CanDropData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "can_drop_data", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) DropData(position *Vector2, data *Variant) {
	log.Println("Calling Control.DropData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "drop_data", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) ForceDrag(data *Variant, preview *Object) {
	log.Println("Calling Control.ForceDrag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(data)
	goArguments[1] = reflect.ValueOf(preview)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_drag", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Return the anchor type (ANCHOR_BEGIN, ANCHOR_END, ANCHOR_RATIO) for a given margin (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM).
*/
func (o *Control) GetAnchor(margin int64) float64 {
	log.Println("Calling Control.GetAnchor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_anchor", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetBegin() *Vector2 {
	log.Println("Calling Control.GetBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_begin", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetColor(name string, aType string) *Color {
	log.Println("Calling Control.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_color", goArguments, "*Color")

	returnValue := goRet.Interface().(*Color)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetCombinedMinimumSize() *Vector2 {
	log.Println("Calling Control.GetCombinedMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_combined_minimum_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetConstant(name string, aType string) int64 {
	log.Println("Calling Control.GetConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_constant", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the mouse cursor shape the control displays on mouse hover, one of the [code]CURSOR_*[/code] constants.
*/
func (o *Control) GetCursorShape(position *Vector2) int64 {
	log.Println("Calling Control.GetCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_cursor_shape", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetCustomMinimumSize() *Vector2 {
	log.Println("Calling Control.GetCustomMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_custom_minimum_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the default cursor shape for this control. See enum [code]CURSOR_*[/code] for the list of shapes.
*/
func (o *Control) GetDefaultCursorShape() int64 {
	log.Println("Calling Control.GetDefaultCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_default_cursor_shape", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetDragData(position *Vector2) *Object {
	log.Println("Calling Control.GetDragData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_drag_data", goArguments, "*Object")

	returnValue := goRet.Interface().(*Object)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) GetEnd() *Vector2 {
	log.Println("Calling Control.GetEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_end", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the focus access mode for the control (FOCUS_NONE, FOCUS_CLICK, FOCUS_ALL) (see [method set_focus_mode]).
*/
func (o *Control) GetFocusMode() int64 {
	log.Println("Calling Control.GetFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_focus_mode", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the forced neighbour for moving the input focus to. When pressing TAB or directional/joypad directions focus is moved to the next control in that direction. However, the neighbour to move to can be forced with this function.
*/
func (o *Control) GetFocusNeighbour(margin int64) *NodePath {
	log.Println("Calling Control.GetFocusNeighbour()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_focus_neighbour", goArguments, "*NodePath")

	returnValue := goRet.Interface().(*NodePath)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return which control is owning the keyboard focus, or null if no one.
*/
func (o *Control) GetFocusOwner() *Control {
	log.Println("Calling Control.GetFocusOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_focus_owner", goArguments, "*Control")

	returnValue := goRet.Interface().(*Control)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetFont(name string, aType string) *Font {
	log.Println("Calling Control.GetFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_font", goArguments, "*Font")

	returnValue := goRet.Interface().(*Font)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the Control position, relative to the top-left corner of the parent Control and independent of the anchor mode.
*/
func (o *Control) GetGlobalPosition() *Vector2 {
	log.Println("Calling Control.GetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_global_position", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return position and size of the Control, relative to the top-left corner of the [i]window[/i] Control. This is a helper (see [method get_global_position], [method get_size]).
*/
func (o *Control) GetGlobalRect() *Rect2 {
	log.Println("Calling Control.GetGlobalRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_global_rect", goArguments, "*Rect2")

	returnValue := goRet.Interface().(*Rect2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetHGrowDirection() int64 {
	log.Println("Calling Control.GetHGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_h_grow_direction", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Hint for containers, return horizontal positioning flags.
*/
func (o *Control) GetHSizeFlags() int64 {
	log.Println("Calling Control.GetHSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_h_size_flags", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetIcon(name string, aType string) *Texture {
	log.Println("Calling Control.GetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_icon", goArguments, "*Texture")

	returnValue := goRet.Interface().(*Texture)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return a margin offset. Margin can be one of (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM). Offset value being returned depends on the anchor mode.
*/
func (o *Control) GetMargin(margin int64) float64 {
	log.Println("Calling Control.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_margin", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the minimum size this Control can shrink to. A control will never be displayed or resized smaller than its minimum size.
*/
func (o *Control) GetMinimumSize() *Vector2 {
	log.Println("Calling Control.GetMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_minimum_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return when the control is ignoring mouse events (even touchpad events send mouse events).
*/
func (o *Control) GetMouseFilter() int64 {
	log.Println("Calling Control.GetMouseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_mouse_filter", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetParentAreaSize() *Vector2 {
	log.Println("Calling Control.GetParentAreaSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_parent_area_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetParentControl() *Control {
	log.Println("Calling Control.GetParentControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_parent_control", goArguments, "*Control")

	returnValue := goRet.Interface().(*Control)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetPivotOffset() *Vector2 {
	log.Println("Calling Control.GetPivotOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_pivot_offset", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the Control position, relative to the top-left corner of the parent Control and independent of the anchor mode.
*/
func (o *Control) GetPosition() *Vector2 {
	log.Println("Calling Control.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_position", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return position and size of the Control, relative to the top-left corner of the parent Control. This is a helper (see [method get_position], [method get_size]).
*/
func (o *Control) GetRect() *Rect2 {
	log.Println("Calling Control.GetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_rect", goArguments, "*Rect2")

	returnValue := goRet.Interface().(*Rect2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the rotation (in radians)
*/
func (o *Control) GetRotation() float64 {
	log.Println("Calling Control.GetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_rotation", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the rotation (in degrees)
*/
func (o *Control) GetRotationDeg() float64 {
	log.Println("Calling Control.GetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_rotation_deg", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetScale() *Vector2 {
	log.Println("Calling Control.GetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_scale", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the size of the Control, computed from all margins, however the size returned will [b]never be smaller than the minimum size reported by[/b] [method get_minimum_size]. This means that even if end position of the Control rectangle is smaller than the begin position, the Control will still display and interact correctly. (see description, [method get_minimum_size], [method set_margin], [method set_anchor]).
*/
func (o *Control) GetSize() *Vector2 {
	log.Println("Calling Control.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Hint for containers, return the stretch ratio. This value is relative to other stretch ratio, so if this control has 2 and another has 1, this one will be twice as big.
*/
func (o *Control) GetStretchRatio() float64 {
	log.Println("Calling Control.GetStretchRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_stretch_ratio", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetStylebox(name string, aType string) *StyleBox {
	log.Println("Calling Control.GetStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_stylebox", goArguments, "*StyleBox")

	returnValue := goRet.Interface().(*StyleBox)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return a [Theme] override, if one exists (see [method set_theme]).
*/
func (o *Control) GetTheme() *Theme {
	log.Println("Calling Control.GetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_theme", goArguments, "*Theme")

	returnValue := goRet.Interface().(*Theme)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the tooltip, which will appear when the cursor is resting over this control.
*/
func (o *Control) GetTooltip(atPosition *Vector2) string {
	log.Println("Calling Control.GetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(atPosition)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_tooltip", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetVGrowDirection() int64 {
	log.Println("Calling Control.GetVGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_v_grow_direction", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Hint for containers, return vertical positioning flags.
*/
func (o *Control) GetVSizeFlags() int64 {
	log.Println("Calling Control.GetVSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_v_size_flags", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GrabClickFocus() {
	log.Println("Calling Control.GrabClickFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "grab_click_focus", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Steal the focus from another control and become the focused control (see [method set_focus_mode]).
*/
func (o *Control) GrabFocus() {
	log.Println("Calling Control.GrabFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "grab_focus", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) HasColor(name string, aType string) bool {
	log.Println("Calling Control.HasColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_color", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasColorOverride(name string) bool {
	log.Println("Calling Control.HasColorOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_color_override", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasConstant(name string, aType string) bool {
	log.Println("Calling Control.HasConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_constant", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasConstantOverride(name string) bool {
	log.Println("Calling Control.HasConstantOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_constant_override", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether the Control is the current focused control (see [method set_focus_mode]).
*/
func (o *Control) HasFocus() bool {
	log.Println("Calling Control.HasFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_focus", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasFont(name string, aType string) bool {
	log.Println("Calling Control.HasFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_font", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasFontOverride(name string) bool {
	log.Println("Calling Control.HasFontOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_font_override", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasIcon(name string, aType string) bool {
	log.Println("Calling Control.HasIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_icon", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasIconOverride(name string) bool {
	log.Println("Calling Control.HasIconOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_icon_override", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasPoint(point *Vector2) bool {
	log.Println("Calling Control.HasPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_point", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasStylebox(name string, aType string) bool {
	log.Println("Calling Control.HasStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_stylebox", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasStyleboxOverride(name string) bool {
	log.Println("Calling Control.HasStyleboxOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_stylebox_override", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) IsClippingContents() bool {
	log.Println("Calling Control.IsClippingContents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_clipping_contents", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) MinimumSizeChanged() {
	log.Println("Calling Control.MinimumSizeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "minimum_size_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Give up the focus, no other control will be able to receive keyboard input.
*/
func (o *Control) ReleaseFocus() {
	log.Println("Calling Control.ReleaseFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "release_focus", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchor(margin int64, anchor float64, keepMargin bool, pushOppositeAnchor bool) {
	log.Println("Calling Control.SetAnchor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(anchor)
	goArguments[2] = reflect.ValueOf(keepMargin)
	goArguments[3] = reflect.ValueOf(pushOppositeAnchor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchor", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchorAndMargin(margin int64, anchor float64, offset float64, pushOppositeAnchor bool) {
	log.Println("Calling Control.SetAnchorAndMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(anchor)
	goArguments[2] = reflect.ValueOf(offset)
	goArguments[3] = reflect.ValueOf(pushOppositeAnchor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchor_and_margin", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchorsAndMarginsPreset(preset int64, resizeMode int64, margin int64) {
	log.Println("Calling Control.SetAnchorsAndMarginsPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(preset)
	goArguments[1] = reflect.ValueOf(resizeMode)
	goArguments[2] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchors_and_margins_preset", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchorsPreset(preset int64, keepMargin bool) {
	log.Println("Calling Control.SetAnchorsPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(preset)
	goArguments[1] = reflect.ValueOf(keepMargin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchors_preset", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) SetBegin(position *Vector2) {
	log.Println("Calling Control.SetBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_begin", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetClipContents(enable bool) {
	log.Println("Calling Control.SetClipContents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clip_contents", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetCustomMinimumSize(size *Vector2) {
	log.Println("Calling Control.SetCustomMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_minimum_size", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets the default cursor shape for this control. See [code]CURSOR_*[/code] for the list of available cursor shapes. Useful for Godot plugins and applications or games that use the system's mouse cursors.
*/
func (o *Control) SetDefaultCursorShape(shape int64) {
	log.Println("Calling Control.SetDefaultCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_cursor_shape", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetDragForwarding(target *Object) {
	log.Println("Calling Control.SetDragForwarding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(target)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drag_forwarding", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetDragPreview(control *Object) {
	log.Println("Calling Control.SetDragPreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drag_preview", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets MARGIN_RIGHT and MARGIN_BOTTOM at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) SetEnd(position *Vector2) {
	log.Println("Calling Control.SetEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_end", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the focus access mode for the control (FOCUS_NONE, FOCUS_CLICK, FOCUS_ALL). Only one Control can be focused at the same time, and it will receive keyboard signals.
*/
func (o *Control) SetFocusMode(mode int64) {
	log.Println("Calling Control.SetFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_focus_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Force a neighbour for moving the input focus to. When pressing TAB or directional/joypad directions focus is moved to the next control in that direction. However, the neighbour to move to can be forced with this function.
*/
func (o *Control) SetFocusNeighbour(margin int64, neighbour *NodePath) {
	log.Println("Calling Control.SetFocusNeighbour()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(neighbour)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_focus_neighbour", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Move the Control to a new position, relative to the top-left corner of the [i]window[/i] Control, and without changing current anchor mode. (see [method set_margin]).
*/
func (o *Control) SetGlobalPosition(position *Vector2) {
	log.Println("Calling Control.SetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_position", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetHGrowDirection(direction int64) {
	log.Println("Calling Control.SetHGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(direction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_grow_direction", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Hint for containers, set horizontal positioning flags.
*/
func (o *Control) SetHSizeFlags(flags int64) {
	log.Println("Calling Control.SetHSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_size_flags", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set a margin offset. Margin can be one of (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM). Offset value being set depends on the anchor mode.
*/
func (o *Control) SetMargin(margin int64, offset float64) {
	log.Println("Calling Control.SetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetMarginsPreset(preset int64, resizeMode int64, margin int64) {
	log.Println("Calling Control.SetMarginsPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(preset)
	goArguments[1] = reflect.ValueOf(resizeMode)
	goArguments[2] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margins_preset", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set when the control is ignoring mouse events (even touchpad events send mouse events). (see the MOUSE_FILTER_* constants)
*/
func (o *Control) SetMouseFilter(filter int64) {
	log.Println("Calling Control.SetMouseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mouse_filter", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetPivotOffset(pivotOffset *Vector2) {
	log.Println("Calling Control.SetPivotOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pivotOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pivot_offset", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Move the Control to a new position, relative to the top-left corner of the parent Control, changing all margins if needed and without changing current anchor mode. This is a helper (see [method set_margin]).
*/
func (o *Control) SetPosition(position *Vector2) {
	log.Println("Calling Control.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_position", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the rotation (in radians).
*/
func (o *Control) SetRotation(radians float64) {
	log.Println("Calling Control.SetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the rotation (in degrees).
*/
func (o *Control) SetRotationDeg(degrees float64) {
	log.Println("Calling Control.SetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation_deg", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetScale(scale *Vector2) {
	log.Println("Calling Control.SetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scale", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Changes MARGIN_RIGHT and MARGIN_BOTTOM to fit a given size. This is a helper (see [method set_margin]).
*/
func (o *Control) SetSize(size *Vector2) {
	log.Println("Calling Control.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Hint for containers, set the stretch ratio. This value is relative to other stretch ratio, so if this control has 2 and another has 1, this one will be twice as big.
*/
func (o *Control) SetStretchRatio(ratio float64) {
	log.Println("Calling Control.SetStretchRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stretch_ratio", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides the whole [Theme] for this node and all its [code]Control[/code] children.
*/
func (o *Control) SetTheme(theme *Theme) {
	log.Println("Calling Control.SetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(theme)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_theme", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Changes the tooltip text. The tooltip appears when the user's mouse cursor stays idle over this control for a few moments.
*/
func (o *Control) SetTooltip(tooltip string) {
	log.Println("Calling Control.SetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tooltip", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetVGrowDirection(direction int64) {
	log.Println("Calling Control.SetVGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(direction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_grow_direction", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Hint for containers, set vertical positioning flags.
*/
func (o *Control) SetVSizeFlags(flags int64) {
	log.Println("Calling Control.SetVSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_size_flags", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Display a Control as modal. Control must be a subwindow. Modal controls capture the input signals until closed or the area outside them is accessed. When a modal control loses focus, or the ESC key is pressed, they automatically hide. Modal controls are used extensively for popup dialogs and menus.
*/
func (o *Control) ShowModal(exclusive bool) {
	log.Println("Calling Control.ShowModal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exclusive)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "show_modal", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) WarpMouse(toPosition *Vector2) {
	log.Println("Calling Control.WarpMouse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "warp_mouse", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   ControlImplementer is an interface for Control objects.
*/
type ControlImplementer interface {
	class.Class
}
