//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package httpclient

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/reference"
)

/*
   Hyper-text transfer protocol client. Supports SSL and SSL server certificate verification. Can be reused to connect to different hosts and make many requests.
*/
type HTTPClient struct {
	reference.Reference
}

func (o *HTTPClient) baseClass() string {
	return "HTTPClient"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *HTTPClient) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *HTTPClient) getOwner() *C.godot_object {
	return o.owner
}

/*
   Cloces the current connection, allows for reusal of [HTTPClient].
*/
func (o *HTTPClient) Close() {
	log.Println("Calling HTTPClient.Close()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "close", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Connect to a host. This needs to be done before any requests are sent. The host should not have http:// prepended but will strip the protocol identifier if provided. verify_host will check the SSL identity of the host if set to true.
*/
func (o *HTTPClient) ConnectToHost(host string, port int64, useSsl bool, verifyHost bool) int64 {
	log.Println("Calling HTTPClient.ConnectToHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(port)
	goArguments[2] = reflect.ValueOf(useSsl)
	goArguments[3] = reflect.ValueOf(verifyHost)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "connect_to_host", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return current connection.
*/
func (o *HTTPClient) GetConnection() *StreamPeer {
	log.Println("Calling HTTPClient.GetConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_connection", goArguments, "*StreamPeer")

	returnValue := goRet.Interface().(*StreamPeer)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the response's body length.
*/
func (o *HTTPClient) GetResponseBodyLength() int64 {
	log.Println("Calling HTTPClient.GetResponseBodyLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_response_body_length", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the HTTP status code of the response.
*/
func (o *HTTPClient) GetResponseCode() int64 {
	log.Println("Calling HTTPClient.GetResponseCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_response_code", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the response headers.
*/
func (o *HTTPClient) GetResponseHeaders() *PoolStringArray {
	log.Println("Calling HTTPClient.GetResponseHeaders()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_response_headers", goArguments, "*PoolStringArray")

	returnValue := goRet.Interface().(*PoolStringArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns all response headers as dictionary where the case-sensitivity of the keys and values is kept like the server delivers it. A value is a simple String, this string can have more than one value where "; " is used as separator. Structure: ("key":"value1; value2") Example: (content-length:12), (Content-Type:application/json; charset=UTF-8)
*/
func (o *HTTPClient) GetResponseHeadersAsDictionary() *Dictionary {
	log.Println("Calling HTTPClient.GetResponseHeadersAsDictionary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_response_headers_as_dictionary", goArguments, "*Dictionary")

	returnValue := goRet.Interface().(*Dictionary)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns a STATUS_* enum constant. Need to call [method poll] in order to get status updates.
*/
func (o *HTTPClient) GetStatus() int64 {
	log.Println("Calling HTTPClient.GetStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_status", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether this [HTTPClient] has a response available.
*/
func (o *HTTPClient) HasResponse() bool {
	log.Println("Calling HTTPClient.HasResponse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_response", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether blocking mode is enabled.
*/
func (o *HTTPClient) IsBlockingModeEnabled() bool {
	log.Println("Calling HTTPClient.IsBlockingModeEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_blocking_mode_enabled", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether this [HTTPClient] has a response that is chunked.
*/
func (o *HTTPClient) IsResponseChunked() bool {
	log.Println("Calling HTTPClient.IsResponseChunked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_response_chunked", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   This needs to be called in order to have any request processed. Check results with [method get_status]
*/
func (o *HTTPClient) Poll() int64 {
	log.Println("Calling HTTPClient.Poll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "poll", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Generates a GET/POST application/x-www-form-urlencoded style query string from a provided dictionary, e.g.: [codeblock] var fields = {"username": "user", "password": "pass"} String queryString = httpClient.query_string_from_dict(fields) returns:= "username=user&password=pass" [/codeblock]
*/
func (o *HTTPClient) QueryStringFromDict(fields *Dictionary) string {
	log.Println("Calling HTTPClient.QueryStringFromDict()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fields)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "query_string_from_dict", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Reads one chunk from the response.
*/
func (o *HTTPClient) ReadResponseBodyChunk() *PoolByteArray {
	log.Println("Calling HTTPClient.ReadResponseBodyChunk()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "read_response_body_chunk", goArguments, "*PoolByteArray")

	returnValue := goRet.Interface().(*PoolByteArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Sends a request to the connected host. The url is what is normally behind the hostname, i.e. in [code]http://somehost.com/index.php[/code], url would be "index.php". Headers are HTTP request headers. To create a POST request with query strings to push to the server, do: [codeblock] var fields = {"username" : "user", "password" : "pass"} var queryString = httpClient.query_string_from_dict(fields) var headers = ["Content-Type: application/x-www-form-urlencoded", "Content-Length: " + str(queryString.length())] var result = httpClient.request(httpClient.METHOD_POST, "index.php", headers, queryString) [/codeblock]
*/
func (o *HTTPClient) Request(method int64, url string, headers *PoolStringArray, body string) int64 {
	log.Println("Calling HTTPClient.Request()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(url)
	goArguments[2] = reflect.ValueOf(headers)
	goArguments[3] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "request", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Sends a raw request to the connected host. The url is what is normally behind the hostname, i.e. in [code]http://somehost.com/index.php[/code], url would be "index.php". Headers are HTTP request headers. Sends body raw, as a byte array, does not encode it in any way.
*/
func (o *HTTPClient) RequestRaw(method int64, url string, headers *PoolStringArray, body *PoolByteArray) int64 {
	log.Println("Calling HTTPClient.RequestRaw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(url)
	goArguments[2] = reflect.ValueOf(headers)
	goArguments[3] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "request_raw", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Stub function
*/
func (o *HTTPClient) SendBodyData(body *PoolByteArray) int64 {
	log.Println("Calling HTTPClient.SendBodyData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "send_body_data", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Stub function
*/
func (o *HTTPClient) SendBodyText(body string) int64 {
	log.Println("Calling HTTPClient.SendBodyText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "send_body_text", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   If set to true, execution will block until all data is read from the response.
*/
func (o *HTTPClient) SetBlockingMode(enabled bool) {
	log.Println("Calling HTTPClient.SetBlockingMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blocking_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set connection to use, for this client.
*/
func (o *HTTPClient) SetConnection(connection *StreamPeer) {
	log.Println("Calling HTTPClient.SetConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(connection)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_connection", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets the size of the buffer used and maximum bytes to read per iteration. see [method read_response_body_chunk]
*/
func (o *HTTPClient) SetReadChunkSize(bytes int64) {
	log.Println("Calling HTTPClient.SetReadChunkSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_read_chunk_size", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   HTTPClientImplementer is an interface for HTTPClient objects.
*/
type HTTPClientImplementer interface {
	class.Class
}
