//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package regex

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/reference"
)

/*
   Class for finding text patterns in a string using regular expressions. It can not perform replacements. Regular expressions are a way to define patterns of text to be searched. Details on writing patterns are too long to explain here but the Internet is full of tutorials and detailed explanations. Once created, the RegEx object needs to be compiled with the search pattern before it can be used. The search pattern must be escaped first for gdscript before it is escaped for the expression. For example: [code]var exp = RegEx.new()[/code] [code]exp.compile("\\d+")[/code] would be read by RegEx as [code]\d+[/code] Similarly: [code]exp.compile("\"(?:\\\\.|[^\"])*\"")[/code] would be read as [code]"(?:\\.|[^"])*"[/code] Currently supported features: * Capturing [code]()[/code] and non-capturing [code](?:)[/code] groups * Named capturing groups [code](?P<name>)[/code] * Any character [code].[/code] * Shorthand character classes [code]\w \W \s \S \d \D[/code] * User-defined character classes such as [code][A-Za-z][/code] * Simple quantifiers [code]?[/code], [code]*[/code] and [code]+[/code] * Range quantifiers [code]{x,y}[/code] * Lazy (non-greedy) quantifiers [code]*?[/code] * Beginning [code]^[/code] and end [code]$[/code] anchors * Alternation [code]|[/code] * Backreferences [code]\1[/code], [code]\g{1}[/code], and [code]\g<name>[/code] * POSIX character classes [code][[:alnum:]][/code] * Lookahead [code](?=)[/code], [code](?!)[/code] and lookbehind [code](?<=)[/code], [code](?<!)[/code] * ASCII [code]\xFF[/code] and Unicode [code]\uFFFF[/code] code points (in a style similar to Python) * Word boundaries [code]\b[/code], [code]\B[/code]
*/
type RegEx struct {
	reference.Reference
}

func (o *RegEx) baseClass() string {
	return "RegEx"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *RegEx) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *RegEx) getOwner() *C.godot_object {
	return o.owner
}

/*
   This method resets the state of the object, as it was freshly created. Namely, it unassigns the regular expression of this object.
*/
func (o *RegEx) Clear() {
	log.Println("Calling RegEx.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Compiles and assign the search pattern to use.
*/
func (o *RegEx) Compile(pattern string) int64 {
	log.Println("Calling RegEx.Compile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pattern)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "compile", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the number of numeric capturing groups.
*/
func (o *RegEx) GetGroupCount() int64 {
	log.Println("Calling RegEx.GetGroupCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_group_count", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns an array of names of named capturing groups.
*/
func (o *RegEx) GetNames() *Array {
	log.Println("Calling RegEx.GetNames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_names", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the search pattern used to compile the code.
*/
func (o *RegEx) GetPattern() string {
	log.Println("Calling RegEx.GetPattern()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_pattern", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns whether this object has a valid search pattern assigned.
*/
func (o *RegEx) IsValid() bool {
	log.Println("Calling RegEx.IsValid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_valid", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Searches the text for the compiled pattern. Returns a [RegExMatch] container of the first matching result if found, otherwise null. The region to search within can be specified without modifying where the start and end anchor would be.
*/
func (o *RegEx) Search(subject string, offset int64, end int64) *RegExMatch {
	log.Println("Calling RegEx.Search()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(subject)
	goArguments[1] = reflect.ValueOf(offset)
	goArguments[2] = reflect.ValueOf(end)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "search", goArguments, "*RegExMatch")

	returnValue := goRet.Interface().(*RegExMatch)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Searches the text for the compiled pattern and replaces it with the specified string. Escapes and backreferences such as [code]\1[/code] and [code]\g<name>[/code] expanded and resolved. By default only the first instance is replaced but it can be changed for all instances (global replacement). The region to search within can be specified without modifying where the start and end anchor would be.
*/
func (o *RegEx) Sub(subject string, replacement string, all bool, offset int64, end int64) string {
	log.Println("Calling RegEx.Sub()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(subject)
	goArguments[1] = reflect.ValueOf(replacement)
	goArguments[2] = reflect.ValueOf(all)
	goArguments[3] = reflect.ValueOf(offset)
	goArguments[4] = reflect.ValueOf(end)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "sub", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   RegExImplementer is an interface for RegEx objects.
*/
type RegExImplementer interface {
	class.Class
}
