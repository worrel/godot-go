//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package animationplayer

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/node"
)

/*
   An animation player is used for general purpose playback of [Animation] resources. It contains a dictionary of animations (referenced by name) and custom blend times between their transitions. Additionally, animations can be played and blended in different channels.
*/
type AnimationPlayer struct {
	node.Node
}

func (o *AnimationPlayer) baseClass() string {
	return "AnimationPlayer"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *AnimationPlayer) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *AnimationPlayer) getOwner() *C.godot_object {
	return o.owner
}

/*
   Undocumented
*/
func (o *AnimationPlayer) X_AnimationChanged() {
	log.Println("Calling AnimationPlayer.X_AnimationChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_animation_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) X_NodeRemoved(arg0 *Object) {
	log.Println("Calling AnimationPlayer.X_NodeRemoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_node_removed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Add an animation resource to the player, which will be later referenced by the "name" argument.
*/
func (o *AnimationPlayer) AddAnimation(name string, animation *Animation) int64 {
	log.Println("Calling AnimationPlayer.AddAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(animation)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "add_animation", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Used to skip ahead or skip back in an animation. Delta is the time in seconds to skip.
*/
func (o *AnimationPlayer) Advance(delta float64) {
	log.Println("Calling AnimationPlayer.Advance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "advance", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Return the name of the next animation in the queue.
*/
func (o *AnimationPlayer) AnimationGetNext(animFrom string) string {
	log.Println("Calling AnimationPlayer.AnimationGetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animFrom)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "animation_get_next", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Set the name of an animation that will be played after.
*/
func (o *AnimationPlayer) AnimationSetNext(animFrom string, animTo string) {
	log.Println("Calling AnimationPlayer.AnimationSetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "animation_set_next", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   The animation player creates caches for faster access to the nodes it will animate. However, if a specific node is removed, it may not notice it, so clear_caches will force the player to search for the nodes again.
*/
func (o *AnimationPlayer) ClearCaches() {
	log.Println("Calling AnimationPlayer.ClearCaches()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_caches", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   If animations are queued to play, clear them.
*/
func (o *AnimationPlayer) ClearQueue() {
	log.Println("Calling AnimationPlayer.ClearQueue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_queue", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Find an animation name by resource.
*/
func (o *AnimationPlayer) FindAnimation(animation *Animation) string {
	log.Println("Calling AnimationPlayer.FindAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animation)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "find_animation", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get an [Animation] resource by requesting a name.
*/
func (o *AnimationPlayer) GetAnimation(name string) *Animation {
	log.Println("Calling AnimationPlayer.GetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_animation", goArguments, "*Animation")

	returnValue := goRet.Interface().(*Animation)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the list of names of the animations stored in the player.
*/
func (o *AnimationPlayer) GetAnimationList() *PoolStringArray {
	log.Println("Calling AnimationPlayer.GetAnimationList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_animation_list", goArguments, "*PoolStringArray")

	returnValue := goRet.Interface().(*PoolStringArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the mode in which the animation player processes. See [method set_animation_process_mode].
*/
func (o *AnimationPlayer) GetAnimationProcessMode() int64 {
	log.Println("Calling AnimationPlayer.GetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_animation_process_mode", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the name of the animation that will be automatically played when the scene is loaded.
*/
func (o *AnimationPlayer) GetAutoplay() string {
	log.Println("Calling AnimationPlayer.GetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_autoplay", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the blend time between two animations, referenced by their names.
*/
func (o *AnimationPlayer) GetBlendTime(animFrom string, animTo string) float64 {
	log.Println("Calling AnimationPlayer.GetBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_blend_time", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the name of the animation being played.
*/
func (o *AnimationPlayer) GetCurrentAnimation() string {
	log.Println("Calling AnimationPlayer.GetCurrentAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_current_animation", goArguments, "string")

	returnValue := goRet.Interface().(string)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the length (in seconds) of the currently being played animation.
*/
func (o *AnimationPlayer) GetCurrentAnimationLength() float64 {
	log.Println("Calling AnimationPlayer.GetCurrentAnimationLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_current_animation_length", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the position (in seconds) of the currently being played animation.
*/
func (o *AnimationPlayer) GetCurrentAnimationPosition() float64 {
	log.Println("Calling AnimationPlayer.GetCurrentAnimationPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_current_animation_position", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the default blend time between animations.
*/
func (o *AnimationPlayer) GetDefaultBlendTime() float64 {
	log.Println("Calling AnimationPlayer.GetDefaultBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_default_blend_time", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the playback position (in seconds) in an animation channel (or channel 0 if none is provided).
*/
func (o *AnimationPlayer) GetPosition() float64 {
	log.Println("Calling AnimationPlayer.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_position", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return path to root node (see [method set_root]).
*/
func (o *AnimationPlayer) GetRoot() *NodePath {
	log.Println("Calling AnimationPlayer.GetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_root", goArguments, "*NodePath")

	returnValue := goRet.Interface().(*NodePath)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the speed scaling ratio in a given animation channel (or channel 0 if none is provided). Default ratio is [i]1[/i] (no scaling).
*/
func (o *AnimationPlayer) GetSpeedScale() float64 {
	log.Println("Calling AnimationPlayer.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_speed_scale", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Request whether an [Animation] name exist within the player.
*/
func (o *AnimationPlayer) HasAnimation(name string) bool {
	log.Println("Calling AnimationPlayer.HasAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "has_animation", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return true if the player is active.
*/
func (o *AnimationPlayer) IsActive() bool {
	log.Println("Calling AnimationPlayer.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_active", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether an animation is playing.
*/
func (o *AnimationPlayer) IsPlaying() bool {
	log.Println("Calling AnimationPlayer.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_playing", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Play a given animation by the animation name. Custom speed and blend times can be set. If custom speed is negative (-1), 'from_end' being true can play the animation backwards.
*/
func (o *AnimationPlayer) Play(name string, customBlend float64, customSpeed float64, fromEnd bool) {
	log.Println("Calling AnimationPlayer.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(customBlend)
	goArguments[2] = reflect.ValueOf(customSpeed)
	goArguments[3] = reflect.ValueOf(fromEnd)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Play a given animation by the animation name in reverse.
*/
func (o *AnimationPlayer) PlayBackwards(name string, customBlend float64) {
	log.Println("Calling AnimationPlayer.PlayBackwards()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(customBlend)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play_backwards", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Queue an animation for playback once the current one is done.
*/
func (o *AnimationPlayer) Queue(name string) {
	log.Println("Calling AnimationPlayer.Queue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Remove an animation from the player (by supplying the same name used to add it).
*/
func (o *AnimationPlayer) RemoveAnimation(name string) {
	log.Println("Calling AnimationPlayer.RemoveAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_animation", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Rename an existing animation.
*/
func (o *AnimationPlayer) RenameAnimation(name string, newname string) {
	log.Println("Calling AnimationPlayer.RenameAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newname)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_animation", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Seek the animation to a given position in time (in seconds). If 'update' is true, the animation will be updated too, otherwise it will be updated at process time.
*/
func (o *AnimationPlayer) Seek(seconds float64, update bool) {
	log.Println("Calling AnimationPlayer.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(seconds)
	goArguments[1] = reflect.ValueOf(update)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the player as active (playing). If false, it will do nothing.
*/
func (o *AnimationPlayer) SetActive(active bool) {
	log.Println("Calling AnimationPlayer.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the mode in which the animation player processes. By default, it processes on idle time (framerate dependent), but using fixed time works well for animating static collision bodies in 2D and 3D. See enum ANIMATION_PROCESS_*.
*/
func (o *AnimationPlayer) SetAnimationProcessMode(mode int64) {
	log.Println("Calling AnimationPlayer.SetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation_process_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the name of the animation that will be automatically played when the scene is loaded.
*/
func (o *AnimationPlayer) SetAutoplay(name string) {
	log.Println("Calling AnimationPlayer.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autoplay", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Specify a blend time (in seconds) between two animations, referenced by their names.
*/
func (o *AnimationPlayer) SetBlendTime(animFrom string, animTo string, sec float64) {
	log.Println("Calling AnimationPlayer.SetBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)
	goArguments[2] = reflect.ValueOf(sec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blend_time", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the current animation (even if no playback occurs). Using set_current_animation() and set_active() are similar to calling play().
*/
func (o *AnimationPlayer) SetCurrentAnimation(anim string) {
	log.Println("Calling AnimationPlayer.SetCurrentAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_animation", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the default blend time between animations.
*/
func (o *AnimationPlayer) SetDefaultBlendTime(sec float64) {
	log.Println("Calling AnimationPlayer.SetDefaultBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_blend_time", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   AnimationPlayer resolves animation track paths from this node (which is relative to itself), by default root is "..", but it can be changed.
*/
func (o *AnimationPlayer) SetRoot(path *NodePath) {
	log.Println("Calling AnimationPlayer.SetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_root", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set a speed scaling ratio in a given animation channel (or channel 0 if none is provided). Default ratio is [i]1[/i] (no scaling).
*/
func (o *AnimationPlayer) SetSpeedScale(speed float64) {
	log.Println("Calling AnimationPlayer.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed_scale", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Stop the currently playing animation.
*/
func (o *AnimationPlayer) Stop(reset bool) {
	log.Println("Calling AnimationPlayer.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(reset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Stop playback of animations (deprecated).
*/
func (o *AnimationPlayer) StopAll() {
	log.Println("Calling AnimationPlayer.StopAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop_all", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   AnimationPlayerImplementer is an interface for AnimationPlayer objects.
*/
type AnimationPlayerImplementer interface {
	class.Class
}
