//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package rigidbody2d

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/physicsbody2d"
)

/*
   This is the node that implements full 2D physics. This means that you do not control a RigidBody2D directly. Instead you can apply forces to it (gravity, impulses, etc.), and the physics simulation will calculate the resulting movement, collision, bouncing, rotating, etc. This node can use custom force integration, for writing complex physics motion behavior per node. This node can shift state between regular Rigid body, Kinematic, Character or Static. Character mode forbids this node from being rotated. As a warning, don't change RigidBody2D's position every frame or very often. Sporadic changes work fine, but physics runs at a different granularity (fixed hz) than usual rendering (process callback) and maybe even in a separate thread, so changing this from a process loop will yield strange behavior.
*/
type RigidBody2D struct {
	physicsbody2d.PhysicsBody2D
}

func (o *RigidBody2D) baseClass() string {
	return "RigidBody2D"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *RigidBody2D) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *RigidBody2D) getOwner() *C.godot_object {
	return o.owner
}

/*
   Undocumented
*/
func (o *RigidBody2D) X_BodyEnterTree(arg0 int64) {
	log.Println("Calling RigidBody2D.X_BodyEnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_enter_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) X_BodyExitTree(arg0 int64) {
	log.Println("Calling RigidBody2D.X_BodyExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_body_exit_tree", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) X_DirectStateChanged(arg0 *Object) {
	log.Println("Calling RigidBody2D.X_DirectStateChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_direct_state_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default it works in addition to the usual physics behavior, but [method set_use_custom_integrator] allows you to disable the default behavior and do fully custom force integration for a body.
*/
func (o *RigidBody2D) X_IntegrateForces(state *Physics2DDirectBodyState) {
	log.Println("Calling RigidBody2D.X_IntegrateForces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(state)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_integrate_forces", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Add a positioned force to the applied force and torque. As with [method apply_impulse], both the force and the offset from the body origin are in global coordinates.
*/
func (o *RigidBody2D) AddForce(offset *Vector2, force *Vector2) {
	log.Println("Calling RigidBody2D.AddForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(force)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_force", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Apply a positioned impulse (which will be affected by the body mass and shape). This is the equivalent of hitting a billiard ball with a cue: a force that is applied once, and only once. Both the impulse and the offset from the body origin are in global coordinates.
*/
func (o *RigidBody2D) ApplyImpulse(offset *Vector2, impulse *Vector2) {
	log.Println("Calling RigidBody2D.ApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_impulse", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Return the angular damp for this body.
*/
func (o *RigidBody2D) GetAngularDamp() float64 {
	log.Println("Calling RigidBody2D.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_angular_damp", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the body angular velocity. This changes by physics granularity. See [method set_angular_velocity].
*/
func (o *RigidBody2D) GetAngularVelocity() float64 {
	log.Println("Calling RigidBody2D.GetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_angular_velocity", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the applied force vector.
*/
func (o *RigidBody2D) GetAppliedForce() *Vector2 {
	log.Println("Calling RigidBody2D.GetAppliedForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_applied_force", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the torque which is being applied to this body.
*/
func (o *RigidBody2D) GetAppliedTorque() float64 {
	log.Println("Calling RigidBody2D.GetAppliedTorque()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_applied_torque", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the body bounciness.
*/
func (o *RigidBody2D) GetBounce() float64 {
	log.Println("Calling RigidBody2D.GetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_bounce", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return a list of the bodies colliding with this one. By default, number of max contacts reported is at 0 , see [method set_max_contacts_reported] to increase it. You must also enable contact monitor, see [method set_contact_monitor]
*/
func (o *RigidBody2D) GetCollidingBodies() *Array {
	log.Println("Calling RigidBody2D.GetCollidingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_colliding_bodies", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether this body is using continuous collision detection.
*/
func (o *RigidBody2D) GetContinuousCollisionDetectionMode() int64 {
	log.Println("Calling RigidBody2D.GetContinuousCollisionDetectionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_continuous_collision_detection_mode", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the body friction.
*/
func (o *RigidBody2D) GetFriction() float64 {
	log.Println("Calling RigidBody2D.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_friction", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the gravity factor.
*/
func (o *RigidBody2D) GetGravityScale() float64 {
	log.Println("Calling RigidBody2D.GetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_gravity_scale", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the body's moment of inertia. This is usually automatically computed from the mass and the shapes. Note that this doesn't seem to work in a [code]_ready[/code] function: it apparently has not been auto-computed yet.
*/
func (o *RigidBody2D) GetInertia() float64 {
	log.Println("Calling RigidBody2D.GetInertia()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_inertia", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the linear damp for this body.
*/
func (o *RigidBody2D) GetLinearDamp() float64 {
	log.Println("Calling RigidBody2D.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_linear_damp", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the body linear velocity. This changes by physics granularity. See [method set_linear_velocity].
*/
func (o *RigidBody2D) GetLinearVelocity() *Vector2 {
	log.Println("Calling RigidBody2D.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_linear_velocity", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the body mass.
*/
func (o *RigidBody2D) GetMass() float64 {
	log.Println("Calling RigidBody2D.GetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_mass", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the maximum contacts that can be reported. See [method set_max_contacts_reported].
*/
func (o *RigidBody2D) GetMaxContactsReported() int64 {
	log.Println("Calling RigidBody2D.GetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_max_contacts_reported", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the current body mode, see [method set_mode].
*/
func (o *RigidBody2D) GetMode() int64 {
	log.Println("Calling RigidBody2D.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_mode", goArguments, "int64")

	returnValue := goRet.Interface().(int64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the body weight given standard earth-weight (gravity 9.8).
*/
func (o *RigidBody2D) GetWeight() float64 {
	log.Println("Calling RigidBody2D.GetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "get_weight", goArguments, "float64")

	returnValue := goRet.Interface().(float64)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return true if the body has the ability to fall asleep when not moving. See [method set_can_sleep].
*/
func (o *RigidBody2D) IsAbleToSleep() bool {
	log.Println("Calling RigidBody2D.IsAbleToSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_able_to_sleep", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether contact monitoring is enabled.
*/
func (o *RigidBody2D) IsContactMonitorEnabled() bool {
	log.Println("Calling RigidBody2D.IsContactMonitorEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_contact_monitor_enabled", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether the body is sleeping.
*/
func (o *RigidBody2D) IsSleeping() bool {
	log.Println("Calling RigidBody2D.IsSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_sleeping", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return true if the body is not doing any built-in force integration.
*/
func (o *RigidBody2D) IsUsingCustomIntegrator() bool {
	log.Println("Calling RigidBody2D.IsUsingCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "is_using_custom_integrator", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Set the angular damp for this body. If this value is different from -1, any angular damp derived from the world or areas will be overridden.
*/
func (o *RigidBody2D) SetAngularDamp(angularDamp float64) {
	log.Println("Calling RigidBody2D.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body angular velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody2D) SetAngularVelocity(angularVelocity float64) {
	log.Println("Calling RigidBody2D.SetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_velocity", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the applied force vector. This is the equivalent of pushing a box over the ground: the force applied is applied constantly.
*/
func (o *RigidBody2D) SetAppliedForce(force *Vector2) {
	log.Println("Calling RigidBody2D.SetAppliedForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(force)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_applied_force", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set a constant torque which will be applied to this body.
*/
func (o *RigidBody2D) SetAppliedTorque(torque float64) {
	log.Println("Calling RigidBody2D.SetAppliedTorque()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(torque)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_applied_torque", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *RigidBody2D) SetAxisVelocity(axisVelocity *Vector2) {
	log.Println("Calling RigidBody2D.SetAxisVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis_velocity", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body bounciness, from 0 (no bounce) to 1 (full bounce).
*/
func (o *RigidBody2D) SetBounce(bounce float64) {
	log.Println("Calling RigidBody2D.SetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounce", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body ability to fall asleep when not moving. This saves an enormous amount of processor time when there are plenty of rigid bodies (non static) in a scene. Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] / [method set_applied_force] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody2D) SetCanSleep(ableToSleep bool) {
	log.Println("Calling RigidBody2D.SetCanSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ableToSleep)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_can_sleep", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Enable contact monitoring. This allows the body to emit signals when it collides with another.
*/
func (o *RigidBody2D) SetContactMonitor(enabled bool) {
	log.Println("Calling RigidBody2D.SetContactMonitor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_contact_monitor", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the continuous collision detection mode from the enum CCD_MODE_*. Continuous collision detection tries to predict where a moving body will collide, instead of moving it and correcting its movement if it collided. The first is more precise, and misses less impacts by small, fast-moving objects. The second is faster to compute, but can miss small, fast-moving objects.
*/
func (o *RigidBody2D) SetContinuousCollisionDetectionMode(mode int64) {
	log.Println("Calling RigidBody2D.SetContinuousCollisionDetectionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_continuous_collision_detection_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body friction, from 0 (frictionless) to 1 (full friction).
*/
func (o *RigidBody2D) SetFriction(friction float64) {
	log.Println("Calling RigidBody2D.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the gravity factor. This factor multiplies gravity intensity just for this body.
*/
func (o *RigidBody2D) SetGravityScale(gravityScale float64) {
	log.Println("Calling RigidBody2D.SetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravityScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_scale", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body's moment of inertia. This is like mass, but for rotation: it determines how much torque it takes to rotate the body. The moment of inertia is usually computed automatically from the mass and the shapes, but this function allows you to set a custom value. Set 0 (or negative) inertia to return to automatically computing it.
*/
func (o *RigidBody2D) SetInertia(inertia float64) {
	log.Println("Calling RigidBody2D.SetInertia()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(inertia)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_inertia", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the linear damp for this body. If this value is different from -1, any linear damp derived from the world or areas will be overridden.
*/
func (o *RigidBody2D) SetLinearDamp(linearDamp float64) {
	log.Println("Calling RigidBody2D.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body linear velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody2D) SetLinearVelocity(linearVelocity *Vector2) {
	log.Println("Calling RigidBody2D.SetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_velocity", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body mass.
*/
func (o *RigidBody2D) SetMass(mass float64) {
	log.Println("Calling RigidBody2D.SetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mass)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mass", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the maximum contacts to report. Bodies can keep a log of the contacts with other bodies, this is enabled by setting the maximum amount of contacts reported to a number greater than 0.
*/
func (o *RigidBody2D) SetMaxContactsReported(amount int64) {
	log.Println("Calling RigidBody2D.SetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_contacts_reported", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body mode, from the MODE_* enum. This allows to change to a static body or a character body.
*/
func (o *RigidBody2D) SetMode(mode int64) {
	log.Println("Calling RigidBody2D.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set whether a body is sleeping or not. Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] / [method set_applied_force] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody2D) SetSleeping(sleeping bool) {
	log.Println("Calling RigidBody2D.SetSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sleeping)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sleeping", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Pass true to disable the internal force integration (like gravity or air friction) for this body. Other than collision response, the body will only move as determined by the [method _integrate_forces] function, if defined.
*/
func (o *RigidBody2D) SetUseCustomIntegrator(enable bool) {
	log.Println("Calling RigidBody2D.SetUseCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_custom_integrator", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the body weight given standard earth-weight (gravity 9.8). Not really useful for 2D since most measures for this node are in pixels.
*/
func (o *RigidBody2D) SetWeight(weight float64) {
	log.Println("Calling RigidBody2D.SetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(weight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_weight", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Return whether the body would collide, if it tried to move in the given vector. This method allows two extra parameters: A margin, which increases slightly the size of the shapes involved in the collision detection, and an object of type [Physics2DTestMotionResult], which will store additional information about the collision (should there be one).
*/
func (o *RigidBody2D) TestMotion(motion *Vector2, margin float64, result *Physics2DTestMotionResult) bool {
	log.Println("Calling RigidBody2D.TestMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(motion)
	goArguments[1] = reflect.ValueOf(margin)
	goArguments[2] = reflect.ValueOf(result)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "test_motion", goArguments, "bool")

	returnValue := goRet.Interface().(bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   RigidBody2DImplementer is an interface for RigidBody2D objects.
*/
type RigidBody2DImplementer interface {
	class.Class
}
