//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/*.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

package surfacetool

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"github.com/shadowapex/godot-go/godot/classes/class"
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/godot/classes/reference"
)

/*
   The [SurfaceTool] is used to construct a [Mesh] by specifying vertex attributes individually. It can be used to construct a [Mesh] from script. All properties except index need to be added before a call to [method add_vertex]. For example adding vertex colors and UVs looks like [codeblock] var st = SurfaceTool.new() st.begin(Mesh.PRIMITIVE_TRIANGLES) st.add_color(Color(1, 0, 0)) st.add_uv(Vector2(0, 0)) st.add_vertex(Vector3(0, 0, 0)) [/codeblock] The [SurfaceTool] now contains one vertex of a triangle which has a UV coordinate and a specified [Color]. If another vertex were added without calls to [method add_uv] or [method add_color] then the last values would be used. It is very important that vertex attributes are passed [b]before[/b] the call to [method add_vertex], failure to do this will result in an error when committing the vertex information to a mesh.
*/
type SurfaceTool struct {
	reference.Reference
}

func (o *SurfaceTool) baseClass() string {
	return "SurfaceTool"
}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *SurfaceTool) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *SurfaceTool) getOwner() *C.godot_object {
	return o.owner
}

/*
   Add an array of bones for the next Vertex to use.
*/
func (o *SurfaceTool) AddBones(bones *PoolIntArray) {
	log.Println("Calling SurfaceTool.AddBones()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bones)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_bones", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Specify a [Color] for the next Vertex to use.
*/
func (o *SurfaceTool) AddColor(color *Color) {
	log.Println("Calling SurfaceTool.AddColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_color", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Adds an index to index array if you are using indexed Vertices. Does not need to be called before adding Vertex.
*/
func (o *SurfaceTool) AddIndex(index int64) {
	log.Println("Calling SurfaceTool.AddIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_index", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Specify a normal for the next Vertex to use.
*/
func (o *SurfaceTool) AddNormal(normal *Vector3) {
	log.Println("Calling SurfaceTool.AddNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normal)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_normal", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Specify whether current Vertex (if using only Vertex arrays) or current index (if also using index arrays) should utilize smooth normals for normal calculation.
*/
func (o *SurfaceTool) AddSmoothGroup(smooth bool) {
	log.Println("Calling SurfaceTool.AddSmoothGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(smooth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_smooth_group", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Specify a Tangent for the next Vertex to use.
*/
func (o *SurfaceTool) AddTangent(tangent *Plane) {
	log.Println("Calling SurfaceTool.AddTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_tangent", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SurfaceTool) AddToFormat(flags int64) {
	log.Println("Calling SurfaceTool.AddToFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_to_format", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Insert a triangle fan made of array data into [Mesh] being constructed.
*/
func (o *SurfaceTool) AddTriangleFan(vertexes *PoolVector3Array, uvs *PoolVector2Array, colors *PoolColorArray, uv2S *PoolVector2Array, normals *PoolVector3Array, tangents *Array) {
	log.Println("Calling SurfaceTool.AddTriangleFan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(vertexes)
	goArguments[1] = reflect.ValueOf(uvs)
	goArguments[2] = reflect.ValueOf(colors)
	goArguments[3] = reflect.ValueOf(uv2S)
	goArguments[4] = reflect.ValueOf(normals)
	goArguments[5] = reflect.ValueOf(tangents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_triangle_fan", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Specify UV Coordinate for next Vertex to use.
*/
func (o *SurfaceTool) AddUv(uv *Vector2) {
	log.Println("Calling SurfaceTool.AddUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_uv", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Specify an optional second set of UV coordinates for next Vertex to use.
*/
func (o *SurfaceTool) AddUv2(uv2 *Vector2) {
	log.Println("Calling SurfaceTool.AddUv2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv2)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_uv2", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Specify position of current Vertex. Should be called after specifying other vertex properties (e.g. Color, UV).
*/
func (o *SurfaceTool) AddVertex(vertex *Vector3) {
	log.Println("Calling SurfaceTool.AddVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vertex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_vertex", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Specify weight value for next Vertex to use.
*/
func (o *SurfaceTool) AddWeights(weights *PoolRealArray) {
	log.Println("Calling SurfaceTool.AddWeights()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(weights)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_weights", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SurfaceTool) AppendFrom(existing *Mesh, surface int64, transform *Transform) {
	log.Println("Calling SurfaceTool.AppendFrom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(existing)
	goArguments[1] = reflect.ValueOf(surface)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "append_from", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Called before adding any Vertices. Takes the primitive type as an argument (e.g. Mesh.PRIMITIVE_TRIANGLES).
*/
func (o *SurfaceTool) Begin(primitive int64) {
	log.Println("Calling SurfaceTool.Begin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(primitive)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "begin", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Clear all information passed into the surface tool so far.
*/
func (o *SurfaceTool) Clear() {
	log.Println("Calling SurfaceTool.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Returns a constructed [ArrayMesh] from current information passed in. If an existing [ArrayMesh] is passed in as an argument, will add an extra surface to the existing [ArrayMesh].
*/
func (o *SurfaceTool) Commit(existing *ArrayMesh) *ArrayMesh {
	log.Println("Calling SurfaceTool.Commit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(existing)

	// Call the parent method.

	goRet := class.CallParentMethod(o, o.baseClass(), "commit", goArguments, "*ArrayMesh")

	returnValue := goRet.Interface().(*ArrayMesh)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *SurfaceTool) CreateFrom(existing *Mesh, surface int64) {
	log.Println("Calling SurfaceTool.CreateFrom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(existing)
	goArguments[1] = reflect.ValueOf(surface)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_from", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Removes index array by expanding Vertex array.
*/
func (o *SurfaceTool) Deindex() {
	log.Println("Calling SurfaceTool.Deindex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "deindex", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Generates normals from Vertices so you do not have to do it manually.
*/
func (o *SurfaceTool) GenerateNormals() {
	log.Println("Calling SurfaceTool.GenerateNormals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generate_normals", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SurfaceTool) GenerateTangents() {
	log.Println("Calling SurfaceTool.GenerateTangents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generate_tangents", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Shrinks Vertex array by creating an index array. Avoids reusing Vertices.
*/
func (o *SurfaceTool) Index() {
	log.Println("Calling SurfaceTool.Index()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "index", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets [Material] to be used by the [Mesh] you are constructing.
*/
func (o *SurfaceTool) SetMaterial(material *Material) {
	log.Println("Calling SurfaceTool.SetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_material", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   SurfaceToolImplementer is an interface for SurfaceTool objects.
*/
type SurfaceToolImplementer interface {
	class.Class
}
