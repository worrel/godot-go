package godot

//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/classes.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
	"log"
	"unsafe"
)

// Class is an interface for any objects that can have Godot
// inheritance.
type Class interface {
	baseClass() string
	setOwner(object *C.godot_object)
	getOwner() *C.godot_object
}

/*
   The ARVR Anchor point is a spatial node that maps a real world location identified by the AR platform to a position within the game world. For example, as long as plane detection in ARKit is on, ARKit will identify and update the position of planes (tables, floors, etc) and create anchors for them. This node is mapped to one of the anchors through its unique id. When you receive a signal that a new anchor is available you should add this node to your scene for that anchor. You can predefine nodes and set the id and the nodes will simply remain on 0,0,0 until a plane is recognised. Keep in mind that as long as plane detection is enable the size, placing and orientation of an anchor will be updates as the detection logic learns more about the real world out there especially if only part of the surface is in view.
*/
type ARVRAnchor struct {
	Spatial
}

func (o *ARVRAnchor) baseClass() string {
	return "ARVRAnchor"
}

/*
   Undocumented
*/
func (o *ARVRAnchor) GetAnchorId() int64 {
	log.Println("Calling ARVRAnchor.GetAnchorId()")

	returnValue := godotCallInt(o, "get_anchor_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the name given to this anchor.
*/
func (o *ARVRAnchor) GetAnchorName() string {
	log.Println("Calling ARVRAnchor.GetAnchorName()")

	returnValue := godotCallString(o, "get_anchor_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns true if the anchor is being tracked and false if no anchor with this id is currently known.
*/
func (o *ARVRAnchor) GetIsActive() bool {
	log.Println("Calling ARVRAnchor.GetIsActive()")

	returnValue := godotCallBool(o, "get_is_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a plane aligned with our anchor, handy for intersection testing
*/
func (o *ARVRAnchor) GetPlane() *Plane {
	log.Println("Calling ARVRAnchor.GetPlane()")

	returnValue := godotCallPlane(o, "get_plane")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the estimated size of the plane that was detected. Say when the anchor relates to a table in the real world, this is the estimated size of the surface of that table.
*/
func (o *ARVRAnchor) GetSize() *Vector3 {
	log.Println("Calling ARVRAnchor.GetSize()")

	returnValue := godotCallVector3(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ARVRAnchor) SetAnchorId(anchorId int64) {
	log.Println("Calling ARVRAnchor.SetAnchorId()")

	godotCallVoidInt(o, "set_anchor_id", anchorId)
	log.Println("  Function successfully completed.")

}

/*
   ARVRAnchorImplementer is an interface for ARVRAnchor objects.
*/
type ARVRAnchorImplementer interface {
	Class
}

/*
   This is a helper spatial node for our camera, note that if stereoscopic rendering is applicable (VR-HMD) most of the camera properties are ignored as the HMD information overrides them. The only properties that can be trusted are the near and far planes. The position and orientation of this node is automatically updated by the ARVR Server to represent the location of the HMD if such tracking is available and can thus be used by game logic. Note that in contrast to the ARVR Controller the render thread has access to the most up to date tracking data of the HMD and the location of the ARVRCamera can lag a few milliseconds behind what is used for rendering as a result.
*/
type ARVRCamera struct {
	Camera
}

func (o *ARVRCamera) baseClass() string {
	return "ARVRCamera"
}

/*
   ARVRCameraImplementer is an interface for ARVRCamera objects.
*/
type ARVRCameraImplementer interface {
	Class
}

/*
   This is a helper spatial node that is linked to the tracking of controllers. It also offers several handy pass throughs to the state of buttons and such on the controllers. Controllers are linked by their id. You can create controller nodes before the controllers are available. Say your game always uses two controllers (one for each hand) you can predefine the controllers with id 1 and 2 and they will become active as soon as the controllers are identified. If you expect additional controllers to be used you should react to the signals and add ARVRController nodes to your scene. The position of the controller node is automatically updated by the ARVR Server. This makes this node ideal to add child nodes to visualise the controller.
*/
type ARVRController struct {
	Spatial
}

func (o *ARVRController) baseClass() string {
	return "ARVRController"
}

/*
   Undocumented
*/
func (o *ARVRController) GetControllerId() int64 {
	log.Println("Calling ARVRController.GetControllerId()")

	returnValue := godotCallInt(o, "get_controller_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If active, returns the name of the associated controller if provided by the AR/VR SDK used.
*/
func (o *ARVRController) GetControllerName() string {
	log.Println("Calling ARVRController.GetControllerName()")

	returnValue := godotCallString(o, "get_controller_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the hand holding this controller, if known. See TRACKER_* constants in [ARVRPositionalTracker].
*/
func (o *ARVRController) GetHand() int64 {
	log.Println("Calling ARVRController.GetHand()")

	returnValue := godotCallInt(o, "get_hand")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the bound controller is active. ARVR systems attempt to track active controllers.
*/
func (o *ARVRController) GetIsActive() bool {
	log.Println("Calling ARVRController.GetIsActive()")

	returnValue := godotCallBool(o, "get_is_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the value of the given axis for things like triggers, touchpads, etc. that are embedded into the controller.
*/
func (o *ARVRController) GetJoystickAxis(axis int64) float64 {
	log.Println("Calling ARVRController.GetJoystickAxis()")

	returnValue := godotCallFloatInt(o, "get_joystick_axis", axis)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the ID of the joystick object bound to this. Every controller tracked by the ARVR Server that has buttons and axis will also be registered as a joystick within Godot. This means that all the normal joystick tracking and input mapping will work for buttons and axis found on the AR/VR controllers. This ID is purely offered as information so you can link up the controller with its joystick entry.
*/
func (o *ARVRController) GetJoystickId() int64 {
	log.Println("Calling ARVRController.GetJoystickId()")

	returnValue := godotCallInt(o, "get_joystick_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ARVRController) GetRumble() float64 {
	log.Println("Calling ARVRController.GetRumble()")

	returnValue := godotCallFloat(o, "get_rumble")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the button at index [code]button[/code] is pressed.
*/
func (o *ARVRController) IsButtonPressed(button int64) int64 {
	log.Println("Calling ARVRController.IsButtonPressed()")

	returnValue := godotCallIntInt(o, "is_button_pressed", button)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ARVRController) SetControllerId(controllerId int64) {
	log.Println("Calling ARVRController.SetControllerId()")

	godotCallVoidInt(o, "set_controller_id", controllerId)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ARVRController) SetRumble(rumble float64) {
	log.Println("Calling ARVRController.SetRumble()")

	godotCallVoidFloat(o, "set_rumble", rumble)
	log.Println("  Function successfully completed.")

}

/*
   ARVRControllerImplementer is an interface for ARVRController objects.
*/
type ARVRControllerImplementer interface {
	Class
}

/*
   This class needs to be implemented to make an AR or VR platform available to Godot and these should be implemented as C++ modules or GDNative modules (note that for GDNative the subclass ARVRScriptInterface should be used). Part of the interface is exposed to GDScript so you can detect, enable and configure an AR or VR platform. Interfaces should be written in such a way that simply enabling them will give us a working setup. You can query the available interfaces through ARVRServer.
*/
type ARVRInterface struct {
	Reference
}

func (o *ARVRInterface) baseClass() string {
	return "ARVRInterface"
}

/*
   Undocumented
*/
func (o *ARVRInterface) GetAnchorDetectionIsEnabled() bool {
	log.Println("Calling ARVRInterface.GetAnchorDetectionIsEnabled()")

	returnValue := godotCallBool(o, "get_anchor_detection_is_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a combination of flags providing information about the capabilities of this interface.
*/
func (o *ARVRInterface) GetCapabilities() int64 {
	log.Println("Calling ARVRInterface.GetCapabilities()")

	returnValue := godotCallInt(o, "get_capabilities")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the name of this interface (OpenVR, OpenHMD, ARKit, etc).
*/
func (o *ARVRInterface) GetName() string {
	log.Println("Calling ARVRInterface.GetName()")

	returnValue := godotCallString(o, "get_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the resolution at which we should render our intermediate results before things like lens distortion are applied by the VR platform.
*/
func (o *ARVRInterface) GetRenderTargetsize() *Vector2 {
	log.Println("Calling ARVRInterface.GetRenderTargetsize()")

	returnValue := godotCallVector2(o, "get_render_targetsize")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If supported, returns the status of our tracking. This will allow you to provide feedback to the user whether there are issues with positional tracking.
*/
func (o *ARVRInterface) GetTrackingStatus() int64 {
	log.Println("Calling ARVRInterface.GetTrackingStatus()")

	returnValue := godotCallInt(o, "get_tracking_status")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Call this to initialize this interface. The first interface that is initialized is identified as the primary interface and it will be used for rendering output. After initializing the interface you want to use you then need to enable the AR/VR mode of a viewport and rendering should commence. Note that you must enable the AR/VR mode on the main viewport for any device that uses the main output of Godot such as for mobile VR. If you do this for a platform that handles its own output (such as OpenVR) Godot will show just one eye without distortion on screen. Alternatively you can add a separate viewport node to your scene and enable AR/VR on that viewport and it will be used to output to the HMD leaving you free to do anything you like in the main window such as using a separate camera as a spectator camera or render out something completely different. While currently not used you can activate additional interfaces, you may wish to do this if you want to track controllers from other platforms. However at this point in time only one interface can render to an HMD.
*/
func (o *ARVRInterface) Initialize() bool {
	log.Println("Calling ARVRInterface.Initialize()")

	returnValue := godotCallBool(o, "initialize")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ARVRInterface) IsInitialized() bool {
	log.Println("Calling ARVRInterface.IsInitialized()")

	returnValue := godotCallBool(o, "is_initialized")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ARVRInterface) IsPrimary() bool {
	log.Println("Calling ARVRInterface.IsPrimary()")

	returnValue := godotCallBool(o, "is_primary")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns true if the current output of this interface is in stereo.
*/
func (o *ARVRInterface) IsStereo() bool {
	log.Println("Calling ARVRInterface.IsStereo()")

	returnValue := godotCallBool(o, "is_stereo")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ARVRInterface) SetAnchorDetectionIsEnabled(enable bool) {
	log.Println("Calling ARVRInterface.SetAnchorDetectionIsEnabled()")

	godotCallVoidBool(o, "set_anchor_detection_is_enabled", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ARVRInterface) SetIsInitialized(initialized bool) {
	log.Println("Calling ARVRInterface.SetIsInitialized()")

	godotCallVoidBool(o, "set_is_initialized", initialized)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ARVRInterface) SetIsPrimary(enable bool) {
	log.Println("Calling ARVRInterface.SetIsPrimary()")

	godotCallVoidBool(o, "set_is_primary", enable)
	log.Println("  Function successfully completed.")

}

/*
   Turns the interface off.
*/
func (o *ARVRInterface) Uninitialize() {
	log.Println("Calling ARVRInterface.Uninitialize()")

	godotCallVoid(o, "uninitialize")
	log.Println("  Function successfully completed.")

}

/*
   ARVRInterfaceImplementer is an interface for ARVRInterface objects.
*/
type ARVRInterfaceImplementer interface {
	Class
}

/*
   Undocumented
*/
type ARVRInterfaceGDNative struct {
	ARVRInterface
}

func (o *ARVRInterfaceGDNative) baseClass() string {
	return "ARVRInterfaceGDNative"
}

/*
   ARVRInterfaceGDNativeImplementer is an interface for ARVRInterfaceGDNative objects.
*/
type ARVRInterfaceGDNativeImplementer interface {
	Class
}

/*
   This is a special node within the AR/VR system that maps the physical location of the center of our tracking space to the virtual location within our game world. There should be only one of these nodes in your scene and you must have one. All the ARVRCamera, ARVRController and ARVRAnchor nodes should be direct children of this node for spatial tracking to work correctly. It is the position of this node that you update when you're character needs to move through your game world while we're not moving in the real world. Movement in the real world is always in relation to this origin point. So say that your character is driving a car, the ARVROrigin node should be a child node of this car. If you implement a teleport system to move your character, you change the position of this node. Etc.
*/
type ARVROrigin struct {
	Spatial
}

func (o *ARVROrigin) baseClass() string {
	return "ARVROrigin"
}

/*
   Undocumented
*/
func (o *ARVROrigin) GetWorldScale() float64 {
	log.Println("Calling ARVROrigin.GetWorldScale()")

	returnValue := godotCallFloat(o, "get_world_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ARVROrigin) SetWorldScale(worldScale float64) {
	log.Println("Calling ARVROrigin.SetWorldScale()")

	godotCallVoidFloat(o, "set_world_scale", worldScale)
	log.Println("  Function successfully completed.")

}

/*
   ARVROriginImplementer is an interface for ARVROrigin objects.
*/
type ARVROriginImplementer interface {
	Class
}

/*
   An instance of this object represents a device that is tracked such as a controller or anchor point. HMDs aren't represented here as they are fully handled internally. As controllers are turned on and the AR/VR interface detects them instances of this object are automatically added to this list of active tracking objects accessible through the ARVRServer The ARVRController and ARVRAnchor both consume objects of this type and should be the objects you use in game. The positional trackers are just the under the hood objects that make this all work and are mostly exposed so GDNative based interfaces can interact with them.
*/
type ARVRPositionalTracker struct {
	Object
}

func (o *ARVRPositionalTracker) baseClass() string {
	return "ARVRPositionalTracker"
}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) X_SetJoyId(joyId int64) {
	log.Println("Calling ARVRPositionalTracker.X_SetJoyId()")

	godotCallVoidInt(o, "_set_joy_id", joyId)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) X_SetName(name string) {
	log.Println("Calling ARVRPositionalTracker.X_SetName()")

	godotCallVoidString(o, "_set_name", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) X_SetOrientation(orientation *Basis) {
	log.Println("Calling ARVRPositionalTracker.X_SetOrientation()")

	godotCallVoidBasis(o, "_set_orientation", orientation)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) X_SetRwPosition(rwPosition *Vector3) {
	log.Println("Calling ARVRPositionalTracker.X_SetRwPosition()")

	godotCallVoidVector3(o, "_set_rw_position", rwPosition)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) X_SetType(aType int64) {
	log.Println("Calling ARVRPositionalTracker.X_SetType()")

	godotCallVoidInt(o, "_set_type", aType)
	log.Println("  Function successfully completed.")

}

/*
   Returns the hand holding this tracker, if known. See TRACKER_* constants.
*/
func (o *ARVRPositionalTracker) GetHand() int64 {
	log.Println("Calling ARVRPositionalTracker.GetHand()")

	returnValue := godotCallInt(o, "get_hand")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If this is a controller that is being tracked the controller will also be represented by a joystick entry with this id.
*/
func (o *ARVRPositionalTracker) GetJoyId() int64 {
	log.Println("Calling ARVRPositionalTracker.GetJoyId()")

	returnValue := godotCallInt(o, "get_joy_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the controller or anchor point's name if available.
*/
func (o *ARVRPositionalTracker) GetName() string {
	log.Println("Calling ARVRPositionalTracker.GetName()")

	returnValue := godotCallString(o, "get_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the controller's orientation matrix.
*/
func (o *ARVRPositionalTracker) GetOrientation() *Basis {
	log.Println("Calling ARVRPositionalTracker.GetOrientation()")

	returnValue := godotCallBasis(o, "get_orientation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the world-space controller position.
*/
func (o *ARVRPositionalTracker) GetPosition() *Vector3 {
	log.Println("Calling ARVRPositionalTracker.GetPosition()")

	returnValue := godotCallVector3(o, "get_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) GetRumble() float64 {
	log.Println("Calling ARVRPositionalTracker.GetRumble()")

	returnValue := godotCallFloat(o, "get_rumble")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if this device tracks orientation.
*/
func (o *ARVRPositionalTracker) GetTracksOrientation() bool {
	log.Println("Calling ARVRPositionalTracker.GetTracksOrientation()")

	returnValue := godotCallBool(o, "get_tracks_orientation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if this device tracks position.
*/
func (o *ARVRPositionalTracker) GetTracksPosition() bool {
	log.Println("Calling ARVRPositionalTracker.GetTracksPosition()")

	returnValue := godotCallBool(o, "get_tracks_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the transform combining this device's orientation and position.
*/
func (o *ARVRPositionalTracker) GetTransform(adjustByReferenceFrame bool) *Transform {
	log.Println("Calling ARVRPositionalTracker.GetTransform()")

	returnValue := godotCallTransformBool(o, "get_transform", adjustByReferenceFrame)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the tracker's type.
*/
func (o *ARVRPositionalTracker) GetType() int64 {
	log.Println("Calling ARVRPositionalTracker.GetType()")

	returnValue := godotCallInt(o, "get_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ARVRPositionalTracker) SetRumble(rumble float64) {
	log.Println("Calling ARVRPositionalTracker.SetRumble()")

	godotCallVoidFloat(o, "set_rumble", rumble)
	log.Println("  Function successfully completed.")

}

/*
   ARVRPositionalTrackerImplementer is an interface for ARVRPositionalTracker objects.
*/
type ARVRPositionalTrackerImplementer interface {
	Class
}

func newSingletonARVRServer() *arvrServer {
	obj := &arvrServer{}
	name := C.CString("ARVRServer")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   The AR/VR Server is the heart of our AR/VR solution and handles all the processing.
*/
var ARVRServer = newSingletonARVRServer()

/*
   The AR/VR Server is the heart of our AR/VR solution and handles all the processing.
*/
type arvrServer struct {
	Object
}

func (o *arvrServer) baseClass() string {
	return "ARVRServer"
}

/*
   This is a really important function to understand correctly. AR and VR platforms all handle positioning slightly differently. For platforms that do not offer spatial tracking our origin point (0,0,0) is the location of our HMD but you have little control over the direction the player is facing in the real world. For platforms that do offer spatial tracking our origin point depends very much on the system. For OpenVR our origin point is usually the center of the tracking space, on the ground. For other platforms its often the location of the tracking camera. This method allows you to center our tracker on the location of the HMD, it will take the current location of the HMD and use that to adjust all our tracking data in essence realigning the real world to your players current position in your game world. For this method to produce usable results tracking information should be available and this often takes a few frames after starting your game. You should call this method after a few seconds have passed, when the user requests a realignment of the display holding a designated button on a controller for a short period of time, and when implementing a teleport mechanism.
*/
func (o *arvrServer) CenterOnHmd(rotationMode int64, keepHeight bool) {
	log.Println("Calling ARVRServer.CenterOnHmd()")

	godotCallVoidIntBool(o, "center_on_hmd", rotationMode, keepHeight)
	log.Println("  Function successfully completed.")

}

/*
   Find an interface by its name. Say that you're making a game that uses specific capabilities of an AR/VR platform you can find the interface for that platform by name and initialize it.
*/
func (o *arvrServer) FindInterface(name string) *ARVRInterface {
	log.Println("Calling ARVRServer.FindInterface()")

	returnValue := godotCallObjectString(o, "find_interface", name)
	log.Println("  Got return value: ", returnValue)

	var ret ARVRInterface
	ret.owner = returnValue.owner
	return &ret

}

/*
   Get the interface registered at a given index in our list of interfaces.
*/
func (o *arvrServer) GetInterface(idx int64) *ARVRInterface {
	log.Println("Calling ARVRServer.GetInterface()")

	returnValue := godotCallObjectInt(o, "get_interface", idx)
	log.Println("  Got return value: ", returnValue)

	var ret ARVRInterface
	ret.owner = returnValue.owner
	return &ret

}

/*
   Get the number of interfaces currently registered with the AR/VR server. If you're game supports multiple AR/VR platforms you can look through the available interface and either present the user with a selection or simply try an initialize each interface and use the first one that returns true.
*/
func (o *arvrServer) GetInterfaceCount() int64 {
	log.Println("Calling ARVRServer.GetInterfaceCount()")

	returnValue := godotCallInt(o, "get_interface_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a list of available interfaces with both id and name of the interface.
*/
func (o *arvrServer) GetInterfaces() *Array {
	log.Println("Calling ARVRServer.GetInterfaces()")

	returnValue := godotCallArray(o, "get_interfaces")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Gets our reference frame transform, mostly used internally and exposed for GDNative build interfaces.
*/
func (o *arvrServer) GetReferenceFrame() *Transform {
	log.Println("Calling ARVRServer.GetReferenceFrame()")

	returnValue := godotCallTransform(o, "get_reference_frame")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the positional tracker at the given ID.
*/
func (o *arvrServer) GetTracker(idx int64) *ARVRPositionalTracker {
	log.Println("Calling ARVRServer.GetTracker()")

	returnValue := godotCallObjectInt(o, "get_tracker", idx)
	log.Println("  Got return value: ", returnValue)

	var ret ARVRPositionalTracker
	ret.owner = returnValue.owner
	return &ret

}

/*
   Get the number of trackers currently registered.
*/
func (o *arvrServer) GetTrackerCount() int64 {
	log.Println("Calling ARVRServer.GetTrackerCount()")

	returnValue := godotCallInt(o, "get_tracker_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *arvrServer) GetWorldScale() float64 {
	log.Println("Calling ARVRServer.GetWorldScale()")

	returnValue := godotCallFloat(o, "get_world_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Changes the primary interface to the specified interface. Again mostly exposed for GDNative interfaces.
*/
func (o *arvrServer) SetPrimaryInterface(intrfce *ARVRInterface) {
	log.Println("Calling ARVRServer.SetPrimaryInterface()")

	godotCallVoidObject(o, "set_primary_interface", &intrfce.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *arvrServer) SetWorldScale(arg0 float64) {
	log.Println("Calling ARVRServer.SetWorldScale()")

	godotCallVoidFloat(o, "set_world_scale", arg0)
	log.Println("  Function successfully completed.")

}

/*
   A* (A star) is a computer algorithm that is widely used in pathfinding and graph traversal, the process of plotting an efficiently directed path between multiple points. It enjoys widespread use due to its performance and accuracy. Godot's A* implementation make use of vectors as points. You must add points manually with [method AStar.add_point] and create segments manually with [method AStar.connect_points]. So you can test if there is a path between two points with the [method AStar.are_points_connected] function, get the list of existing ids in the found path with [method AStar.get_id_path], or the points list with [method AStar.get_point_path].
*/
type AStar struct {
	Reference
}

func (o *AStar) baseClass() string {
	return "AStar"
}

/*
   Called when computing the cost between two connected points.
*/
func (o *AStar) X_ComputeCost(fromId int64, toId int64) float64 {
	log.Println("Calling AStar.X_ComputeCost()")

	returnValue := godotCallFloatIntInt(o, "_compute_cost", fromId, toId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Called when estimating the cost between a point and the path's ending point.
*/
func (o *AStar) X_EstimateCost(fromId int64, toId int64) float64 {
	log.Println("Calling AStar.X_EstimateCost()")

	returnValue := godotCallFloatIntInt(o, "_estimate_cost", fromId, toId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Adds a new point at the given position with the given identifier. The algorithm prefers points with lower [code]weight_scale[/code] to form a path. The [code]id[/code] must be 0 or larger, and the [code]weight_scale[/code] must be 1 or larger. [codeblock] var as = AStar.new() as.add_point(1, Vector3(1,0,0), 4) # Adds the point (1,0,0) with weight_scale=4 and id=1 [/codeblock] If there already exists a point for the given id, its position and weight scale are updated to the given values.
*/
func (o *AStar) AddPoint(id int64, position *Vector3, weightScale float64) {
	log.Println("Calling AStar.AddPoint()")

	godotCallVoidIntVector3Float(o, "add_point", id, position, weightScale)
	log.Println("  Function successfully completed.")

}

/*
   Returns whether there is a connection/segment between the given points.
*/
func (o *AStar) ArePointsConnected(id int64, toId int64) bool {
	log.Println("Calling AStar.ArePointsConnected()")

	returnValue := godotCallBoolIntInt(o, "are_points_connected", id, toId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Clears all the points and segments.
*/
func (o *AStar) Clear() {
	log.Println("Calling AStar.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Creates a segment between the given points. [codeblock] var as = AStar.new() as.add_point(1, Vector3(1,1,0)) as.add_point(2, Vector3(0,5,0)) as.connect_points(1, 2, false) # If bidirectional=false it's only possible to go from point 1 to point 2 # and not from point 2 to point 1. [/codeblock]
*/
func (o *AStar) ConnectPoints(id int64, toId int64, bidirectional bool) {
	log.Println("Calling AStar.ConnectPoints()")

	godotCallVoidIntIntBool(o, "connect_points", id, toId, bidirectional)
	log.Println("  Function successfully completed.")

}

/*
   Deletes the segment between the given points.
*/
func (o *AStar) DisconnectPoints(id int64, toId int64) {
	log.Println("Calling AStar.DisconnectPoints()")

	godotCallVoidIntInt(o, "disconnect_points", id, toId)
	log.Println("  Function successfully completed.")

}

/*
   Returns the next available point id with no point associated to it.
*/
func (o *AStar) GetAvailablePointId() int64 {
	log.Println("Calling AStar.GetAvailablePointId()")

	returnValue := godotCallInt(o, "get_available_point_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the id of the closest point to [code]to_position[/code]. Returns -1 if there are no points in the points pool.
*/
func (o *AStar) GetClosestPoint(toPosition *Vector3) int64 {
	log.Println("Calling AStar.GetClosestPoint()")

	returnValue := godotCallIntVector3(o, "get_closest_point", toPosition)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the closest position to [code]to_position[/code] that resides inside a segment between two connected points. [codeblock] var as = AStar.new() as.add_point(1, Vector3(0,0,0)) as.add_point(2, Vector3(0,5,0)) as.connect_points(1, 2) var res = as.get_closest_position_in_segment(Vector3(3,3,0)) # returns (0, 3, 0) [/codeblock] The result is in the segment that goes from [code]y=0[/code] to [code]y=5[/code]. It's the closest position in the segment to the given point.
*/
func (o *AStar) GetClosestPositionInSegment(toPosition *Vector3) *Vector3 {
	log.Println("Calling AStar.GetClosestPositionInSegment()")

	returnValue := godotCallVector3Vector3(o, "get_closest_position_in_segment", toPosition)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an array with the ids of the points that form the path found by AStar between the given points. The array is ordered from the starting point to the ending point of the path. [codeblock] var as = AStar.new() as.add_point(1, Vector3(0,0,0)) as.add_point(2, Vector3(0,1,0), 1) # default weight is 1 as.add_point(3, Vector3(1,1,0)) as.add_point(4, Vector3(2,0,0)) as.connect_points(1, 2, false) as.connect_points(2, 3, false) as.connect_points(4, 3, false) as.connect_points(1, 4, false) as.connect_points(5, 4, false) var res = as.get_id_path(1, 3) # returns [1, 2, 3] [/codeblock] If you change the 2nd point's weight to 3, then the result will be [code][1, 4, 3][/code] instead, because now even though the distance is longer, it's "easier" to get through point 4 than through point 2.
*/
func (o *AStar) GetIdPath(fromId int64, toId int64) *PoolIntArray {
	log.Println("Calling AStar.GetIdPath()")

	returnValue := godotCallPoolIntArrayIntInt(o, "get_id_path", fromId, toId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an array with the ids of the points that form the connect with the given point. [codeblock] var as = AStar.new() as.add_point(1, Vector3(0,0,0)) as.add_point(2, Vector3(0,1,0)) as.add_point(3, Vector3(1,1,0)) as.add_point(4, Vector3(2,0,0)) as.connect_points(1, 2, true) as.connect_points(1, 3, true) var neighbors = as.get_point_connections(1) # returns [2, 3] [/codeblock]
*/
func (o *AStar) GetPointConnections(id int64) *PoolIntArray {
	log.Println("Calling AStar.GetPointConnections()")

	returnValue := godotCallPoolIntArrayInt(o, "get_point_connections", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an array with the points that are in the path found by AStar between the given points. The array is ordered from the starting point to the ending point of the path.
*/
func (o *AStar) GetPointPath(fromId int64, toId int64) *PoolVector3Array {
	log.Println("Calling AStar.GetPointPath()")

	returnValue := godotCallPoolVector3ArrayIntInt(o, "get_point_path", fromId, toId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position of the point associated with the given id.
*/
func (o *AStar) GetPointPosition(id int64) *Vector3 {
	log.Println("Calling AStar.GetPointPosition()")

	returnValue := godotCallVector3Int(o, "get_point_position", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the weight scale of the point associated with the given id.
*/
func (o *AStar) GetPointWeightScale(id int64) float64 {
	log.Println("Calling AStar.GetPointWeightScale()")

	returnValue := godotCallFloatInt(o, "get_point_weight_scale", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an array of all points.
*/
func (o *AStar) GetPoints() *Array {
	log.Println("Calling AStar.GetPoints()")

	returnValue := godotCallArray(o, "get_points")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether a point associated with the given id exists.
*/
func (o *AStar) HasPoint(id int64) bool {
	log.Println("Calling AStar.HasPoint()")

	returnValue := godotCallBoolInt(o, "has_point", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes the point associated with the given id from the points pool.
*/
func (o *AStar) RemovePoint(id int64) {
	log.Println("Calling AStar.RemovePoint()")

	godotCallVoidInt(o, "remove_point", id)
	log.Println("  Function successfully completed.")

}

/*
   Sets the position for the point with the given id.
*/
func (o *AStar) SetPointPosition(id int64, position *Vector3) {
	log.Println("Calling AStar.SetPointPosition()")

	godotCallVoidIntVector3(o, "set_point_position", id, position)
	log.Println("  Function successfully completed.")

}

/*
   Sets the [code]weight_scale[/code] for the point with the given id.
*/
func (o *AStar) SetPointWeightScale(id int64, weightScale float64) {
	log.Println("Calling AStar.SetPointWeightScale()")

	godotCallVoidIntFloat(o, "set_point_weight_scale", id, weightScale)
	log.Println("  Function successfully completed.")

}

/*
   AStarImplementer is an interface for AStar objects.
*/
type AStarImplementer interface {
	Class
}

/*
   This dialog is useful for small notifications to the user about an event. It can only be accepted or closed, with the same result.
*/
type AcceptDialog struct {
	WindowDialog
}

func (o *AcceptDialog) baseClass() string {
	return "AcceptDialog"
}

/*
   Undocumented
*/
func (o *AcceptDialog) X_BuiltinTextEntered(arg0 string) {
	log.Println("Calling AcceptDialog.X_BuiltinTextEntered()")

	godotCallVoidString(o, "_builtin_text_entered", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AcceptDialog) X_CustomAction(arg0 string) {
	log.Println("Calling AcceptDialog.X_CustomAction()")

	godotCallVoidString(o, "_custom_action", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AcceptDialog) X_Ok() {
	log.Println("Calling AcceptDialog.X_Ok()")

	godotCallVoid(o, "_ok")
	log.Println("  Function successfully completed.")

}

/*
   Adds a button with label [i]text[/i] and a custom [i]action[/i] to the dialog and returns the created button. [i]action[/i] will be passed to the [custom_action] signal when pressed. If [code]true[/code], [i]right[/i] will place the button to the right of any sibling buttons. Default value: [code]false[/code].
*/
func (o *AcceptDialog) AddButton(text string, right bool, action string) *Button {
	log.Println("Calling AcceptDialog.AddButton()")

	returnValue := godotCallObjectStringBoolString(o, "add_button", text, right, action)
	log.Println("  Got return value: ", returnValue)

	var ret Button
	ret.owner = returnValue.owner
	return &ret

}

/*
   Adds a button with label [i]name[/i] and a cancel action to the dialog and returns the created button.
*/
func (o *AcceptDialog) AddCancel(name string) *Button {
	log.Println("Calling AcceptDialog.AddCancel()")

	returnValue := godotCallObjectString(o, "add_cancel", name)
	log.Println("  Got return value: ", returnValue)

	var ret Button
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *AcceptDialog) GetHideOnOk() bool {
	log.Println("Calling AcceptDialog.GetHideOnOk()")

	returnValue := godotCallBool(o, "get_hide_on_ok")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the label used for built-in text.
*/
func (o *AcceptDialog) GetLabel() *Label {
	log.Println("Calling AcceptDialog.GetLabel()")

	returnValue := godotCallObject(o, "get_label")
	log.Println("  Got return value: ", returnValue)

	var ret Label
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the OK Button.
*/
func (o *AcceptDialog) GetOk() *Button {
	log.Println("Calling AcceptDialog.GetOk()")

	returnValue := godotCallObject(o, "get_ok")
	log.Println("  Got return value: ", returnValue)

	var ret Button
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *AcceptDialog) GetText() string {
	log.Println("Calling AcceptDialog.GetText()")

	returnValue := godotCallString(o, "get_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Registers a [LineEdit] in the dialog. When the enter key is pressed, the dialog will be accepted.
*/
func (o *AcceptDialog) RegisterTextEnter(lineEdit *Object) {
	log.Println("Calling AcceptDialog.RegisterTextEnter()")

	godotCallVoidObject(o, "register_text_enter", lineEdit)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AcceptDialog) SetHideOnOk(enabled bool) {
	log.Println("Calling AcceptDialog.SetHideOnOk()")

	godotCallVoidBool(o, "set_hide_on_ok", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AcceptDialog) SetText(text string) {
	log.Println("Calling AcceptDialog.SetText()")

	godotCallVoidString(o, "set_text", text)
	log.Println("  Function successfully completed.")

}

/*
   AcceptDialogImplementer is an interface for AcceptDialog objects.
*/
type AcceptDialogImplementer interface {
	Class
}

/*
   Animations are created using a [SpriteFrames] resource, which can be configured in the editor via the SpriteFrames panel.
*/
type AnimatedSprite struct {
	Node2D
}

func (o *AnimatedSprite) baseClass() string {
	return "AnimatedSprite"
}

/*
   Undocumented
*/
func (o *AnimatedSprite) X_IsPlaying() bool {
	log.Println("Calling AnimatedSprite.X_IsPlaying()")

	returnValue := godotCallBool(o, "_is_playing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite) X_ResChanged() {
	log.Println("Calling AnimatedSprite.X_ResChanged()")

	godotCallVoid(o, "_res_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite) X_SetPlaying(playing bool) {
	log.Println("Calling AnimatedSprite.X_SetPlaying()")

	godotCallVoidBool(o, "_set_playing", playing)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite) GetAnimation() string {
	log.Println("Calling AnimatedSprite.GetAnimation()")

	returnValue := godotCallString(o, "get_animation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite) GetFrame() int64 {
	log.Println("Calling AnimatedSprite.GetFrame()")

	returnValue := godotCallInt(o, "get_frame")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite) GetOffset() *Vector2 {
	log.Println("Calling AnimatedSprite.GetOffset()")

	returnValue := godotCallVector2(o, "get_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite) GetSpriteFrames() *SpriteFrames {
	log.Println("Calling AnimatedSprite.GetSpriteFrames()")

	returnValue := godotCallObject(o, "get_sprite_frames")
	log.Println("  Got return value: ", returnValue)

	var ret SpriteFrames
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *AnimatedSprite) IsCentered() bool {
	log.Println("Calling AnimatedSprite.IsCentered()")

	returnValue := godotCallBool(o, "is_centered")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite) IsFlippedH() bool {
	log.Println("Calling AnimatedSprite.IsFlippedH()")

	returnValue := godotCallBool(o, "is_flipped_h")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite) IsFlippedV() bool {
	log.Println("Calling AnimatedSprite.IsFlippedV()")

	returnValue := godotCallBool(o, "is_flipped_v")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return true if an animation if currently being played.
*/
func (o *AnimatedSprite) IsPlaying() bool {
	log.Println("Calling AnimatedSprite.IsPlaying()")

	returnValue := godotCallBool(o, "is_playing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Play the animation set in parameter. If no parameter is provided, the current animation is played.
*/
func (o *AnimatedSprite) Play(anim string) {
	log.Println("Calling AnimatedSprite.Play()")

	godotCallVoidString(o, "play", anim)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite) SetAnimation(animation string) {
	log.Println("Calling AnimatedSprite.SetAnimation()")

	godotCallVoidString(o, "set_animation", animation)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite) SetCentered(centered bool) {
	log.Println("Calling AnimatedSprite.SetCentered()")

	godotCallVoidBool(o, "set_centered", centered)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite) SetFlipH(flipH bool) {
	log.Println("Calling AnimatedSprite.SetFlipH()")

	godotCallVoidBool(o, "set_flip_h", flipH)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite) SetFlipV(flipV bool) {
	log.Println("Calling AnimatedSprite.SetFlipV()")

	godotCallVoidBool(o, "set_flip_v", flipV)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite) SetFrame(frame int64) {
	log.Println("Calling AnimatedSprite.SetFrame()")

	godotCallVoidInt(o, "set_frame", frame)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite) SetOffset(offset *Vector2) {
	log.Println("Calling AnimatedSprite.SetOffset()")

	godotCallVoidVector2(o, "set_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite) SetSpriteFrames(spriteFrames *SpriteFrames) {
	log.Println("Calling AnimatedSprite.SetSpriteFrames()")

	godotCallVoidObject(o, "set_sprite_frames", &spriteFrames.Object)
	log.Println("  Function successfully completed.")

}

/*
   Stop the current animation (does not reset the frame counter).
*/
func (o *AnimatedSprite) Stop() {
	log.Println("Calling AnimatedSprite.Stop()")

	godotCallVoid(o, "stop")
	log.Println("  Function successfully completed.")

}

/*
   AnimatedSpriteImplementer is an interface for AnimatedSprite objects.
*/
type AnimatedSpriteImplementer interface {
	Class
}

/*
   Animations are created using a [SpriteFrames] resource, which can be configured in the editor via the SpriteFrames panel.
*/
type AnimatedSprite3D struct {
	SpriteBase3D
}

func (o *AnimatedSprite3D) baseClass() string {
	return "AnimatedSprite3D"
}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) X_IsPlaying() bool {
	log.Println("Calling AnimatedSprite3D.X_IsPlaying()")

	returnValue := godotCallBool(o, "_is_playing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) X_ResChanged() {
	log.Println("Calling AnimatedSprite3D.X_ResChanged()")

	godotCallVoid(o, "_res_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) X_SetPlaying(playing bool) {
	log.Println("Calling AnimatedSprite3D.X_SetPlaying()")

	godotCallVoidBool(o, "_set_playing", playing)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) GetAnimation() string {
	log.Println("Calling AnimatedSprite3D.GetAnimation()")

	returnValue := godotCallString(o, "get_animation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) GetFrame() int64 {
	log.Println("Calling AnimatedSprite3D.GetFrame()")

	returnValue := godotCallInt(o, "get_frame")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) GetSpriteFrames() *SpriteFrames {
	log.Println("Calling AnimatedSprite3D.GetSpriteFrames()")

	returnValue := godotCallObject(o, "get_sprite_frames")
	log.Println("  Got return value: ", returnValue)

	var ret SpriteFrames
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return true if an animation if currently being played.
*/
func (o *AnimatedSprite3D) IsPlaying() bool {
	log.Println("Calling AnimatedSprite3D.IsPlaying()")

	returnValue := godotCallBool(o, "is_playing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Play the animation set in parameter. If no parameter is provided, the current animation is played.
*/
func (o *AnimatedSprite3D) Play(anim string) {
	log.Println("Calling AnimatedSprite3D.Play()")

	godotCallVoidString(o, "play", anim)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) SetAnimation(animation string) {
	log.Println("Calling AnimatedSprite3D.SetAnimation()")

	godotCallVoidString(o, "set_animation", animation)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) SetFrame(frame int64) {
	log.Println("Calling AnimatedSprite3D.SetFrame()")

	godotCallVoidInt(o, "set_frame", frame)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimatedSprite3D) SetSpriteFrames(spriteFrames *SpriteFrames) {
	log.Println("Calling AnimatedSprite3D.SetSpriteFrames()")

	godotCallVoidObject(o, "set_sprite_frames", &spriteFrames.Object)
	log.Println("  Function successfully completed.")

}

/*
   Stop the current animation (does not reset the frame counter).
*/
func (o *AnimatedSprite3D) Stop() {
	log.Println("Calling AnimatedSprite3D.Stop()")

	godotCallVoid(o, "stop")
	log.Println("  Function successfully completed.")

}

/*
   AnimatedSprite3DImplementer is an interface for AnimatedSprite3D objects.
*/
type AnimatedSprite3DImplementer interface {
	Class
}

/*
   An Animation resource contains data used to animate everything in the engine. Animations are divided into tracks, and each track must be linked to a node. The state of that node can be changed through time, by adding timed keys (events) to the track. Animations are just data containers, and must be added to odes such as an [AnimationPlayer] or [AnimationTreePlayer] to be played back.
*/
type Animation struct {
	Resource
}

func (o *Animation) baseClass() string {
	return "Animation"
}

/*
   Add a track to the Animation. The track type must be specified as any of the values in the TYPE_* enumeration.
*/
func (o *Animation) AddTrack(aType int64, atPosition int64) int64 {
	log.Println("Calling Animation.AddTrack()")

	returnValue := godotCallIntIntInt(o, "add_track", aType, atPosition)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Clear the animation (clear all tracks and reset all).
*/
func (o *Animation) Clear() {
	log.Println("Calling Animation.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Adds a new track that is a copy of the given track from [code]to_animation[/code].
*/
func (o *Animation) CopyTrack(track int64, toAnimation *Animation) {
	log.Println("Calling Animation.CopyTrack()")

	godotCallVoidIntObject(o, "copy_track", track, &toAnimation.Object)
	log.Println("  Function successfully completed.")

}

/*
   Return the index of the specified track. If the track is not found, return -1.
*/
func (o *Animation) FindTrack(path *NodePath) int64 {
	log.Println("Calling Animation.FindTrack()")

	returnValue := godotCallIntNodePath(o, "find_track", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Animation) GetLength() float64 {
	log.Println("Calling Animation.GetLength()")

	returnValue := godotCallFloat(o, "get_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Animation) GetStep() float64 {
	log.Println("Calling Animation.GetStep()")

	returnValue := godotCallFloat(o, "get_step")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the amount of tracks in the animation.
*/
func (o *Animation) GetTrackCount() int64 {
	log.Println("Calling Animation.GetTrackCount()")

	returnValue := godotCallInt(o, "get_track_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Animation) HasLoop() bool {
	log.Println("Calling Animation.HasLoop()")

	returnValue := godotCallBool(o, "has_loop")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return all the key indices of a method track, given a position and delta time.
*/
func (o *Animation) MethodTrackGetKeyIndices(idx int64, timeSec float64, delta float64) *PoolIntArray {
	log.Println("Calling Animation.MethodTrackGetKeyIndices()")

	returnValue := godotCallPoolIntArrayIntFloatFloat(o, "method_track_get_key_indices", idx, timeSec, delta)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the method name of a method track.
*/
func (o *Animation) MethodTrackGetName(idx int64, keyIdx int64) string {
	log.Println("Calling Animation.MethodTrackGetName()")

	returnValue := godotCallStringIntInt(o, "method_track_get_name", idx, keyIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the arguments values to be called on a method track for a given key in a given track.
*/
func (o *Animation) MethodTrackGetParams(idx int64, keyIdx int64) *Array {
	log.Println("Calling Animation.MethodTrackGetParams()")

	returnValue := godotCallArrayIntInt(o, "method_track_get_params", idx, keyIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Remove a track by specifying the track index.
*/
func (o *Animation) RemoveTrack(idx int64) {
	log.Println("Calling Animation.RemoveTrack()")

	godotCallVoidInt(o, "remove_track", idx)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Animation) SetLength(timeSec float64) {
	log.Println("Calling Animation.SetLength()")

	godotCallVoidFloat(o, "set_length", timeSec)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Animation) SetLoop(enabled bool) {
	log.Println("Calling Animation.SetLoop()")

	godotCallVoidBool(o, "set_loop", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Animation) SetStep(sizeSec float64) {
	log.Println("Calling Animation.SetStep()")

	godotCallVoidFloat(o, "set_step", sizeSec)
	log.Println("  Function successfully completed.")

}

/*
   Find the key index by time in a given track. Optionally, only find it if the exact time is given.
*/
func (o *Animation) TrackFindKey(idx int64, time float64, exact bool) int64 {
	log.Println("Calling Animation.TrackFindKey()")

	returnValue := godotCallIntIntFloatBool(o, "track_find_key", idx, time, exact)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the track at [code]idx[/code] wraps the interpolation loop. Default value: [code]true[/code].
*/
func (o *Animation) TrackGetInterpolationLoopWrap(idx int64) bool {
	log.Println("Calling Animation.TrackGetInterpolationLoopWrap()")

	returnValue := godotCallBoolInt(o, "track_get_interpolation_loop_wrap", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the interpolation type of a given track, from the INTERPOLATION_* enum.
*/
func (o *Animation) TrackGetInterpolationType(idx int64) int64 {
	log.Println("Calling Animation.TrackGetInterpolationType()")

	returnValue := godotCallIntInt(o, "track_get_interpolation_type", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the amount of keys in a given track.
*/
func (o *Animation) TrackGetKeyCount(idx int64) int64 {
	log.Println("Calling Animation.TrackGetKeyCount()")

	returnValue := godotCallIntInt(o, "track_get_key_count", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the time at which the key is located.
*/
func (o *Animation) TrackGetKeyTime(idx int64, keyIdx int64) float64 {
	log.Println("Calling Animation.TrackGetKeyTime()")

	returnValue := godotCallFloatIntInt(o, "track_get_key_time", idx, keyIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the transition curve (easing) for a specific key (see built-in math function "ease").
*/
func (o *Animation) TrackGetKeyTransition(idx int64, keyIdx int64) float64 {
	log.Println("Calling Animation.TrackGetKeyTransition()")

	returnValue := godotCallFloatIntInt(o, "track_get_key_transition", idx, keyIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the value of a given key in a given track.
*/
func (o *Animation) TrackGetKeyValue(idx int64, keyIdx int64) *Variant {
	log.Println("Calling Animation.TrackGetKeyValue()")

	returnValue := godotCallVariantIntInt(o, "track_get_key_value", idx, keyIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the path of a track. for more information on the path format, see [method track_set_path]
*/
func (o *Animation) TrackGetPath(idx int64) *NodePath {
	log.Println("Calling Animation.TrackGetPath()")

	returnValue := godotCallNodePathInt(o, "track_get_path", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the type of a track.
*/
func (o *Animation) TrackGetType(idx int64) int64 {
	log.Println("Calling Animation.TrackGetType()")

	returnValue := godotCallIntInt(o, "track_get_type", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Insert a generic key in a given track.
*/
func (o *Animation) TrackInsertKey(idx int64, time float64, key *Variant, transition float64) {
	log.Println("Calling Animation.TrackInsertKey()")

	godotCallVoidIntFloatVariantFloat(o, "track_insert_key", idx, time, key, transition)
	log.Println("  Function successfully completed.")

}

/*
   Returns [code]true[/code] if the track at index [code]idx[/code] is enabled.
*/
func (o *Animation) TrackIsEnabled(idx int64) bool {
	log.Println("Calling Animation.TrackIsEnabled()")

	returnValue := godotCallBoolInt(o, "track_is_enabled", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return true if the given track is imported. Else, return false.
*/
func (o *Animation) TrackIsImported(idx int64) bool {
	log.Println("Calling Animation.TrackIsImported()")

	returnValue := godotCallBoolInt(o, "track_is_imported", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Move a track down.
*/
func (o *Animation) TrackMoveDown(idx int64) {
	log.Println("Calling Animation.TrackMoveDown()")

	godotCallVoidInt(o, "track_move_down", idx)
	log.Println("  Function successfully completed.")

}

/*
   Move a track up.
*/
func (o *Animation) TrackMoveUp(idx int64) {
	log.Println("Calling Animation.TrackMoveUp()")

	godotCallVoidInt(o, "track_move_up", idx)
	log.Println("  Function successfully completed.")

}

/*
   Remove a key by index in a given track.
*/
func (o *Animation) TrackRemoveKey(idx int64, keyIdx int64) {
	log.Println("Calling Animation.TrackRemoveKey()")

	godotCallVoidIntInt(o, "track_remove_key", idx, keyIdx)
	log.Println("  Function successfully completed.")

}

/*
   Remove a key by position (seconds) in a given track.
*/
func (o *Animation) TrackRemoveKeyAtPosition(idx int64, position float64) {
	log.Println("Calling Animation.TrackRemoveKeyAtPosition()")

	godotCallVoidIntFloat(o, "track_remove_key_at_position", idx, position)
	log.Println("  Function successfully completed.")

}

/*
   Enables/disables the given track. Tracks are enabled by default.
*/
func (o *Animation) TrackSetEnabled(idx int64, enabled bool) {
	log.Println("Calling Animation.TrackSetEnabled()")

	godotCallVoidIntBool(o, "track_set_enabled", idx, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Set the given track as imported or not.
*/
func (o *Animation) TrackSetImported(idx int64, imported bool) {
	log.Println("Calling Animation.TrackSetImported()")

	godotCallVoidIntBool(o, "track_set_imported", idx, imported)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the track at [code]idx[/code] wraps the interpolation loop.
*/
func (o *Animation) TrackSetInterpolationLoopWrap(idx int64, interpolation bool) {
	log.Println("Calling Animation.TrackSetInterpolationLoopWrap()")

	godotCallVoidIntBool(o, "track_set_interpolation_loop_wrap", idx, interpolation)
	log.Println("  Function successfully completed.")

}

/*
   Set the interpolation type of a given track, from the INTERPOLATION_* enum.
*/
func (o *Animation) TrackSetInterpolationType(idx int64, interpolation int64) {
	log.Println("Calling Animation.TrackSetInterpolationType()")

	godotCallVoidIntInt(o, "track_set_interpolation_type", idx, interpolation)
	log.Println("  Function successfully completed.")

}

/*
   Set the transition curve (easing) for a specific key (see built-in math function "ease").
*/
func (o *Animation) TrackSetKeyTransition(idx int64, keyIdx int64, transition float64) {
	log.Println("Calling Animation.TrackSetKeyTransition()")

	godotCallVoidIntIntFloat(o, "track_set_key_transition", idx, keyIdx, transition)
	log.Println("  Function successfully completed.")

}

/*
   Set the value of an existing key.
*/
func (o *Animation) TrackSetKeyValue(idx int64, key int64, value *Variant) {
	log.Println("Calling Animation.TrackSetKeyValue()")

	godotCallVoidIntIntVariant(o, "track_set_key_value", idx, key, value)
	log.Println("  Function successfully completed.")

}

/*
   Set the path of a track. Paths must be valid scene-tree paths to a node, and must be specified starting from the parent node of the node that will reproduce the animation. Tracks that control properties or bones must append their name after the path, separated by ":". Example: "character/skeleton:ankle" or "character/mesh:transform/local"
*/
func (o *Animation) TrackSetPath(idx int64, path *NodePath) {
	log.Println("Calling Animation.TrackSetPath()")

	godotCallVoidIntNodePath(o, "track_set_path", idx, path)
	log.Println("  Function successfully completed.")

}

/*
   Insert a transform key for a transform track.
*/
func (o *Animation) TransformTrackInsertKey(idx int64, time float64, location *Vector3, rotation *Quat, scale *Vector3) int64 {
	log.Println("Calling Animation.TransformTrackInsertKey()")

	returnValue := godotCallIntIntFloatVector3QuatVector3(o, "transform_track_insert_key", idx, time, location, rotation, scale)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the interpolated value of a transform track at a given time (in seconds). An array consisting of 3 elements: position ([Vector3]), rotation ([Quat]) and scale ([Vector3]).
*/
func (o *Animation) TransformTrackInterpolate(idx int64, timeSec float64) *Array {
	log.Println("Calling Animation.TransformTrackInterpolate()")

	returnValue := godotCallArrayIntFloat(o, "transform_track_interpolate", idx, timeSec)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return all the key indices of a value track, given a position and delta time.
*/
func (o *Animation) ValueTrackGetKeyIndices(idx int64, timeSec float64, delta float64) *PoolIntArray {
	log.Println("Calling Animation.ValueTrackGetKeyIndices()")

	returnValue := godotCallPoolIntArrayIntFloatFloat(o, "value_track_get_key_indices", idx, timeSec, delta)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the update mode of a value track.
*/
func (o *Animation) ValueTrackGetUpdateMode(idx int64) int64 {
	log.Println("Calling Animation.ValueTrackGetUpdateMode()")

	returnValue := godotCallIntInt(o, "value_track_get_update_mode", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Set the update mode (UPDATE_*) of a value track.
*/
func (o *Animation) ValueTrackSetUpdateMode(idx int64, mode int64) {
	log.Println("Calling Animation.ValueTrackSetUpdateMode()")

	godotCallVoidIntInt(o, "value_track_set_update_mode", idx, mode)
	log.Println("  Function successfully completed.")

}

/*
   AnimationImplementer is an interface for Animation objects.
*/
type AnimationImplementer interface {
	Class
}

/*
   An animation player is used for general purpose playback of [Animation] resources. It contains a dictionary of animations (referenced by name) and custom blend times between their transitions. Additionally, animations can be played and blended in different channels.
*/
type AnimationPlayer struct {
	Node
}

func (o *AnimationPlayer) baseClass() string {
	return "AnimationPlayer"
}

/*
   Undocumented
*/
func (o *AnimationPlayer) X_AnimationChanged() {
	log.Println("Calling AnimationPlayer.X_AnimationChanged()")

	godotCallVoid(o, "_animation_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) X_NodeRemoved(arg0 *Object) {
	log.Println("Calling AnimationPlayer.X_NodeRemoved()")

	godotCallVoidObject(o, "_node_removed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Adds [code]animation[/code] to the player accessible with the key [code]name[/code].
*/
func (o *AnimationPlayer) AddAnimation(name string, animation *Animation) int64 {
	log.Println("Calling AnimationPlayer.AddAnimation()")

	returnValue := godotCallIntStringObject(o, "add_animation", name, &animation.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Shifts position in the animation timeline. Delta is the time in seconds to shift.
*/
func (o *AnimationPlayer) Advance(delta float64) {
	log.Println("Calling AnimationPlayer.Advance()")

	godotCallVoidFloat(o, "advance", delta)
	log.Println("  Function successfully completed.")

}

/*
   Returns the name of the next animation in the queue.
*/
func (o *AnimationPlayer) AnimationGetNext(animFrom string) string {
	log.Println("Calling AnimationPlayer.AnimationGetNext()")

	returnValue := godotCallStringString(o, "animation_get_next", animFrom)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Triggers the [code]anim_to[/code] animation when the [code]anim_from[/code] animation completes.
*/
func (o *AnimationPlayer) AnimationSetNext(animFrom string, animTo string) {
	log.Println("Calling AnimationPlayer.AnimationSetNext()")

	godotCallVoidStringString(o, "animation_set_next", animFrom, animTo)
	log.Println("  Function successfully completed.")

}

/*
   [code]AnimationPlayer[/code] caches animated nodes. It may not notice if a node disappears, so clear_caches forces it to update the cache again.
*/
func (o *AnimationPlayer) ClearCaches() {
	log.Println("Calling AnimationPlayer.ClearCaches()")

	godotCallVoid(o, "clear_caches")
	log.Println("  Function successfully completed.")

}

/*
   Clears all queued, unplayed animations.
*/
func (o *AnimationPlayer) ClearQueue() {
	log.Println("Calling AnimationPlayer.ClearQueue()")

	godotCallVoid(o, "clear_queue")
	log.Println("  Function successfully completed.")

}

/*
   Returns the name of [code]animation[/code] or empty string if not found.
*/
func (o *AnimationPlayer) FindAnimation(animation *Animation) string {
	log.Println("Calling AnimationPlayer.FindAnimation()")

	returnValue := godotCallStringObject(o, "find_animation", &animation.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [Animation] with key [code]name[/code] or [code]null[/code] if not found.
*/
func (o *AnimationPlayer) GetAnimation(name string) *Animation {
	log.Println("Calling AnimationPlayer.GetAnimation()")

	returnValue := godotCallObjectString(o, "get_animation", name)
	log.Println("  Got return value: ", returnValue)

	var ret Animation
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the list of stored animation names.
*/
func (o *AnimationPlayer) GetAnimationList() *PoolStringArray {
	log.Println("Calling AnimationPlayer.GetAnimationList()")

	returnValue := godotCallPoolStringArray(o, "get_animation_list")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetAnimationProcessMode() int64 {
	log.Println("Calling AnimationPlayer.GetAnimationProcessMode()")

	returnValue := godotCallInt(o, "get_animation_process_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetAssignedAnimation() string {
	log.Println("Calling AnimationPlayer.GetAssignedAnimation()")

	returnValue := godotCallString(o, "get_assigned_animation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetAutoplay() string {
	log.Println("Calling AnimationPlayer.GetAutoplay()")

	returnValue := godotCallString(o, "get_autoplay")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the blend time (in seconds) between two animations, referenced by their names.
*/
func (o *AnimationPlayer) GetBlendTime(animFrom string, animTo string) float64 {
	log.Println("Calling AnimationPlayer.GetBlendTime()")

	returnValue := godotCallFloatStringString(o, "get_blend_time", animFrom, animTo)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetCurrentAnimation() string {
	log.Println("Calling AnimationPlayer.GetCurrentAnimation()")

	returnValue := godotCallString(o, "get_current_animation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetCurrentAnimationLength() float64 {
	log.Println("Calling AnimationPlayer.GetCurrentAnimationLength()")

	returnValue := godotCallFloat(o, "get_current_animation_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetCurrentAnimationPosition() float64 {
	log.Println("Calling AnimationPlayer.GetCurrentAnimationPosition()")

	returnValue := godotCallFloat(o, "get_current_animation_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetDefaultBlendTime() float64 {
	log.Println("Calling AnimationPlayer.GetDefaultBlendTime()")

	returnValue := godotCallFloat(o, "get_default_blend_time")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetRoot() *NodePath {
	log.Println("Calling AnimationPlayer.GetRoot()")

	returnValue := godotCallNodePath(o, "get_root")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetSpeedScale() float64 {
	log.Println("Calling AnimationPlayer.GetSpeedScale()")

	returnValue := godotCallFloat(o, "get_speed_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the [code]AnimationPlayer[/code] stores an [Animation] with key [code]name[/code].
*/
func (o *AnimationPlayer) HasAnimation(name string) bool {
	log.Println("Calling AnimationPlayer.HasAnimation()")

	returnValue := godotCallBoolString(o, "has_animation", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) IsActive() bool {
	log.Println("Calling AnimationPlayer.IsActive()")

	returnValue := godotCallBool(o, "is_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if playing an animation.
*/
func (o *AnimationPlayer) IsPlaying() bool {
	log.Println("Calling AnimationPlayer.IsPlaying()")

	returnValue := godotCallBool(o, "is_playing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Play the animation with key [code]name[/code]. Custom speed and blend times can be set. If custom speed is negative (-1), 'from_end' being true can play the animation backwards.
*/
func (o *AnimationPlayer) Play(name string, customBlend float64, customSpeed float64, fromEnd bool) {
	log.Println("Calling AnimationPlayer.Play()")

	godotCallVoidStringFloatFloatBool(o, "play", name, customBlend, customSpeed, fromEnd)
	log.Println("  Function successfully completed.")

}

/*
   Play the animation with key [code]name[/code] in reverse.
*/
func (o *AnimationPlayer) PlayBackwards(name string, customBlend float64) {
	log.Println("Calling AnimationPlayer.PlayBackwards()")

	godotCallVoidStringFloat(o, "play_backwards", name, customBlend)
	log.Println("  Function successfully completed.")

}

/*
   Queue an animation for playback once the current one is done.
*/
func (o *AnimationPlayer) Queue(name string) {
	log.Println("Calling AnimationPlayer.Queue()")

	godotCallVoidString(o, "queue", name)
	log.Println("  Function successfully completed.")

}

/*
   Remove the animation with key [code]name[/code].
*/
func (o *AnimationPlayer) RemoveAnimation(name string) {
	log.Println("Calling AnimationPlayer.RemoveAnimation()")

	godotCallVoidString(o, "remove_animation", name)
	log.Println("  Function successfully completed.")

}

/*
   Rename an existing animation with key [code]name[/code] to [code]newname[/code].
*/
func (o *AnimationPlayer) RenameAnimation(name string, newname string) {
	log.Println("Calling AnimationPlayer.RenameAnimation()")

	godotCallVoidStringString(o, "rename_animation", name, newname)
	log.Println("  Function successfully completed.")

}

/*
   Seek the animation to the [code]seconds[/code] point in time (in seconds). If [code]update[/code] is [code]true[/code], the animation updates too, otherwise it updates at process time.
*/
func (o *AnimationPlayer) Seek(seconds float64, update bool) {
	log.Println("Calling AnimationPlayer.Seek()")

	godotCallVoidFloatBool(o, "seek", seconds, update)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetActive(active bool) {
	log.Println("Calling AnimationPlayer.SetActive()")

	godotCallVoidBool(o, "set_active", active)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetAnimationProcessMode(mode int64) {
	log.Println("Calling AnimationPlayer.SetAnimationProcessMode()")

	godotCallVoidInt(o, "set_animation_process_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetAssignedAnimation(anim string) {
	log.Println("Calling AnimationPlayer.SetAssignedAnimation()")

	godotCallVoidString(o, "set_assigned_animation", anim)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetAutoplay(name string) {
	log.Println("Calling AnimationPlayer.SetAutoplay()")

	godotCallVoidString(o, "set_autoplay", name)
	log.Println("  Function successfully completed.")

}

/*
   Specify a blend time (in seconds) between two animations, referenced by their names.
*/
func (o *AnimationPlayer) SetBlendTime(animFrom string, animTo string, sec float64) {
	log.Println("Calling AnimationPlayer.SetBlendTime()")

	godotCallVoidStringStringFloat(o, "set_blend_time", animFrom, animTo, sec)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetCurrentAnimation(anim string) {
	log.Println("Calling AnimationPlayer.SetCurrentAnimation()")

	godotCallVoidString(o, "set_current_animation", anim)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetDefaultBlendTime(sec float64) {
	log.Println("Calling AnimationPlayer.SetDefaultBlendTime()")

	godotCallVoidFloat(o, "set_default_blend_time", sec)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetRoot(path *NodePath) {
	log.Println("Calling AnimationPlayer.SetRoot()")

	godotCallVoidNodePath(o, "set_root", path)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetSpeedScale(speed float64) {
	log.Println("Calling AnimationPlayer.SetSpeedScale()")

	godotCallVoidFloat(o, "set_speed_scale", speed)
	log.Println("  Function successfully completed.")

}

/*
   Stop the currently playing animation. If [code]reset[/code] is [code]true[/code], the anim position is reset to [code]0[/code].
*/
func (o *AnimationPlayer) Stop(reset bool) {
	log.Println("Calling AnimationPlayer.Stop()")

	godotCallVoidBool(o, "stop", reset)
	log.Println("  Function successfully completed.")

}

/*
   AnimationPlayerImplementer is an interface for AnimationPlayer objects.
*/
type AnimationPlayerImplementer interface {
	Class
}

/*
   A node graph tool for blending multiple animations bound to an [AnimationPlayer]. Especially useful for animating characters or other skeleton-based rigs. It can combine several animations to form a desired pose. It takes [Animation]s from an [AnimationPlayer] node and mixes them depending on the graph.
*/
type AnimationTreePlayer struct {
	Node
}

func (o *AnimationTreePlayer) baseClass() string {
	return "AnimationTreePlayer"
}

/*
   Adds a [code]type[/code] node to the graph with name [code]id[/code].
*/
func (o *AnimationTreePlayer) AddNode(aType int64, id string) {
	log.Println("Calling AnimationTreePlayer.AddNode()")

	godotCallVoidIntString(o, "add_node", aType, id)
	log.Println("  Function successfully completed.")

}

/*
   Shifts position in the animation timeline. Delta is the time in seconds to shift.
*/
func (o *AnimationTreePlayer) Advance(delta float64) {
	log.Println("Calling AnimationTreePlayer.Advance()")

	godotCallVoidFloat(o, "advance", delta)
	log.Println("  Function successfully completed.")

}

/*
   Returns the [AnimationPlayer]'s [Animation] bound to the [code]AnimationTreePlayer[/code]'s animation node with name [code]id[/code].
*/
func (o *AnimationTreePlayer) AnimationNodeGetAnimation(id string) *Animation {
	log.Println("Calling AnimationTreePlayer.AnimationNodeGetAnimation()")

	returnValue := godotCallObjectString(o, "animation_node_get_animation", id)
	log.Println("  Got return value: ", returnValue)

	var ret Animation
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the name of the [member master_player]'s [Animation] bound to this animation node.
*/
func (o *AnimationTreePlayer) AnimationNodeGetMasterAnimation(id string) string {
	log.Println("Calling AnimationTreePlayer.AnimationNodeGetMasterAnimation()")

	returnValue := godotCallStringString(o, "animation_node_get_master_animation", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Binds a new [Animation] from the [member master_player] to the [code]AnimationTreePlayer[/code]'s animation node with name [code]id[/code].
*/
func (o *AnimationTreePlayer) AnimationNodeSetAnimation(id string, animation *Animation) {
	log.Println("Calling AnimationTreePlayer.AnimationNodeSetAnimation()")

	godotCallVoidStringObject(o, "animation_node_set_animation", id, &animation.Object)
	log.Println("  Function successfully completed.")

}

/*
   If [code]enable[/code] is [code]true[/code], the animation node with ID [code]id[/code] turns off the track modifying the property at [code]path[/code]. The modified node's children continue to animate.
*/
func (o *AnimationTreePlayer) AnimationNodeSetFilterPath(id string, path *NodePath, enable bool) {
	log.Println("Calling AnimationTreePlayer.AnimationNodeSetFilterPath()")

	godotCallVoidStringNodePathBool(o, "animation_node_set_filter_path", id, path, enable)
	log.Println("  Function successfully completed.")

}

/*
   Binds the [Animation] named [code]source[/code] from [member master_player] to the animation node [code]id[/code]. Recalculates caches.
*/
func (o *AnimationTreePlayer) AnimationNodeSetMasterAnimation(id string, source string) {
	log.Println("Calling AnimationTreePlayer.AnimationNodeSetMasterAnimation()")

	godotCallVoidStringString(o, "animation_node_set_master_animation", id, source)
	log.Println("  Function successfully completed.")

}

/*
   Returns whether node [code]id[/code] and [code]dst_id[/code] are connected at the specified slot.
*/
func (o *AnimationTreePlayer) AreNodesConnected(id string, dstId string, dstInputIdx int64) bool {
	log.Println("Calling AnimationTreePlayer.AreNodesConnected()")

	returnValue := godotCallBoolStringStringInt(o, "are_nodes_connected", id, dstId, dstInputIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the blend amount of a Blend2 node given its name.
*/
func (o *AnimationTreePlayer) Blend2NodeGetAmount(id string) float64 {
	log.Println("Calling AnimationTreePlayer.Blend2NodeGetAmount()")

	returnValue := godotCallFloatString(o, "blend2_node_get_amount", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the blend amount of a Blend2 node given its name and value. A Blend2 Node blends two animations with the amount between 0 and 1. At 0, Output is input a. Towards 1, the influence of a gets lessened, the influence of b gets raised. At 1, Output is input b.
*/
func (o *AnimationTreePlayer) Blend2NodeSetAmount(id string, blend float64) {
	log.Println("Calling AnimationTreePlayer.Blend2NodeSetAmount()")

	godotCallVoidStringFloat(o, "blend2_node_set_amount", id, blend)
	log.Println("  Function successfully completed.")

}

/*
   If [code]enable[/code] is [code]true[/code], the blend2 node with ID [code]id[/code] turns off the track modifying the property at [code]path[/code]. The modified node's children continue to animate.
*/
func (o *AnimationTreePlayer) Blend2NodeSetFilterPath(id string, path *NodePath, enable bool) {
	log.Println("Calling AnimationTreePlayer.Blend2NodeSetFilterPath()")

	godotCallVoidStringNodePathBool(o, "blend2_node_set_filter_path", id, path, enable)
	log.Println("  Function successfully completed.")

}

/*
   Returns the blend amount of a Blend3 node given its name.
*/
func (o *AnimationTreePlayer) Blend3NodeGetAmount(id string) float64 {
	log.Println("Calling AnimationTreePlayer.Blend3NodeGetAmount()")

	returnValue := godotCallFloatString(o, "blend3_node_get_amount", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the blend amount of a Blend3 node given its name and value. A Blend3 Node blends three animations with the amount between -1 and 1. At -1, Output is input b-. From -1 to 0, the influence of b- gets lessened, the influence of a gets raised and the influence of b+ is 0. At 0, Output is input a. From 0 to 1, the influence of a gets lessened, the influence of b+ gets raised and the influence of b+ is 0. At 1, Output is input b+.
*/
func (o *AnimationTreePlayer) Blend3NodeSetAmount(id string, blend float64) {
	log.Println("Calling AnimationTreePlayer.Blend3NodeSetAmount()")

	godotCallVoidStringFloat(o, "blend3_node_set_amount", id, blend)
	log.Println("  Function successfully completed.")

}

/*
   Returns the blend amount of a Blend4 node given its name.
*/
func (o *AnimationTreePlayer) Blend4NodeGetAmount(id string) *Vector2 {
	log.Println("Calling AnimationTreePlayer.Blend4NodeGetAmount()")

	returnValue := godotCallVector2String(o, "blend4_node_get_amount", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the blend amount of a Blend4 node given its name and value. A Blend4 Node blends two pairs of animations. The two pairs are blended like blend2 and then added together.
*/
func (o *AnimationTreePlayer) Blend4NodeSetAmount(id string, blend *Vector2) {
	log.Println("Calling AnimationTreePlayer.Blend4NodeSetAmount()")

	godotCallVoidStringVector2(o, "blend4_node_set_amount", id, blend)
	log.Println("  Function successfully completed.")

}

/*
   Connects node [code]id[/code] to [code]dst_id[/code] at the specified input slot.
*/
func (o *AnimationTreePlayer) ConnectNodes(id string, dstId string, dstInputIdx int64) int64 {
	log.Println("Calling AnimationTreePlayer.ConnectNodes()")

	returnValue := godotCallIntStringStringInt(o, "connect_nodes", id, dstId, dstInputIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Disconnects nodes connected to [code]id[/code] at the specified input slot.
*/
func (o *AnimationTreePlayer) DisconnectNodes(id string, dstInputIdx int64) {
	log.Println("Calling AnimationTreePlayer.DisconnectNodes()")

	godotCallVoidStringInt(o, "disconnect_nodes", id, dstInputIdx)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationTreePlayer) GetAnimationProcessMode() int64 {
	log.Println("Calling AnimationTreePlayer.GetAnimationProcessMode()")

	returnValue := godotCallInt(o, "get_animation_process_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationTreePlayer) GetBasePath() *NodePath {
	log.Println("Calling AnimationTreePlayer.GetBasePath()")

	returnValue := godotCallNodePath(o, "get_base_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationTreePlayer) GetMasterPlayer() *NodePath {
	log.Println("Calling AnimationTreePlayer.GetMasterPlayer()")

	returnValue := godotCallNodePath(o, "get_master_player")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a [PoolStringArray] containing the name of all nodes.
*/
func (o *AnimationTreePlayer) GetNodeList() *PoolStringArray {
	log.Println("Calling AnimationTreePlayer.GetNodeList()")

	returnValue := godotCallPoolStringArray(o, "get_node_list")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationTreePlayer) IsActive() bool {
	log.Println("Calling AnimationTreePlayer.IsActive()")

	returnValue := godotCallBool(o, "is_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns mix amount of a Mix node given its name.
*/
func (o *AnimationTreePlayer) MixNodeGetAmount(id string) float64 {
	log.Println("Calling AnimationTreePlayer.MixNodeGetAmount()")

	returnValue := godotCallFloatString(o, "mix_node_get_amount", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets mix amount of a Mix node given its name and value. A Mix node adds input b to input a by a the amount given by ratio.
*/
func (o *AnimationTreePlayer) MixNodeSetAmount(id string, ratio float64) {
	log.Println("Calling AnimationTreePlayer.MixNodeSetAmount()")

	godotCallVoidStringFloat(o, "mix_node_set_amount", id, ratio)
	log.Println("  Function successfully completed.")

}

/*
   Check if a node exists (by name).
*/
func (o *AnimationTreePlayer) NodeExists(node string) bool {
	log.Println("Calling AnimationTreePlayer.NodeExists()")

	returnValue := godotCallBoolString(o, "node_exists", node)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the input count for a given node. Different types of nodes have different amount of inputs.
*/
func (o *AnimationTreePlayer) NodeGetInputCount(id string) int64 {
	log.Println("Calling AnimationTreePlayer.NodeGetInputCount()")

	returnValue := godotCallIntString(o, "node_get_input_count", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the input source for a given node input.
*/
func (o *AnimationTreePlayer) NodeGetInputSource(id string, idx int64) string {
	log.Println("Calling AnimationTreePlayer.NodeGetInputSource()")

	returnValue := godotCallStringStringInt(o, "node_get_input_source", id, idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns position of a node in the graph given its name.
*/
func (o *AnimationTreePlayer) NodeGetPosition(id string) *Vector2 {
	log.Println("Calling AnimationTreePlayer.NodeGetPosition()")

	returnValue := godotCallVector2String(o, "node_get_position", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the node type, will return from NODE_* enum.
*/
func (o *AnimationTreePlayer) NodeGetType(id string) int64 {
	log.Println("Calling AnimationTreePlayer.NodeGetType()")

	returnValue := godotCallIntString(o, "node_get_type", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Rename a node in the graph.
*/
func (o *AnimationTreePlayer) NodeRename(node string, newName string) int64 {
	log.Println("Calling AnimationTreePlayer.NodeRename()")

	returnValue := godotCallIntStringString(o, "node_rename", node, newName)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets position of a node in the graph given its name and position.
*/
func (o *AnimationTreePlayer) NodeSetPosition(id string, screenPosition *Vector2) {
	log.Println("Calling AnimationTreePlayer.NodeSetPosition()")

	godotCallVoidStringVector2(o, "node_set_position", id, screenPosition)
	log.Println("  Function successfully completed.")

}

/*
   Returns autostart delay of a OneShot node given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeGetAutorestartDelay(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetAutorestartDelay()")

	returnValue := godotCallFloatString(o, "oneshot_node_get_autorestart_delay", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns autostart random delay of a OneShot node given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeGetAutorestartRandomDelay(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetAutorestartRandomDelay()")

	returnValue := godotCallFloatString(o, "oneshot_node_get_autorestart_random_delay", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns fade in time of a OneShot node given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeGetFadeinTime(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetFadeinTime()")

	returnValue := godotCallFloatString(o, "oneshot_node_get_fadein_time", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns fade out time of a OneShot node given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeGetFadeoutTime(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetFadeoutTime()")

	returnValue := godotCallFloatString(o, "oneshot_node_get_fadeout_time", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether a OneShot node will auto restart given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeHasAutorestart(id string) bool {
	log.Println("Calling AnimationTreePlayer.OneshotNodeHasAutorestart()")

	returnValue := godotCallBoolString(o, "oneshot_node_has_autorestart", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether a OneShot node is active given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeIsActive(id string) bool {
	log.Println("Calling AnimationTreePlayer.OneshotNodeIsActive()")

	returnValue := godotCallBoolString(o, "oneshot_node_is_active", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets autorestart property of a OneShot node given its name and value.
*/
func (o *AnimationTreePlayer) OneshotNodeSetAutorestart(id string, enable bool) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetAutorestart()")

	godotCallVoidStringBool(o, "oneshot_node_set_autorestart", id, enable)
	log.Println("  Function successfully completed.")

}

/*
   Sets autorestart delay of a OneShot node given its name and value in seconds.
*/
func (o *AnimationTreePlayer) OneshotNodeSetAutorestartDelay(id string, delaySec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetAutorestartDelay()")

	godotCallVoidStringFloat(o, "oneshot_node_set_autorestart_delay", id, delaySec)
	log.Println("  Function successfully completed.")

}

/*
   Sets autorestart random delay of a OneShot node given its name and value in seconds.
*/
func (o *AnimationTreePlayer) OneshotNodeSetAutorestartRandomDelay(id string, randSec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetAutorestartRandomDelay()")

	godotCallVoidStringFloat(o, "oneshot_node_set_autorestart_random_delay", id, randSec)
	log.Println("  Function successfully completed.")

}

/*
   Sets fade in time of a OneShot node given its name and value in seconds.
*/
func (o *AnimationTreePlayer) OneshotNodeSetFadeinTime(id string, timeSec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetFadeinTime()")

	godotCallVoidStringFloat(o, "oneshot_node_set_fadein_time", id, timeSec)
	log.Println("  Function successfully completed.")

}

/*
   Sets fade out time of a OneShot node given its name and value in seconds.
*/
func (o *AnimationTreePlayer) OneshotNodeSetFadeoutTime(id string, timeSec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetFadeoutTime()")

	godotCallVoidStringFloat(o, "oneshot_node_set_fadeout_time", id, timeSec)
	log.Println("  Function successfully completed.")

}

/*
   If [code]enable[/code] is [code]true[/code], the oneshot node with ID [code]id[/code] turns off the track modifying the property at [code]path[/code]. The modified node's children continue to animate.
*/
func (o *AnimationTreePlayer) OneshotNodeSetFilterPath(id string, path *NodePath, enable bool) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetFilterPath()")

	godotCallVoidStringNodePathBool(o, "oneshot_node_set_filter_path", id, path, enable)
	log.Println("  Function successfully completed.")

}

/*
   Starts a OneShot node given its name.
*/
func (o *AnimationTreePlayer) OneshotNodeStart(id string) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeStart()")

	godotCallVoidString(o, "oneshot_node_start", id)
	log.Println("  Function successfully completed.")

}

/*
   Stops the OneShot node with name [code]id[/code].
*/
func (o *AnimationTreePlayer) OneshotNodeStop(id string) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeStop()")

	godotCallVoidString(o, "oneshot_node_stop", id)
	log.Println("  Function successfully completed.")

}

/*
   Manually recalculates the cache of track information generated from animation nodes. Needed when external sources modify the animation nodes' state.
*/
func (o *AnimationTreePlayer) RecomputeCaches() {
	log.Println("Calling AnimationTreePlayer.RecomputeCaches()")

	godotCallVoid(o, "recompute_caches")
	log.Println("  Function successfully completed.")

}

/*
   Removes the animation node with name [code]id[/code].
*/
func (o *AnimationTreePlayer) RemoveNode(id string) {
	log.Println("Calling AnimationTreePlayer.RemoveNode()")

	godotCallVoidString(o, "remove_node", id)
	log.Println("  Function successfully completed.")

}

/*
   Resets this [code]AnimationTreePlayer[/code].
*/
func (o *AnimationTreePlayer) Reset() {
	log.Println("Calling AnimationTreePlayer.Reset()")

	godotCallVoid(o, "reset")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationTreePlayer) SetActive(enabled bool) {
	log.Println("Calling AnimationTreePlayer.SetActive()")

	godotCallVoidBool(o, "set_active", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationTreePlayer) SetAnimationProcessMode(mode int64) {
	log.Println("Calling AnimationTreePlayer.SetAnimationProcessMode()")

	godotCallVoidInt(o, "set_animation_process_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationTreePlayer) SetBasePath(path *NodePath) {
	log.Println("Calling AnimationTreePlayer.SetBasePath()")

	godotCallVoidNodePath(o, "set_base_path", path)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationTreePlayer) SetMasterPlayer(nodepath *NodePath) {
	log.Println("Calling AnimationTreePlayer.SetMasterPlayer()")

	godotCallVoidNodePath(o, "set_master_player", nodepath)
	log.Println("  Function successfully completed.")

}

/*
   Returns time scale value of the TimeScale node with name [code]id[/code].
*/
func (o *AnimationTreePlayer) TimescaleNodeGetScale(id string) float64 {
	log.Println("Calling AnimationTreePlayer.TimescaleNodeGetScale()")

	returnValue := godotCallFloatString(o, "timescale_node_get_scale", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the time scale of the TimeScale node with name [code]id[/code] to [code]scale[/code]. The timescale node is used to speed [Animation]s up if the scale is above 1 or slow them down if it is below 1. If applied after a blend or mix, affects all input animations to that blend or mix.
*/
func (o *AnimationTreePlayer) TimescaleNodeSetScale(id string, scale float64) {
	log.Println("Calling AnimationTreePlayer.TimescaleNodeSetScale()")

	godotCallVoidStringFloat(o, "timescale_node_set_scale", id, scale)
	log.Println("  Function successfully completed.")

}

/*
   Sets the time seek value of the TimeSeek node with name [code]id[/code] to [code]seconds[/code] This functions as a seek in the [Animation] or the blend or mix of [Animation]s input in it.
*/
func (o *AnimationTreePlayer) TimeseekNodeSeek(id string, seconds float64) {
	log.Println("Calling AnimationTreePlayer.TimeseekNodeSeek()")

	godotCallVoidStringFloat(o, "timeseek_node_seek", id, seconds)
	log.Println("  Function successfully completed.")

}

/*
   Deletes the input at [code]input_idx[/code] for the transition node with name [code]id[/code].
*/
func (o *AnimationTreePlayer) TransitionNodeDeleteInput(id string, inputIdx int64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeDeleteInput()")

	godotCallVoidStringInt(o, "transition_node_delete_input", id, inputIdx)
	log.Println("  Function successfully completed.")

}

/*
   Returns the index of the currently evaluated input for the transition node with name [code]id[/code].
*/
func (o *AnimationTreePlayer) TransitionNodeGetCurrent(id string) int64 {
	log.Println("Calling AnimationTreePlayer.TransitionNodeGetCurrent()")

	returnValue := godotCallIntString(o, "transition_node_get_current", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of inputs for the transition node with name [code]id[/code]. You can add inputs by rightclicking on the transition node.
*/
func (o *AnimationTreePlayer) TransitionNodeGetInputCount(id string) int64 {
	log.Println("Calling AnimationTreePlayer.TransitionNodeGetInputCount()")

	returnValue := godotCallIntString(o, "transition_node_get_input_count", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the cross fade time for the transition node with name [code]id[/code].
*/
func (o *AnimationTreePlayer) TransitionNodeGetXfadeTime(id string) float64 {
	log.Println("Calling AnimationTreePlayer.TransitionNodeGetXfadeTime()")

	returnValue := godotCallFloatString(o, "transition_node_get_xfade_time", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the input at [code]input_idx[/code] on transition node with name [code]id[/code] is set to automatically advance to the next input upon completion.
*/
func (o *AnimationTreePlayer) TransitionNodeHasInputAutoAdvance(id string, inputIdx int64) bool {
	log.Println("Calling AnimationTreePlayer.TransitionNodeHasInputAutoAdvance()")

	returnValue := godotCallBoolStringInt(o, "transition_node_has_input_auto_advance", id, inputIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   The transition node with name [code]id[/code] sets its current input at [code]input_idx[/code].
*/
func (o *AnimationTreePlayer) TransitionNodeSetCurrent(id string, inputIdx int64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetCurrent()")

	godotCallVoidStringInt(o, "transition_node_set_current", id, inputIdx)
	log.Println("  Function successfully completed.")

}

/*
   The transition node with name [code]id[/code] advances to its next input automatically when the input at [code]input_idx[/code] completes.
*/
func (o *AnimationTreePlayer) TransitionNodeSetInputAutoAdvance(id string, inputIdx int64, enable bool) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetInputAutoAdvance()")

	godotCallVoidStringIntBool(o, "transition_node_set_input_auto_advance", id, inputIdx, enable)
	log.Println("  Function successfully completed.")

}

/*
   Resizes the number of inputs available for the transition node with name [code]id[/code].
*/
func (o *AnimationTreePlayer) TransitionNodeSetInputCount(id string, count int64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetInputCount()")

	godotCallVoidStringInt(o, "transition_node_set_input_count", id, count)
	log.Println("  Function successfully completed.")

}

/*
   The transition node with name [code]id[/code] sets its cross fade time to [code]time_sec[/code].
*/
func (o *AnimationTreePlayer) TransitionNodeSetXfadeTime(id string, timeSec float64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetXfadeTime()")

	godotCallVoidStringFloat(o, "transition_node_set_xfade_time", id, timeSec)
	log.Println("  Function successfully completed.")

}

/*
   AnimationTreePlayerImplementer is an interface for AnimationTreePlayer objects.
*/
type AnimationTreePlayerImplementer interface {
	Class
}

/*
   3D area that detects [CollisionObject] nodes overlapping, entering, or exiting. Can also alter or override local physics parameters (gravity, damping).
*/
type Area struct {
	CollisionObject
}

func (o *Area) baseClass() string {
	return "Area"
}

/*
   Undocumented
*/
func (o *Area) X_AreaEnterTree(id int64) {
	log.Println("Calling Area.X_AreaEnterTree()")

	godotCallVoidInt(o, "_area_enter_tree", id)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) X_AreaExitTree(id int64) {
	log.Println("Calling Area.X_AreaExitTree()")

	godotCallVoidInt(o, "_area_exit_tree", id)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) X_AreaInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area.X_AreaInout()")

	godotCallVoidIntRidIntIntInt(o, "_area_inout", arg0, arg1, arg2, arg3, arg4)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) X_BodyEnterTree(id int64) {
	log.Println("Calling Area.X_BodyEnterTree()")

	godotCallVoidInt(o, "_body_enter_tree", id)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) X_BodyExitTree(id int64) {
	log.Println("Calling Area.X_BodyExitTree()")

	godotCallVoidInt(o, "_body_exit_tree", id)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) X_BodyInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area.X_BodyInout()")

	godotCallVoidIntRidIntIntInt(o, "_body_inout", arg0, arg1, arg2, arg3, arg4)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) GetAngularDamp() float64 {
	log.Println("Calling Area.GetAngularDamp()")

	returnValue := godotCallFloat(o, "get_angular_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetAudioBus() string {
	log.Println("Calling Area.GetAudioBus()")

	returnValue := godotCallString(o, "get_audio_bus")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetCollisionLayer() int64 {
	log.Println("Calling Area.GetCollisionLayer()")

	returnValue := godotCallInt(o, "get_collision_layer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an individual bit on the layer mask.
*/
func (o *Area) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling Area.GetCollisionLayerBit()")

	returnValue := godotCallBoolInt(o, "get_collision_layer_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetCollisionMask() int64 {
	log.Println("Calling Area.GetCollisionMask()")

	returnValue := godotCallInt(o, "get_collision_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an individual bit on the collision mask.
*/
func (o *Area) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling Area.GetCollisionMaskBit()")

	returnValue := godotCallBoolInt(o, "get_collision_mask_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetGravity() float64 {
	log.Println("Calling Area.GetGravity()")

	returnValue := godotCallFloat(o, "get_gravity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetGravityDistanceScale() float64 {
	log.Println("Calling Area.GetGravityDistanceScale()")

	returnValue := godotCallFloat(o, "get_gravity_distance_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetGravityVector() *Vector3 {
	log.Println("Calling Area.GetGravityVector()")

	returnValue := godotCallVector3(o, "get_gravity_vector")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetLinearDamp() float64 {
	log.Println("Calling Area.GetLinearDamp()")

	returnValue := godotCallFloat(o, "get_linear_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a list of intersecting [code]Area[/code]s. For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (o *Area) GetOverlappingAreas() *Array {
	log.Println("Calling Area.GetOverlappingAreas()")

	returnValue := godotCallArray(o, "get_overlapping_areas")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a list of intersecting [PhysicsBody]s. For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (o *Area) GetOverlappingBodies() *Array {
	log.Println("Calling Area.GetOverlappingBodies()")

	returnValue := godotCallArray(o, "get_overlapping_bodies")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetPriority() float64 {
	log.Println("Calling Area.GetPriority()")

	returnValue := godotCallFloat(o, "get_priority")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetReverbAmount() float64 {
	log.Println("Calling Area.GetReverbAmount()")

	returnValue := godotCallFloat(o, "get_reverb_amount")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetReverbBus() string {
	log.Println("Calling Area.GetReverbBus()")

	returnValue := godotCallString(o, "get_reverb_bus")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetReverbUniformity() float64 {
	log.Println("Calling Area.GetReverbUniformity()")

	returnValue := godotCallFloat(o, "get_reverb_uniformity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) GetSpaceOverrideMode() int64 {
	log.Println("Calling Area.GetSpaceOverrideMode()")

	returnValue := godotCallInt(o, "get_space_override_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) IsGravityAPoint() bool {
	log.Println("Calling Area.IsGravityAPoint()")

	returnValue := godotCallBool(o, "is_gravity_a_point")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) IsMonitorable() bool {
	log.Println("Calling Area.IsMonitorable()")

	returnValue := godotCallBool(o, "is_monitorable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) IsMonitoring() bool {
	log.Println("Calling Area.IsMonitoring()")

	returnValue := godotCallBool(o, "is_monitoring")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) IsOverridingAudioBus() bool {
	log.Println("Calling Area.IsOverridingAudioBus()")

	returnValue := godotCallBool(o, "is_overriding_audio_bus")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) IsUsingReverbBus() bool {
	log.Println("Calling Area.IsUsingReverbBus()")

	returnValue := godotCallBool(o, "is_using_reverb_bus")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the given area overlaps the Area. Note that the result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
*/
func (o *Area) OverlapsArea(area *Object) bool {
	log.Println("Calling Area.OverlapsArea()")

	returnValue := godotCallBoolObject(o, "overlaps_area", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the given body overlaps the Area. Note that the result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
*/
func (o *Area) OverlapsBody(body *Object) bool {
	log.Println("Calling Area.OverlapsBody()")

	returnValue := godotCallBoolObject(o, "overlaps_body", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area) SetAngularDamp(angularDamp float64) {
	log.Println("Calling Area.SetAngularDamp()")

	godotCallVoidFloat(o, "set_angular_damp", angularDamp)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetAudioBus(name string) {
	log.Println("Calling Area.SetAudioBus()")

	godotCallVoidString(o, "set_audio_bus", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetAudioBusOverride(enable bool) {
	log.Println("Calling Area.SetAudioBusOverride()")

	godotCallVoidBool(o, "set_audio_bus_override", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling Area.SetCollisionLayer()")

	godotCallVoidInt(o, "set_collision_layer", collisionLayer)
	log.Println("  Function successfully completed.")

}

/*
   Set/clear individual bits on the layer mask. This simplifies editing this [code]Area[code]'s layers.
*/
func (o *Area) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling Area.SetCollisionLayerBit()")

	godotCallVoidIntBool(o, "set_collision_layer_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetCollisionMask(collisionMask int64) {
	log.Println("Calling Area.SetCollisionMask()")

	godotCallVoidInt(o, "set_collision_mask", collisionMask)
	log.Println("  Function successfully completed.")

}

/*
   Set/clear individual bits on the collision mask. This simplifies editing which [code]Area[/code] layers this [code]Area[/code] scans.
*/
func (o *Area) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling Area.SetCollisionMaskBit()")

	godotCallVoidIntBool(o, "set_collision_mask_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetGravity(gravity float64) {
	log.Println("Calling Area.SetGravity()")

	godotCallVoidFloat(o, "set_gravity", gravity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetGravityDistanceScale(distanceScale float64) {
	log.Println("Calling Area.SetGravityDistanceScale()")

	godotCallVoidFloat(o, "set_gravity_distance_scale", distanceScale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetGravityIsPoint(enable bool) {
	log.Println("Calling Area.SetGravityIsPoint()")

	godotCallVoidBool(o, "set_gravity_is_point", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetGravityVector(vector *Vector3) {
	log.Println("Calling Area.SetGravityVector()")

	godotCallVoidVector3(o, "set_gravity_vector", vector)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetLinearDamp(linearDamp float64) {
	log.Println("Calling Area.SetLinearDamp()")

	godotCallVoidFloat(o, "set_linear_damp", linearDamp)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetMonitorable(enable bool) {
	log.Println("Calling Area.SetMonitorable()")

	godotCallVoidBool(o, "set_monitorable", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetMonitoring(enable bool) {
	log.Println("Calling Area.SetMonitoring()")

	godotCallVoidBool(o, "set_monitoring", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetPriority(priority float64) {
	log.Println("Calling Area.SetPriority()")

	godotCallVoidFloat(o, "set_priority", priority)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetReverbAmount(amount float64) {
	log.Println("Calling Area.SetReverbAmount()")

	godotCallVoidFloat(o, "set_reverb_amount", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetReverbBus(name string) {
	log.Println("Calling Area.SetReverbBus()")

	godotCallVoidString(o, "set_reverb_bus", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetReverbUniformity(amount float64) {
	log.Println("Calling Area.SetReverbUniformity()")

	godotCallVoidFloat(o, "set_reverb_uniformity", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetSpaceOverrideMode(enable int64) {
	log.Println("Calling Area.SetSpaceOverrideMode()")

	godotCallVoidInt(o, "set_space_override_mode", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area) SetUseReverbBus(enable bool) {
	log.Println("Calling Area.SetUseReverbBus()")

	godotCallVoidBool(o, "set_use_reverb_bus", enable)
	log.Println("  Function successfully completed.")

}

/*
   AreaImplementer is an interface for Area objects.
*/
type AreaImplementer interface {
	Class
}

/*
   2D area that detects [CollisionObject2D] nodes overlapping, entering, or exiting. Can also alter or override local physics parameters (gravity, damping).
*/
type Area2D struct {
	CollisionObject2D
}

func (o *Area2D) baseClass() string {
	return "Area2D"
}

/*
   Undocumented
*/
func (o *Area2D) X_AreaEnterTree(id int64) {
	log.Println("Calling Area2D.X_AreaEnterTree()")

	godotCallVoidInt(o, "_area_enter_tree", id)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) X_AreaExitTree(id int64) {
	log.Println("Calling Area2D.X_AreaExitTree()")

	godotCallVoidInt(o, "_area_exit_tree", id)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) X_AreaInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area2D.X_AreaInout()")

	godotCallVoidIntRidIntIntInt(o, "_area_inout", arg0, arg1, arg2, arg3, arg4)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) X_BodyEnterTree(id int64) {
	log.Println("Calling Area2D.X_BodyEnterTree()")

	godotCallVoidInt(o, "_body_enter_tree", id)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) X_BodyExitTree(id int64) {
	log.Println("Calling Area2D.X_BodyExitTree()")

	godotCallVoidInt(o, "_body_exit_tree", id)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) X_BodyInout(arg0 int64, arg1 *RID, arg2 int64, arg3 int64, arg4 int64) {
	log.Println("Calling Area2D.X_BodyInout()")

	godotCallVoidIntRidIntIntInt(o, "_body_inout", arg0, arg1, arg2, arg3, arg4)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) GetAngularDamp() float64 {
	log.Println("Calling Area2D.GetAngularDamp()")

	returnValue := godotCallFloat(o, "get_angular_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) GetAudioBusName() string {
	log.Println("Calling Area2D.GetAudioBusName()")

	returnValue := godotCallString(o, "get_audio_bus_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) GetCollisionLayer() int64 {
	log.Println("Calling Area2D.GetCollisionLayer()")

	returnValue := godotCallInt(o, "get_collision_layer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return an individual bit on the layer mask. Describes whether other areas will collide with this one on the given layer.
*/
func (o *Area2D) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling Area2D.GetCollisionLayerBit()")

	returnValue := godotCallBoolInt(o, "get_collision_layer_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) GetCollisionMask() int64 {
	log.Println("Calling Area2D.GetCollisionMask()")

	returnValue := godotCallInt(o, "get_collision_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return an individual bit on the collision mask. Describes whether this area will collide with others on the given layer.
*/
func (o *Area2D) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling Area2D.GetCollisionMaskBit()")

	returnValue := godotCallBoolInt(o, "get_collision_mask_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) GetGravity() float64 {
	log.Println("Calling Area2D.GetGravity()")

	returnValue := godotCallFloat(o, "get_gravity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) GetGravityDistanceScale() float64 {
	log.Println("Calling Area2D.GetGravityDistanceScale()")

	returnValue := godotCallFloat(o, "get_gravity_distance_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) GetGravityVector() *Vector2 {
	log.Println("Calling Area2D.GetGravityVector()")

	returnValue := godotCallVector2(o, "get_gravity_vector")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) GetLinearDamp() float64 {
	log.Println("Calling Area2D.GetLinearDamp()")

	returnValue := godotCallFloat(o, "get_linear_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a list of intersecting [code]Area2D[/code]s. For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (o *Area2D) GetOverlappingAreas() *Array {
	log.Println("Calling Area2D.GetOverlappingAreas()")

	returnValue := godotCallArray(o, "get_overlapping_areas")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a list of intersecting [PhysicsBody2D]s. For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (o *Area2D) GetOverlappingBodies() *Array {
	log.Println("Calling Area2D.GetOverlappingBodies()")

	returnValue := godotCallArray(o, "get_overlapping_bodies")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) GetPriority() float64 {
	log.Println("Calling Area2D.GetPriority()")

	returnValue := godotCallFloat(o, "get_priority")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) GetSpaceOverrideMode() int64 {
	log.Println("Calling Area2D.GetSpaceOverrideMode()")

	returnValue := godotCallInt(o, "get_space_override_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) IsGravityAPoint() bool {
	log.Println("Calling Area2D.IsGravityAPoint()")

	returnValue := godotCallBool(o, "is_gravity_a_point")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) IsMonitorable() bool {
	log.Println("Calling Area2D.IsMonitorable()")

	returnValue := godotCallBool(o, "is_monitorable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) IsMonitoring() bool {
	log.Println("Calling Area2D.IsMonitoring()")

	returnValue := godotCallBool(o, "is_monitoring")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) IsOverridingAudioBus() bool {
	log.Println("Calling Area2D.IsOverridingAudioBus()")

	returnValue := godotCallBool(o, "is_overriding_audio_bus")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the given area overlaps the Area2D. Note that the result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
*/
func (o *Area2D) OverlapsArea(area *Object) bool {
	log.Println("Calling Area2D.OverlapsArea()")

	returnValue := godotCallBoolObject(o, "overlaps_area", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the given body overlaps the Area2D. Note that the result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
*/
func (o *Area2D) OverlapsBody(body *Object) bool {
	log.Println("Calling Area2D.OverlapsBody()")

	returnValue := godotCallBoolObject(o, "overlaps_body", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Area2D) SetAngularDamp(angularDamp float64) {
	log.Println("Calling Area2D.SetAngularDamp()")

	godotCallVoidFloat(o, "set_angular_damp", angularDamp)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetAudioBusName(name string) {
	log.Println("Calling Area2D.SetAudioBusName()")

	godotCallVoidString(o, "set_audio_bus_name", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetAudioBusOverride(enable bool) {
	log.Println("Calling Area2D.SetAudioBusOverride()")

	godotCallVoidBool(o, "set_audio_bus_override", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling Area2D.SetCollisionLayer()")

	godotCallVoidInt(o, "set_collision_layer", collisionLayer)
	log.Println("  Function successfully completed.")

}

/*
   Set/clear individual bits on the layer mask. This makes getting an area in/out of only one layer easier.
*/
func (o *Area2D) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling Area2D.SetCollisionLayerBit()")

	godotCallVoidIntBool(o, "set_collision_layer_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetCollisionMask(collisionMask int64) {
	log.Println("Calling Area2D.SetCollisionMask()")

	godotCallVoidInt(o, "set_collision_mask", collisionMask)
	log.Println("  Function successfully completed.")

}

/*
   Set/clear individual bits on the collision mask. This makes selecting the areas scanned easier.
*/
func (o *Area2D) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling Area2D.SetCollisionMaskBit()")

	godotCallVoidIntBool(o, "set_collision_mask_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetGravity(gravity float64) {
	log.Println("Calling Area2D.SetGravity()")

	godotCallVoidFloat(o, "set_gravity", gravity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetGravityDistanceScale(distanceScale float64) {
	log.Println("Calling Area2D.SetGravityDistanceScale()")

	godotCallVoidFloat(o, "set_gravity_distance_scale", distanceScale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetGravityIsPoint(enable bool) {
	log.Println("Calling Area2D.SetGravityIsPoint()")

	godotCallVoidBool(o, "set_gravity_is_point", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetGravityVector(vector *Vector2) {
	log.Println("Calling Area2D.SetGravityVector()")

	godotCallVoidVector2(o, "set_gravity_vector", vector)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetLinearDamp(linearDamp float64) {
	log.Println("Calling Area2D.SetLinearDamp()")

	godotCallVoidFloat(o, "set_linear_damp", linearDamp)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetMonitorable(enable bool) {
	log.Println("Calling Area2D.SetMonitorable()")

	godotCallVoidBool(o, "set_monitorable", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetMonitoring(enable bool) {
	log.Println("Calling Area2D.SetMonitoring()")

	godotCallVoidBool(o, "set_monitoring", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetPriority(priority float64) {
	log.Println("Calling Area2D.SetPriority()")

	godotCallVoidFloat(o, "set_priority", priority)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Area2D) SetSpaceOverrideMode(spaceOverrideMode int64) {
	log.Println("Calling Area2D.SetSpaceOverrideMode()")

	godotCallVoidInt(o, "set_space_override_mode", spaceOverrideMode)
	log.Println("  Function successfully completed.")

}

/*
   Area2DImplementer is an interface for Area2D objects.
*/
type Area2DImplementer interface {
	Class
}

/*

 */
type ArrayMesh struct {
	Mesh
}

func (o *ArrayMesh) baseClass() string {
	return "ArrayMesh"
}

/*

 */
func (o *ArrayMesh) AddBlendShape(name string) {
	log.Println("Calling ArrayMesh.AddBlendShape()")

	godotCallVoidString(o, "add_blend_shape", name)
	log.Println("  Function successfully completed.")

}

/*
   Create a new surface ([method get_surface_count] that will become surf_idx for this. Surfaces are created to be rendered using a "primitive", which may be PRIMITIVE_POINTS, PRIMITIVE_LINES, PRIMITIVE_LINE_STRIP, PRIMITIVE_LINE_LOOP, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIANGLE_STRIP, PRIMITIVE_TRIANGLE_FAN. (As a note, when using indices, it is recommended to only use just points, lines or triangles).
*/
func (o *ArrayMesh) AddSurfaceFromArrays(primitive int64, arrays *Array, blendShapes *Array, compressFlags int64) {
	log.Println("Calling ArrayMesh.AddSurfaceFromArrays()")

	godotCallVoidIntArrayArrayInt(o, "add_surface_from_arrays", primitive, arrays, blendShapes, compressFlags)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ArrayMesh) CenterGeometry() {
	log.Println("Calling ArrayMesh.CenterGeometry()")

	godotCallVoid(o, "center_geometry")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ArrayMesh) ClearBlendShapes() {
	log.Println("Calling ArrayMesh.ClearBlendShapes()")

	godotCallVoid(o, "clear_blend_shapes")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ArrayMesh) GetBlendShapeCount() int64 {
	log.Println("Calling ArrayMesh.GetBlendShapeCount()")

	returnValue := godotCallInt(o, "get_blend_shape_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ArrayMesh) GetBlendShapeMode() int64 {
	log.Println("Calling ArrayMesh.GetBlendShapeMode()")

	returnValue := godotCallInt(o, "get_blend_shape_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *ArrayMesh) GetBlendShapeName(index int64) string {
	log.Println("Calling ArrayMesh.GetBlendShapeName()")

	returnValue := godotCallStringInt(o, "get_blend_shape_name", index)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ArrayMesh) GetCustomAabb() *AABB {
	log.Println("Calling ArrayMesh.GetCustomAabb()")

	returnValue := godotCallAabb(o, "get_custom_aabb")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the amount of surfaces that the [code]ArrayMesh[/code] holds.
*/
func (o *ArrayMesh) GetSurfaceCount() int64 {
	log.Println("Calling ArrayMesh.GetSurfaceCount()")

	returnValue := godotCallInt(o, "get_surface_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *ArrayMesh) RegenNormalmaps() {
	log.Println("Calling ArrayMesh.RegenNormalmaps()")

	godotCallVoid(o, "regen_normalmaps")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ArrayMesh) SetBlendShapeMode(mode int64) {
	log.Println("Calling ArrayMesh.SetBlendShapeMode()")

	godotCallVoidInt(o, "set_blend_shape_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ArrayMesh) SetCustomAabb(aabb *AABB) {
	log.Println("Calling ArrayMesh.SetCustomAabb()")

	godotCallVoidAabb(o, "set_custom_aabb", aabb)
	log.Println("  Function successfully completed.")

}

/*
   Return the length in indices of the index array in the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetArrayIndexLen(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetArrayIndexLen()")

	returnValue := godotCallIntInt(o, "surface_get_array_index_len", surfIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the length in vertices of the vertex array in the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetArrayLen(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetArrayLen()")

	returnValue := godotCallIntInt(o, "surface_get_array_len", surfIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *ArrayMesh) SurfaceGetArrays(surfIdx int64) *Array {
	log.Println("Calling ArrayMesh.SurfaceGetArrays()")

	returnValue := godotCallArrayInt(o, "surface_get_arrays", surfIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *ArrayMesh) SurfaceGetBlendShapeArrays(surfIdx int64) *Array {
	log.Println("Calling ArrayMesh.SurfaceGetBlendShapeArrays()")

	returnValue := godotCallArrayInt(o, "surface_get_blend_shape_arrays", surfIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the format mask of the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetFormat(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetFormat()")

	returnValue := godotCallIntInt(o, "surface_get_format", surfIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return a [Material] in a given surface. Surface is rendered using this material.
*/
func (o *ArrayMesh) SurfaceGetMaterial(surfIdx int64) *Material {
	log.Println("Calling ArrayMesh.SurfaceGetMaterial()")

	returnValue := godotCallObjectInt(o, "surface_get_material", surfIdx)
	log.Println("  Got return value: ", returnValue)

	var ret Material
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *ArrayMesh) SurfaceGetName(surfIdx int64) string {
	log.Println("Calling ArrayMesh.SurfaceGetName()")

	returnValue := godotCallStringInt(o, "surface_get_name", surfIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the primitive type of the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetPrimitiveType(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetPrimitiveType()")

	returnValue := godotCallIntInt(o, "surface_get_primitive_type", surfIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Remove a surface at position surf_idx, shifting greater surfaces one surf_idx slot down.
*/
func (o *ArrayMesh) SurfaceRemove(surfIdx int64) {
	log.Println("Calling ArrayMesh.SurfaceRemove()")

	godotCallVoidInt(o, "surface_remove", surfIdx)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ArrayMesh) SurfaceSetMaterial(surfIdx int64, material *Material) {
	log.Println("Calling ArrayMesh.SurfaceSetMaterial()")

	godotCallVoidIntObject(o, "surface_set_material", surfIdx, &material.Object)
	log.Println("  Function successfully completed.")

}

/*
   Set a [Material] for a given surface. Surface will be rendered using this material.
*/
func (o *ArrayMesh) SurfaceSetName(surfIdx int64, name string) {
	log.Println("Calling ArrayMesh.SurfaceSetName()")

	godotCallVoidIntString(o, "surface_set_name", surfIdx, name)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ArrayMesh) SurfaceUpdateRegion(surfIdx int64, offset int64, data *PoolByteArray) {
	log.Println("Calling ArrayMesh.SurfaceUpdateRegion()")

	godotCallVoidIntIntPoolByteArray(o, "surface_update_region", surfIdx, offset, data)
	log.Println("  Function successfully completed.")

}

/*
   ArrayMeshImplementer is an interface for ArrayMesh objects.
*/
type ArrayMeshImplementer interface {
	Class
}

/*
   [Texture] resource aimed at managing big textures files that pack multiple smaller textures. Consists of a [Texture], a margin that defines the border width, and a region that defines the actual area of the AtlasTexture.
*/
type AtlasTexture struct {
	Texture
}

func (o *AtlasTexture) baseClass() string {
	return "AtlasTexture"
}

/*
   Undocumented
*/
func (o *AtlasTexture) GetAtlas() *Texture {
	log.Println("Calling AtlasTexture.GetAtlas()")

	returnValue := godotCallObject(o, "get_atlas")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *AtlasTexture) GetMargin() *Rect2 {
	log.Println("Calling AtlasTexture.GetMargin()")

	returnValue := godotCallRect2(o, "get_margin")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AtlasTexture) GetRegion() *Rect2 {
	log.Println("Calling AtlasTexture.GetRegion()")

	returnValue := godotCallRect2(o, "get_region")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AtlasTexture) HasFilterClip() bool {
	log.Println("Calling AtlasTexture.HasFilterClip()")

	returnValue := godotCallBool(o, "has_filter_clip")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AtlasTexture) SetAtlas(atlas *Texture) {
	log.Println("Calling AtlasTexture.SetAtlas()")

	godotCallVoidObject(o, "set_atlas", &atlas.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AtlasTexture) SetFilterClip(enable bool) {
	log.Println("Calling AtlasTexture.SetFilterClip()")

	godotCallVoidBool(o, "set_filter_clip", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AtlasTexture) SetMargin(margin *Rect2) {
	log.Println("Calling AtlasTexture.SetMargin()")

	godotCallVoidRect2(o, "set_margin", margin)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AtlasTexture) SetRegion(region *Rect2) {
	log.Println("Calling AtlasTexture.SetRegion()")

	godotCallVoidRect2(o, "set_region", region)
	log.Println("  Function successfully completed.")

}

/*
   AtlasTextureImplementer is an interface for AtlasTexture objects.
*/
type AtlasTextureImplementer interface {
	Class
}

/*
   Stores position, muting, solo, bypass, effects, effect position, volume, and the connections between busses. See [AudioServer] for usage.
*/
type AudioBusLayout struct {
	Resource
}

func (o *AudioBusLayout) baseClass() string {
	return "AudioBusLayout"
}

/*
   AudioBusLayoutImplementer is an interface for AudioBusLayout objects.
*/
type AudioBusLayoutImplementer interface {
	Class
}

/*
   Base resource for audio bus. Applies an audio effect on the bus that the resource is applied on.
*/
type AudioEffect struct {
	Resource
}

func (o *AudioEffect) baseClass() string {
	return "AudioEffect"
}

/*
   AudioEffectImplementer is an interface for AudioEffect objects.
*/
type AudioEffectImplementer interface {
	Class
}

/*
   Increases or decreases the volume being routed through the audio bus.
*/
type AudioEffectAmplify struct {
	AudioEffect
}

func (o *AudioEffectAmplify) baseClass() string {
	return "AudioEffectAmplify"
}

/*
   Undocumented
*/
func (o *AudioEffectAmplify) GetVolumeDb() float64 {
	log.Println("Calling AudioEffectAmplify.GetVolumeDb()")

	returnValue := godotCallFloat(o, "get_volume_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectAmplify) SetVolumeDb(volume float64) {
	log.Println("Calling AudioEffectAmplify.SetVolumeDb()")

	godotCallVoidFloat(o, "set_volume_db", volume)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectAmplifyImplementer is an interface for AudioEffectAmplify objects.
*/
type AudioEffectAmplifyImplementer interface {
	Class
}

/*
   Limits the frequencies in a range around the [member cutoff_hz] and allows frequencies outside of this range to pass.
*/
type AudioEffectBandLimitFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectBandLimitFilter) baseClass() string {
	return "AudioEffectBandLimitFilter"
}

/*
   AudioEffectBandLimitFilterImplementer is an interface for AudioEffectBandLimitFilter objects.
*/
type AudioEffectBandLimitFilterImplementer interface {
	Class
}

/*
   Attenuates the frequencies inside of a range around the [member cutoff_hz] and cuts frequencies outside of this band.
*/
type AudioEffectBandPassFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectBandPassFilter) baseClass() string {
	return "AudioEffectBandPassFilter"
}

/*
   AudioEffectBandPassFilterImplementer is an interface for AudioEffectBandPassFilter objects.
*/
type AudioEffectBandPassFilterImplementer interface {
	Class
}

/*
   Adds a chorus audio effect. The effect applies a filter with voices to duplicate the audio source and manipulate it through the filter.
*/
type AudioEffectChorus struct {
	AudioEffect
}

func (o *AudioEffectChorus) baseClass() string {
	return "AudioEffectChorus"
}

/*
   Undocumented
*/
func (o *AudioEffectChorus) GetDry() float64 {
	log.Println("Calling AudioEffectChorus.GetDry()")

	returnValue := godotCallFloat(o, "get_dry")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) GetVoiceCount() int64 {
	log.Println("Calling AudioEffectChorus.GetVoiceCount()")

	returnValue := godotCallInt(o, "get_voice_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) GetVoiceCutoffHz(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceCutoffHz()")

	returnValue := godotCallFloatInt(o, "get_voice_cutoff_hz", voiceIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) GetVoiceDelayMs(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceDelayMs()")

	returnValue := godotCallFloatInt(o, "get_voice_delay_ms", voiceIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) GetVoiceDepthMs(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceDepthMs()")

	returnValue := godotCallFloatInt(o, "get_voice_depth_ms", voiceIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) GetVoiceLevelDb(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceLevelDb()")

	returnValue := godotCallFloatInt(o, "get_voice_level_db", voiceIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) GetVoicePan(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoicePan()")

	returnValue := godotCallFloatInt(o, "get_voice_pan", voiceIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) GetVoiceRateHz(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceRateHz()")

	returnValue := godotCallFloatInt(o, "get_voice_rate_hz", voiceIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) GetWet() float64 {
	log.Println("Calling AudioEffectChorus.GetWet()")

	returnValue := godotCallFloat(o, "get_wet")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) SetDry(amount float64) {
	log.Println("Calling AudioEffectChorus.SetDry()")

	godotCallVoidFloat(o, "set_dry", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) SetVoiceCount(voices int64) {
	log.Println("Calling AudioEffectChorus.SetVoiceCount()")

	godotCallVoidInt(o, "set_voice_count", voices)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) SetVoiceCutoffHz(voiceIdx int64, cutoffHz float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceCutoffHz()")

	godotCallVoidIntFloat(o, "set_voice_cutoff_hz", voiceIdx, cutoffHz)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) SetVoiceDelayMs(voiceIdx int64, delayMs float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceDelayMs()")

	godotCallVoidIntFloat(o, "set_voice_delay_ms", voiceIdx, delayMs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) SetVoiceDepthMs(voiceIdx int64, depthMs float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceDepthMs()")

	godotCallVoidIntFloat(o, "set_voice_depth_ms", voiceIdx, depthMs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) SetVoiceLevelDb(voiceIdx int64, levelDb float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceLevelDb()")

	godotCallVoidIntFloat(o, "set_voice_level_db", voiceIdx, levelDb)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) SetVoicePan(voiceIdx int64, pan float64) {
	log.Println("Calling AudioEffectChorus.SetVoicePan()")

	godotCallVoidIntFloat(o, "set_voice_pan", voiceIdx, pan)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) SetVoiceRateHz(voiceIdx int64, rateHz float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceRateHz()")

	godotCallVoidIntFloat(o, "set_voice_rate_hz", voiceIdx, rateHz)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectChorus) SetWet(amount float64) {
	log.Println("Calling AudioEffectChorus.SetWet()")

	godotCallVoidFloat(o, "set_wet", amount)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectChorusImplementer is an interface for AudioEffectChorus objects.
*/
type AudioEffectChorusImplementer interface {
	Class
}

/*
   Dynamic range compressor reduces the level of the sound when the amplitude goes over a certain threshold in Decibels. One of the main uses of a compressor is to increase the dynamic range by clipping as little as possible (when sound goes over 0dB). Compressor has many uses in the mix: - In the Master bus to compress the whole output (Although a [AudioEffectLimiter] is probably better) - In voice channels to ensure they sound as balanced as possible. - Sidechained. Sidechained, which can reduce the sound level sidechained with another audio bus for threshold detection.. This technique is very common in video game mixing to download the level of Music/SFX while voices are being heard. - Accentuates transients by using a wider attack, making effects sound more punchy.
*/
type AudioEffectCompressor struct {
	AudioEffect
}

func (o *AudioEffectCompressor) baseClass() string {
	return "AudioEffectCompressor"
}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) GetAttackUs() float64 {
	log.Println("Calling AudioEffectCompressor.GetAttackUs()")

	returnValue := godotCallFloat(o, "get_attack_us")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) GetGain() float64 {
	log.Println("Calling AudioEffectCompressor.GetGain()")

	returnValue := godotCallFloat(o, "get_gain")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) GetMix() float64 {
	log.Println("Calling AudioEffectCompressor.GetMix()")

	returnValue := godotCallFloat(o, "get_mix")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) GetRatio() float64 {
	log.Println("Calling AudioEffectCompressor.GetRatio()")

	returnValue := godotCallFloat(o, "get_ratio")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) GetReleaseMs() float64 {
	log.Println("Calling AudioEffectCompressor.GetReleaseMs()")

	returnValue := godotCallFloat(o, "get_release_ms")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) GetSidechain() string {
	log.Println("Calling AudioEffectCompressor.GetSidechain()")

	returnValue := godotCallString(o, "get_sidechain")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) GetThreshold() float64 {
	log.Println("Calling AudioEffectCompressor.GetThreshold()")

	returnValue := godotCallFloat(o, "get_threshold")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) SetAttackUs(attackUs float64) {
	log.Println("Calling AudioEffectCompressor.SetAttackUs()")

	godotCallVoidFloat(o, "set_attack_us", attackUs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) SetGain(gain float64) {
	log.Println("Calling AudioEffectCompressor.SetGain()")

	godotCallVoidFloat(o, "set_gain", gain)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) SetMix(mix float64) {
	log.Println("Calling AudioEffectCompressor.SetMix()")

	godotCallVoidFloat(o, "set_mix", mix)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) SetRatio(ratio float64) {
	log.Println("Calling AudioEffectCompressor.SetRatio()")

	godotCallVoidFloat(o, "set_ratio", ratio)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) SetReleaseMs(releaseMs float64) {
	log.Println("Calling AudioEffectCompressor.SetReleaseMs()")

	godotCallVoidFloat(o, "set_release_ms", releaseMs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) SetSidechain(sidechain string) {
	log.Println("Calling AudioEffectCompressor.SetSidechain()")

	godotCallVoidString(o, "set_sidechain", sidechain)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectCompressor) SetThreshold(threshold float64) {
	log.Println("Calling AudioEffectCompressor.SetThreshold()")

	godotCallVoidFloat(o, "set_threshold", threshold)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectCompressorImplementer is an interface for AudioEffectCompressor objects.
*/
type AudioEffectCompressorImplementer interface {
	Class
}

/*
   Plays input signal back after a period of time. The delayed signal may be played back multiple times to create the sound of a repeating, decaying echo. Delay effects range from a subtle echo effect to a pronounced blending of previous sounds with new sounds.
*/
type AudioEffectDelay struct {
	AudioEffect
}

func (o *AudioEffectDelay) baseClass() string {
	return "AudioEffectDelay"
}

/*
   Undocumented
*/
func (o *AudioEffectDelay) GetDry() float64 {
	log.Println("Calling AudioEffectDelay.GetDry()")

	returnValue := godotCallFloat(o, "get_dry")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) GetFeedbackDelayMs() float64 {
	log.Println("Calling AudioEffectDelay.GetFeedbackDelayMs()")

	returnValue := godotCallFloat(o, "get_feedback_delay_ms")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) GetFeedbackLevelDb() float64 {
	log.Println("Calling AudioEffectDelay.GetFeedbackLevelDb()")

	returnValue := godotCallFloat(o, "get_feedback_level_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) GetFeedbackLowpass() float64 {
	log.Println("Calling AudioEffectDelay.GetFeedbackLowpass()")

	returnValue := godotCallFloat(o, "get_feedback_lowpass")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) GetTap1DelayMs() float64 {
	log.Println("Calling AudioEffectDelay.GetTap1DelayMs()")

	returnValue := godotCallFloat(o, "get_tap1_delay_ms")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) GetTap1LevelDb() float64 {
	log.Println("Calling AudioEffectDelay.GetTap1LevelDb()")

	returnValue := godotCallFloat(o, "get_tap1_level_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) GetTap1Pan() float64 {
	log.Println("Calling AudioEffectDelay.GetTap1Pan()")

	returnValue := godotCallFloat(o, "get_tap1_pan")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) GetTap2DelayMs() float64 {
	log.Println("Calling AudioEffectDelay.GetTap2DelayMs()")

	returnValue := godotCallFloat(o, "get_tap2_delay_ms")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) GetTap2LevelDb() float64 {
	log.Println("Calling AudioEffectDelay.GetTap2LevelDb()")

	returnValue := godotCallFloat(o, "get_tap2_level_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) GetTap2Pan() float64 {
	log.Println("Calling AudioEffectDelay.GetTap2Pan()")

	returnValue := godotCallFloat(o, "get_tap2_pan")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) IsFeedbackActive() bool {
	log.Println("Calling AudioEffectDelay.IsFeedbackActive()")

	returnValue := godotCallBool(o, "is_feedback_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) IsTap1Active() bool {
	log.Println("Calling AudioEffectDelay.IsTap1Active()")

	returnValue := godotCallBool(o, "is_tap1_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) IsTap2Active() bool {
	log.Println("Calling AudioEffectDelay.IsTap2Active()")

	returnValue := godotCallBool(o, "is_tap2_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetDry(amount float64) {
	log.Println("Calling AudioEffectDelay.SetDry()")

	godotCallVoidFloat(o, "set_dry", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetFeedbackActive(amount bool) {
	log.Println("Calling AudioEffectDelay.SetFeedbackActive()")

	godotCallVoidBool(o, "set_feedback_active", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetFeedbackDelayMs(amount float64) {
	log.Println("Calling AudioEffectDelay.SetFeedbackDelayMs()")

	godotCallVoidFloat(o, "set_feedback_delay_ms", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetFeedbackLevelDb(amount float64) {
	log.Println("Calling AudioEffectDelay.SetFeedbackLevelDb()")

	godotCallVoidFloat(o, "set_feedback_level_db", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetFeedbackLowpass(amount float64) {
	log.Println("Calling AudioEffectDelay.SetFeedbackLowpass()")

	godotCallVoidFloat(o, "set_feedback_lowpass", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetTap1Active(amount bool) {
	log.Println("Calling AudioEffectDelay.SetTap1Active()")

	godotCallVoidBool(o, "set_tap1_active", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetTap1DelayMs(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap1DelayMs()")

	godotCallVoidFloat(o, "set_tap1_delay_ms", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetTap1LevelDb(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap1LevelDb()")

	godotCallVoidFloat(o, "set_tap1_level_db", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetTap1Pan(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap1Pan()")

	godotCallVoidFloat(o, "set_tap1_pan", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetTap2Active(amount bool) {
	log.Println("Calling AudioEffectDelay.SetTap2Active()")

	godotCallVoidBool(o, "set_tap2_active", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetTap2DelayMs(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap2DelayMs()")

	godotCallVoidFloat(o, "set_tap2_delay_ms", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetTap2LevelDb(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap2LevelDb()")

	godotCallVoidFloat(o, "set_tap2_level_db", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDelay) SetTap2Pan(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap2Pan()")

	godotCallVoidFloat(o, "set_tap2_pan", amount)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectDelayImplementer is an interface for AudioEffectDelay objects.
*/
type AudioEffectDelayImplementer interface {
	Class
}

/*
   Modify the sound and make it dirty. Different types are available : clip, tan, lofi (bit crushing), overdrive, or waveshape. By distorting the waveform the frequency content change, which will often make the sound "crunchy" or "abrasive". For games, it can simulate sound coming from some saturated device or speaker very efficiently.
*/
type AudioEffectDistortion struct {
	AudioEffect
}

func (o *AudioEffectDistortion) baseClass() string {
	return "AudioEffectDistortion"
}

/*
   Undocumented
*/
func (o *AudioEffectDistortion) GetDrive() float64 {
	log.Println("Calling AudioEffectDistortion.GetDrive()")

	returnValue := godotCallFloat(o, "get_drive")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDistortion) GetKeepHfHz() float64 {
	log.Println("Calling AudioEffectDistortion.GetKeepHfHz()")

	returnValue := godotCallFloat(o, "get_keep_hf_hz")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDistortion) GetMode() int64 {
	log.Println("Calling AudioEffectDistortion.GetMode()")

	returnValue := godotCallInt(o, "get_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDistortion) GetPostGain() float64 {
	log.Println("Calling AudioEffectDistortion.GetPostGain()")

	returnValue := godotCallFloat(o, "get_post_gain")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDistortion) GetPreGain() float64 {
	log.Println("Calling AudioEffectDistortion.GetPreGain()")

	returnValue := godotCallFloat(o, "get_pre_gain")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectDistortion) SetDrive(drive float64) {
	log.Println("Calling AudioEffectDistortion.SetDrive()")

	godotCallVoidFloat(o, "set_drive", drive)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDistortion) SetKeepHfHz(keepHfHz float64) {
	log.Println("Calling AudioEffectDistortion.SetKeepHfHz()")

	godotCallVoidFloat(o, "set_keep_hf_hz", keepHfHz)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDistortion) SetMode(mode int64) {
	log.Println("Calling AudioEffectDistortion.SetMode()")

	godotCallVoidInt(o, "set_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDistortion) SetPostGain(postGain float64) {
	log.Println("Calling AudioEffectDistortion.SetPostGain()")

	godotCallVoidFloat(o, "set_post_gain", postGain)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectDistortion) SetPreGain(preGain float64) {
	log.Println("Calling AudioEffectDistortion.SetPreGain()")

	godotCallVoidFloat(o, "set_pre_gain", preGain)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectDistortionImplementer is an interface for AudioEffectDistortion objects.
*/
type AudioEffectDistortionImplementer interface {
	Class
}

/*
   AudioEffectEQ gives you control over frequencies. Use it to compensate for existing deficiencies in audio. AudioEffectEQ are very useful on the Master Bus to completely master a mix and give it character. They are also very useful when a game is run on a mobile device, to adjust the mix to that kind of speakers (it can be added but disabled when headphones are plugged).
*/
type AudioEffectEQ struct {
	AudioEffect
}

func (o *AudioEffectEQ) baseClass() string {
	return "AudioEffectEQ"
}

/*
   Returns the number of bands of the equalizer.
*/
func (o *AudioEffectEQ) GetBandCount() int64 {
	log.Println("Calling AudioEffectEQ.GetBandCount()")

	returnValue := godotCallInt(o, "get_band_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the band's gain at the specified index, in dB.
*/
func (o *AudioEffectEQ) GetBandGainDb(bandIdx int64) float64 {
	log.Println("Calling AudioEffectEQ.GetBandGainDb()")

	returnValue := godotCallFloatInt(o, "get_band_gain_db", bandIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets band's gain at the specified index, in dB.
*/
func (o *AudioEffectEQ) SetBandGainDb(bandIdx int64, volumeDb float64) {
	log.Println("Calling AudioEffectEQ.SetBandGainDb()")

	godotCallVoidIntFloat(o, "set_band_gain_db", bandIdx, volumeDb)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectEQImplementer is an interface for AudioEffectEQ objects.
*/
type AudioEffectEQImplementer interface {
	Class
}

/*
   Frequency bands : Band 1 : 31 Hz Band 2 : 62 Hz Band 3 : 125 Hz Band 4 : 250 Hz Band 5 : 500 Hz Band 6 : 1000 Hz Band 7 : 2000 Hz Band 8 : 4000 Hz Band 9 : 8000 Hz Band 10 : 16000 Hz See also [AudioEffectEQ], [AudioEffectEQ6], [AudioEffectEQ21].
*/
type AudioEffectEQ10 struct {
	AudioEffectEQ
}

func (o *AudioEffectEQ10) baseClass() string {
	return "AudioEffectEQ10"
}

/*
   AudioEffectEQ10Implementer is an interface for AudioEffectEQ10 objects.
*/
type AudioEffectEQ10Implementer interface {
	Class
}

/*
   Frequency bands : Band 1 : 22 Hz Band 2 : 32 Hz Band 3 : 44 Hz Band 4 : 63 Hz Band 5 : 90 Hz Band 6 : 125 Hz Band 7 : 175 Hz Band 8 : 250 Hz Band 9 : 350 Hz Band 10 : 500 Hz Band 11 : 700 Hz Band 12 : 1000 Hz Band 13 : 1400 Hz Band 14 : 2000 Hz Band 15 : 2800 Hz Band 16 : 4000 Hz Band 17 : 5600 Hz Band 18 : 8000 Hz Band 19 : 11000 Hz Band 20 : 16000 Hz Band 21 : 22000 Hz See also [AudioEffectEQ], [AudioEffectEQ6], [AudioEffectEQ10].
*/
type AudioEffectEQ21 struct {
	AudioEffectEQ
}

func (o *AudioEffectEQ21) baseClass() string {
	return "AudioEffectEQ21"
}

/*
   AudioEffectEQ21Implementer is an interface for AudioEffectEQ21 objects.
*/
type AudioEffectEQ21Implementer interface {
	Class
}

/*
   Frequency bands : Band 1 : 32 Hz Band 2 : 100 Hz Band 3 : 320 Hz Band 4 : 1000 Hz Band 5 : 3200 Hz Band 6 : 10000 Hz See also [AudioEffectEQ], [AudioEffectEQ10], [AudioEffectEQ21].
*/
type AudioEffectEQ6 struct {
	AudioEffectEQ
}

func (o *AudioEffectEQ6) baseClass() string {
	return "AudioEffectEQ6"
}

/*
   AudioEffectEQ6Implementer is an interface for AudioEffectEQ6 objects.
*/
type AudioEffectEQ6Implementer interface {
	Class
}

/*
   Allows frequencies other than the [member cutoff_hz] to pass.
*/
type AudioEffectFilter struct {
	AudioEffect
}

func (o *AudioEffectFilter) baseClass() string {
	return "AudioEffectFilter"
}

/*
   Undocumented
*/
func (o *AudioEffectFilter) GetCutoff() float64 {
	log.Println("Calling AudioEffectFilter.GetCutoff()")

	returnValue := godotCallFloat(o, "get_cutoff")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectFilter) GetDb() int64 {
	log.Println("Calling AudioEffectFilter.GetDb()")

	returnValue := godotCallInt(o, "get_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectFilter) GetGain() float64 {
	log.Println("Calling AudioEffectFilter.GetGain()")

	returnValue := godotCallFloat(o, "get_gain")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectFilter) GetResonance() float64 {
	log.Println("Calling AudioEffectFilter.GetResonance()")

	returnValue := godotCallFloat(o, "get_resonance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectFilter) SetCutoff(freq float64) {
	log.Println("Calling AudioEffectFilter.SetCutoff()")

	godotCallVoidFloat(o, "set_cutoff", freq)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectFilter) SetDb(amount int64) {
	log.Println("Calling AudioEffectFilter.SetDb()")

	godotCallVoidInt(o, "set_db", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectFilter) SetGain(amount float64) {
	log.Println("Calling AudioEffectFilter.SetGain()")

	godotCallVoidFloat(o, "set_gain", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectFilter) SetResonance(amount float64) {
	log.Println("Calling AudioEffectFilter.SetResonance()")

	godotCallVoidFloat(o, "set_resonance", amount)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectFilterImplementer is an interface for AudioEffectFilter objects.
*/
type AudioEffectFilterImplementer interface {
	Class
}

/*
   Cuts frequencies lower than the [member cutoff_hz] and allows higher frequencies to pass.
*/
type AudioEffectHighPassFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectHighPassFilter) baseClass() string {
	return "AudioEffectHighPassFilter"
}

/*
   AudioEffectHighPassFilterImplementer is an interface for AudioEffectHighPassFilter objects.
*/
type AudioEffectHighPassFilterImplementer interface {
	Class
}

/*

 */
type AudioEffectHighShelfFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectHighShelfFilter) baseClass() string {
	return "AudioEffectHighShelfFilter"
}

/*
   AudioEffectHighShelfFilterImplementer is an interface for AudioEffectHighShelfFilter objects.
*/
type AudioEffectHighShelfFilterImplementer interface {
	Class
}

/*
   A limiter is similar to a compressor, but it’s less flexible and designed to disallow sound going over a given dB threshold. Adding one in the Master Bus is always recommended to reduce the effects of clipping. Soft clipping starts to reduce the peaks a little below the threshold level and progressively increases its effect as the input level increases such that the threshold is never exceeded.
*/
type AudioEffectLimiter struct {
	AudioEffect
}

func (o *AudioEffectLimiter) baseClass() string {
	return "AudioEffectLimiter"
}

/*
   Undocumented
*/
func (o *AudioEffectLimiter) GetCeilingDb() float64 {
	log.Println("Calling AudioEffectLimiter.GetCeilingDb()")

	returnValue := godotCallFloat(o, "get_ceiling_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectLimiter) GetSoftClipDb() float64 {
	log.Println("Calling AudioEffectLimiter.GetSoftClipDb()")

	returnValue := godotCallFloat(o, "get_soft_clip_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectLimiter) GetSoftClipRatio() float64 {
	log.Println("Calling AudioEffectLimiter.GetSoftClipRatio()")

	returnValue := godotCallFloat(o, "get_soft_clip_ratio")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectLimiter) GetThresholdDb() float64 {
	log.Println("Calling AudioEffectLimiter.GetThresholdDb()")

	returnValue := godotCallFloat(o, "get_threshold_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectLimiter) SetCeilingDb(ceiling float64) {
	log.Println("Calling AudioEffectLimiter.SetCeilingDb()")

	godotCallVoidFloat(o, "set_ceiling_db", ceiling)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectLimiter) SetSoftClipDb(softClip float64) {
	log.Println("Calling AudioEffectLimiter.SetSoftClipDb()")

	godotCallVoidFloat(o, "set_soft_clip_db", softClip)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectLimiter) SetSoftClipRatio(softClip float64) {
	log.Println("Calling AudioEffectLimiter.SetSoftClipRatio()")

	godotCallVoidFloat(o, "set_soft_clip_ratio", softClip)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectLimiter) SetThresholdDb(threshold float64) {
	log.Println("Calling AudioEffectLimiter.SetThresholdDb()")

	godotCallVoidFloat(o, "set_threshold_db", threshold)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectLimiterImplementer is an interface for AudioEffectLimiter objects.
*/
type AudioEffectLimiterImplementer interface {
	Class
}

/*
   Cuts frequencies higher than the [member cutoff_hz] and allows lower frequencies to pass.
*/
type AudioEffectLowPassFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectLowPassFilter) baseClass() string {
	return "AudioEffectLowPassFilter"
}

/*
   AudioEffectLowPassFilterImplementer is an interface for AudioEffectLowPassFilter objects.
*/
type AudioEffectLowPassFilterImplementer interface {
	Class
}

/*

 */
type AudioEffectLowShelfFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectLowShelfFilter) baseClass() string {
	return "AudioEffectLowShelfFilter"
}

/*
   AudioEffectLowShelfFilterImplementer is an interface for AudioEffectLowShelfFilter objects.
*/
type AudioEffectLowShelfFilterImplementer interface {
	Class
}

/*
   Attenuates frequencies in a narrow band around the [member cutoff_hz] and cuts frequencies outside of this range.
*/
type AudioEffectNotchFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectNotchFilter) baseClass() string {
	return "AudioEffectNotchFilter"
}

/*
   AudioEffectNotchFilterImplementer is an interface for AudioEffectNotchFilter objects.
*/
type AudioEffectNotchFilterImplementer interface {
	Class
}

/*
   Determines how much of an audio signal is sent to the left and right buses.
*/
type AudioEffectPanner struct {
	AudioEffect
}

func (o *AudioEffectPanner) baseClass() string {
	return "AudioEffectPanner"
}

/*
   Undocumented
*/
func (o *AudioEffectPanner) GetPan() float64 {
	log.Println("Calling AudioEffectPanner.GetPan()")

	returnValue := godotCallFloat(o, "get_pan")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectPanner) SetPan(cpanume float64) {
	log.Println("Calling AudioEffectPanner.SetPan()")

	godotCallVoidFloat(o, "set_pan", cpanume)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectPannerImplementer is an interface for AudioEffectPanner objects.
*/
type AudioEffectPannerImplementer interface {
	Class
}

/*
   Combines phase-shifted signals with the original signal. The movement of the phase-shifted signals is controlled using a Low Frequency Oscillator.
*/
type AudioEffectPhaser struct {
	AudioEffect
}

func (o *AudioEffectPhaser) baseClass() string {
	return "AudioEffectPhaser"
}

/*
   Undocumented
*/
func (o *AudioEffectPhaser) GetDepth() float64 {
	log.Println("Calling AudioEffectPhaser.GetDepth()")

	returnValue := godotCallFloat(o, "get_depth")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectPhaser) GetFeedback() float64 {
	log.Println("Calling AudioEffectPhaser.GetFeedback()")

	returnValue := godotCallFloat(o, "get_feedback")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectPhaser) GetRangeMaxHz() float64 {
	log.Println("Calling AudioEffectPhaser.GetRangeMaxHz()")

	returnValue := godotCallFloat(o, "get_range_max_hz")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectPhaser) GetRangeMinHz() float64 {
	log.Println("Calling AudioEffectPhaser.GetRangeMinHz()")

	returnValue := godotCallFloat(o, "get_range_min_hz")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectPhaser) GetRateHz() float64 {
	log.Println("Calling AudioEffectPhaser.GetRateHz()")

	returnValue := godotCallFloat(o, "get_rate_hz")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectPhaser) SetDepth(depth float64) {
	log.Println("Calling AudioEffectPhaser.SetDepth()")

	godotCallVoidFloat(o, "set_depth", depth)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectPhaser) SetFeedback(fbk float64) {
	log.Println("Calling AudioEffectPhaser.SetFeedback()")

	godotCallVoidFloat(o, "set_feedback", fbk)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectPhaser) SetRangeMaxHz(hz float64) {
	log.Println("Calling AudioEffectPhaser.SetRangeMaxHz()")

	godotCallVoidFloat(o, "set_range_max_hz", hz)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectPhaser) SetRangeMinHz(hz float64) {
	log.Println("Calling AudioEffectPhaser.SetRangeMinHz()")

	godotCallVoidFloat(o, "set_range_min_hz", hz)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectPhaser) SetRateHz(hz float64) {
	log.Println("Calling AudioEffectPhaser.SetRateHz()")

	godotCallVoidFloat(o, "set_rate_hz", hz)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectPhaserImplementer is an interface for AudioEffectPhaser objects.
*/
type AudioEffectPhaserImplementer interface {
	Class
}

/*
   Allows modulation of pitch independently of tempo. All frequencies can be increased/decreased with minimal effect on transients.
*/
type AudioEffectPitchShift struct {
	AudioEffect
}

func (o *AudioEffectPitchShift) baseClass() string {
	return "AudioEffectPitchShift"
}

/*
   Undocumented
*/
func (o *AudioEffectPitchShift) GetPitchScale() float64 {
	log.Println("Calling AudioEffectPitchShift.GetPitchScale()")

	returnValue := godotCallFloat(o, "get_pitch_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectPitchShift) SetPitchScale(rate float64) {
	log.Println("Calling AudioEffectPitchShift.SetPitchScale()")

	godotCallVoidFloat(o, "set_pitch_scale", rate)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectPitchShiftImplementer is an interface for AudioEffectPitchShift objects.
*/
type AudioEffectPitchShiftImplementer interface {
	Class
}

/*
   Simulates rooms of different sizes. Its parameters can be adjusted to simulate the sound of a specific room.
*/
type AudioEffectReverb struct {
	AudioEffect
}

func (o *AudioEffectReverb) baseClass() string {
	return "AudioEffectReverb"
}

/*
   Undocumented
*/
func (o *AudioEffectReverb) GetDamping() float64 {
	log.Println("Calling AudioEffectReverb.GetDamping()")

	returnValue := godotCallFloat(o, "get_damping")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) GetDry() float64 {
	log.Println("Calling AudioEffectReverb.GetDry()")

	returnValue := godotCallFloat(o, "get_dry")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) GetHpf() float64 {
	log.Println("Calling AudioEffectReverb.GetHpf()")

	returnValue := godotCallFloat(o, "get_hpf")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) GetPredelayFeedback() float64 {
	log.Println("Calling AudioEffectReverb.GetPredelayFeedback()")

	returnValue := godotCallFloat(o, "get_predelay_feedback")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) GetPredelayMsec() float64 {
	log.Println("Calling AudioEffectReverb.GetPredelayMsec()")

	returnValue := godotCallFloat(o, "get_predelay_msec")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) GetRoomSize() float64 {
	log.Println("Calling AudioEffectReverb.GetRoomSize()")

	returnValue := godotCallFloat(o, "get_room_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) GetSpread() float64 {
	log.Println("Calling AudioEffectReverb.GetSpread()")

	returnValue := godotCallFloat(o, "get_spread")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) GetWet() float64 {
	log.Println("Calling AudioEffectReverb.GetWet()")

	returnValue := godotCallFloat(o, "get_wet")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) SetDamping(amount float64) {
	log.Println("Calling AudioEffectReverb.SetDamping()")

	godotCallVoidFloat(o, "set_damping", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) SetDry(amount float64) {
	log.Println("Calling AudioEffectReverb.SetDry()")

	godotCallVoidFloat(o, "set_dry", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) SetHpf(amount float64) {
	log.Println("Calling AudioEffectReverb.SetHpf()")

	godotCallVoidFloat(o, "set_hpf", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) SetPredelayFeedback(feedback float64) {
	log.Println("Calling AudioEffectReverb.SetPredelayFeedback()")

	godotCallVoidFloat(o, "set_predelay_feedback", feedback)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) SetPredelayMsec(msec float64) {
	log.Println("Calling AudioEffectReverb.SetPredelayMsec()")

	godotCallVoidFloat(o, "set_predelay_msec", msec)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) SetRoomSize(size float64) {
	log.Println("Calling AudioEffectReverb.SetRoomSize()")

	godotCallVoidFloat(o, "set_room_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) SetSpread(amount float64) {
	log.Println("Calling AudioEffectReverb.SetSpread()")

	godotCallVoidFloat(o, "set_spread", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectReverb) SetWet(amount float64) {
	log.Println("Calling AudioEffectReverb.SetWet()")

	godotCallVoidFloat(o, "set_wet", amount)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectReverbImplementer is an interface for AudioEffectReverb objects.
*/
type AudioEffectReverbImplementer interface {
	Class
}

/*

 */
type AudioEffectStereoEnhance struct {
	AudioEffect
}

func (o *AudioEffectStereoEnhance) baseClass() string {
	return "AudioEffectStereoEnhance"
}

/*
   Undocumented
*/
func (o *AudioEffectStereoEnhance) GetPanPullout() float64 {
	log.Println("Calling AudioEffectStereoEnhance.GetPanPullout()")

	returnValue := godotCallFloat(o, "get_pan_pullout")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectStereoEnhance) GetSurround() float64 {
	log.Println("Calling AudioEffectStereoEnhance.GetSurround()")

	returnValue := godotCallFloat(o, "get_surround")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectStereoEnhance) GetTimePullout() float64 {
	log.Println("Calling AudioEffectStereoEnhance.GetTimePullout()")

	returnValue := godotCallFloat(o, "get_time_pullout")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioEffectStereoEnhance) SetPanPullout(amount float64) {
	log.Println("Calling AudioEffectStereoEnhance.SetPanPullout()")

	godotCallVoidFloat(o, "set_pan_pullout", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectStereoEnhance) SetSurround(amount float64) {
	log.Println("Calling AudioEffectStereoEnhance.SetSurround()")

	godotCallVoidFloat(o, "set_surround", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioEffectStereoEnhance) SetTimePullout(amount float64) {
	log.Println("Calling AudioEffectStereoEnhance.SetTimePullout()")

	godotCallVoidFloat(o, "set_time_pullout", amount)
	log.Println("  Function successfully completed.")

}

/*
   AudioEffectStereoEnhanceImplementer is an interface for AudioEffectStereoEnhance objects.
*/
type AudioEffectStereoEnhanceImplementer interface {
	Class
}

func newSingletonAudioServer() *audioServer {
	obj := &audioServer{}
	name := C.CString("AudioServer")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   AudioServer is a low level server interface for audio access. It is in charge of creating sample data (playable audio) as well as its playback via a voice interface.
*/
var AudioServer = newSingletonAudioServer()

/*
   AudioServer is a low level server interface for audio access. It is in charge of creating sample data (playable audio) as well as its playback via a voice interface.
*/
type audioServer struct {
	Object
}

func (o *audioServer) baseClass() string {
	return "AudioServer"
}

/*
   Adds a bus at [code]at_position[/code].
*/
func (o *audioServer) AddBus(atPosition int64) {
	log.Println("Calling AudioServer.AddBus()")

	godotCallVoidInt(o, "add_bus", atPosition)
	log.Println("  Function successfully completed.")

}

/*
   Adds an [AudioEffect] effect to the bus [code]bus_idx[/code] at [code]at_position[/code].
*/
func (o *audioServer) AddBusEffect(busIdx int64, effect *AudioEffect, atPosition int64) {
	log.Println("Calling AudioServer.AddBusEffect()")

	godotCallVoidIntObjectInt(o, "add_bus_effect", busIdx, &effect.Object, atPosition)
	log.Println("  Function successfully completed.")

}

/*
   Generates an [AudioBusLayout] using the available busses and effects.
*/
func (o *audioServer) GenerateBusLayout() *AudioBusLayout {
	log.Println("Calling AudioServer.GenerateBusLayout()")

	returnValue := godotCallObject(o, "generate_bus_layout")
	log.Println("  Got return value: ", returnValue)

	var ret AudioBusLayout
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of available busses.
*/
func (o *audioServer) GetBusCount() int64 {
	log.Println("Calling AudioServer.GetBusCount()")

	returnValue := godotCallInt(o, "get_bus_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [AudioEffect] at position [code]effect_idx[/code] in bus [code]bus_idx[/code].
*/
func (o *audioServer) GetBusEffect(busIdx int64, effectIdx int64) *AudioEffect {
	log.Println("Calling AudioServer.GetBusEffect()")

	returnValue := godotCallObjectIntInt(o, "get_bus_effect", busIdx, effectIdx)
	log.Println("  Got return value: ", returnValue)

	var ret AudioEffect
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of effects on the bus at [code]bus_idx[/code].
*/
func (o *audioServer) GetBusEffectCount(busIdx int64) int64 {
	log.Println("Calling AudioServer.GetBusEffectCount()")

	returnValue := godotCallIntInt(o, "get_bus_effect_count", busIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the index of the bus with the name [code]bus_name[/code].
*/
func (o *audioServer) GetBusIndex(busName string) int64 {
	log.Println("Calling AudioServer.GetBusIndex()")

	returnValue := godotCallIntString(o, "get_bus_index", busName)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the name of the bus with the index [code]bus_idx[/code].
*/
func (o *audioServer) GetBusName(busIdx int64) string {
	log.Println("Calling AudioServer.GetBusName()")

	returnValue := godotCallStringInt(o, "get_bus_name", busIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the peak volume of the left speaker at bus index [code]bus_idx[/code] and channel index [code]channel[/code].
*/
func (o *audioServer) GetBusPeakVolumeLeftDb(busIdx int64, channel int64) float64 {
	log.Println("Calling AudioServer.GetBusPeakVolumeLeftDb()")

	returnValue := godotCallFloatIntInt(o, "get_bus_peak_volume_left_db", busIdx, channel)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the peak volume of the right speaker at bus index [code]bus_idx[/code] and channel index [code]channel[/code].
*/
func (o *audioServer) GetBusPeakVolumeRightDb(busIdx int64, channel int64) float64 {
	log.Println("Calling AudioServer.GetBusPeakVolumeRightDb()")

	returnValue := godotCallFloatIntInt(o, "get_bus_peak_volume_right_db", busIdx, channel)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the name of the bus that the bus at index [code]bus_idx[/code] sends to.
*/
func (o *audioServer) GetBusSend(busIdx int64) string {
	log.Println("Calling AudioServer.GetBusSend()")

	returnValue := godotCallStringInt(o, "get_bus_send", busIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the volume of the bus at index [code]bus_idx[/code] in dB.
*/
func (o *audioServer) GetBusVolumeDb(busIdx int64) float64 {
	log.Println("Calling AudioServer.GetBusVolumeDb()")

	returnValue := godotCallFloatInt(o, "get_bus_volume_db", busIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the sample rate at the output of the audioserver.
*/
func (o *audioServer) GetMixRate() float64 {
	log.Println("Calling AudioServer.GetMixRate()")

	returnValue := godotCallFloat(o, "get_mix_rate")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the speaker configuration.
*/
func (o *audioServer) GetSpeakerMode() int64 {
	log.Println("Calling AudioServer.GetSpeakerMode()")

	returnValue := godotCallInt(o, "get_speaker_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the bus at index [code]bus_idx[/code] is bypassing effects.
*/
func (o *audioServer) IsBusBypassingEffects(busIdx int64) bool {
	log.Println("Calling AudioServer.IsBusBypassingEffects()")

	returnValue := godotCallBoolInt(o, "is_bus_bypassing_effects", busIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the effect at index [code]effect_idx[/code] on the bus at index [code]bus_idx[/code] is enabled.
*/
func (o *audioServer) IsBusEffectEnabled(busIdx int64, effectIdx int64) bool {
	log.Println("Calling AudioServer.IsBusEffectEnabled()")

	returnValue := godotCallBoolIntInt(o, "is_bus_effect_enabled", busIdx, effectIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the bus at index [code]bus_idx[/code] is muted.
*/
func (o *audioServer) IsBusMute(busIdx int64) bool {
	log.Println("Calling AudioServer.IsBusMute()")

	returnValue := godotCallBoolInt(o, "is_bus_mute", busIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the bus at index [code]bus_idx[/code] is in solo mode.
*/
func (o *audioServer) IsBusSolo(busIdx int64) bool {
	log.Println("Calling AudioServer.IsBusSolo()")

	returnValue := godotCallBoolInt(o, "is_bus_solo", busIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Locks the audio drivers mainloop. Remember to unlock it afterwards.
*/
func (o *audioServer) Lock() {
	log.Println("Calling AudioServer.Lock()")

	godotCallVoid(o, "lock")
	log.Println("  Function successfully completed.")

}

/*
   Moves the bus from index [code]index[/code] to index [code]to_index[/code].
*/
func (o *audioServer) MoveBus(index int64, toIndex int64) {
	log.Println("Calling AudioServer.MoveBus()")

	godotCallVoidIntInt(o, "move_bus", index, toIndex)
	log.Println("  Function successfully completed.")

}

/*
   Removes the bus at index [code]index[/code].
*/
func (o *audioServer) RemoveBus(index int64) {
	log.Println("Calling AudioServer.RemoveBus()")

	godotCallVoidInt(o, "remove_bus", index)
	log.Println("  Function successfully completed.")

}

/*
   Removes the effect at index [code]effect_idx[/code] from the bus at index [code]bus_idx[/code].
*/
func (o *audioServer) RemoveBusEffect(busIdx int64, effectIdx int64) {
	log.Println("Calling AudioServer.RemoveBusEffect()")

	godotCallVoidIntInt(o, "remove_bus_effect", busIdx, effectIdx)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the bus at index [code]bus_idx[/code] is bypassing effects.
*/
func (o *audioServer) SetBusBypassEffects(busIdx int64, enable bool) {
	log.Println("Calling AudioServer.SetBusBypassEffects()")

	godotCallVoidIntBool(o, "set_bus_bypass_effects", busIdx, enable)
	log.Println("  Function successfully completed.")

}

/*
   Adds and removes busses to make the number of busses match [code]amount[/code].
*/
func (o *audioServer) SetBusCount(amount int64) {
	log.Println("Calling AudioServer.SetBusCount()")

	godotCallVoidInt(o, "set_bus_count", amount)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the effect at index [code]effect_idx[/code] on the bus at index [code]bus_idx[/code] is enabled.
*/
func (o *audioServer) SetBusEffectEnabled(busIdx int64, effectIdx int64, enabled bool) {
	log.Println("Calling AudioServer.SetBusEffectEnabled()")

	godotCallVoidIntIntBool(o, "set_bus_effect_enabled", busIdx, effectIdx, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Overwrites the currently used [AudioBusLayout].
*/
func (o *audioServer) SetBusLayout(busLayout *AudioBusLayout) {
	log.Println("Calling AudioServer.SetBusLayout()")

	godotCallVoidObject(o, "set_bus_layout", &busLayout.Object)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the bus at index [code]bus_idx[/code] is muted.
*/
func (o *audioServer) SetBusMute(busIdx int64, enable bool) {
	log.Println("Calling AudioServer.SetBusMute()")

	godotCallVoidIntBool(o, "set_bus_mute", busIdx, enable)
	log.Println("  Function successfully completed.")

}

/*
   Sets the name of the bus at index [code]bus_idx[/code] to [code]name[/code].
*/
func (o *audioServer) SetBusName(busIdx int64, name string) {
	log.Println("Calling AudioServer.SetBusName()")

	godotCallVoidIntString(o, "set_bus_name", busIdx, name)
	log.Println("  Function successfully completed.")

}

/*
   Connects the output of the bus at [code]bus_idx[/code] to the bus named [code]send[/code].
*/
func (o *audioServer) SetBusSend(busIdx int64, send string) {
	log.Println("Calling AudioServer.SetBusSend()")

	godotCallVoidIntString(o, "set_bus_send", busIdx, send)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the bus at index [code]bus_idx[/code] is in solo mode.
*/
func (o *audioServer) SetBusSolo(busIdx int64, enable bool) {
	log.Println("Calling AudioServer.SetBusSolo()")

	godotCallVoidIntBool(o, "set_bus_solo", busIdx, enable)
	log.Println("  Function successfully completed.")

}

/*
   Sets the volume of the bus at index [code]bus_idx[/code] to [code]volume_db[/code].
*/
func (o *audioServer) SetBusVolumeDb(busIdx int64, volumeDb float64) {
	log.Println("Calling AudioServer.SetBusVolumeDb()")

	godotCallVoidIntFloat(o, "set_bus_volume_db", busIdx, volumeDb)
	log.Println("  Function successfully completed.")

}

/*
   Swaps the position of two effects in bus [code]bus_idx[/code].
*/
func (o *audioServer) SwapBusEffects(busIdx int64, effectIdx int64, byEffectIdx int64) {
	log.Println("Calling AudioServer.SwapBusEffects()")

	godotCallVoidIntIntInt(o, "swap_bus_effects", busIdx, effectIdx, byEffectIdx)
	log.Println("  Function successfully completed.")

}

/*
   Unlocks the audiodriver's main loop. After locking it always unlock it.
*/
func (o *audioServer) Unlock() {
	log.Println("Calling AudioServer.Unlock()")

	godotCallVoid(o, "unlock")
	log.Println("  Function successfully completed.")

}

/*
   Base class for audio streams. Audio streams are used for music playback, or other types of streamed sounds that don't fit or require more flexibility than a [Sample].
*/
type AudioStream struct {
	Resource
}

func (o *AudioStream) baseClass() string {
	return "AudioStream"
}

/*
   AudioStreamImplementer is an interface for AudioStream objects.
*/
type AudioStreamImplementer interface {
	Class
}

/*
   Undocumented
*/
type AudioStreamOGGVorbis struct {
	AudioStream
}

func (o *AudioStreamOGGVorbis) baseClass() string {
	return "AudioStreamOGGVorbis"
}

/*
   Undocumented
*/
func (o *AudioStreamOGGVorbis) X_GetData() *PoolByteArray {
	log.Println("Calling AudioStreamOGGVorbis.X_GetData()")

	returnValue := godotCallPoolByteArray(o, "_get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamOGGVorbis) X_SetData(data *PoolByteArray) {
	log.Println("Calling AudioStreamOGGVorbis.X_SetData()")

	godotCallVoidPoolByteArray(o, "_set_data", data)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamOGGVorbis) GetLoopOffset() float64 {
	log.Println("Calling AudioStreamOGGVorbis.GetLoopOffset()")

	returnValue := godotCallFloat(o, "get_loop_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamOGGVorbis) HasLoop() bool {
	log.Println("Calling AudioStreamOGGVorbis.HasLoop()")

	returnValue := godotCallBool(o, "has_loop")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamOGGVorbis) SetLoop(enable bool) {
	log.Println("Calling AudioStreamOGGVorbis.SetLoop()")

	godotCallVoidBool(o, "set_loop", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamOGGVorbis) SetLoopOffset(seconds float64) {
	log.Println("Calling AudioStreamOGGVorbis.SetLoopOffset()")

	godotCallVoidFloat(o, "set_loop_offset", seconds)
	log.Println("  Function successfully completed.")

}

/*
   AudioStreamOGGVorbisImplementer is an interface for AudioStreamOGGVorbis objects.
*/
type AudioStreamOGGVorbisImplementer interface {
	Class
}

/*
   Can play, loop, pause a scroll through Audio. See [AudioStream] and [AudioStreamOGGVorbis] for usage.
*/
type AudioStreamPlayback struct {
	Reference
}

func (o *AudioStreamPlayback) baseClass() string {
	return "AudioStreamPlayback"
}

/*
   AudioStreamPlaybackImplementer is an interface for AudioStreamPlayback objects.
*/
type AudioStreamPlaybackImplementer interface {
	Class
}

/*
   Plays background audio.
*/
type AudioStreamPlayer struct {
	Node
}

func (o *AudioStreamPlayer) baseClass() string {
	return "AudioStreamPlayer"
}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) X_BusLayoutChanged() {
	log.Println("Calling AudioStreamPlayer.X_BusLayoutChanged()")

	godotCallVoid(o, "_bus_layout_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) X_IsActive() bool {
	log.Println("Calling AudioStreamPlayer.X_IsActive()")

	returnValue := godotCallBool(o, "_is_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) X_SetPlaying(enable bool) {
	log.Println("Calling AudioStreamPlayer.X_SetPlaying()")

	godotCallVoidBool(o, "_set_playing", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) GetBus() string {
	log.Println("Calling AudioStreamPlayer.GetBus()")

	returnValue := godotCallString(o, "get_bus")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) GetMixTarget() int64 {
	log.Println("Calling AudioStreamPlayer.GetMixTarget()")

	returnValue := godotCallInt(o, "get_mix_target")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position in the [AudioStream].
*/
func (o *AudioStreamPlayer) GetPlaybackPosition() float64 {
	log.Println("Calling AudioStreamPlayer.GetPlaybackPosition()")

	returnValue := godotCallFloat(o, "get_playback_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) GetStream() *AudioStream {
	log.Println("Calling AudioStreamPlayer.GetStream()")

	returnValue := godotCallObject(o, "get_stream")
	log.Println("  Got return value: ", returnValue)

	var ret AudioStream
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) GetVolumeDb() float64 {
	log.Println("Calling AudioStreamPlayer.GetVolumeDb()")

	returnValue := godotCallFloat(o, "get_volume_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) IsAutoplayEnabled() bool {
	log.Println("Calling AudioStreamPlayer.IsAutoplayEnabled()")

	returnValue := godotCallBool(o, "is_autoplay_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) IsPlaying() bool {
	log.Println("Calling AudioStreamPlayer.IsPlaying()")

	returnValue := godotCallBool(o, "is_playing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Plays the audio from the given position 'from_position', in seconds.
*/
func (o *AudioStreamPlayer) Play(fromPosition float64) {
	log.Println("Calling AudioStreamPlayer.Play()")

	godotCallVoidFloat(o, "play", fromPosition)
	log.Println("  Function successfully completed.")

}

/*
   Sets the position from which audio will be played, in seconds.
*/
func (o *AudioStreamPlayer) Seek(toPosition float64) {
	log.Println("Calling AudioStreamPlayer.Seek()")

	godotCallVoidFloat(o, "seek", toPosition)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) SetAutoplay(enable bool) {
	log.Println("Calling AudioStreamPlayer.SetAutoplay()")

	godotCallVoidBool(o, "set_autoplay", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) SetBus(bus string) {
	log.Println("Calling AudioStreamPlayer.SetBus()")

	godotCallVoidString(o, "set_bus", bus)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) SetMixTarget(mixTarget int64) {
	log.Println("Calling AudioStreamPlayer.SetMixTarget()")

	godotCallVoidInt(o, "set_mix_target", mixTarget)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) SetStream(stream *AudioStream) {
	log.Println("Calling AudioStreamPlayer.SetStream()")

	godotCallVoidObject(o, "set_stream", &stream.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer) SetVolumeDb(volumeDb float64) {
	log.Println("Calling AudioStreamPlayer.SetVolumeDb()")

	godotCallVoidFloat(o, "set_volume_db", volumeDb)
	log.Println("  Function successfully completed.")

}

/*
   Stops the audio.
*/
func (o *AudioStreamPlayer) Stop() {
	log.Println("Calling AudioStreamPlayer.Stop()")

	godotCallVoid(o, "stop")
	log.Println("  Function successfully completed.")

}

/*
   AudioStreamPlayerImplementer is an interface for AudioStreamPlayer objects.
*/
type AudioStreamPlayerImplementer interface {
	Class
}

/*
   Plays audio that dampens with distance from screen center.
*/
type AudioStreamPlayer2D struct {
	Node2D
}

func (o *AudioStreamPlayer2D) baseClass() string {
	return "AudioStreamPlayer2D"
}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) X_BusLayoutChanged() {
	log.Println("Calling AudioStreamPlayer2D.X_BusLayoutChanged()")

	godotCallVoid(o, "_bus_layout_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) X_IsActive() bool {
	log.Println("Calling AudioStreamPlayer2D.X_IsActive()")

	returnValue := godotCallBool(o, "_is_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) X_SetPlaying(enable bool) {
	log.Println("Calling AudioStreamPlayer2D.X_SetPlaying()")

	godotCallVoidBool(o, "_set_playing", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) GetAreaMask() int64 {
	log.Println("Calling AudioStreamPlayer2D.GetAreaMask()")

	returnValue := godotCallInt(o, "get_area_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) GetAttenuation() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetAttenuation()")

	returnValue := godotCallFloat(o, "get_attenuation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) GetBus() string {
	log.Println("Calling AudioStreamPlayer2D.GetBus()")

	returnValue := godotCallString(o, "get_bus")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) GetMaxDistance() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetMaxDistance()")

	returnValue := godotCallFloat(o, "get_max_distance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position in the [AudioStream].
*/
func (o *AudioStreamPlayer2D) GetPlaybackPosition() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetPlaybackPosition()")

	returnValue := godotCallFloat(o, "get_playback_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) GetStream() *AudioStream {
	log.Println("Calling AudioStreamPlayer2D.GetStream()")

	returnValue := godotCallObject(o, "get_stream")
	log.Println("  Got return value: ", returnValue)

	var ret AudioStream
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) GetVolumeDb() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetVolumeDb()")

	returnValue := godotCallFloat(o, "get_volume_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) IsAutoplayEnabled() bool {
	log.Println("Calling AudioStreamPlayer2D.IsAutoplayEnabled()")

	returnValue := godotCallBool(o, "is_autoplay_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) IsPlaying() bool {
	log.Println("Calling AudioStreamPlayer2D.IsPlaying()")

	returnValue := godotCallBool(o, "is_playing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Plays the audio from the given position 'from_position', in seconds.
*/
func (o *AudioStreamPlayer2D) Play(fromPosition float64) {
	log.Println("Calling AudioStreamPlayer2D.Play()")

	godotCallVoidFloat(o, "play", fromPosition)
	log.Println("  Function successfully completed.")

}

/*
   Sets the position from which audio will be played, in seconds.
*/
func (o *AudioStreamPlayer2D) Seek(toPosition float64) {
	log.Println("Calling AudioStreamPlayer2D.Seek()")

	godotCallVoidFloat(o, "seek", toPosition)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) SetAreaMask(mask int64) {
	log.Println("Calling AudioStreamPlayer2D.SetAreaMask()")

	godotCallVoidInt(o, "set_area_mask", mask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) SetAttenuation(curve float64) {
	log.Println("Calling AudioStreamPlayer2D.SetAttenuation()")

	godotCallVoidFloat(o, "set_attenuation", curve)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) SetAutoplay(enable bool) {
	log.Println("Calling AudioStreamPlayer2D.SetAutoplay()")

	godotCallVoidBool(o, "set_autoplay", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) SetBus(bus string) {
	log.Println("Calling AudioStreamPlayer2D.SetBus()")

	godotCallVoidString(o, "set_bus", bus)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) SetMaxDistance(pixels float64) {
	log.Println("Calling AudioStreamPlayer2D.SetMaxDistance()")

	godotCallVoidFloat(o, "set_max_distance", pixels)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) SetStream(stream *AudioStream) {
	log.Println("Calling AudioStreamPlayer2D.SetStream()")

	godotCallVoidObject(o, "set_stream", &stream.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer2D) SetVolumeDb(volumeDb float64) {
	log.Println("Calling AudioStreamPlayer2D.SetVolumeDb()")

	godotCallVoidFloat(o, "set_volume_db", volumeDb)
	log.Println("  Function successfully completed.")

}

/*
   Stops the audio.
*/
func (o *AudioStreamPlayer2D) Stop() {
	log.Println("Calling AudioStreamPlayer2D.Stop()")

	godotCallVoid(o, "stop")
	log.Println("  Function successfully completed.")

}

/*
   AudioStreamPlayer2DImplementer is an interface for AudioStreamPlayer2D objects.
*/
type AudioStreamPlayer2DImplementer interface {
	Class
}

/*
   Plays a sound effect with directed sound effects, dampens with distance if needed, generates effect of hearable position in space.
*/
type AudioStreamPlayer3D struct {
	Spatial
}

func (o *AudioStreamPlayer3D) baseClass() string {
	return "AudioStreamPlayer3D"
}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) X_BusLayoutChanged() {
	log.Println("Calling AudioStreamPlayer3D.X_BusLayoutChanged()")

	godotCallVoid(o, "_bus_layout_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) X_IsActive() bool {
	log.Println("Calling AudioStreamPlayer3D.X_IsActive()")

	returnValue := godotCallBool(o, "_is_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) X_SetPlaying(enable bool) {
	log.Println("Calling AudioStreamPlayer3D.X_SetPlaying()")

	godotCallVoidBool(o, "_set_playing", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetAreaMask() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetAreaMask()")

	returnValue := godotCallInt(o, "get_area_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetAttenuationFilterCutoffHz() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetAttenuationFilterCutoffHz()")

	returnValue := godotCallFloat(o, "get_attenuation_filter_cutoff_hz")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetAttenuationFilterDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetAttenuationFilterDb()")

	returnValue := godotCallFloat(o, "get_attenuation_filter_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetAttenuationModel() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetAttenuationModel()")

	returnValue := godotCallInt(o, "get_attenuation_model")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetBus() string {
	log.Println("Calling AudioStreamPlayer3D.GetBus()")

	returnValue := godotCallString(o, "get_bus")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetDopplerTracking() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetDopplerTracking()")

	returnValue := godotCallInt(o, "get_doppler_tracking")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetEmissionAngle() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetEmissionAngle()")

	returnValue := godotCallFloat(o, "get_emission_angle")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetEmissionAngleFilterAttenuationDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetEmissionAngleFilterAttenuationDb()")

	returnValue := godotCallFloat(o, "get_emission_angle_filter_attenuation_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetMaxDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetMaxDb()")

	returnValue := godotCallFloat(o, "get_max_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetMaxDistance() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetMaxDistance()")

	returnValue := godotCallFloat(o, "get_max_distance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetOutOfRangeMode() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetOutOfRangeMode()")

	returnValue := godotCallInt(o, "get_out_of_range_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position in the [AudioStream].
*/
func (o *AudioStreamPlayer3D) GetPlaybackPosition() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetPlaybackPosition()")

	returnValue := godotCallFloat(o, "get_playback_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetStream() *AudioStream {
	log.Println("Calling AudioStreamPlayer3D.GetStream()")

	returnValue := godotCallObject(o, "get_stream")
	log.Println("  Got return value: ", returnValue)

	var ret AudioStream
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetUnitDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetUnitDb()")

	returnValue := godotCallFloat(o, "get_unit_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) GetUnitSize() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetUnitSize()")

	returnValue := godotCallFloat(o, "get_unit_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) IsAutoplayEnabled() bool {
	log.Println("Calling AudioStreamPlayer3D.IsAutoplayEnabled()")

	returnValue := godotCallBool(o, "is_autoplay_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) IsEmissionAngleEnabled() bool {
	log.Println("Calling AudioStreamPlayer3D.IsEmissionAngleEnabled()")

	returnValue := godotCallBool(o, "is_emission_angle_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) IsPlaying() bool {
	log.Println("Calling AudioStreamPlayer3D.IsPlaying()")

	returnValue := godotCallBool(o, "is_playing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Plays the audio from the given position 'from_position', in seconds.
*/
func (o *AudioStreamPlayer3D) Play(fromPosition float64) {
	log.Println("Calling AudioStreamPlayer3D.Play()")

	godotCallVoidFloat(o, "play", fromPosition)
	log.Println("  Function successfully completed.")

}

/*
   Sets the position from which audio will be played, in seconds.
*/
func (o *AudioStreamPlayer3D) Seek(toPosition float64) {
	log.Println("Calling AudioStreamPlayer3D.Seek()")

	godotCallVoidFloat(o, "seek", toPosition)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetAreaMask(mask int64) {
	log.Println("Calling AudioStreamPlayer3D.SetAreaMask()")

	godotCallVoidInt(o, "set_area_mask", mask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetAttenuationFilterCutoffHz(degrees float64) {
	log.Println("Calling AudioStreamPlayer3D.SetAttenuationFilterCutoffHz()")

	godotCallVoidFloat(o, "set_attenuation_filter_cutoff_hz", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetAttenuationFilterDb(db float64) {
	log.Println("Calling AudioStreamPlayer3D.SetAttenuationFilterDb()")

	godotCallVoidFloat(o, "set_attenuation_filter_db", db)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetAttenuationModel(model int64) {
	log.Println("Calling AudioStreamPlayer3D.SetAttenuationModel()")

	godotCallVoidInt(o, "set_attenuation_model", model)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetAutoplay(enable bool) {
	log.Println("Calling AudioStreamPlayer3D.SetAutoplay()")

	godotCallVoidBool(o, "set_autoplay", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetBus(bus string) {
	log.Println("Calling AudioStreamPlayer3D.SetBus()")

	godotCallVoidString(o, "set_bus", bus)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetDopplerTracking(mode int64) {
	log.Println("Calling AudioStreamPlayer3D.SetDopplerTracking()")

	godotCallVoidInt(o, "set_doppler_tracking", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetEmissionAngle(degrees float64) {
	log.Println("Calling AudioStreamPlayer3D.SetEmissionAngle()")

	godotCallVoidFloat(o, "set_emission_angle", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetEmissionAngleEnabled(enabled bool) {
	log.Println("Calling AudioStreamPlayer3D.SetEmissionAngleEnabled()")

	godotCallVoidBool(o, "set_emission_angle_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetEmissionAngleFilterAttenuationDb(db float64) {
	log.Println("Calling AudioStreamPlayer3D.SetEmissionAngleFilterAttenuationDb()")

	godotCallVoidFloat(o, "set_emission_angle_filter_attenuation_db", db)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetMaxDb(maxDb float64) {
	log.Println("Calling AudioStreamPlayer3D.SetMaxDb()")

	godotCallVoidFloat(o, "set_max_db", maxDb)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetMaxDistance(metres float64) {
	log.Println("Calling AudioStreamPlayer3D.SetMaxDistance()")

	godotCallVoidFloat(o, "set_max_distance", metres)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetOutOfRangeMode(mode int64) {
	log.Println("Calling AudioStreamPlayer3D.SetOutOfRangeMode()")

	godotCallVoidInt(o, "set_out_of_range_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetStream(stream *AudioStream) {
	log.Println("Calling AudioStreamPlayer3D.SetStream()")

	godotCallVoidObject(o, "set_stream", &stream.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetUnitDb(unitDb float64) {
	log.Println("Calling AudioStreamPlayer3D.SetUnitDb()")

	godotCallVoidFloat(o, "set_unit_db", unitDb)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamPlayer3D) SetUnitSize(unitSize float64) {
	log.Println("Calling AudioStreamPlayer3D.SetUnitSize()")

	godotCallVoidFloat(o, "set_unit_size", unitSize)
	log.Println("  Function successfully completed.")

}

/*
   Stops the audio.
*/
func (o *AudioStreamPlayer3D) Stop() {
	log.Println("Calling AudioStreamPlayer3D.Stop()")

	godotCallVoid(o, "stop")
	log.Println("  Function successfully completed.")

}

/*
   AudioStreamPlayer3DImplementer is an interface for AudioStreamPlayer3D objects.
*/
type AudioStreamPlayer3DImplementer interface {
	Class
}

/*
   Randomly varies pitch on each start.
*/
type AudioStreamRandomPitch struct {
	AudioStream
}

func (o *AudioStreamRandomPitch) baseClass() string {
	return "AudioStreamRandomPitch"
}

/*
   Undocumented
*/
func (o *AudioStreamRandomPitch) GetAudioStream() *AudioStream {
	log.Println("Calling AudioStreamRandomPitch.GetAudioStream()")

	returnValue := godotCallObject(o, "get_audio_stream")
	log.Println("  Got return value: ", returnValue)

	var ret AudioStream
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *AudioStreamRandomPitch) GetRandomPitch() float64 {
	log.Println("Calling AudioStreamRandomPitch.GetRandomPitch()")

	returnValue := godotCallFloat(o, "get_random_pitch")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamRandomPitch) SetAudioStream(stream *AudioStream) {
	log.Println("Calling AudioStreamRandomPitch.SetAudioStream()")

	godotCallVoidObject(o, "set_audio_stream", &stream.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamRandomPitch) SetRandomPitch(scale float64) {
	log.Println("Calling AudioStreamRandomPitch.SetRandomPitch()")

	godotCallVoidFloat(o, "set_random_pitch", scale)
	log.Println("  Function successfully completed.")

}

/*
   AudioStreamRandomPitchImplementer is an interface for AudioStreamRandomPitch objects.
*/
type AudioStreamRandomPitchImplementer interface {
	Class
}

/*
   Plays audio, can loop.
*/
type AudioStreamSample struct {
	AudioStream
}

func (o *AudioStreamSample) baseClass() string {
	return "AudioStreamSample"
}

/*
   Undocumented
*/
func (o *AudioStreamSample) X_GetData() *PoolByteArray {
	log.Println("Calling AudioStreamSample.X_GetData()")

	returnValue := godotCallPoolByteArray(o, "_get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamSample) X_SetData(data *PoolByteArray) {
	log.Println("Calling AudioStreamSample.X_SetData()")

	godotCallVoidPoolByteArray(o, "_set_data", data)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamSample) GetFormat() int64 {
	log.Println("Calling AudioStreamSample.GetFormat()")

	returnValue := godotCallInt(o, "get_format")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamSample) GetLoopBegin() int64 {
	log.Println("Calling AudioStreamSample.GetLoopBegin()")

	returnValue := godotCallInt(o, "get_loop_begin")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamSample) GetLoopEnd() int64 {
	log.Println("Calling AudioStreamSample.GetLoopEnd()")

	returnValue := godotCallInt(o, "get_loop_end")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamSample) GetLoopMode() int64 {
	log.Println("Calling AudioStreamSample.GetLoopMode()")

	returnValue := godotCallInt(o, "get_loop_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamSample) GetMixRate() int64 {
	log.Println("Calling AudioStreamSample.GetMixRate()")

	returnValue := godotCallInt(o, "get_mix_rate")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamSample) IsStereo() bool {
	log.Println("Calling AudioStreamSample.IsStereo()")

	returnValue := godotCallBool(o, "is_stereo")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *AudioStreamSample) SetFormat(format int64) {
	log.Println("Calling AudioStreamSample.SetFormat()")

	godotCallVoidInt(o, "set_format", format)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamSample) SetLoopBegin(loopBegin int64) {
	log.Println("Calling AudioStreamSample.SetLoopBegin()")

	godotCallVoidInt(o, "set_loop_begin", loopBegin)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamSample) SetLoopEnd(loopEnd int64) {
	log.Println("Calling AudioStreamSample.SetLoopEnd()")

	godotCallVoidInt(o, "set_loop_end", loopEnd)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamSample) SetLoopMode(loopMode int64) {
	log.Println("Calling AudioStreamSample.SetLoopMode()")

	godotCallVoidInt(o, "set_loop_mode", loopMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamSample) SetMixRate(mixRate int64) {
	log.Println("Calling AudioStreamSample.SetMixRate()")

	godotCallVoidInt(o, "set_mix_rate", mixRate)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AudioStreamSample) SetStereo(stereo bool) {
	log.Println("Calling AudioStreamSample.SetStereo()")

	godotCallVoidBool(o, "set_stereo", stereo)
	log.Println("  Function successfully completed.")

}

/*
   AudioStreamSampleImplementer is an interface for AudioStreamSample objects.
*/
type AudioStreamSampleImplementer interface {
	Class
}

/*
   Node for back-buffering the currently displayed screen. The region defined in the BackBufferCopy node is bufferized with the content of the screen it covers, or the entire screen according to the copy mode set. Accessing this buffer is done with the texscreen() shader instruction.
*/
type BackBufferCopy struct {
	Node2D
}

func (o *BackBufferCopy) baseClass() string {
	return "BackBufferCopy"
}

/*
   Undocumented
*/
func (o *BackBufferCopy) GetCopyMode() int64 {
	log.Println("Calling BackBufferCopy.GetCopyMode()")

	returnValue := godotCallInt(o, "get_copy_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BackBufferCopy) GetRect() *Rect2 {
	log.Println("Calling BackBufferCopy.GetRect()")

	returnValue := godotCallRect2(o, "get_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BackBufferCopy) SetCopyMode(copyMode int64) {
	log.Println("Calling BackBufferCopy.SetCopyMode()")

	godotCallVoidInt(o, "set_copy_mode", copyMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BackBufferCopy) SetRect(rect *Rect2) {
	log.Println("Calling BackBufferCopy.SetRect()")

	godotCallVoidRect2(o, "set_rect", rect)
	log.Println("  Function successfully completed.")

}

/*
   BackBufferCopyImplementer is an interface for BackBufferCopy objects.
*/
type BackBufferCopyImplementer interface {
	Class
}

/*

 */
type BakedLightmap struct {
	VisualInstance
}

func (o *BakedLightmap) baseClass() string {
	return "BakedLightmap"
}

/*

 */
func (o *BakedLightmap) Bake(fromNode *Object, createVisualDebug bool) int64 {
	log.Println("Calling BakedLightmap.Bake()")

	returnValue := godotCallIntObjectBool(o, "bake", fromNode, createVisualDebug)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *BakedLightmap) DebugBake() {
	log.Println("Calling BakedLightmap.DebugBake()")

	godotCallVoid(o, "debug_bake")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmap) GetBakeCellSize() float64 {
	log.Println("Calling BakedLightmap.GetBakeCellSize()")

	returnValue := godotCallFloat(o, "get_bake_cell_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmap) GetBakeMode() int64 {
	log.Println("Calling BakedLightmap.GetBakeMode()")

	returnValue := godotCallInt(o, "get_bake_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmap) GetBakeQuality() int64 {
	log.Println("Calling BakedLightmap.GetBakeQuality()")

	returnValue := godotCallInt(o, "get_bake_quality")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmap) GetCaptureCellSize() float64 {
	log.Println("Calling BakedLightmap.GetCaptureCellSize()")

	returnValue := godotCallFloat(o, "get_capture_cell_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmap) GetEnergy() float64 {
	log.Println("Calling BakedLightmap.GetEnergy()")

	returnValue := godotCallFloat(o, "get_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmap) GetExtents() *Vector3 {
	log.Println("Calling BakedLightmap.GetExtents()")

	returnValue := godotCallVector3(o, "get_extents")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmap) GetImagePath() string {
	log.Println("Calling BakedLightmap.GetImagePath()")

	returnValue := godotCallString(o, "get_image_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmap) GetLightData() *BakedLightmapData {
	log.Println("Calling BakedLightmap.GetLightData()")

	returnValue := godotCallObject(o, "get_light_data")
	log.Println("  Got return value: ", returnValue)

	var ret BakedLightmapData
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *BakedLightmap) GetPropagation() float64 {
	log.Println("Calling BakedLightmap.GetPropagation()")

	returnValue := godotCallFloat(o, "get_propagation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmap) IsHdr() bool {
	log.Println("Calling BakedLightmap.IsHdr()")

	returnValue := godotCallBool(o, "is_hdr")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmap) SetBakeCellSize(bakeCellSize float64) {
	log.Println("Calling BakedLightmap.SetBakeCellSize()")

	godotCallVoidFloat(o, "set_bake_cell_size", bakeCellSize)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmap) SetBakeMode(bakeMode int64) {
	log.Println("Calling BakedLightmap.SetBakeMode()")

	godotCallVoidInt(o, "set_bake_mode", bakeMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmap) SetBakeQuality(bakeQuality int64) {
	log.Println("Calling BakedLightmap.SetBakeQuality()")

	godotCallVoidInt(o, "set_bake_quality", bakeQuality)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmap) SetCaptureCellSize(captureCellSize float64) {
	log.Println("Calling BakedLightmap.SetCaptureCellSize()")

	godotCallVoidFloat(o, "set_capture_cell_size", captureCellSize)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmap) SetEnergy(energy float64) {
	log.Println("Calling BakedLightmap.SetEnergy()")

	godotCallVoidFloat(o, "set_energy", energy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmap) SetExtents(extents *Vector3) {
	log.Println("Calling BakedLightmap.SetExtents()")

	godotCallVoidVector3(o, "set_extents", extents)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmap) SetHdr(hdr bool) {
	log.Println("Calling BakedLightmap.SetHdr()")

	godotCallVoidBool(o, "set_hdr", hdr)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmap) SetImagePath(imagePath string) {
	log.Println("Calling BakedLightmap.SetImagePath()")

	godotCallVoidString(o, "set_image_path", imagePath)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmap) SetLightData(data *BakedLightmapData) {
	log.Println("Calling BakedLightmap.SetLightData()")

	godotCallVoidObject(o, "set_light_data", &data.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmap) SetPropagation(propagation float64) {
	log.Println("Calling BakedLightmap.SetPropagation()")

	godotCallVoidFloat(o, "set_propagation", propagation)
	log.Println("  Function successfully completed.")

}

/*
   BakedLightmapImplementer is an interface for BakedLightmap objects.
*/
type BakedLightmapImplementer interface {
	Class
}

/*

 */
type BakedLightmapData struct {
	Resource
}

func (o *BakedLightmapData) baseClass() string {
	return "BakedLightmapData"
}

/*
   Undocumented
*/
func (o *BakedLightmapData) X_GetUserData() *Array {
	log.Println("Calling BakedLightmapData.X_GetUserData()")

	returnValue := godotCallArray(o, "_get_user_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmapData) X_SetUserData(data *Array) {
	log.Println("Calling BakedLightmapData.X_SetUserData()")

	godotCallVoidArray(o, "_set_user_data", data)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *BakedLightmapData) AddUser(path *NodePath, lightmap *Texture, instance int64) {
	log.Println("Calling BakedLightmapData.AddUser()")

	godotCallVoidNodePathObjectInt(o, "add_user", path, &lightmap.Object, instance)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *BakedLightmapData) ClearUsers() {
	log.Println("Calling BakedLightmapData.ClearUsers()")

	godotCallVoid(o, "clear_users")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmapData) GetBounds() *AABB {
	log.Println("Calling BakedLightmapData.GetBounds()")

	returnValue := godotCallAabb(o, "get_bounds")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmapData) GetCellSpaceTransform() *Transform {
	log.Println("Calling BakedLightmapData.GetCellSpaceTransform()")

	returnValue := godotCallTransform(o, "get_cell_space_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmapData) GetCellSubdiv() int64 {
	log.Println("Calling BakedLightmapData.GetCellSubdiv()")

	returnValue := godotCallInt(o, "get_cell_subdiv")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmapData) GetEnergy() float64 {
	log.Println("Calling BakedLightmapData.GetEnergy()")

	returnValue := godotCallFloat(o, "get_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmapData) GetOctree() *PoolByteArray {
	log.Println("Calling BakedLightmapData.GetOctree()")

	returnValue := godotCallPoolByteArray(o, "get_octree")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *BakedLightmapData) GetUserCount() int64 {
	log.Println("Calling BakedLightmapData.GetUserCount()")

	returnValue := godotCallInt(o, "get_user_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *BakedLightmapData) GetUserLightmap(userIdx int64) *Texture {
	log.Println("Calling BakedLightmapData.GetUserLightmap()")

	returnValue := godotCallObjectInt(o, "get_user_lightmap", userIdx)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *BakedLightmapData) GetUserPath(userIdx int64) *NodePath {
	log.Println("Calling BakedLightmapData.GetUserPath()")

	returnValue := godotCallNodePathInt(o, "get_user_path", userIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BakedLightmapData) SetBounds(bounds *AABB) {
	log.Println("Calling BakedLightmapData.SetBounds()")

	godotCallVoidAabb(o, "set_bounds", bounds)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmapData) SetCellSpaceTransform(xform *Transform) {
	log.Println("Calling BakedLightmapData.SetCellSpaceTransform()")

	godotCallVoidTransform(o, "set_cell_space_transform", xform)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmapData) SetCellSubdiv(cellSubdiv int64) {
	log.Println("Calling BakedLightmapData.SetCellSubdiv()")

	godotCallVoidInt(o, "set_cell_subdiv", cellSubdiv)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmapData) SetEnergy(energy float64) {
	log.Println("Calling BakedLightmapData.SetEnergy()")

	godotCallVoidFloat(o, "set_energy", energy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BakedLightmapData) SetOctree(octree *PoolByteArray) {
	log.Println("Calling BakedLightmapData.SetOctree()")

	godotCallVoidPoolByteArray(o, "set_octree", octree)
	log.Println("  Function successfully completed.")

}

/*
   BakedLightmapDataImplementer is an interface for BakedLightmapData objects.
*/
type BakedLightmapDataImplementer interface {
	Class
}

/*
   BaseButton is the abstract base class for buttons, so it shouldn't be used directly (it doesn't display anything). Other types of buttons inherit from it.
*/
type BaseButton struct {
	Control
}

func (o *BaseButton) baseClass() string {
	return "BaseButton"
}

/*
   Undocumented
*/
func (o *BaseButton) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling BaseButton.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Called when button is pressed.
*/
func (o *BaseButton) X_Pressed() {
	log.Println("Calling BaseButton.X_Pressed()")

	godotCallVoid(o, "_pressed")
	log.Println("  Function successfully completed.")

}

/*
   Called when button is toggled (only if toggle_mode is active).
*/
func (o *BaseButton) X_Toggled(buttonPressed bool) {
	log.Println("Calling BaseButton.X_Toggled()")

	godotCallVoidBool(o, "_toggled", buttonPressed)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BaseButton) X_UnhandledInput(arg0 *InputEvent) {
	log.Println("Calling BaseButton.X_UnhandledInput()")

	godotCallVoidObject(o, "_unhandled_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BaseButton) GetActionMode() int64 {
	log.Println("Calling BaseButton.GetActionMode()")

	returnValue := godotCallInt(o, "get_action_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BaseButton) GetButtonGroup() *ButtonGroup {
	log.Println("Calling BaseButton.GetButtonGroup()")

	returnValue := godotCallObject(o, "get_button_group")
	log.Println("  Got return value: ", returnValue)

	var ret ButtonGroup
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the visual state used to draw the button. This is useful mainly when implementing your own draw code by either overriding _draw() or connecting to "draw" signal. The visual state of the button is defined by the DRAW_* enum.
*/
func (o *BaseButton) GetDrawMode() int64 {
	log.Println("Calling BaseButton.GetDrawMode()")

	returnValue := godotCallInt(o, "get_draw_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BaseButton) GetEnabledFocusMode() int64 {
	log.Println("Calling BaseButton.GetEnabledFocusMode()")

	returnValue := godotCallInt(o, "get_enabled_focus_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BaseButton) GetShortcut() *ShortCut {
	log.Println("Calling BaseButton.GetShortcut()")

	returnValue := godotCallObject(o, "get_shortcut")
	log.Println("  Got return value: ", returnValue)

	var ret ShortCut
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *BaseButton) IsDisabled() bool {
	log.Println("Calling BaseButton.IsDisabled()")

	returnValue := godotCallBool(o, "is_disabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return true if mouse entered the button before it exit.
*/
func (o *BaseButton) IsHovered() bool {
	log.Println("Calling BaseButton.IsHovered()")

	returnValue := godotCallBool(o, "is_hovered")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BaseButton) IsPressed() bool {
	log.Println("Calling BaseButton.IsPressed()")

	returnValue := godotCallBool(o, "is_pressed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BaseButton) IsToggleMode() bool {
	log.Println("Calling BaseButton.IsToggleMode()")

	returnValue := godotCallBool(o, "is_toggle_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BaseButton) SetActionMode(mode int64) {
	log.Println("Calling BaseButton.SetActionMode()")

	godotCallVoidInt(o, "set_action_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BaseButton) SetButtonGroup(buttonGroup *ButtonGroup) {
	log.Println("Calling BaseButton.SetButtonGroup()")

	godotCallVoidObject(o, "set_button_group", &buttonGroup.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BaseButton) SetDisabled(disabled bool) {
	log.Println("Calling BaseButton.SetDisabled()")

	godotCallVoidBool(o, "set_disabled", disabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BaseButton) SetEnabledFocusMode(mode int64) {
	log.Println("Calling BaseButton.SetEnabledFocusMode()")

	godotCallVoidInt(o, "set_enabled_focus_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BaseButton) SetPressed(pressed bool) {
	log.Println("Calling BaseButton.SetPressed()")

	godotCallVoidBool(o, "set_pressed", pressed)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BaseButton) SetShortcut(shortcut *ShortCut) {
	log.Println("Calling BaseButton.SetShortcut()")

	godotCallVoidObject(o, "set_shortcut", &shortcut.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BaseButton) SetToggleMode(enabled bool) {
	log.Println("Calling BaseButton.SetToggleMode()")

	godotCallVoidBool(o, "set_toggle_mode", enabled)
	log.Println("  Function successfully completed.")

}

/*
   BaseButtonImplementer is an interface for BaseButton objects.
*/
type BaseButtonImplementer interface {
	Class
}

/*
   A two-dimensional array of boolean values, can be used to efficiently store a binary matrix (every matrix element takes only one bit) and query the values using natural cartesian coordinates.
*/
type BitMap struct {
	Resource
}

func (o *BitMap) baseClass() string {
	return "BitMap"
}

/*
   Undocumented
*/
func (o *BitMap) X_GetData() *Dictionary {
	log.Println("Calling BitMap.X_GetData()")

	returnValue := godotCallDictionary(o, "_get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BitMap) X_SetData(arg0 *Dictionary) {
	log.Println("Calling BitMap.X_SetData()")

	godotCallVoidDictionary(o, "_set_data", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Creates a bitmap with the specified size, filled with false.
*/
func (o *BitMap) Create(size *Vector2) {
	log.Println("Calling BitMap.Create()")

	godotCallVoidVector2(o, "create", size)
	log.Println("  Function successfully completed.")

}

/*
   Creates a bitmap that matches the given image dimensions, every element of the bitmap is set to false if the alpha value of the image at that position is 0, and true in other case.
*/
func (o *BitMap) CreateFromImageAlpha(image *Image) {
	log.Println("Calling BitMap.CreateFromImageAlpha()")

	godotCallVoidObject(o, "create_from_image_alpha", &image.Object)
	log.Println("  Function successfully completed.")

}

/*
   Returns bitmap's value at the specified position.
*/
func (o *BitMap) GetBit(position *Vector2) bool {
	log.Println("Calling BitMap.GetBit()")

	returnValue := godotCallBoolVector2(o, "get_bit", position)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns bitmap's dimensions.
*/
func (o *BitMap) GetSize() *Vector2 {
	log.Println("Calling BitMap.GetSize()")

	returnValue := godotCallVector2(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the amount of bitmap elements that are set to true.
*/
func (o *BitMap) GetTrueBitCount() int64 {
	log.Println("Calling BitMap.GetTrueBitCount()")

	returnValue := godotCallInt(o, "get_true_bit_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the bitmap's element at the specified position, to the specified value.
*/
func (o *BitMap) SetBit(position *Vector2, bit bool) {
	log.Println("Calling BitMap.SetBit()")

	godotCallVoidVector2Bool(o, "set_bit", position, bit)
	log.Println("  Function successfully completed.")

}

/*
   Sets a rectangular portion of the bitmap to the specified value.
*/
func (o *BitMap) SetBitRect(pRect *Rect2, bit bool) {
	log.Println("Calling BitMap.SetBitRect()")

	godotCallVoidRect2Bool(o, "set_bit_rect", pRect, bit)
	log.Println("  Function successfully completed.")

}

/*
   BitMapImplementer is an interface for BitMap objects.
*/
type BitMapImplementer interface {
	Class
}

/*
   Renders text using [code]*.fnt[/code] fonts containing texture atlases. Supports distance fields. For using vector font files like TTF directly, see [DynamicFont].
*/
type BitmapFont struct {
	Font
}

func (o *BitmapFont) baseClass() string {
	return "BitmapFont"
}

/*
   Undocumented
*/
func (o *BitmapFont) X_GetChars() *PoolIntArray {
	log.Println("Calling BitmapFont.X_GetChars()")

	returnValue := godotCallPoolIntArray(o, "_get_chars")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BitmapFont) X_GetKernings() *PoolIntArray {
	log.Println("Calling BitmapFont.X_GetKernings()")

	returnValue := godotCallPoolIntArray(o, "_get_kernings")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BitmapFont) X_GetTextures() *Array {
	log.Println("Calling BitmapFont.X_GetTextures()")

	returnValue := godotCallArray(o, "_get_textures")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BitmapFont) X_SetChars(arg0 *PoolIntArray) {
	log.Println("Calling BitmapFont.X_SetChars()")

	godotCallVoidPoolIntArray(o, "_set_chars", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BitmapFont) X_SetKernings(arg0 *PoolIntArray) {
	log.Println("Calling BitmapFont.X_SetKernings()")

	godotCallVoidPoolIntArray(o, "_set_kernings", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BitmapFont) X_SetTextures(arg0 *Array) {
	log.Println("Calling BitmapFont.X_SetTextures()")

	godotCallVoidArray(o, "_set_textures", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Adds a character to the font, where [code]character[/code] is the unicode value, [code]texture[/code] is the texture index, [code]rect[/code] is the region in the texture (in pixels!), [code]align[/code] is the (optional) alignment for the character and [code]advance[/code] is the (optional) advance.
*/
func (o *BitmapFont) AddChar(character int64, texture int64, rect *Rect2, align *Vector2, advance float64) {
	log.Println("Calling BitmapFont.AddChar()")

	godotCallVoidIntIntRect2Vector2Float(o, "add_char", character, texture, rect, align, advance)
	log.Println("  Function successfully completed.")

}

/*
   Adds a kerning pair to the [code]BitmapFont[/code] as a difference. Kerning pairs are special cases where a typeface advance is determined by the next character.
*/
func (o *BitmapFont) AddKerningPair(charA int64, charB int64, kerning int64) {
	log.Println("Calling BitmapFont.AddKerningPair()")

	godotCallVoidIntIntInt(o, "add_kerning_pair", charA, charB, kerning)
	log.Println("  Function successfully completed.")

}

/*
   Adds a texture to the [code]BitmapFont[/code].
*/
func (o *BitmapFont) AddTexture(texture *Texture) {
	log.Println("Calling BitmapFont.AddTexture()")

	godotCallVoidObject(o, "add_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Clears all the font data and settings.
*/
func (o *BitmapFont) Clear() {
	log.Println("Calling BitmapFont.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Creates a BitmapFont from the [code]*.fnt[/code] file at [code]path[/code].
*/
func (o *BitmapFont) CreateFromFnt(path string) int64 {
	log.Println("Calling BitmapFont.CreateFromFnt()")

	returnValue := godotCallIntString(o, "create_from_fnt", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the size of a character, optionally taking kerning into account if the next character is provided.
*/
func (o *BitmapFont) GetCharSize(char int64, next int64) *Vector2 {
	log.Println("Calling BitmapFont.GetCharSize()")

	returnValue := godotCallVector2IntInt(o, "get_char_size", char, next)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BitmapFont) GetFallback() *BitmapFont {
	log.Println("Calling BitmapFont.GetFallback()")

	returnValue := godotCallObject(o, "get_fallback")
	log.Println("  Got return value: ", returnValue)

	var ret BitmapFont
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns a kerning pair as a difference.
*/
func (o *BitmapFont) GetKerningPair(charA int64, charB int64) int64 {
	log.Println("Calling BitmapFont.GetKerningPair()")

	returnValue := godotCallIntIntInt(o, "get_kerning_pair", charA, charB)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the font atlas texture at index [code]idx[/code].
*/
func (o *BitmapFont) GetTexture(idx int64) *Texture {
	log.Println("Calling BitmapFont.GetTexture()")

	returnValue := godotCallObjectInt(o, "get_texture", idx)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of textures in the BitmapFont atlas.
*/
func (o *BitmapFont) GetTextureCount() int64 {
	log.Println("Calling BitmapFont.GetTextureCount()")

	returnValue := godotCallInt(o, "get_texture_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BitmapFont) SetAscent(px float64) {
	log.Println("Calling BitmapFont.SetAscent()")

	godotCallVoidFloat(o, "set_ascent", px)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BitmapFont) SetDistanceFieldHint(enable bool) {
	log.Println("Calling BitmapFont.SetDistanceFieldHint()")

	godotCallVoidBool(o, "set_distance_field_hint", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BitmapFont) SetFallback(fallback *BitmapFont) {
	log.Println("Calling BitmapFont.SetFallback()")

	godotCallVoidObject(o, "set_fallback", &fallback.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BitmapFont) SetHeight(px float64) {
	log.Println("Calling BitmapFont.SetHeight()")

	godotCallVoidFloat(o, "set_height", px)
	log.Println("  Function successfully completed.")

}

/*
   BitmapFontImplementer is an interface for BitmapFont objects.
*/
type BitmapFontImplementer interface {
	Class
}

/*
   This node must be the child of a [Skeleton] node. You can then select a bone for this node to attach to. The BoneAttachment node will copy the transform of the selected bone.
*/
type BoneAttachment struct {
	Spatial
}

func (o *BoneAttachment) baseClass() string {
	return "BoneAttachment"
}

/*
   Undocumented
*/
func (o *BoneAttachment) GetBoneName() string {
	log.Println("Calling BoneAttachment.GetBoneName()")

	returnValue := godotCallString(o, "get_bone_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BoneAttachment) SetBoneName(boneName string) {
	log.Println("Calling BoneAttachment.SetBoneName()")

	godotCallVoidString(o, "set_bone_name", boneName)
	log.Println("  Function successfully completed.")

}

/*
   BoneAttachmentImplementer is an interface for BoneAttachment objects.
*/
type BoneAttachmentImplementer interface {
	Class
}

/*
   Arranges child controls vertically or horizontally, and rearranges the controls automatically when their minimum size changes.
*/
type BoxContainer struct {
	Container
}

func (o *BoxContainer) baseClass() string {
	return "BoxContainer"
}

/*
   Adds a control to the box as a spacer. If [code]true[/code], [i]begin[/i] will insert the spacer control in front of other children.
*/
func (o *BoxContainer) AddSpacer(begin bool) {
	log.Println("Calling BoxContainer.AddSpacer()")

	godotCallVoidBool(o, "add_spacer", begin)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *BoxContainer) GetAlignment() int64 {
	log.Println("Calling BoxContainer.GetAlignment()")

	returnValue := godotCallInt(o, "get_alignment")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BoxContainer) SetAlignment(alignment int64) {
	log.Println("Calling BoxContainer.SetAlignment()")

	godotCallVoidInt(o, "set_alignment", alignment)
	log.Println("  Function successfully completed.")

}

/*
   BoxContainerImplementer is an interface for BoxContainer objects.
*/
type BoxContainerImplementer interface {
	Class
}

/*
   3D box shape that can be a child of a [PhysicsBody] or [Area].
*/
type BoxShape struct {
	Shape
}

func (o *BoxShape) baseClass() string {
	return "BoxShape"
}

/*
   Undocumented
*/
func (o *BoxShape) GetExtents() *Vector3 {
	log.Println("Calling BoxShape.GetExtents()")

	returnValue := godotCallVector3(o, "get_extents")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *BoxShape) SetExtents(extents *Vector3) {
	log.Println("Calling BoxShape.SetExtents()")

	godotCallVoidVector3(o, "set_extents", extents)
	log.Println("  Function successfully completed.")

}

/*
   BoxShapeImplementer is an interface for BoxShape objects.
*/
type BoxShapeImplementer interface {
	Class
}

/*
   Undocumented
*/
type BulletPhysicsDirectBodyState struct {
	PhysicsDirectBodyState
}

func (o *BulletPhysicsDirectBodyState) baseClass() string {
	return "BulletPhysicsDirectBodyState"
}

/*
   BulletPhysicsDirectBodyStateImplementer is an interface for BulletPhysicsDirectBodyState objects.
*/
type BulletPhysicsDirectBodyStateImplementer interface {
	Class
}

/*
   Undocumented
*/
type BulletPhysicsServer struct {
	physicsServer
}

func (o *BulletPhysicsServer) baseClass() string {
	return "BulletPhysicsServer"
}

/*
   BulletPhysicsServerImplementer is an interface for BulletPhysicsServer objects.
*/
type BulletPhysicsServerImplementer interface {
	Class
}

/*
   Button is the standard themed button. It can contain text and an icon, and will display them according to the current [Theme].
*/
type Button struct {
	BaseButton
}

func (o *Button) baseClass() string {
	return "Button"
}

/*
   Undocumented
*/
func (o *Button) GetButtonIcon() *Texture {
	log.Println("Calling Button.GetButtonIcon()")

	returnValue := godotCallObject(o, "get_button_icon")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Button) GetClipText() bool {
	log.Println("Calling Button.GetClipText()")

	returnValue := godotCallBool(o, "get_clip_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Button) GetText() string {
	log.Println("Calling Button.GetText()")

	returnValue := godotCallString(o, "get_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Button) GetTextAlign() int64 {
	log.Println("Calling Button.GetTextAlign()")

	returnValue := godotCallInt(o, "get_text_align")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Button) IsFlat() bool {
	log.Println("Calling Button.IsFlat()")

	returnValue := godotCallBool(o, "is_flat")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Button) SetButtonIcon(texture *Texture) {
	log.Println("Calling Button.SetButtonIcon()")

	godotCallVoidObject(o, "set_button_icon", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Button) SetClipText(enabled bool) {
	log.Println("Calling Button.SetClipText()")

	godotCallVoidBool(o, "set_clip_text", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Button) SetFlat(enabled bool) {
	log.Println("Calling Button.SetFlat()")

	godotCallVoidBool(o, "set_flat", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Button) SetText(text string) {
	log.Println("Calling Button.SetText()")

	godotCallVoidString(o, "set_text", text)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Button) SetTextAlign(align int64) {
	log.Println("Calling Button.SetTextAlign()")

	godotCallVoidInt(o, "set_text_align", align)
	log.Println("  Function successfully completed.")

}

/*
   ButtonImplementer is an interface for Button objects.
*/
type ButtonImplementer interface {
	Class
}

/*
   Group of [Button]. All direct and indirect children buttons become radios. Only one allows being pressed. [member BaseButton.toggle_mode] should be [code]true[/code].
*/
type ButtonGroup struct {
	Resource
}

func (o *ButtonGroup) baseClass() string {
	return "ButtonGroup"
}

/*
   Return the pressed button.
*/
func (o *ButtonGroup) GetPressedButton() *BaseButton {
	log.Println("Calling ButtonGroup.GetPressedButton()")

	returnValue := godotCallObject(o, "get_pressed_button")
	log.Println("  Got return value: ", returnValue)

	var ret BaseButton
	ret.owner = returnValue.owner
	return &ret

}

/*
   ButtonGroupImplementer is an interface for ButtonGroup objects.
*/
type ButtonGroupImplementer interface {
	Class
}

/*
   Camera is a special node that displays what is visible from its current location. Cameras register themselves in the nearest [Viewport] node (when ascending the tree). Only one camera can be active per viewport. If no viewport is available ascending the tree, the Camera will register in the global viewport. In other words, a Camera just provides [i]3D[/i] display capabilities to a [Viewport], and, without one, a scene registered in that [Viewport] (or higher viewports) can't be displayed.
*/
type Camera struct {
	Spatial
}

func (o *Camera) baseClass() string {
	return "Camera"
}

/*
   If this is the current Camera, remove it from being current. If it is inside the node tree, request to make the next Camera current, if any.
*/
func (o *Camera) ClearCurrent() {
	log.Println("Calling Camera.ClearCurrent()")

	godotCallVoid(o, "clear_current")
	log.Println("  Function successfully completed.")

}

/*
   Get the camera transform. Subclassed cameras (such as CharacterCamera) may provide different transforms than the [Node] transform.
*/
func (o *Camera) GetCameraTransform() *Transform {
	log.Println("Calling Camera.GetCameraTransform()")

	returnValue := godotCallTransform(o, "get_camera_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) GetCullMask() int64 {
	log.Println("Calling Camera.GetCullMask()")

	returnValue := godotCallInt(o, "get_cull_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) GetDopplerTracking() int64 {
	log.Println("Calling Camera.GetDopplerTracking()")

	returnValue := godotCallInt(o, "get_doppler_tracking")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) GetEnvironment() *Environment {
	log.Println("Calling Camera.GetEnvironment()")

	returnValue := godotCallObject(o, "get_environment")
	log.Println("  Got return value: ", returnValue)

	var ret Environment
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Camera) GetFov() float64 {
	log.Println("Calling Camera.GetFov()")

	returnValue := godotCallFloat(o, "get_fov")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) GetHOffset() float64 {
	log.Println("Calling Camera.GetHOffset()")

	returnValue := godotCallFloat(o, "get_h_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) GetKeepAspectMode() int64 {
	log.Println("Calling Camera.GetKeepAspectMode()")

	returnValue := godotCallInt(o, "get_keep_aspect_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) GetProjection() int64 {
	log.Println("Calling Camera.GetProjection()")

	returnValue := godotCallInt(o, "get_projection")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) GetSize() float64 {
	log.Println("Calling Camera.GetSize()")

	returnValue := godotCallFloat(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) GetVOffset() float64 {
	log.Println("Calling Camera.GetVOffset()")

	returnValue := godotCallFloat(o, "get_v_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) GetZfar() float64 {
	log.Println("Calling Camera.GetZfar()")

	returnValue := godotCallFloat(o, "get_zfar")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) GetZnear() float64 {
	log.Println("Calling Camera.GetZnear()")

	returnValue := godotCallFloat(o, "get_znear")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) IsCurrent() bool {
	log.Println("Calling Camera.IsCurrent()")

	returnValue := godotCallBool(o, "is_current")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the given position is behind the Camera.
*/
func (o *Camera) IsPositionBehind(worldPoint *Vector3) bool {
	log.Println("Calling Camera.IsPositionBehind()")

	returnValue := godotCallBoolVector3(o, "is_position_behind", worldPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Make this camera the current Camera for the [Viewport] (see class description). If the Camera Node is outside the scene tree, it will attempt to become current once it's added.
*/
func (o *Camera) MakeCurrent() {
	log.Println("Calling Camera.MakeCurrent()")

	godotCallVoid(o, "make_current")
	log.Println("  Function successfully completed.")

}

/*
   Returns a normal vector from the screen point location directed along the camera. Orthogonal cameras are normalized. Perspective cameras account for perspective, screen width/height, etc.
*/
func (o *Camera) ProjectLocalRayNormal(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectLocalRayNormal()")

	returnValue := godotCallVector3Vector2(o, "project_local_ray_normal", screenPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns how a 2D coordinate in the Viewport rectangle maps to a 3D point in worldspace.
*/
func (o *Camera) ProjectPosition(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectPosition()")

	returnValue := godotCallVector3Vector2(o, "project_position", screenPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a normal vector in worldspace, that is the result of projecting a point on the [Viewport] rectangle by the camera projection. This is useful for casting rays in the form of (origin, normal) for object intersection or picking.
*/
func (o *Camera) ProjectRayNormal(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectRayNormal()")

	returnValue := godotCallVector3Vector2(o, "project_ray_normal", screenPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a 3D position in worldspace, that is the result of projecting a point on the [Viewport] rectangle by the camera projection. This is useful for casting rays in the form of (origin, normal) for object intersection or picking.
*/
func (o *Camera) ProjectRayOrigin(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectRayOrigin()")

	returnValue := godotCallVector3Vector2(o, "project_ray_origin", screenPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera) SetCullMask(mask int64) {
	log.Println("Calling Camera.SetCullMask()")

	godotCallVoidInt(o, "set_cull_mask", mask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera) SetCurrent(arg0 bool) {
	log.Println("Calling Camera.SetCurrent()")

	godotCallVoidBool(o, "set_current", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera) SetDopplerTracking(mode int64) {
	log.Println("Calling Camera.SetDopplerTracking()")

	godotCallVoidInt(o, "set_doppler_tracking", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera) SetEnvironment(env *Environment) {
	log.Println("Calling Camera.SetEnvironment()")

	godotCallVoidObject(o, "set_environment", &env.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera) SetFov(arg0 float64) {
	log.Println("Calling Camera.SetFov()")

	godotCallVoidFloat(o, "set_fov", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera) SetHOffset(ofs float64) {
	log.Println("Calling Camera.SetHOffset()")

	godotCallVoidFloat(o, "set_h_offset", ofs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera) SetKeepAspectMode(mode int64) {
	log.Println("Calling Camera.SetKeepAspectMode()")

	godotCallVoidInt(o, "set_keep_aspect_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Set the camera projection to orthogonal mode, by specifying a width and the [i]near[/i] and [i]far[/i] clip planes in worldspace units. (As a hint, 2D games often use this projection, with values specified in pixels)
*/
func (o *Camera) SetOrthogonal(size float64, zNear float64, zFar float64) {
	log.Println("Calling Camera.SetOrthogonal()")

	godotCallVoidFloatFloatFloat(o, "set_orthogonal", size, zNear, zFar)
	log.Println("  Function successfully completed.")

}

/*
   Set the camera projection to perspective mode, by specifying a [i]FOV[/i] Y angle in degrees (FOV means Field of View), and the [i]near[/i] and [i]far[/i] clip planes in worldspace units.
*/
func (o *Camera) SetPerspective(fov float64, zNear float64, zFar float64) {
	log.Println("Calling Camera.SetPerspective()")

	godotCallVoidFloatFloatFloat(o, "set_perspective", fov, zNear, zFar)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera) SetProjection(arg0 int64) {
	log.Println("Calling Camera.SetProjection()")

	godotCallVoidInt(o, "set_projection", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera) SetSize(arg0 float64) {
	log.Println("Calling Camera.SetSize()")

	godotCallVoidFloat(o, "set_size", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera) SetVOffset(ofs float64) {
	log.Println("Calling Camera.SetVOffset()")

	godotCallVoidFloat(o, "set_v_offset", ofs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera) SetZfar(arg0 float64) {
	log.Println("Calling Camera.SetZfar()")

	godotCallVoidFloat(o, "set_zfar", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera) SetZnear(arg0 float64) {
	log.Println("Calling Camera.SetZnear()")

	godotCallVoidFloat(o, "set_znear", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Returns how a 3D point in worldspace maps to a 2D coordinate in the [Viewport] rectangle.
*/
func (o *Camera) UnprojectPosition(worldPoint *Vector3) *Vector2 {
	log.Println("Calling Camera.UnprojectPosition()")

	returnValue := godotCallVector2Vector3(o, "unproject_position", worldPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   CameraImplementer is an interface for Camera objects.
*/
type CameraImplementer interface {
	Class
}

/*
   Camera node for 2D scenes. It forces the screen (current layer) to scroll following this node. This makes it easier (and faster) to program scrollable scenes than manually changing the position of [CanvasItem] based nodes. This node is intended to be a simple helper to get things going quickly and it may happen often that more functionality is desired to change how the camera works. To make your own custom camera node, simply inherit from [Node2D] and change the transform of the canvas by calling get_viewport().set_canvas_transform(m) in [Viewport].
*/
type Camera2D struct {
	Node2D
}

func (o *Camera2D) baseClass() string {
	return "Camera2D"
}

/*
   Undocumented
*/
func (o *Camera2D) X_MakeCurrent(arg0 *Object) {
	log.Println("Calling Camera2D.X_MakeCurrent()")

	godotCallVoidObject(o, "_make_current", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) X_SetCurrent(current bool) {
	log.Println("Calling Camera2D.X_SetCurrent()")

	godotCallVoidBool(o, "_set_current", current)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) X_SetOldSmoothing(followSmoothing float64) {
	log.Println("Calling Camera2D.X_SetOldSmoothing()")

	godotCallVoidFloat(o, "_set_old_smoothing", followSmoothing)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) X_UpdateScroll() {
	log.Println("Calling Camera2D.X_UpdateScroll()")

	godotCallVoid(o, "_update_scroll")
	log.Println("  Function successfully completed.")

}

/*
   Align the camera to the tracked node
*/
func (o *Camera2D) Align() {
	log.Println("Calling Camera2D.Align()")

	godotCallVoid(o, "align")
	log.Println("  Function successfully completed.")

}

/*
   Removes any [code]Camera2D[/code] from the ancestor [Viewport]'s internal currently-assigned camera.
*/
func (o *Camera2D) ClearCurrent() {
	log.Println("Calling Camera2D.ClearCurrent()")

	godotCallVoid(o, "clear_current")
	log.Println("  Function successfully completed.")

}

/*
   Force the camera to update scroll immediately.
*/
func (o *Camera2D) ForceUpdateScroll() {
	log.Println("Calling Camera2D.ForceUpdateScroll()")

	godotCallVoid(o, "force_update_scroll")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) GetAnchorMode() int64 {
	log.Println("Calling Camera2D.GetAnchorMode()")

	returnValue := godotCallInt(o, "get_anchor_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the camera position.
*/
func (o *Camera2D) GetCameraPosition() *Vector2 {
	log.Println("Calling Camera2D.GetCameraPosition()")

	returnValue := godotCallVector2(o, "get_camera_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the location of the [code]Camera2D[/code]'s screen-center, relative to the origin.
*/
func (o *Camera2D) GetCameraScreenCenter() *Vector2 {
	log.Println("Calling Camera2D.GetCameraScreenCenter()")

	returnValue := godotCallVector2(o, "get_camera_screen_center")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) GetCustomViewport() *Node {
	log.Println("Calling Camera2D.GetCustomViewport()")

	returnValue := godotCallObject(o, "get_custom_viewport")
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Camera2D) GetDragMargin(margin int64) float64 {
	log.Println("Calling Camera2D.GetDragMargin()")

	returnValue := godotCallFloatInt(o, "get_drag_margin", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) GetFollowSmoothing() float64 {
	log.Println("Calling Camera2D.GetFollowSmoothing()")

	returnValue := godotCallFloat(o, "get_follow_smoothing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) GetHOffset() float64 {
	log.Println("Calling Camera2D.GetHOffset()")

	returnValue := godotCallFloat(o, "get_h_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) GetLimit(margin int64) int64 {
	log.Println("Calling Camera2D.GetLimit()")

	returnValue := godotCallIntInt(o, "get_limit", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) GetOffset() *Vector2 {
	log.Println("Calling Camera2D.GetOffset()")

	returnValue := godotCallVector2(o, "get_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) GetVOffset() float64 {
	log.Println("Calling Camera2D.GetVOffset()")

	returnValue := godotCallFloat(o, "get_v_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) GetZoom() *Vector2 {
	log.Println("Calling Camera2D.GetZoom()")

	returnValue := godotCallVector2(o, "get_zoom")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) IsCurrent() bool {
	log.Println("Calling Camera2D.IsCurrent()")

	returnValue := godotCallBool(o, "is_current")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) IsFollowSmoothingEnabled() bool {
	log.Println("Calling Camera2D.IsFollowSmoothingEnabled()")

	returnValue := godotCallBool(o, "is_follow_smoothing_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) IsHDragEnabled() bool {
	log.Println("Calling Camera2D.IsHDragEnabled()")

	returnValue := godotCallBool(o, "is_h_drag_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) IsLimitDrawingEnabled() bool {
	log.Println("Calling Camera2D.IsLimitDrawingEnabled()")

	returnValue := godotCallBool(o, "is_limit_drawing_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) IsLimitSmoothingEnabled() bool {
	log.Println("Calling Camera2D.IsLimitSmoothingEnabled()")

	returnValue := godotCallBool(o, "is_limit_smoothing_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) IsMarginDrawingEnabled() bool {
	log.Println("Calling Camera2D.IsMarginDrawingEnabled()")

	returnValue := godotCallBool(o, "is_margin_drawing_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) IsRotating() bool {
	log.Println("Calling Camera2D.IsRotating()")

	returnValue := godotCallBool(o, "is_rotating")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) IsScreenDrawingEnabled() bool {
	log.Println("Calling Camera2D.IsScreenDrawingEnabled()")

	returnValue := godotCallBool(o, "is_screen_drawing_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Camera2D) IsVDragEnabled() bool {
	log.Println("Calling Camera2D.IsVDragEnabled()")

	returnValue := godotCallBool(o, "is_v_drag_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Make this the current 2D camera for the scene (viewport and layer), in case there's many cameras in the scene.
*/
func (o *Camera2D) MakeCurrent() {
	log.Println("Calling Camera2D.MakeCurrent()")

	godotCallVoid(o, "make_current")
	log.Println("  Function successfully completed.")

}

/*
   Set the camera's position immediately to its current smoothing destination. This has no effect if smoothing is disabled.
*/
func (o *Camera2D) ResetSmoothing() {
	log.Println("Calling Camera2D.ResetSmoothing()")

	godotCallVoid(o, "reset_smoothing")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetAnchorMode(anchorMode int64) {
	log.Println("Calling Camera2D.SetAnchorMode()")

	godotCallVoidInt(o, "set_anchor_mode", anchorMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetCustomViewport(viewport *Object) {
	log.Println("Calling Camera2D.SetCustomViewport()")

	godotCallVoidObject(o, "set_custom_viewport", viewport)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetDragMargin(margin int64, dragMargin float64) {
	log.Println("Calling Camera2D.SetDragMargin()")

	godotCallVoidIntFloat(o, "set_drag_margin", margin, dragMargin)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetEnableFollowSmoothing(followSmoothing bool) {
	log.Println("Calling Camera2D.SetEnableFollowSmoothing()")

	godotCallVoidBool(o, "set_enable_follow_smoothing", followSmoothing)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetFollowSmoothing(followSmoothing float64) {
	log.Println("Calling Camera2D.SetFollowSmoothing()")

	godotCallVoidFloat(o, "set_follow_smoothing", followSmoothing)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetHDragEnabled(enabled bool) {
	log.Println("Calling Camera2D.SetHDragEnabled()")

	godotCallVoidBool(o, "set_h_drag_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetHOffset(ofs float64) {
	log.Println("Calling Camera2D.SetHOffset()")

	godotCallVoidFloat(o, "set_h_offset", ofs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetLimit(margin int64, limit int64) {
	log.Println("Calling Camera2D.SetLimit()")

	godotCallVoidIntInt(o, "set_limit", margin, limit)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetLimitDrawingEnabled(limitDrawingEnabled bool) {
	log.Println("Calling Camera2D.SetLimitDrawingEnabled()")

	godotCallVoidBool(o, "set_limit_drawing_enabled", limitDrawingEnabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetLimitSmoothingEnabled(limitSmoothingEnabled bool) {
	log.Println("Calling Camera2D.SetLimitSmoothingEnabled()")

	godotCallVoidBool(o, "set_limit_smoothing_enabled", limitSmoothingEnabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetMarginDrawingEnabled(marginDrawingEnabled bool) {
	log.Println("Calling Camera2D.SetMarginDrawingEnabled()")

	godotCallVoidBool(o, "set_margin_drawing_enabled", marginDrawingEnabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetOffset(offset *Vector2) {
	log.Println("Calling Camera2D.SetOffset()")

	godotCallVoidVector2(o, "set_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetRotating(rotating bool) {
	log.Println("Calling Camera2D.SetRotating()")

	godotCallVoidBool(o, "set_rotating", rotating)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetScreenDrawingEnabled(screenDrawingEnabled bool) {
	log.Println("Calling Camera2D.SetScreenDrawingEnabled()")

	godotCallVoidBool(o, "set_screen_drawing_enabled", screenDrawingEnabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetVDragEnabled(enabled bool) {
	log.Println("Calling Camera2D.SetVDragEnabled()")

	godotCallVoidBool(o, "set_v_drag_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetVOffset(ofs float64) {
	log.Println("Calling Camera2D.SetVOffset()")

	godotCallVoidFloat(o, "set_v_offset", ofs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Camera2D) SetZoom(zoom *Vector2) {
	log.Println("Calling Camera2D.SetZoom()")

	godotCallVoidVector2(o, "set_zoom", zoom)
	log.Println("  Function successfully completed.")

}

/*
   Camera2DImplementer is an interface for Camera2D objects.
*/
type Camera2DImplementer interface {
	Class
}

/*
   Base class of anything 2D. Canvas items are laid out in a tree and children inherit and extend the transform of their parent. CanvasItem is extended by [Control], for anything GUI related, and by [Node2D] for anything 2D engine related. Any CanvasItem can draw. For this, the "update" function must be called, then NOTIFICATION_DRAW will be received on idle time to request redraw. Because of this, canvas items don't need to be redraw on every frame, improving the performance significantly. Several functions for drawing on the CanvasItem are provided (see draw_* functions). They can only be used inside the notification, signal or _draw() overrides function, though. Canvas items are draw in tree order. By default, children are on top of their parents so a root CanvasItem will be drawn behind everything (this can be changed per item though). Canvas items can also be hidden (hiding also their subtree). They provide many means for changing standard parameters such as opacity (for it and the subtree) and self opacity, blend mode. Ultimately, a transform notification can be requested, which will notify the node that its global position changed in case the parent tree changed.
*/
type CanvasItem struct {
	Node
}

func (o *CanvasItem) baseClass() string {
	return "CanvasItem"
}

/*
   Called (if exists) to draw the canvas item.
*/
func (o *CanvasItem) X_Draw() {
	log.Println("Calling CanvasItem.X_Draw()")

	godotCallVoid(o, "_draw")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditGetItemAndChildrenRect() *Rect2 {
	log.Println("Calling CanvasItem.X_EditGetItemAndChildrenRect()")

	returnValue := godotCallRect2(o, "_edit_get_item_and_children_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditGetPivot() *Vector2 {
	log.Println("Calling CanvasItem.X_EditGetPivot()")

	returnValue := godotCallVector2(o, "_edit_get_pivot")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditGetPosition() *Vector2 {
	log.Println("Calling CanvasItem.X_EditGetPosition()")

	returnValue := godotCallVector2(o, "_edit_get_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditGetRect() *Rect2 {
	log.Println("Calling CanvasItem.X_EditGetRect()")

	returnValue := godotCallRect2(o, "_edit_get_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditGetRotation() float64 {
	log.Println("Calling CanvasItem.X_EditGetRotation()")

	returnValue := godotCallFloat(o, "_edit_get_rotation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditGetState() *Dictionary {
	log.Println("Calling CanvasItem.X_EditGetState()")

	returnValue := godotCallDictionary(o, "_edit_get_state")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditSetPivot(pivot *Vector2) {
	log.Println("Calling CanvasItem.X_EditSetPivot()")

	godotCallVoidVector2(o, "_edit_set_pivot", pivot)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditSetPosition(position *Vector2) {
	log.Println("Calling CanvasItem.X_EditSetPosition()")

	godotCallVoidVector2(o, "_edit_set_position", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditSetRect(rect *Rect2) {
	log.Println("Calling CanvasItem.X_EditSetRect()")

	godotCallVoidRect2(o, "_edit_set_rect", rect)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditSetRotation(degrees float64) {
	log.Println("Calling CanvasItem.X_EditSetRotation()")

	godotCallVoidFloat(o, "_edit_set_rotation", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditSetState(state *Dictionary) {
	log.Println("Calling CanvasItem.X_EditSetState()")

	godotCallVoidDictionary(o, "_edit_set_state", state)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditUsePivot() bool {
	log.Println("Calling CanvasItem.X_EditUsePivot()")

	returnValue := godotCallBool(o, "_edit_use_pivot")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditUsePosition() bool {
	log.Println("Calling CanvasItem.X_EditUsePosition()")

	returnValue := godotCallBool(o, "_edit_use_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditUseRect() bool {
	log.Println("Calling CanvasItem.X_EditUseRect()")

	returnValue := godotCallBool(o, "_edit_use_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_EditUseRotation() bool {
	log.Println("Calling CanvasItem.X_EditUseRotation()")

	returnValue := godotCallBool(o, "_edit_use_rotation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_IsOnTop() bool {
	log.Println("Calling CanvasItem.X_IsOnTop()")

	returnValue := godotCallBool(o, "_is_on_top")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) X_SetOnTop(onTop bool) {
	log.Println("Calling CanvasItem.X_SetOnTop()")

	godotCallVoidBool(o, "_set_on_top", onTop)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) X_ToplevelRaiseSelf() {
	log.Println("Calling CanvasItem.X_ToplevelRaiseSelf()")

	godotCallVoid(o, "_toplevel_raise_self")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) X_UpdateCallback() {
	log.Println("Calling CanvasItem.X_UpdateCallback()")

	godotCallVoid(o, "_update_callback")
	log.Println("  Function successfully completed.")

}

/*
   Draws a string character using a custom font. Returns the advance, depending on the char width and kerning with an optional next char.
*/
func (o *CanvasItem) DrawChar(font *Font, position *Vector2, char string, next string, modulate *Color) float64 {
	log.Println("Calling CanvasItem.DrawChar()")

	returnValue := godotCallFloatObjectVector2StringStringColor(o, "draw_char", &font.Object, position, char, next, modulate)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Draws a colored circle.
*/
func (o *CanvasItem) DrawCircle(position *Vector2, radius float64, color *Color) {
	log.Println("Calling CanvasItem.DrawCircle()")

	godotCallVoidVector2FloatColor(o, "draw_circle", position, radius, color)
	log.Println("  Function successfully completed.")

}

/*
   Draws a colored polygon of any amount of points, convex or concave.
*/
func (o *CanvasItem) DrawColoredPolygon(points *PoolVector2Array, color *Color, uvs *PoolVector2Array, texture *Texture, normalMap *Texture, antialiased bool) {
	log.Println("Calling CanvasItem.DrawColoredPolygon()")

	godotCallVoidPoolVector2ArrayColorPoolVector2ArrayObjectObjectBool(o, "draw_colored_polygon", points, color, uvs, &texture.Object, &normalMap.Object, antialiased)
	log.Println("  Function successfully completed.")

}

/*
   Draws a line from a 2D point to another, with a given color and width. It can be optionally antialiased.
*/
func (o *CanvasItem) DrawLine(from *Vector2, to *Vector2, color *Color, width float64, antialiased bool) {
	log.Println("Calling CanvasItem.DrawLine()")

	godotCallVoidVector2Vector2ColorFloatBool(o, "draw_line", from, to, color, width, antialiased)
	log.Println("  Function successfully completed.")

}

/*
   Draws multiple, parallel lines with a uniform [code]color[/code] and [code]width[/code] and optional antialiasing.
*/
func (o *CanvasItem) DrawMultiline(points *PoolVector2Array, color *Color, width float64, antialiased bool) {
	log.Println("Calling CanvasItem.DrawMultiline()")

	godotCallVoidPoolVector2ArrayColorFloatBool(o, "draw_multiline", points, color, width, antialiased)
	log.Println("  Function successfully completed.")

}

/*
   Draws multiple, parallel lines with a uniform [code]width[/code], segment-by-segment coloring, and optional antialiasing. Colors assigned to line segments match by index between [code]points[/code] and [code]colors[/code].
*/
func (o *CanvasItem) DrawMultilineColors(points *PoolVector2Array, colors *PoolColorArray, width float64, antialiased bool) {
	log.Println("Calling CanvasItem.DrawMultilineColors()")

	godotCallVoidPoolVector2ArrayPoolColorArrayFloatBool(o, "draw_multiline_colors", points, colors, width, antialiased)
	log.Println("  Function successfully completed.")

}

/*
   Draws a polygon of any amount of points, convex or concave.
*/
func (o *CanvasItem) DrawPolygon(points *PoolVector2Array, colors *PoolColorArray, uvs *PoolVector2Array, texture *Texture, normalMap *Texture, antialiased bool) {
	log.Println("Calling CanvasItem.DrawPolygon()")

	godotCallVoidPoolVector2ArrayPoolColorArrayPoolVector2ArrayObjectObjectBool(o, "draw_polygon", points, colors, uvs, &texture.Object, &normalMap.Object, antialiased)
	log.Println("  Function successfully completed.")

}

/*
   Draws interconnected line segments with a uniform [code]color[/code] and [code]width[/code] and optional antialiasing.
*/
func (o *CanvasItem) DrawPolyline(points *PoolVector2Array, color *Color, width float64, antialiased bool) {
	log.Println("Calling CanvasItem.DrawPolyline()")

	godotCallVoidPoolVector2ArrayColorFloatBool(o, "draw_polyline", points, color, width, antialiased)
	log.Println("  Function successfully completed.")

}

/*
   Draws interconnected line segments with a uniform [code]width[/code], segment-by-segment coloring, and optional antialiasing. Colors assigned to line segments match by index between [code]points[/code] and [code]colors[/code].
*/
func (o *CanvasItem) DrawPolylineColors(points *PoolVector2Array, colors *PoolColorArray, width float64, antialiased bool) {
	log.Println("Calling CanvasItem.DrawPolylineColors()")

	godotCallVoidPoolVector2ArrayPoolColorArrayFloatBool(o, "draw_polyline_colors", points, colors, width, antialiased)
	log.Println("  Function successfully completed.")

}

/*
   Draws a custom primitive, 1 point for a point, 2 points for a line, 3 points for a triangle and 4 points for a quad.
*/
func (o *CanvasItem) DrawPrimitive(points *PoolVector2Array, colors *PoolColorArray, uvs *PoolVector2Array, texture *Texture, width float64, normalMap *Texture) {
	log.Println("Calling CanvasItem.DrawPrimitive()")

	godotCallVoidPoolVector2ArrayPoolColorArrayPoolVector2ArrayObjectFloatObject(o, "draw_primitive", points, colors, uvs, &texture.Object, width, &normalMap.Object)
	log.Println("  Function successfully completed.")

}

/*
   Draws a colored rectangle.
*/
func (o *CanvasItem) DrawRect(rect *Rect2, color *Color, filled bool) {
	log.Println("Calling CanvasItem.DrawRect()")

	godotCallVoidRect2ColorBool(o, "draw_rect", rect, color, filled)
	log.Println("  Function successfully completed.")

}

/*
   Sets a custom transform for drawing via components. Anything drawn afterwards will be transformed by this.
*/
func (o *CanvasItem) DrawSetTransform(position *Vector2, rotation float64, scale *Vector2) {
	log.Println("Calling CanvasItem.DrawSetTransform()")

	godotCallVoidVector2FloatVector2(o, "draw_set_transform", position, rotation, scale)
	log.Println("  Function successfully completed.")

}

/*
   Sets a custom transform for drawing via matrix. Anything drawn afterwards will be transformed by this.
*/
func (o *CanvasItem) DrawSetTransformMatrix(xform *Transform2D) {
	log.Println("Calling CanvasItem.DrawSetTransformMatrix()")

	godotCallVoidTransform2D(o, "draw_set_transform_matrix", xform)
	log.Println("  Function successfully completed.")

}

/*
   Draws a string using a custom font.
*/
func (o *CanvasItem) DrawString(font *Font, position *Vector2, text string, modulate *Color, clipW int64) {
	log.Println("Calling CanvasItem.DrawString()")

	godotCallVoidObjectVector2StringColorInt(o, "draw_string", &font.Object, position, text, modulate, clipW)
	log.Println("  Function successfully completed.")

}

/*
   Draws a styled rectangle.
*/
func (o *CanvasItem) DrawStyleBox(styleBox *StyleBox, rect *Rect2) {
	log.Println("Calling CanvasItem.DrawStyleBox()")

	godotCallVoidObjectRect2(o, "draw_style_box", &styleBox.Object, rect)
	log.Println("  Function successfully completed.")

}

/*
   Draws a texture at a given position.
*/
func (o *CanvasItem) DrawTexture(texture *Texture, position *Vector2, modulate *Color, normalMap *Texture) {
	log.Println("Calling CanvasItem.DrawTexture()")

	godotCallVoidObjectVector2ColorObject(o, "draw_texture", &texture.Object, position, modulate, &normalMap.Object)
	log.Println("  Function successfully completed.")

}

/*
   Draws a textured rectangle at a given position, optionally modulated by a color. Transpose swaps the x and y coordinates when reading the texture.
*/
func (o *CanvasItem) DrawTextureRect(texture *Texture, rect *Rect2, tile bool, modulate *Color, transpose bool, normalMap *Texture) {
	log.Println("Calling CanvasItem.DrawTextureRect()")

	godotCallVoidObjectRect2BoolColorBoolObject(o, "draw_texture_rect", &texture.Object, rect, tile, modulate, transpose, &normalMap.Object)
	log.Println("  Function successfully completed.")

}

/*
   Draws a textured rectangle region at a given position, optionally modulated by a color. Transpose swaps the x and y coordinates when reading the texture.
*/
func (o *CanvasItem) DrawTextureRectRegion(texture *Texture, rect *Rect2, srcRect *Rect2, modulate *Color, transpose bool, normalMap *Texture, clipUv bool) {
	log.Println("Calling CanvasItem.DrawTextureRectRegion()")

	godotCallVoidObjectRect2Rect2ColorBoolObjectBool(o, "draw_texture_rect_region", &texture.Object, rect, srcRect, modulate, transpose, &normalMap.Object, clipUv)
	log.Println("  Function successfully completed.")

}

/*
   Return the [RID] of the [World2D] canvas where this item is in.
*/
func (o *CanvasItem) GetCanvas() *RID {
	log.Println("Calling CanvasItem.GetCanvas()")

	returnValue := godotCallRid(o, "get_canvas")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the canvas item RID used by [VisualServer] for this item.
*/
func (o *CanvasItem) GetCanvasItem() *RID {
	log.Println("Calling CanvasItem.GetCanvasItem()")

	returnValue := godotCallRid(o, "get_canvas_item")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the transform matrix of this item's canvas.
*/
func (o *CanvasItem) GetCanvasTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetCanvasTransform()")

	returnValue := godotCallTransform2D(o, "get_canvas_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the global position of the mouse.
*/
func (o *CanvasItem) GetGlobalMousePosition() *Vector2 {
	log.Println("Calling CanvasItem.GetGlobalMousePosition()")

	returnValue := godotCallVector2(o, "get_global_mouse_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the global transform matrix of this item.
*/
func (o *CanvasItem) GetGlobalTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetGlobalTransform()")

	returnValue := godotCallTransform2D(o, "get_global_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the global transform matrix of this item in relation to the canvas.
*/
func (o *CanvasItem) GetGlobalTransformWithCanvas() *Transform2D {
	log.Println("Calling CanvasItem.GetGlobalTransformWithCanvas()")

	returnValue := godotCallTransform2D(o, "get_global_transform_with_canvas")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) GetLightMask() int64 {
	log.Println("Calling CanvasItem.GetLightMask()")

	returnValue := godotCallInt(o, "get_light_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the mouse position relative to this item's position.
*/
func (o *CanvasItem) GetLocalMousePosition() *Vector2 {
	log.Println("Calling CanvasItem.GetLocalMousePosition()")

	returnValue := godotCallVector2(o, "get_local_mouse_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) GetMaterial() *Material {
	log.Println("Calling CanvasItem.GetMaterial()")

	returnValue := godotCallObject(o, "get_material")
	log.Println("  Got return value: ", returnValue)

	var ret Material
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *CanvasItem) GetModulate() *Color {
	log.Println("Calling CanvasItem.GetModulate()")

	returnValue := godotCallColor(o, "get_modulate")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) GetSelfModulate() *Color {
	log.Println("Calling CanvasItem.GetSelfModulate()")

	returnValue := godotCallColor(o, "get_self_modulate")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the transform matrix of this item.
*/
func (o *CanvasItem) GetTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetTransform()")

	returnValue := godotCallTransform2D(o, "get_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) GetUseParentMaterial() bool {
	log.Println("Calling CanvasItem.GetUseParentMaterial()")

	returnValue := godotCallBool(o, "get_use_parent_material")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the viewport's boundaries as a [Rect2].
*/
func (o *CanvasItem) GetViewportRect() *Rect2 {
	log.Println("Calling CanvasItem.GetViewportRect()")

	returnValue := godotCallRect2(o, "get_viewport_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get this item's transform in relation to the viewport.
*/
func (o *CanvasItem) GetViewportTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetViewportTransform()")

	returnValue := godotCallTransform2D(o, "get_viewport_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the [World2D] where this item is in.
*/
func (o *CanvasItem) GetWorld2D() *World2D {
	log.Println("Calling CanvasItem.GetWorld2D()")

	returnValue := godotCallObject(o, "get_world_2d")
	log.Println("  Got return value: ", returnValue)

	var ret World2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Hide the CanvasItem currently visible.
*/
func (o *CanvasItem) Hide() {
	log.Println("Calling CanvasItem.Hide()")

	godotCallVoid(o, "hide")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) IsDrawBehindParentEnabled() bool {
	log.Println("Calling CanvasItem.IsDrawBehindParentEnabled()")

	returnValue := godotCallBool(o, "is_draw_behind_parent_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if local transform notifications are communicated to children.
*/
func (o *CanvasItem) IsLocalTransformNotificationEnabled() bool {
	log.Println("Calling CanvasItem.IsLocalTransformNotificationEnabled()")

	returnValue := godotCallBool(o, "is_local_transform_notification_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return if set as toplevel. See [method set_as_toplevel].
*/
func (o *CanvasItem) IsSetAsToplevel() bool {
	log.Println("Calling CanvasItem.IsSetAsToplevel()")

	returnValue := godotCallBool(o, "is_set_as_toplevel")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if global transform notifications are communicated to children.
*/
func (o *CanvasItem) IsTransformNotificationEnabled() bool {
	log.Println("Calling CanvasItem.IsTransformNotificationEnabled()")

	returnValue := godotCallBool(o, "is_transform_notification_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItem) IsVisible() bool {
	log.Println("Calling CanvasItem.IsVisible()")

	returnValue := godotCallBool(o, "is_visible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the node is present in the [SceneTree], its [member visible] property is [code]true[/code] and its inherited visibility is also [code]true[/code].
*/
func (o *CanvasItem) IsVisibleInTree() bool {
	log.Println("Calling CanvasItem.IsVisibleInTree()")

	returnValue := godotCallBool(o, "is_visible_in_tree")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Assigns [code]screen_point[/code] as this node's new local transform.
*/
func (o *CanvasItem) MakeCanvasPositionLocal(screenPoint *Vector2) *Vector2 {
	log.Println("Calling CanvasItem.MakeCanvasPositionLocal()")

	returnValue := godotCallVector2Vector2(o, "make_canvas_position_local", screenPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Transformations issued by [code]event[/code]'s inputs are applied in local space instead of global space.
*/
func (o *CanvasItem) MakeInputLocal(event *InputEvent) *InputEvent {
	log.Println("Calling CanvasItem.MakeInputLocal()")

	returnValue := godotCallObjectObject(o, "make_input_local", &event.Object)
	log.Println("  Got return value: ", returnValue)

	var ret InputEvent
	ret.owner = returnValue.owner
	return &ret

}

/*
   Sets as top level. This means that it will not inherit transform from parent canvas items.
*/
func (o *CanvasItem) SetAsToplevel(enable bool) {
	log.Println("Calling CanvasItem.SetAsToplevel()")

	godotCallVoidBool(o, "set_as_toplevel", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) SetDrawBehindParent(enable bool) {
	log.Println("Calling CanvasItem.SetDrawBehindParent()")

	godotCallVoidBool(o, "set_draw_behind_parent", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) SetLightMask(lightMask int64) {
	log.Println("Calling CanvasItem.SetLightMask()")

	godotCallVoidInt(o, "set_light_mask", lightMask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) SetMaterial(material *Material) {
	log.Println("Calling CanvasItem.SetMaterial()")

	godotCallVoidObject(o, "set_material", &material.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) SetModulate(modulate *Color) {
	log.Println("Calling CanvasItem.SetModulate()")

	godotCallVoidColor(o, "set_modulate", modulate)
	log.Println("  Function successfully completed.")

}

/*
   If [code]enable[/code] is [code]true[/code], children will be updated with local transform data.
*/
func (o *CanvasItem) SetNotifyLocalTransform(enable bool) {
	log.Println("Calling CanvasItem.SetNotifyLocalTransform()")

	godotCallVoidBool(o, "set_notify_local_transform", enable)
	log.Println("  Function successfully completed.")

}

/*
   If [code]enable[/code] is [code]true[/code], children will be updated with global transform data.
*/
func (o *CanvasItem) SetNotifyTransform(enable bool) {
	log.Println("Calling CanvasItem.SetNotifyTransform()")

	godotCallVoidBool(o, "set_notify_transform", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) SetSelfModulate(selfModulate *Color) {
	log.Println("Calling CanvasItem.SetSelfModulate()")

	godotCallVoidColor(o, "set_self_modulate", selfModulate)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) SetUseParentMaterial(enable bool) {
	log.Println("Calling CanvasItem.SetUseParentMaterial()")

	godotCallVoidBool(o, "set_use_parent_material", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItem) SetVisible(visible bool) {
	log.Println("Calling CanvasItem.SetVisible()")

	godotCallVoidBool(o, "set_visible", visible)
	log.Println("  Function successfully completed.")

}

/*
   Show the CanvasItem currently hidden.
*/
func (o *CanvasItem) Show() {
	log.Println("Calling CanvasItem.Show()")

	godotCallVoid(o, "show")
	log.Println("  Function successfully completed.")

}

/*
   Queue the CanvasItem for update. [code]NOTIFICATION_DRAW[/code] will be called on idle time to request redraw.
*/
func (o *CanvasItem) Update() {
	log.Println("Calling CanvasItem.Update()")

	godotCallVoid(o, "update")
	log.Println("  Function successfully completed.")

}

/*
   CanvasItemImplementer is an interface for CanvasItem objects.
*/
type CanvasItemImplementer interface {
	Class
}

/*
   [code]CanvasItemMaterial[/code]s provide a means of modifying the textures associated with a CanvasItem. They specialize in describing blend and lighting behaviors for textures. Use a [ShaderMaterial] to more fully customize a material's interactions with a [CanvasItem].
*/
type CanvasItemMaterial struct {
	Material
}

func (o *CanvasItemMaterial) baseClass() string {
	return "CanvasItemMaterial"
}

/*
   Undocumented
*/
func (o *CanvasItemMaterial) GetBlendMode() int64 {
	log.Println("Calling CanvasItemMaterial.GetBlendMode()")

	returnValue := godotCallInt(o, "get_blend_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItemMaterial) GetLightMode() int64 {
	log.Println("Calling CanvasItemMaterial.GetLightMode()")

	returnValue := godotCallInt(o, "get_light_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasItemMaterial) SetBlendMode(blendMode int64) {
	log.Println("Calling CanvasItemMaterial.SetBlendMode()")

	godotCallVoidInt(o, "set_blend_mode", blendMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasItemMaterial) SetLightMode(lightMode int64) {
	log.Println("Calling CanvasItemMaterial.SetLightMode()")

	godotCallVoidInt(o, "set_light_mode", lightMode)
	log.Println("  Function successfully completed.")

}

/*
   CanvasItemMaterialImplementer is an interface for CanvasItemMaterial objects.
*/
type CanvasItemMaterialImplementer interface {
	Class
}

/*
   Canvas drawing layer. [CanvasItem] nodes that are direct or indirect children of a [code]CanvasLayer[/code] will be drawn in that layer. The layer is a numeric index that defines the draw order. The default 2D scene renders with index 0, so a [code]CanvasLayer[/code] with index -1 will be drawn below, and one with index 1 will be drawn above. This is very useful for HUDs (in layer 1+ or above), or backgrounds (in layer -1 or below).
*/
type CanvasLayer struct {
	Node
}

func (o *CanvasLayer) baseClass() string {
	return "CanvasLayer"
}

/*
   Undocumented
*/
func (o *CanvasLayer) GetCustomViewport() *Node {
	log.Println("Calling CanvasLayer.GetCustomViewport()")

	returnValue := godotCallObject(o, "get_custom_viewport")
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *CanvasLayer) GetLayer() int64 {
	log.Println("Calling CanvasLayer.GetLayer()")

	returnValue := godotCallInt(o, "get_layer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasLayer) GetOffset() *Vector2 {
	log.Println("Calling CanvasLayer.GetOffset()")

	returnValue := godotCallVector2(o, "get_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasLayer) GetRotation() float64 {
	log.Println("Calling CanvasLayer.GetRotation()")

	returnValue := godotCallFloat(o, "get_rotation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasLayer) GetRotationDegrees() float64 {
	log.Println("Calling CanvasLayer.GetRotationDegrees()")

	returnValue := godotCallFloat(o, "get_rotation_degrees")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasLayer) GetScale() *Vector2 {
	log.Println("Calling CanvasLayer.GetScale()")

	returnValue := godotCallVector2(o, "get_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasLayer) GetTransform() *Transform2D {
	log.Println("Calling CanvasLayer.GetTransform()")

	returnValue := godotCallTransform2D(o, "get_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the [World2D] used by this layer.
*/
func (o *CanvasLayer) GetWorld2D() *World2D {
	log.Println("Calling CanvasLayer.GetWorld2D()")

	returnValue := godotCallObject(o, "get_world_2d")
	log.Println("  Got return value: ", returnValue)

	var ret World2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *CanvasLayer) SetCustomViewport(viewport *Object) {
	log.Println("Calling CanvasLayer.SetCustomViewport()")

	godotCallVoidObject(o, "set_custom_viewport", viewport)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasLayer) SetLayer(layer int64) {
	log.Println("Calling CanvasLayer.SetLayer()")

	godotCallVoidInt(o, "set_layer", layer)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasLayer) SetOffset(offset *Vector2) {
	log.Println("Calling CanvasLayer.SetOffset()")

	godotCallVoidVector2(o, "set_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasLayer) SetRotation(radians float64) {
	log.Println("Calling CanvasLayer.SetRotation()")

	godotCallVoidFloat(o, "set_rotation", radians)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasLayer) SetRotationDegrees(degrees float64) {
	log.Println("Calling CanvasLayer.SetRotationDegrees()")

	godotCallVoidFloat(o, "set_rotation_degrees", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasLayer) SetScale(scale *Vector2) {
	log.Println("Calling CanvasLayer.SetScale()")

	godotCallVoidVector2(o, "set_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CanvasLayer) SetTransform(transform *Transform2D) {
	log.Println("Calling CanvasLayer.SetTransform()")

	godotCallVoidTransform2D(o, "set_transform", transform)
	log.Println("  Function successfully completed.")

}

/*
   CanvasLayerImplementer is an interface for CanvasLayer objects.
*/
type CanvasLayerImplementer interface {
	Class
}

/*
   [code]CanvasModulate[/code] tints the canvas elements using its assigned [code]color[/code].
*/
type CanvasModulate struct {
	Node2D
}

func (o *CanvasModulate) baseClass() string {
	return "CanvasModulate"
}

/*
   Undocumented
*/
func (o *CanvasModulate) GetColor() *Color {
	log.Println("Calling CanvasModulate.GetColor()")

	returnValue := godotCallColor(o, "get_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CanvasModulate) SetColor(color *Color) {
	log.Println("Calling CanvasModulate.SetColor()")

	godotCallVoidColor(o, "set_color", color)
	log.Println("  Function successfully completed.")

}

/*
   CanvasModulateImplementer is an interface for CanvasModulate objects.
*/
type CanvasModulateImplementer interface {
	Class
}

/*
   Class representing a capsule-shaped [PrimitiveMesh].
*/
type CapsuleMesh struct {
	PrimitiveMesh
}

func (o *CapsuleMesh) baseClass() string {
	return "CapsuleMesh"
}

/*
   Undocumented
*/
func (o *CapsuleMesh) GetMidHeight() float64 {
	log.Println("Calling CapsuleMesh.GetMidHeight()")

	returnValue := godotCallFloat(o, "get_mid_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CapsuleMesh) GetRadialSegments() int64 {
	log.Println("Calling CapsuleMesh.GetRadialSegments()")

	returnValue := godotCallInt(o, "get_radial_segments")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CapsuleMesh) GetRadius() float64 {
	log.Println("Calling CapsuleMesh.GetRadius()")

	returnValue := godotCallFloat(o, "get_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CapsuleMesh) GetRings() int64 {
	log.Println("Calling CapsuleMesh.GetRings()")

	returnValue := godotCallInt(o, "get_rings")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CapsuleMesh) SetMidHeight(midHeight float64) {
	log.Println("Calling CapsuleMesh.SetMidHeight()")

	godotCallVoidFloat(o, "set_mid_height", midHeight)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CapsuleMesh) SetRadialSegments(segments int64) {
	log.Println("Calling CapsuleMesh.SetRadialSegments()")

	godotCallVoidInt(o, "set_radial_segments", segments)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CapsuleMesh) SetRadius(radius float64) {
	log.Println("Calling CapsuleMesh.SetRadius()")

	godotCallVoidFloat(o, "set_radius", radius)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CapsuleMesh) SetRings(rings int64) {
	log.Println("Calling CapsuleMesh.SetRings()")

	godotCallVoidInt(o, "set_rings", rings)
	log.Println("  Function successfully completed.")

}

/*
   CapsuleMeshImplementer is an interface for CapsuleMesh objects.
*/
type CapsuleMeshImplementer interface {
	Class
}

/*
   Capsule shape for collisions.
*/
type CapsuleShape struct {
	Shape
}

func (o *CapsuleShape) baseClass() string {
	return "CapsuleShape"
}

/*
   Undocumented
*/
func (o *CapsuleShape) GetHeight() float64 {
	log.Println("Calling CapsuleShape.GetHeight()")

	returnValue := godotCallFloat(o, "get_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CapsuleShape) GetRadius() float64 {
	log.Println("Calling CapsuleShape.GetRadius()")

	returnValue := godotCallFloat(o, "get_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CapsuleShape) SetHeight(height float64) {
	log.Println("Calling CapsuleShape.SetHeight()")

	godotCallVoidFloat(o, "set_height", height)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CapsuleShape) SetRadius(radius float64) {
	log.Println("Calling CapsuleShape.SetRadius()")

	godotCallVoidFloat(o, "set_radius", radius)
	log.Println("  Function successfully completed.")

}

/*
   CapsuleShapeImplementer is an interface for CapsuleShape objects.
*/
type CapsuleShapeImplementer interface {
	Class
}

/*
   Capsule shape for 2D collisions.
*/
type CapsuleShape2D struct {
	Shape2D
}

func (o *CapsuleShape2D) baseClass() string {
	return "CapsuleShape2D"
}

/*
   Undocumented
*/
func (o *CapsuleShape2D) GetHeight() float64 {
	log.Println("Calling CapsuleShape2D.GetHeight()")

	returnValue := godotCallFloat(o, "get_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CapsuleShape2D) GetRadius() float64 {
	log.Println("Calling CapsuleShape2D.GetRadius()")

	returnValue := godotCallFloat(o, "get_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CapsuleShape2D) SetHeight(height float64) {
	log.Println("Calling CapsuleShape2D.SetHeight()")

	godotCallVoidFloat(o, "set_height", height)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CapsuleShape2D) SetRadius(radius float64) {
	log.Println("Calling CapsuleShape2D.SetRadius()")

	godotCallVoidFloat(o, "set_radius", radius)
	log.Println("  Function successfully completed.")

}

/*
   CapsuleShape2DImplementer is an interface for CapsuleShape2D objects.
*/
type CapsuleShape2DImplementer interface {
	Class
}

/*
   CenterContainer Keeps children controls centered. This container keeps all children to their minimum size, in the center.
*/
type CenterContainer struct {
	Container
}

func (o *CenterContainer) baseClass() string {
	return "CenterContainer"
}

/*
   Undocumented
*/
func (o *CenterContainer) IsUsingTopLeft() bool {
	log.Println("Calling CenterContainer.IsUsingTopLeft()")

	returnValue := godotCallBool(o, "is_using_top_left")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CenterContainer) SetUseTopLeft(enable bool) {
	log.Println("Calling CenterContainer.SetUseTopLeft()")

	godotCallVoidBool(o, "set_use_top_left", enable)
	log.Println("  Function successfully completed.")

}

/*
   CenterContainerImplementer is an interface for CenterContainer objects.
*/
type CenterContainerImplementer interface {
	Class
}

/*
   A checkbox allows the user to make a binary choice (choosing only one of two possible options), for example Answer 'yes' or 'no'.
*/
type CheckBox struct {
	Button
}

func (o *CheckBox) baseClass() string {
	return "CheckBox"
}

/*
   CheckBoxImplementer is an interface for CheckBox objects.
*/
type CheckBoxImplementer interface {
	Class
}

/*
   CheckButton is a toggle button displayed as a check field.
*/
type CheckButton struct {
	Button
}

func (o *CheckButton) baseClass() string {
	return "CheckButton"
}

/*
   CheckButtonImplementer is an interface for CheckButton objects.
*/
type CheckButtonImplementer interface {
	Class
}

/*
   Circular shape for 2D collisions. This shape is useful for modeling balls or small characters and its collision detection with everything else is very fast.
*/
type CircleShape2D struct {
	Shape2D
}

func (o *CircleShape2D) baseClass() string {
	return "CircleShape2D"
}

/*
   Undocumented
*/
func (o *CircleShape2D) GetRadius() float64 {
	log.Println("Calling CircleShape2D.GetRadius()")

	returnValue := godotCallFloat(o, "get_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CircleShape2D) SetRadius(radius float64) {
	log.Println("Calling CircleShape2D.SetRadius()")

	godotCallVoidFloat(o, "set_radius", radius)
	log.Println("  Function successfully completed.")

}

/*
   CircleShape2DImplementer is an interface for CircleShape2D objects.
*/
type CircleShape2DImplementer interface {
	Class
}

/*
   CollisionObject is the base class for physics objects. It can hold any number of collision [Shape]s. Each shape must be assigned to a [i]shape owner[/i]. The CollisionObject can have any number of shape owners. Shape owners are not nodes and do not appear in the editor, but are accessible through code using the [code]shape_owner_*[/code] methods.
*/
type CollisionObject struct {
	Spatial
}

func (o *CollisionObject) baseClass() string {
	return "CollisionObject"
}

/*
   Accepts unhandled [InputEvent]s. [code]click_position[/code] is the clicked location in world space and [code]click_normal[/code] is the normal vector extending from the clicked surface of the [Shape] at [code]shape_idx[/code]. Connect to the [code]input_event[/code] signal to easily pick up these events.
*/
func (o *CollisionObject) X_InputEvent(camera *Object, event *InputEvent, clickPosition *Vector3, clickNormal *Vector3, shapeIdx int64) {
	log.Println("Calling CollisionObject.X_InputEvent()")

	godotCallVoidObjectObjectVector3Vector3Int(o, "_input_event", camera, &event.Object, clickPosition, clickNormal, shapeIdx)
	log.Println("  Function successfully completed.")

}

/*
   Creates a new shape owner for the given object. Returns [code]owner_id[/code] of the new owner for future reference.
*/
func (o *CollisionObject) CreateShapeOwner(owner *Object) int64 {
	log.Println("Calling CollisionObject.CreateShapeOwner()")

	returnValue := godotCallIntObject(o, "create_shape_owner", owner)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionObject) GetCaptureInputOnDrag() bool {
	log.Println("Calling CollisionObject.GetCaptureInputOnDrag()")

	returnValue := godotCallBool(o, "get_capture_input_on_drag")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the object's [RID].
*/
func (o *CollisionObject) GetRid() *RID {
	log.Println("Calling CollisionObject.GetRid()")

	returnValue := godotCallRid(o, "get_rid")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an [Array] of [code]owner_id[/code] identifiers. You can use these ids in other methods that take [code]owner_id[/code] as an argument.
*/
func (o *CollisionObject) GetShapeOwners() *Array {
	log.Println("Calling CollisionObject.GetShapeOwners()")

	returnValue := godotCallArray(o, "get_shape_owners")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionObject) IsRayPickable() bool {
	log.Println("Calling CollisionObject.IsRayPickable()")

	returnValue := godotCallBool(o, "is_ray_pickable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the shape owner and its shapes are disabled.
*/
func (o *CollisionObject) IsShapeOwnerDisabled(ownerId int64) bool {
	log.Println("Calling CollisionObject.IsShapeOwnerDisabled()")

	returnValue := godotCallBoolInt(o, "is_shape_owner_disabled", ownerId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes the given shape owner.
*/
func (o *CollisionObject) RemoveShapeOwner(ownerId int64) {
	log.Println("Calling CollisionObject.RemoveShapeOwner()")

	godotCallVoidInt(o, "remove_shape_owner", ownerId)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionObject) SetCaptureInputOnDrag(enable bool) {
	log.Println("Calling CollisionObject.SetCaptureInputOnDrag()")

	godotCallVoidBool(o, "set_capture_input_on_drag", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionObject) SetRayPickable(rayPickable bool) {
	log.Println("Calling CollisionObject.SetRayPickable()")

	godotCallVoidBool(o, "set_ray_pickable", rayPickable)
	log.Println("  Function successfully completed.")

}

/*
   Returns the [code]owner_id[/code] of the given shape.
*/
func (o *CollisionObject) ShapeFindOwner(shapeIndex int64) int64 {
	log.Println("Calling CollisionObject.ShapeFindOwner()")

	returnValue := godotCallIntInt(o, "shape_find_owner", shapeIndex)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Adds a [Shape] to the shape owner.
*/
func (o *CollisionObject) ShapeOwnerAddShape(ownerId int64, shape *Shape) {
	log.Println("Calling CollisionObject.ShapeOwnerAddShape()")

	godotCallVoidIntObject(o, "shape_owner_add_shape", ownerId, &shape.Object)
	log.Println("  Function successfully completed.")

}

/*
   Removes all shapes from the shape owner.
*/
func (o *CollisionObject) ShapeOwnerClearShapes(ownerId int64) {
	log.Println("Calling CollisionObject.ShapeOwnerClearShapes()")

	godotCallVoidInt(o, "shape_owner_clear_shapes", ownerId)
	log.Println("  Function successfully completed.")

}

/*
   Returns the parent object of the given shape owner.
*/
func (o *CollisionObject) ShapeOwnerGetOwner(ownerId int64) *Object {
	log.Println("Calling CollisionObject.ShapeOwnerGetOwner()")

	returnValue := godotCallObjectInt(o, "shape_owner_get_owner", ownerId)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the [Shape] with the given id from the given shape owner.
*/
func (o *CollisionObject) ShapeOwnerGetShape(ownerId int64, shapeId int64) *Shape {
	log.Println("Calling CollisionObject.ShapeOwnerGetShape()")

	returnValue := godotCallObjectIntInt(o, "shape_owner_get_shape", ownerId, shapeId)
	log.Println("  Got return value: ", returnValue)

	var ret Shape
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of shapes the given shape owner contains.
*/
func (o *CollisionObject) ShapeOwnerGetShapeCount(ownerId int64) int64 {
	log.Println("Calling CollisionObject.ShapeOwnerGetShapeCount()")

	returnValue := godotCallIntInt(o, "shape_owner_get_shape_count", ownerId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the child index of the [Shape] with the given id from the given shape owner.
*/
func (o *CollisionObject) ShapeOwnerGetShapeIndex(ownerId int64, shapeId int64) int64 {
	log.Println("Calling CollisionObject.ShapeOwnerGetShapeIndex()")

	returnValue := godotCallIntIntInt(o, "shape_owner_get_shape_index", ownerId, shapeId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the shape owner's [Transform].
*/
func (o *CollisionObject) ShapeOwnerGetTransform(ownerId int64) *Transform {
	log.Println("Calling CollisionObject.ShapeOwnerGetTransform()")

	returnValue := godotCallTransformInt(o, "shape_owner_get_transform", ownerId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a shape from the given shape owner.
*/
func (o *CollisionObject) ShapeOwnerRemoveShape(ownerId int64, shapeId int64) {
	log.Println("Calling CollisionObject.ShapeOwnerRemoveShape()")

	godotCallVoidIntInt(o, "shape_owner_remove_shape", ownerId, shapeId)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] disables the given shape owner.
*/
func (o *CollisionObject) ShapeOwnerSetDisabled(ownerId int64, disabled bool) {
	log.Println("Calling CollisionObject.ShapeOwnerSetDisabled()")

	godotCallVoidIntBool(o, "shape_owner_set_disabled", ownerId, disabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets the [Transform] of the given shape owner.
*/
func (o *CollisionObject) ShapeOwnerSetTransform(ownerId int64, transform *Transform) {
	log.Println("Calling CollisionObject.ShapeOwnerSetTransform()")

	godotCallVoidIntTransform(o, "shape_owner_set_transform", ownerId, transform)
	log.Println("  Function successfully completed.")

}

/*
   CollisionObjectImplementer is an interface for CollisionObject objects.
*/
type CollisionObjectImplementer interface {
	Class
}

/*
   CollisionObject2D is the base class for 2D physics objects. It can hold any number of 2D collision [Shape2D]s. Each shape must be assigned to a [i]shape owner[/i]. The CollisionObject2D can have any number of shape owners. Shape owners are not nodes and do not appear in the editor, but are accessible through code using the [code]shape_owner_*[/code] methods.
*/
type CollisionObject2D struct {
	Node2D
}

func (o *CollisionObject2D) baseClass() string {
	return "CollisionObject2D"
}

/*
   Accepts unhandled [InputEvent]s. [code]shape_idx[/code] is the child index of the clicked [Shape2D]. Connect to the [code]input_event[/code] signal to easily pick up these events.
*/
func (o *CollisionObject2D) X_InputEvent(viewport *Object, event *InputEvent, shapeIdx int64) {
	log.Println("Calling CollisionObject2D.X_InputEvent()")

	godotCallVoidObjectObjectInt(o, "_input_event", viewport, &event.Object, shapeIdx)
	log.Println("  Function successfully completed.")

}

/*
   Creates a new shape owner for the given object. Returns [code]owner_id[/code] of the new owner for future reference.
*/
func (o *CollisionObject2D) CreateShapeOwner(owner *Object) int64 {
	log.Println("Calling CollisionObject2D.CreateShapeOwner()")

	returnValue := godotCallIntObject(o, "create_shape_owner", owner)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the object's [RID].
*/
func (o *CollisionObject2D) GetRid() *RID {
	log.Println("Calling CollisionObject2D.GetRid()")

	returnValue := godotCallRid(o, "get_rid")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an [Array] of [code]owner_id[/code] identifiers. You can use these ids in other methods that take [code]owner_id[/code] as an argument.
*/
func (o *CollisionObject2D) GetShapeOwners() *Array {
	log.Println("Calling CollisionObject2D.GetShapeOwners()")

	returnValue := godotCallArray(o, "get_shape_owners")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionObject2D) IsPickable() bool {
	log.Println("Calling CollisionObject2D.IsPickable()")

	returnValue := godotCallBool(o, "is_pickable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the shape owner and its shapes are disabled.
*/
func (o *CollisionObject2D) IsShapeOwnerDisabled(ownerId int64) bool {
	log.Println("Calling CollisionObject2D.IsShapeOwnerDisabled()")

	returnValue := godotCallBoolInt(o, "is_shape_owner_disabled", ownerId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if collisions for the shape owner originating from this [code]CollisionObject2D[/code] will not be reported to collided with [code]CollisionObject2D[/code]s.
*/
func (o *CollisionObject2D) IsShapeOwnerOneWayCollisionEnabled(ownerId int64) bool {
	log.Println("Calling CollisionObject2D.IsShapeOwnerOneWayCollisionEnabled()")

	returnValue := godotCallBoolInt(o, "is_shape_owner_one_way_collision_enabled", ownerId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes the given shape owner.
*/
func (o *CollisionObject2D) RemoveShapeOwner(ownerId int64) {
	log.Println("Calling CollisionObject2D.RemoveShapeOwner()")

	godotCallVoidInt(o, "remove_shape_owner", ownerId)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionObject2D) SetPickable(enabled bool) {
	log.Println("Calling CollisionObject2D.SetPickable()")

	godotCallVoidBool(o, "set_pickable", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Returns the [code]owner_id[/code] of the given shape.
*/
func (o *CollisionObject2D) ShapeFindOwner(shapeIndex int64) int64 {
	log.Println("Calling CollisionObject2D.ShapeFindOwner()")

	returnValue := godotCallIntInt(o, "shape_find_owner", shapeIndex)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Adds a [Shape2D] to the shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerAddShape(ownerId int64, shape *Shape2D) {
	log.Println("Calling CollisionObject2D.ShapeOwnerAddShape()")

	godotCallVoidIntObject(o, "shape_owner_add_shape", ownerId, &shape.Object)
	log.Println("  Function successfully completed.")

}

/*
   Removes all shapes from the shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerClearShapes(ownerId int64) {
	log.Println("Calling CollisionObject2D.ShapeOwnerClearShapes()")

	godotCallVoidInt(o, "shape_owner_clear_shapes", ownerId)
	log.Println("  Function successfully completed.")

}

/*
   Returns the parent object of the given shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerGetOwner(ownerId int64) *Object {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetOwner()")

	returnValue := godotCallObjectInt(o, "shape_owner_get_owner", ownerId)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the [Shape2D] with the given id from the given shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerGetShape(ownerId int64, shapeId int64) *Shape2D {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetShape()")

	returnValue := godotCallObjectIntInt(o, "shape_owner_get_shape", ownerId, shapeId)
	log.Println("  Got return value: ", returnValue)

	var ret Shape2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of shapes the given shape owner contains.
*/
func (o *CollisionObject2D) ShapeOwnerGetShapeCount(ownerId int64) int64 {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetShapeCount()")

	returnValue := godotCallIntInt(o, "shape_owner_get_shape_count", ownerId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the child index of the [Shape2D] with the given id from the given shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerGetShapeIndex(ownerId int64, shapeId int64) int64 {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetShapeIndex()")

	returnValue := godotCallIntIntInt(o, "shape_owner_get_shape_index", ownerId, shapeId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the shape owner's [Transform2D].
*/
func (o *CollisionObject2D) ShapeOwnerGetTransform(ownerId int64) *Transform2D {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetTransform()")

	returnValue := godotCallTransform2DInt(o, "shape_owner_get_transform", ownerId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a shape from the given shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerRemoveShape(ownerId int64, shapeId int64) {
	log.Println("Calling CollisionObject2D.ShapeOwnerRemoveShape()")

	godotCallVoidIntInt(o, "shape_owner_remove_shape", ownerId, shapeId)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] disables the given shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerSetDisabled(ownerId int64, disabled bool) {
	log.Println("Calling CollisionObject2D.ShapeOwnerSetDisabled()")

	godotCallVoidIntBool(o, "shape_owner_set_disabled", ownerId, disabled)
	log.Println("  Function successfully completed.")

}

/*
   If [code]enable[/code] is [code]true[/code], collisions for the shape owner originating from this [code]CollisionObject2D[/code] will not be reported to collided with [code]CollisionObject2D[/code]s.
*/
func (o *CollisionObject2D) ShapeOwnerSetOneWayCollision(ownerId int64, enable bool) {
	log.Println("Calling CollisionObject2D.ShapeOwnerSetOneWayCollision()")

	godotCallVoidIntBool(o, "shape_owner_set_one_way_collision", ownerId, enable)
	log.Println("  Function successfully completed.")

}

/*
   Sets the [Transform2D] of the given shape owner.
*/
func (o *CollisionObject2D) ShapeOwnerSetTransform(ownerId int64, transform *Transform2D) {
	log.Println("Calling CollisionObject2D.ShapeOwnerSetTransform()")

	godotCallVoidIntTransform2D(o, "shape_owner_set_transform", ownerId, transform)
	log.Println("  Function successfully completed.")

}

/*
   CollisionObject2DImplementer is an interface for CollisionObject2D objects.
*/
type CollisionObject2DImplementer interface {
	Class
}

/*
   Allows editing a collision polygon's vertices on a selected plane. Can also set a depth perpendicular to that plane. This class is only available in the editor. It will not appear in the scene tree at runtime. Creates a [Shape] for gameplay. Properties modified during gameplay will have no effect.
*/
type CollisionPolygon struct {
	Spatial
}

func (o *CollisionPolygon) baseClass() string {
	return "CollisionPolygon"
}

/*
   Undocumented
*/
func (o *CollisionPolygon) GetDepth() float64 {
	log.Println("Calling CollisionPolygon.GetDepth()")

	returnValue := godotCallFloat(o, "get_depth")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionPolygon) GetPolygon() *PoolVector2Array {
	log.Println("Calling CollisionPolygon.GetPolygon()")

	returnValue := godotCallPoolVector2Array(o, "get_polygon")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionPolygon) IsDisabled() bool {
	log.Println("Calling CollisionPolygon.IsDisabled()")

	returnValue := godotCallBool(o, "is_disabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionPolygon) SetDepth(depth float64) {
	log.Println("Calling CollisionPolygon.SetDepth()")

	godotCallVoidFloat(o, "set_depth", depth)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionPolygon) SetDisabled(disabled bool) {
	log.Println("Calling CollisionPolygon.SetDisabled()")

	godotCallVoidBool(o, "set_disabled", disabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionPolygon) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling CollisionPolygon.SetPolygon()")

	godotCallVoidPoolVector2Array(o, "set_polygon", polygon)
	log.Println("  Function successfully completed.")

}

/*
   CollisionPolygonImplementer is an interface for CollisionPolygon objects.
*/
type CollisionPolygonImplementer interface {
	Class
}

/*
   Provides a 2D collision polygon to a [CollisionObject2D] parent. Polygon can be drawn in the editor or specified by a list of vertices.
*/
type CollisionPolygon2D struct {
	Node2D
}

func (o *CollisionPolygon2D) baseClass() string {
	return "CollisionPolygon2D"
}

/*
   Undocumented
*/
func (o *CollisionPolygon2D) GetBuildMode() int64 {
	log.Println("Calling CollisionPolygon2D.GetBuildMode()")

	returnValue := godotCallInt(o, "get_build_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionPolygon2D) GetPolygon() *PoolVector2Array {
	log.Println("Calling CollisionPolygon2D.GetPolygon()")

	returnValue := godotCallPoolVector2Array(o, "get_polygon")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionPolygon2D) IsDisabled() bool {
	log.Println("Calling CollisionPolygon2D.IsDisabled()")

	returnValue := godotCallBool(o, "is_disabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionPolygon2D) IsOneWayCollisionEnabled() bool {
	log.Println("Calling CollisionPolygon2D.IsOneWayCollisionEnabled()")

	returnValue := godotCallBool(o, "is_one_way_collision_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionPolygon2D) SetBuildMode(buildMode int64) {
	log.Println("Calling CollisionPolygon2D.SetBuildMode()")

	godotCallVoidInt(o, "set_build_mode", buildMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionPolygon2D) SetDisabled(disabled bool) {
	log.Println("Calling CollisionPolygon2D.SetDisabled()")

	godotCallVoidBool(o, "set_disabled", disabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionPolygon2D) SetOneWayCollision(enabled bool) {
	log.Println("Calling CollisionPolygon2D.SetOneWayCollision()")

	godotCallVoidBool(o, "set_one_way_collision", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionPolygon2D) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling CollisionPolygon2D.SetPolygon()")

	godotCallVoidPoolVector2Array(o, "set_polygon", polygon)
	log.Println("  Function successfully completed.")

}

/*
   CollisionPolygon2DImplementer is an interface for CollisionPolygon2D objects.
*/
type CollisionPolygon2DImplementer interface {
	Class
}

/*
   Editor facility for creating and editing collision shapes in 3D space. You can use this node to represent all sorts of collision shapes, for example, add this to an [Area] to give it a detection shape, or add it to a [PhysicsBody] to give create solid object. [b]IMPORTANT[/b]: this is an Editor-only helper to create shapes, use [method get_shape] to get the actual shape.
*/
type CollisionShape struct {
	Spatial
}

func (o *CollisionShape) baseClass() string {
	return "CollisionShape"
}

/*
   Undocumented
*/
func (o *CollisionShape) GetShape() *Shape {
	log.Println("Calling CollisionShape.GetShape()")

	returnValue := godotCallObject(o, "get_shape")
	log.Println("  Got return value: ", returnValue)

	var ret Shape
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *CollisionShape) IsDisabled() bool {
	log.Println("Calling CollisionShape.IsDisabled()")

	returnValue := godotCallBool(o, "is_disabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the collision shape's shape to the addition of all its convexed [MeshInstance] siblings geometry.
*/
func (o *CollisionShape) MakeConvexFromBrothers() {
	log.Println("Calling CollisionShape.MakeConvexFromBrothers()")

	godotCallVoid(o, "make_convex_from_brothers")
	log.Println("  Function successfully completed.")

}

/*
   If this method exists within a script it will be called whenever the shape resource has been modified.
*/
func (o *CollisionShape) ResourceChanged(resource *Resource) {
	log.Println("Calling CollisionShape.ResourceChanged()")

	godotCallVoidObject(o, "resource_changed", &resource.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionShape) SetDisabled(enable bool) {
	log.Println("Calling CollisionShape.SetDisabled()")

	godotCallVoidBool(o, "set_disabled", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionShape) SetShape(shape *Shape) {
	log.Println("Calling CollisionShape.SetShape()")

	godotCallVoidObject(o, "set_shape", &shape.Object)
	log.Println("  Function successfully completed.")

}

/*
   CollisionShapeImplementer is an interface for CollisionShape objects.
*/
type CollisionShapeImplementer interface {
	Class
}

/*
   Editor facility for creating and editing collision shapes in 2D space. You can use this node to represent all sorts of collision shapes, for example, add this to an [Area2D] to give it a detection shape, or add it to a [PhysicsBody2D] to give create solid object. [b]IMPORTANT[/b]: this is an Editor-only helper to create shapes, use [method get_shape] to get the actual shape.
*/
type CollisionShape2D struct {
	Node2D
}

func (o *CollisionShape2D) baseClass() string {
	return "CollisionShape2D"
}

/*
   Undocumented
*/
func (o *CollisionShape2D) X_ShapeChanged() {
	log.Println("Calling CollisionShape2D.X_ShapeChanged()")

	godotCallVoid(o, "_shape_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionShape2D) GetShape() *Shape2D {
	log.Println("Calling CollisionShape2D.GetShape()")

	returnValue := godotCallObject(o, "get_shape")
	log.Println("  Got return value: ", returnValue)

	var ret Shape2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *CollisionShape2D) IsDisabled() bool {
	log.Println("Calling CollisionShape2D.IsDisabled()")

	returnValue := godotCallBool(o, "is_disabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionShape2D) IsOneWayCollisionEnabled() bool {
	log.Println("Calling CollisionShape2D.IsOneWayCollisionEnabled()")

	returnValue := godotCallBool(o, "is_one_way_collision_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CollisionShape2D) SetDisabled(disabled bool) {
	log.Println("Calling CollisionShape2D.SetDisabled()")

	godotCallVoidBool(o, "set_disabled", disabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionShape2D) SetOneWayCollision(enabled bool) {
	log.Println("Calling CollisionShape2D.SetOneWayCollision()")

	godotCallVoidBool(o, "set_one_way_collision", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CollisionShape2D) SetShape(shape *Shape2D) {
	log.Println("Calling CollisionShape2D.SetShape()")

	godotCallVoidObject(o, "set_shape", &shape.Object)
	log.Println("  Function successfully completed.")

}

/*
   CollisionShape2DImplementer is an interface for CollisionShape2D objects.
*/
type CollisionShape2DImplementer interface {
	Class
}

/*
   This is a simple color picker [Control]. It's useful for selecting a color from an RGB/RGBA colorspace.
*/
type ColorPicker struct {
	BoxContainer
}

func (o *ColorPicker) baseClass() string {
	return "ColorPicker"
}

/*
   Undocumented
*/
func (o *ColorPicker) X_AddPresetPressed() {
	log.Println("Calling ColorPicker.X_AddPresetPressed()")

	godotCallVoid(o, "_add_preset_pressed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_HsvDraw(arg0 int64, arg1 *Object) {
	log.Println("Calling ColorPicker.X_HsvDraw()")

	godotCallVoidIntObject(o, "_hsv_draw", arg0, arg1)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_HtmlEntered(arg0 string) {
	log.Println("Calling ColorPicker.X_HtmlEntered()")

	godotCallVoidString(o, "_html_entered", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_PresetInput(arg0 *InputEvent) {
	log.Println("Calling ColorPicker.X_PresetInput()")

	godotCallVoidObject(o, "_preset_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_SampleDraw() {
	log.Println("Calling ColorPicker.X_SampleDraw()")

	godotCallVoid(o, "_sample_draw")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_ScreenInput(arg0 *InputEvent) {
	log.Println("Calling ColorPicker.X_ScreenInput()")

	godotCallVoidObject(o, "_screen_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_ScreenPickPressed() {
	log.Println("Calling ColorPicker.X_ScreenPickPressed()")

	godotCallVoid(o, "_screen_pick_pressed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_TextTypeToggled() {
	log.Println("Calling ColorPicker.X_TextTypeToggled()")

	godotCallVoid(o, "_text_type_toggled")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_UpdatePresets() {
	log.Println("Calling ColorPicker.X_UpdatePresets()")

	godotCallVoid(o, "_update_presets")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_UvInput(arg0 *InputEvent) {
	log.Println("Calling ColorPicker.X_UvInput()")

	godotCallVoidObject(o, "_uv_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_ValueChanged(arg0 float64) {
	log.Println("Calling ColorPicker.X_ValueChanged()")

	godotCallVoidFloat(o, "_value_changed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) X_WInput(arg0 *InputEvent) {
	log.Println("Calling ColorPicker.X_WInput()")

	godotCallVoidObject(o, "_w_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Adds the current selected to color to a list of colors (presets), the presets will be displayed in the color picker and the user will be able to select them, notice that the presets list is only for this color picker.
*/
func (o *ColorPicker) AddPreset(color *Color) {
	log.Println("Calling ColorPicker.AddPreset()")

	godotCallVoidColor(o, "add_preset", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) GetPickColor() *Color {
	log.Println("Calling ColorPicker.GetPickColor()")

	returnValue := godotCallColor(o, "get_pick_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ColorPicker) IsEditingAlpha() bool {
	log.Println("Calling ColorPicker.IsEditingAlpha()")

	returnValue := godotCallBool(o, "is_editing_alpha")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ColorPicker) IsRawMode() bool {
	log.Println("Calling ColorPicker.IsRawMode()")

	returnValue := godotCallBool(o, "is_raw_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ColorPicker) SetEditAlpha(show bool) {
	log.Println("Calling ColorPicker.SetEditAlpha()")

	godotCallVoidBool(o, "set_edit_alpha", show)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) SetPickColor(color *Color) {
	log.Println("Calling ColorPicker.SetPickColor()")

	godotCallVoidColor(o, "set_pick_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPicker) SetRawMode(mode bool) {
	log.Println("Calling ColorPicker.SetRawMode()")

	godotCallVoidBool(o, "set_raw_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   ColorPickerImplementer is an interface for ColorPicker objects.
*/
type ColorPickerImplementer interface {
	Class
}

/*
   Encapsulates a [ColorPicker] making it accesible by pressing a button, pressing the button will toggle the [ColorPicker] visibility
*/
type ColorPickerButton struct {
	Button
}

func (o *ColorPickerButton) baseClass() string {
	return "ColorPickerButton"
}

/*
   Undocumented
*/
func (o *ColorPickerButton) X_ColorChanged(arg0 *Color) {
	log.Println("Calling ColorPickerButton.X_ColorChanged()")

	godotCallVoidColor(o, "_color_changed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPickerButton) GetPickColor() *Color {
	log.Println("Calling ColorPickerButton.GetPickColor()")

	returnValue := godotCallColor(o, "get_pick_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [code]ColorPicker[/code] that this [code]ColorPickerButton[/code] toggles.
*/
func (o *ColorPickerButton) GetPicker() *ColorPicker {
	log.Println("Calling ColorPickerButton.GetPicker()")

	returnValue := godotCallObject(o, "get_picker")
	log.Println("  Got return value: ", returnValue)

	var ret ColorPicker
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the control's [PopupPanel] which allows you to connect to Popup Signals. This allows you to handle events when the ColorPicker is shown or hidden.
*/
func (o *ColorPickerButton) GetPopup() *PopupPanel {
	log.Println("Calling ColorPickerButton.GetPopup()")

	returnValue := godotCallObject(o, "get_popup")
	log.Println("  Got return value: ", returnValue)

	var ret PopupPanel
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *ColorPickerButton) IsEditingAlpha() bool {
	log.Println("Calling ColorPickerButton.IsEditingAlpha()")

	returnValue := godotCallBool(o, "is_editing_alpha")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ColorPickerButton) SetEditAlpha(show bool) {
	log.Println("Calling ColorPickerButton.SetEditAlpha()")

	godotCallVoidBool(o, "set_edit_alpha", show)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ColorPickerButton) SetPickColor(color *Color) {
	log.Println("Calling ColorPickerButton.SetPickColor()")

	godotCallVoidColor(o, "set_pick_color", color)
	log.Println("  Function successfully completed.")

}

/*
   ColorPickerButtonImplementer is an interface for ColorPickerButton objects.
*/
type ColorPickerButtonImplementer interface {
	Class
}

/*
   An object that is represented on the canvas as a rect with color. [Color] is used to set or get color info for the rect.
*/
type ColorRect struct {
	Control
}

func (o *ColorRect) baseClass() string {
	return "ColorRect"
}

/*
   Undocumented
*/
func (o *ColorRect) GetFrameColor() *Color {
	log.Println("Calling ColorRect.GetFrameColor()")

	returnValue := godotCallColor(o, "get_frame_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ColorRect) SetFrameColor(color *Color) {
	log.Println("Calling ColorRect.SetFrameColor()")

	godotCallVoidColor(o, "set_frame_color", color)
	log.Println("  Function successfully completed.")

}

/*
   ColorRectImplementer is an interface for ColorRect objects.
*/
type ColorRectImplementer interface {
	Class
}

/*
   Concave polygon shape resource, which can be set into a [PhysicsBody] or area. This shape is created by feeding a list of triangles.
*/
type ConcavePolygonShape struct {
	Shape
}

func (o *ConcavePolygonShape) baseClass() string {
	return "ConcavePolygonShape"
}

/*
   Return the faces (an array of triangles).
*/
func (o *ConcavePolygonShape) GetFaces() *PoolVector3Array {
	log.Println("Calling ConcavePolygonShape.GetFaces()")

	returnValue := godotCallPoolVector3Array(o, "get_faces")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Set the faces (an array of triangles).
*/
func (o *ConcavePolygonShape) SetFaces(faces *PoolVector3Array) {
	log.Println("Calling ConcavePolygonShape.SetFaces()")

	godotCallVoidPoolVector3Array(o, "set_faces", faces)
	log.Println("  Function successfully completed.")

}

/*
   ConcavePolygonShapeImplementer is an interface for ConcavePolygonShape objects.
*/
type ConcavePolygonShapeImplementer interface {
	Class
}

/*
   Concave polygon 2D shape resource for physics. It is made out of segments and is very optimal for complex polygonal concave collisions. It is really not advised to use for [RigidBody2D] nodes. A CollisionPolygon2D in convex decomposition mode (solids) or several convex objects are advised for that instead. Otherwise, a concave polygon 2D shape is better for static collisions. The main difference between a [ConvexPolygonShape2D] and a [code]ConcavePolygonShape2D[/code] is that a concave polygon assumes it is concave and uses a more complex method of collision detection, and a convex one forces itself to be convex in order to speed up collision detection.
*/
type ConcavePolygonShape2D struct {
	Shape2D
}

func (o *ConcavePolygonShape2D) baseClass() string {
	return "ConcavePolygonShape2D"
}

/*
   Undocumented
*/
func (o *ConcavePolygonShape2D) GetSegments() *PoolVector2Array {
	log.Println("Calling ConcavePolygonShape2D.GetSegments()")

	returnValue := godotCallPoolVector2Array(o, "get_segments")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ConcavePolygonShape2D) SetSegments(segments *PoolVector2Array) {
	log.Println("Calling ConcavePolygonShape2D.SetSegments()")

	godotCallVoidPoolVector2Array(o, "set_segments", segments)
	log.Println("  Function successfully completed.")

}

/*
   ConcavePolygonShape2DImplementer is an interface for ConcavePolygonShape2D objects.
*/
type ConcavePolygonShape2DImplementer interface {
	Class
}

/*
   The joint can rotate the bodies across an axis defined by the local x-axes of the [Joint]. The twist axis is initiated as the x-axis of the [Joint]. Once the Bodies swing, the twist axis is calculated as the middle of the x-axes of the Joint in the local space of the two Bodies.
*/
type ConeTwistJoint struct {
	Joint
}

func (o *ConeTwistJoint) baseClass() string {
	return "ConeTwistJoint"
}

/*
   Undocumented
*/
func (o *ConeTwistJoint) X_GetSwingSpan() float64 {
	log.Println("Calling ConeTwistJoint.X_GetSwingSpan()")

	returnValue := godotCallFloat(o, "_get_swing_span")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ConeTwistJoint) X_GetTwistSpan() float64 {
	log.Println("Calling ConeTwistJoint.X_GetTwistSpan()")

	returnValue := godotCallFloat(o, "_get_twist_span")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ConeTwistJoint) X_SetSwingSpan(swingSpan float64) {
	log.Println("Calling ConeTwistJoint.X_SetSwingSpan()")

	godotCallVoidFloat(o, "_set_swing_span", swingSpan)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ConeTwistJoint) X_SetTwistSpan(twistSpan float64) {
	log.Println("Calling ConeTwistJoint.X_SetTwistSpan()")

	godotCallVoidFloat(o, "_set_twist_span", twistSpan)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ConeTwistJoint) GetParam(param int64) float64 {
	log.Println("Calling ConeTwistJoint.GetParam()")

	returnValue := godotCallFloatInt(o, "get_param", param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ConeTwistJoint) SetParam(param int64, value float64) {
	log.Println("Calling ConeTwistJoint.SetParam()")

	godotCallVoidIntFloat(o, "set_param", param, value)
	log.Println("  Function successfully completed.")

}

/*
   ConeTwistJointImplementer is an interface for ConeTwistJoint objects.
*/
type ConeTwistJointImplementer interface {
	Class
}

/*
   This helper class can be used to store [Variant] values on the filesystem using INI-style formatting. The stored values are identified by a section and a key: [codeblock] [section] some_key=42 string_example="Hello World!" a_vector=Vector3( 1, 0, 2 ) [/codeblock] The stored data can be saved to or parsed from a file, though ConfigFile objects can also be used directly without accessing the filesystem. The following example shows how to parse an INI-style file from the system, read its contents and store new values in it: [codeblock] var config = ConfigFile.new() var err = config.load("user://settings.cfg") if err == OK: # if not, something went wrong with the file loading # Look for the display/width pair, and default to 1024 if missing var screen_width = get_value("display", "width", 1024) # Store a variable if and only if it hasn't been defined yet if not config.has_section_key("audio", "mute"): config.set_value("audio", "mute", false) # Save the changes by overwriting the previous file config.save("user://settings.cfg") [/codeblock]
*/
type ConfigFile struct {
	Reference
}

func (o *ConfigFile) baseClass() string {
	return "ConfigFile"
}

/*
   Deletes the specified section along with all the key-value pairs inside.
*/
func (o *ConfigFile) EraseSection(section string) {
	log.Println("Calling ConfigFile.EraseSection()")

	godotCallVoidString(o, "erase_section", section)
	log.Println("  Function successfully completed.")

}

/*
   Returns an array of all defined key identifiers in the specified section.
*/
func (o *ConfigFile) GetSectionKeys(section string) *PoolStringArray {
	log.Println("Calling ConfigFile.GetSectionKeys()")

	returnValue := godotCallPoolStringArrayString(o, "get_section_keys", section)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an array of all defined section identifiers.
*/
func (o *ConfigFile) GetSections() *PoolStringArray {
	log.Println("Calling ConfigFile.GetSections()")

	returnValue := godotCallPoolStringArray(o, "get_sections")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the current value for the specified section and key. If the section and/or the key do not exist, the method returns the value of the optional [code]default[/code] argument, or [code]null[/code] if it is omitted.
*/
func (o *ConfigFile) GetValue(section string, key string, aDefault *Variant) *Variant {
	log.Println("Calling ConfigFile.GetValue()")

	returnValue := godotCallVariantStringStringVariant(o, "get_value", section, key, aDefault)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the specified section exists.
*/
func (o *ConfigFile) HasSection(section string) bool {
	log.Println("Calling ConfigFile.HasSection()")

	returnValue := godotCallBoolString(o, "has_section", section)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the specified section-key pair exists.
*/
func (o *ConfigFile) HasSectionKey(section string, key string) bool {
	log.Println("Calling ConfigFile.HasSectionKey()")

	returnValue := godotCallBoolStringString(o, "has_section_key", section, key)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Loads the config file specified as a parameter. The file's contents are parsed and loaded in the ConfigFile object which the method was called on. Returns one of the [code]OK[/code], [code]FAILED[/code] or [code]ERR_*[/code] constants listed in [@GlobalScope]. If the load was successful, the return value is [code]OK[/code].
*/
func (o *ConfigFile) Load(path string) int64 {
	log.Println("Calling ConfigFile.Load()")

	returnValue := godotCallIntString(o, "load", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Saves the contents of the ConfigFile object to the file specified as a parameter. The output file uses an INI-style structure. Returns one of the [code]OK[/code], [code]FAILED[/code] or [code]ERR_*[/code] constants listed in [@GlobalScope]. If the load was successful, the return value is [code]OK[/code].
*/
func (o *ConfigFile) Save(path string) int64 {
	log.Println("Calling ConfigFile.Save()")

	returnValue := godotCallIntString(o, "save", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Assigns a value to the specified key of the the specified section. If the section and/or the key do not exist, they are created. Passing a [code]null[/code] value deletes the specified key if it exists, and deletes the section if it ends up empty once the key has been removed.
*/
func (o *ConfigFile) SetValue(section string, key string, value *Variant) {
	log.Println("Calling ConfigFile.SetValue()")

	godotCallVoidStringStringVariant(o, "set_value", section, key, value)
	log.Println("  Function successfully completed.")

}

/*
   ConfigFileImplementer is an interface for ConfigFile objects.
*/
type ConfigFileImplementer interface {
	Class
}

/*
   Dialog for confirmation of actions. This dialog inherits from [AcceptDialog], but has by default an OK and Cancel button (in host OS order).
*/
type ConfirmationDialog struct {
	AcceptDialog
}

func (o *ConfirmationDialog) baseClass() string {
	return "ConfirmationDialog"
}

/*
   Return the cancel button.
*/
func (o *ConfirmationDialog) GetCancel() *Button {
	log.Println("Calling ConfirmationDialog.GetCancel()")

	returnValue := godotCallObject(o, "get_cancel")
	log.Println("  Got return value: ", returnValue)

	var ret Button
	ret.owner = returnValue.owner
	return &ret

}

/*
   ConfirmationDialogImplementer is an interface for ConfirmationDialog objects.
*/
type ConfirmationDialogImplementer interface {
	Class
}

/*
   Base node for containers. A [code]Container[/code] contains other controls and automatically arranges them in a certain way. A Control can inherit this to create custom container classes.
*/
type Container struct {
	Control
}

func (o *Container) baseClass() string {
	return "Container"
}

/*
   Undocumented
*/
func (o *Container) X_ChildMinsizeChanged() {
	log.Println("Calling Container.X_ChildMinsizeChanged()")

	godotCallVoid(o, "_child_minsize_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Container) X_SortChildren() {
	log.Println("Calling Container.X_SortChildren()")

	godotCallVoid(o, "_sort_children")
	log.Println("  Function successfully completed.")

}

/*
   Fit a child control in a given rect. This is mainly a helper for creating custom container classes.
*/
func (o *Container) FitChildInRect(child *Object, rect *Rect2) {
	log.Println("Calling Container.FitChildInRect()")

	godotCallVoidObjectRect2(o, "fit_child_in_rect", child, rect)
	log.Println("  Function successfully completed.")

}

/*
   Queue resort of the contained children. This is called automatically anyway, but can be called upon request.
*/
func (o *Container) QueueSort() {
	log.Println("Calling Container.QueueSort()")

	godotCallVoid(o, "queue_sort")
	log.Println("  Function successfully completed.")

}

/*
   ContainerImplementer is an interface for Container objects.
*/
type ContainerImplementer interface {
	Class
}

/*
   Base class for all User Interface or [i]UI[/i] related nodes. [code]Control[/code] features a bounding rectangle that defines its extents, an anchor position relative to its parent and margins that represent an offset to the anchor. The margins update automatically when the node, any of its parents, or the screen size change. For more information on Godot's UI system, anchors, margins, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from [code]Control[/code] and [Container] nodes. [b]User Interface nodes and input[/b] Godot sends input events to the scene's root node first, by calling [method Node._input]. [method Node._input] forwards the event down the node tree to the nodes under the mouse cursor, or on keyboard focus. To do so, it calls [method MainLoop._input_event]. Call [method accept_event] so no other node receives the event. Once you accepted an input, it becomes handled so [method Node._unhandled_input] will not process it. Only one [code]Control[/code] node can be in keyboard focus. Only the node in focus will receive keyboard events. To get the focus, call [method grab_focus]. [code]Control[/code] nodes lose focus when another node grabs it, or if you hide the node in focus. Set [member mouse_filter] to MOUSE_FILTER_IGNORE to tell a [code]Control[/code] node to ignore mouse or touch events. You'll need it if you place an icon on top of a button. [Theme] resources change the Control's appearance. If you change the [Theme] on a [code]Control[/code] node, it affects all of its children. To override some of the theme's parameters, call one of the [code]add_*_override[/code] methods, like [method add_font_override]. You can override the theme with the inspector.
*/
type Control struct {
	CanvasItem
}

func (o *Control) baseClass() string {
	return "Control"
}

/*
   Undocumented
*/
func (o *Control) X_FontChanged() {
	log.Println("Calling Control.X_FontChanged()")

	godotCallVoid(o, "_font_changed")
	log.Println("  Function successfully completed.")

}

/*
   Returns the minimum size this Control can shrink to. The node can never be smaller than this minimum size.
*/
func (o *Control) X_GetMinimumSize() *Vector2 {
	log.Println("Calling Control.X_GetMinimumSize()")

	returnValue := godotCallVector2(o, "_get_minimum_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) X_GetTooltip() string {
	log.Println("Calling Control.X_GetTooltip()")

	returnValue := godotCallString(o, "_get_tooltip")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   The node's parent forwards input events to this method. Use it to process and accept inputs on UI elements. See [method accept_event]. Replaces Godot 2's [code]_input_event[/code].
*/
func (o *Control) X_GuiInput(event *InputEvent) {
	log.Println("Calling Control.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &event.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_SetAnchor(margin int64, anchor float64) {
	log.Println("Calling Control.X_SetAnchor()")

	godotCallVoidIntFloat(o, "_set_anchor", margin, anchor)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_SizeChanged() {
	log.Println("Calling Control.X_SizeChanged()")

	godotCallVoid(o, "_size_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_ThemeChanged() {
	log.Println("Calling Control.X_ThemeChanged()")

	godotCallVoid(o, "_theme_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_UpdateMinimumSize() {
	log.Println("Calling Control.X_UpdateMinimumSize()")

	godotCallVoid(o, "_update_minimum_size")
	log.Println("  Function successfully completed.")

}

/*
   Marks an input event as handled. Once you accept an input event, it stops propagating, even to nodes listening to [method Node._unhandled_input] or [method Node._unhandled_key_input].
*/
func (o *Control) AcceptEvent() {
	log.Println("Calling Control.AcceptEvent()")

	godotCallVoid(o, "accept_event")
	log.Println("  Function successfully completed.")

}

/*
   Overrides the color in the [theme] resource the node uses.
*/
func (o *Control) AddColorOverride(name string, color *Color) {
	log.Println("Calling Control.AddColorOverride()")

	godotCallVoidStringColor(o, "add_color_override", name, color)
	log.Println("  Function successfully completed.")

}

/*
   Overrides an integer constant in the [Theme] resource the node uses. If the [code]constant[/code] is invalid, Godot clears the override. See [member Theme.INVALID_CONSTANT] for more information.
*/
func (o *Control) AddConstantOverride(name string, constant int64) {
	log.Println("Calling Control.AddConstantOverride()")

	godotCallVoidStringInt(o, "add_constant_override", name, constant)
	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] font in the [theme] resource the node uses. If [code]font[/code] is empty, Godot clears the override.
*/
func (o *Control) AddFontOverride(name string, font *Font) {
	log.Println("Calling Control.AddFontOverride()")

	godotCallVoidStringObject(o, "add_font_override", name, &font.Object)
	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] icon in the [theme] resource the node uses. If [code]icon[/code] is empty, Godot clears the override.
*/
func (o *Control) AddIconOverride(name string, texture *Texture) {
	log.Println("Calling Control.AddIconOverride()")

	godotCallVoidStringObject(o, "add_icon_override", name, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] shader in the [theme] resource the node uses. If [code]shader[/code] is empty, Godot clears the override.
*/
func (o *Control) AddShaderOverride(name string, shader *Shader) {
	log.Println("Calling Control.AddShaderOverride()")

	godotCallVoidStringObject(o, "add_shader_override", name, &shader.Object)
	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] [Stylebox] in the [theme] resource the node uses. If [code]stylebox[/code] is empty, Godot clears the override.
*/
func (o *Control) AddStyleboxOverride(name string, stylebox *StyleBox) {
	log.Println("Calling Control.AddStyleboxOverride()")

	godotCallVoidStringObject(o, "add_stylebox_override", name, &stylebox.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) CanDropData(position *Vector2, data *Variant) bool {
	log.Println("Calling Control.CanDropData()")

	returnValue := godotCallBoolVector2Variant(o, "can_drop_data", position, data)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) DropData(position *Vector2, data *Variant) {
	log.Println("Calling Control.DropData()")

	godotCallVoidVector2Variant(o, "drop_data", position, data)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) ForceDrag(data *Variant, preview *Object) {
	log.Println("Calling Control.ForceDrag()")

	godotCallVoidVariantObject(o, "force_drag", data, preview)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) GetAnchor(margin int64) float64 {
	log.Println("Calling Control.GetAnchor()")

	returnValue := godotCallFloatInt(o, "get_anchor", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) GetBegin() *Vector2 {
	log.Println("Calling Control.GetBegin()")

	returnValue := godotCallVector2(o, "get_begin")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) GetColor(name string, aType string) *Color {
	log.Println("Calling Control.GetColor()")

	returnValue := godotCallColorStringString(o, "get_color", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) GetCombinedMinimumSize() *Vector2 {
	log.Println("Calling Control.GetCombinedMinimumSize()")

	returnValue := godotCallVector2(o, "get_combined_minimum_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) GetConstant(name string, aType string) int64 {
	log.Println("Calling Control.GetConstant()")

	returnValue := godotCallIntStringString(o, "get_constant", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the mouse cursor shape the control displays on mouse hover, one of the [code]CURSOR_*[/code] constants.
*/
func (o *Control) GetCursorShape(position *Vector2) int64 {
	log.Println("Calling Control.GetCursorShape()")

	returnValue := godotCallIntVector2(o, "get_cursor_shape", position)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetCustomMinimumSize() *Vector2 {
	log.Println("Calling Control.GetCustomMinimumSize()")

	returnValue := godotCallVector2(o, "get_custom_minimum_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetDefaultCursorShape() int64 {
	log.Println("Calling Control.GetDefaultCursorShape()")

	returnValue := godotCallInt(o, "get_default_cursor_shape")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) GetDragData(position *Vector2) *Object {
	log.Println("Calling Control.GetDragData()")

	returnValue := godotCallObjectVector2(o, "get_drag_data", position)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) GetEnd() *Vector2 {
	log.Println("Calling Control.GetEnd()")

	returnValue := godotCallVector2(o, "get_end")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetFocusMode() int64 {
	log.Println("Calling Control.GetFocusMode()")

	returnValue := godotCallInt(o, "get_focus_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetFocusNeighbour(margin int64) *NodePath {
	log.Println("Calling Control.GetFocusNeighbour()")

	returnValue := godotCallNodePathInt(o, "get_focus_neighbour", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetFocusNext() *NodePath {
	log.Println("Calling Control.GetFocusNext()")

	returnValue := godotCallNodePath(o, "get_focus_next")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return which control is owning the keyboard focus, or null if no one.
*/
func (o *Control) GetFocusOwner() *Control {
	log.Println("Calling Control.GetFocusOwner()")

	returnValue := godotCallObject(o, "get_focus_owner")
	log.Println("  Got return value: ", returnValue)

	var ret Control
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Control) GetFocusPrevious() *NodePath {
	log.Println("Calling Control.GetFocusPrevious()")

	returnValue := godotCallNodePath(o, "get_focus_previous")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) GetFont(name string, aType string) *Font {
	log.Println("Calling Control.GetFont()")

	returnValue := godotCallObjectStringString(o, "get_font", name, aType)
	log.Println("  Got return value: ", returnValue)

	var ret Font
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Control) GetGlobalPosition() *Vector2 {
	log.Println("Calling Control.GetGlobalPosition()")

	returnValue := godotCallVector2(o, "get_global_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return position and size of the Control, relative to the top-left corner of the [i]window[/i] Control. This is a helper (see [method get_global_position], [method get_size]).
*/
func (o *Control) GetGlobalRect() *Rect2 {
	log.Println("Calling Control.GetGlobalRect()")

	returnValue := godotCallRect2(o, "get_global_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetHGrowDirection() int64 {
	log.Println("Calling Control.GetHGrowDirection()")

	returnValue := godotCallInt(o, "get_h_grow_direction")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetHSizeFlags() int64 {
	log.Println("Calling Control.GetHSizeFlags()")

	returnValue := godotCallInt(o, "get_h_size_flags")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) GetIcon(name string, aType string) *Texture {
	log.Println("Calling Control.GetIcon()")

	returnValue := godotCallObjectStringString(o, "get_icon", name, aType)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Control) GetMargin(margin int64) float64 {
	log.Println("Calling Control.GetMargin()")

	returnValue := godotCallFloatInt(o, "get_margin", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the minimum size this Control can shrink to. A control will never be displayed or resized smaller than its minimum size.
*/
func (o *Control) GetMinimumSize() *Vector2 {
	log.Println("Calling Control.GetMinimumSize()")

	returnValue := godotCallVector2(o, "get_minimum_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetMouseFilter() int64 {
	log.Println("Calling Control.GetMouseFilter()")

	returnValue := godotCallInt(o, "get_mouse_filter")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) GetParentAreaSize() *Vector2 {
	log.Println("Calling Control.GetParentAreaSize()")

	returnValue := godotCallVector2(o, "get_parent_area_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) GetParentControl() *Control {
	log.Println("Calling Control.GetParentControl()")

	returnValue := godotCallObject(o, "get_parent_control")
	log.Println("  Got return value: ", returnValue)

	var ret Control
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Control) GetPivotOffset() *Vector2 {
	log.Println("Calling Control.GetPivotOffset()")

	returnValue := godotCallVector2(o, "get_pivot_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetPosition() *Vector2 {
	log.Println("Calling Control.GetPosition()")

	returnValue := godotCallVector2(o, "get_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return position and size of the Control, relative to the top-left corner of the parent Control. This is a helper (see [method get_position], [method get_size]).
*/
func (o *Control) GetRect() *Rect2 {
	log.Println("Calling Control.GetRect()")

	returnValue := godotCallRect2(o, "get_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the rotation (in radians)
*/
func (o *Control) GetRotation() float64 {
	log.Println("Calling Control.GetRotation()")

	returnValue := godotCallFloat(o, "get_rotation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetRotationDegrees() float64 {
	log.Println("Calling Control.GetRotationDegrees()")

	returnValue := godotCallFloat(o, "get_rotation_degrees")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetScale() *Vector2 {
	log.Println("Calling Control.GetScale()")

	returnValue := godotCallVector2(o, "get_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetSize() *Vector2 {
	log.Println("Calling Control.GetSize()")

	returnValue := godotCallVector2(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetStretchRatio() float64 {
	log.Println("Calling Control.GetStretchRatio()")

	returnValue := godotCallFloat(o, "get_stretch_ratio")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) GetStylebox(name string, aType string) *StyleBox {
	log.Println("Calling Control.GetStylebox()")

	returnValue := godotCallObjectStringString(o, "get_stylebox", name, aType)
	log.Println("  Got return value: ", returnValue)

	var ret StyleBox
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Control) GetTheme() *Theme {
	log.Println("Calling Control.GetTheme()")

	returnValue := godotCallObject(o, "get_theme")
	log.Println("  Got return value: ", returnValue)

	var ret Theme
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the tooltip, which will appear when the cursor is resting over this control.
*/
func (o *Control) GetTooltip(atPosition *Vector2) string {
	log.Println("Calling Control.GetTooltip()")

	returnValue := godotCallStringVector2(o, "get_tooltip", atPosition)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetVGrowDirection() int64 {
	log.Println("Calling Control.GetVGrowDirection()")

	returnValue := godotCallInt(o, "get_v_grow_direction")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetVSizeFlags() int64 {
	log.Println("Calling Control.GetVSizeFlags()")

	returnValue := godotCallInt(o, "get_v_size_flags")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) GrabClickFocus() {
	log.Println("Calling Control.GrabClickFocus()")

	godotCallVoid(o, "grab_click_focus")
	log.Println("  Function successfully completed.")

}

/*
   Steal the focus from another control and become the focused control (see [method set_focus_mode]).
*/
func (o *Control) GrabFocus() {
	log.Println("Calling Control.GrabFocus()")

	godotCallVoid(o, "grab_focus")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) HasColor(name string, aType string) bool {
	log.Println("Calling Control.HasColor()")

	returnValue := godotCallBoolStringString(o, "has_color", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) HasColorOverride(name string) bool {
	log.Println("Calling Control.HasColorOverride()")

	returnValue := godotCallBoolString(o, "has_color_override", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) HasConstant(name string, aType string) bool {
	log.Println("Calling Control.HasConstant()")

	returnValue := godotCallBoolStringString(o, "has_constant", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) HasConstantOverride(name string) bool {
	log.Println("Calling Control.HasConstantOverride()")

	returnValue := godotCallBoolString(o, "has_constant_override", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return whether the Control is the current focused control (see [method set_focus_mode]).
*/
func (o *Control) HasFocus() bool {
	log.Println("Calling Control.HasFocus()")

	returnValue := godotCallBool(o, "has_focus")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) HasFont(name string, aType string) bool {
	log.Println("Calling Control.HasFont()")

	returnValue := godotCallBoolStringString(o, "has_font", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) HasFontOverride(name string) bool {
	log.Println("Calling Control.HasFontOverride()")

	returnValue := godotCallBoolString(o, "has_font_override", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) HasIcon(name string, aType string) bool {
	log.Println("Calling Control.HasIcon()")

	returnValue := godotCallBoolStringString(o, "has_icon", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) HasIconOverride(name string) bool {
	log.Println("Calling Control.HasIconOverride()")

	returnValue := godotCallBoolString(o, "has_icon_override", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) HasPoint(point *Vector2) bool {
	log.Println("Calling Control.HasPoint()")

	returnValue := godotCallBoolVector2(o, "has_point", point)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) HasShaderOverride(name string) bool {
	log.Println("Calling Control.HasShaderOverride()")

	returnValue := godotCallBoolString(o, "has_shader_override", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) HasStylebox(name string, aType string) bool {
	log.Println("Calling Control.HasStylebox()")

	returnValue := godotCallBoolStringString(o, "has_stylebox", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) HasStyleboxOverride(name string) bool {
	log.Println("Calling Control.HasStyleboxOverride()")

	returnValue := godotCallBoolString(o, "has_stylebox_override", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Control) IsClippingContents() bool {
	log.Println("Calling Control.IsClippingContents()")

	returnValue := godotCallBool(o, "is_clipping_contents")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Control) MinimumSizeChanged() {
	log.Println("Calling Control.MinimumSizeChanged()")

	godotCallVoid(o, "minimum_size_changed")
	log.Println("  Function successfully completed.")

}

/*
   Give up the focus, no other control will be able to receive keyboard input.
*/
func (o *Control) ReleaseFocus() {
	log.Println("Calling Control.ReleaseFocus()")

	godotCallVoid(o, "release_focus")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchor(margin int64, anchor float64, keepMargin bool, pushOppositeAnchor bool) {
	log.Println("Calling Control.SetAnchor()")

	godotCallVoidIntFloatBoolBool(o, "set_anchor", margin, anchor, keepMargin, pushOppositeAnchor)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchorAndMargin(margin int64, anchor float64, offset float64, pushOppositeAnchor bool) {
	log.Println("Calling Control.SetAnchorAndMargin()")

	godotCallVoidIntFloatFloatBool(o, "set_anchor_and_margin", margin, anchor, offset, pushOppositeAnchor)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchorsAndMarginsPreset(preset int64, resizeMode int64, margin int64) {
	log.Println("Calling Control.SetAnchorsAndMarginsPreset()")

	godotCallVoidIntIntInt(o, "set_anchors_and_margins_preset", preset, resizeMode, margin)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchorsPreset(preset int64, keepMargin bool) {
	log.Println("Calling Control.SetAnchorsPreset()")

	godotCallVoidIntBool(o, "set_anchors_preset", preset, keepMargin)
	log.Println("  Function successfully completed.")

}

/*
   Sets MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) SetBegin(position *Vector2) {
	log.Println("Calling Control.SetBegin()")

	godotCallVoidVector2(o, "set_begin", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetClipContents(enable bool) {
	log.Println("Calling Control.SetClipContents()")

	godotCallVoidBool(o, "set_clip_contents", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetCustomMinimumSize(size *Vector2) {
	log.Println("Calling Control.SetCustomMinimumSize()")

	godotCallVoidVector2(o, "set_custom_minimum_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetDefaultCursorShape(shape int64) {
	log.Println("Calling Control.SetDefaultCursorShape()")

	godotCallVoidInt(o, "set_default_cursor_shape", shape)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetDragForwarding(target *Object) {
	log.Println("Calling Control.SetDragForwarding()")

	godotCallVoidObject(o, "set_drag_forwarding", target)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetDragPreview(control *Object) {
	log.Println("Calling Control.SetDragPreview()")

	godotCallVoidObject(o, "set_drag_preview", control)
	log.Println("  Function successfully completed.")

}

/*
   Sets MARGIN_RIGHT and MARGIN_BOTTOM at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) SetEnd(position *Vector2) {
	log.Println("Calling Control.SetEnd()")

	godotCallVoidVector2(o, "set_end", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetFocusMode(mode int64) {
	log.Println("Calling Control.SetFocusMode()")

	godotCallVoidInt(o, "set_focus_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetFocusNeighbour(margin int64, neighbour *NodePath) {
	log.Println("Calling Control.SetFocusNeighbour()")

	godotCallVoidIntNodePath(o, "set_focus_neighbour", margin, neighbour)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetFocusNext(next *NodePath) {
	log.Println("Calling Control.SetFocusNext()")

	godotCallVoidNodePath(o, "set_focus_next", next)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetFocusPrevious(previous *NodePath) {
	log.Println("Calling Control.SetFocusPrevious()")

	godotCallVoidNodePath(o, "set_focus_previous", previous)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetGlobalPosition(position *Vector2) {
	log.Println("Calling Control.SetGlobalPosition()")

	godotCallVoidVector2(o, "set_global_position", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetHGrowDirection(direction int64) {
	log.Println("Calling Control.SetHGrowDirection()")

	godotCallVoidInt(o, "set_h_grow_direction", direction)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetHSizeFlags(flags int64) {
	log.Println("Calling Control.SetHSizeFlags()")

	godotCallVoidInt(o, "set_h_size_flags", flags)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetMargin(margin int64, offset float64) {
	log.Println("Calling Control.SetMargin()")

	godotCallVoidIntFloat(o, "set_margin", margin, offset)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetMarginsPreset(preset int64, resizeMode int64, margin int64) {
	log.Println("Calling Control.SetMarginsPreset()")

	godotCallVoidIntIntInt(o, "set_margins_preset", preset, resizeMode, margin)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetMouseFilter(filter int64) {
	log.Println("Calling Control.SetMouseFilter()")

	godotCallVoidInt(o, "set_mouse_filter", filter)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetPivotOffset(pivotOffset *Vector2) {
	log.Println("Calling Control.SetPivotOffset()")

	godotCallVoidVector2(o, "set_pivot_offset", pivotOffset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetPosition(position *Vector2) {
	log.Println("Calling Control.SetPosition()")

	godotCallVoidVector2(o, "set_position", position)
	log.Println("  Function successfully completed.")

}

/*
   Set the rotation (in radians).
*/
func (o *Control) SetRotation(radians float64) {
	log.Println("Calling Control.SetRotation()")

	godotCallVoidFloat(o, "set_rotation", radians)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetRotationDegrees(degrees float64) {
	log.Println("Calling Control.SetRotationDegrees()")

	godotCallVoidFloat(o, "set_rotation_degrees", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetScale(scale *Vector2) {
	log.Println("Calling Control.SetScale()")

	godotCallVoidVector2(o, "set_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetSize(size *Vector2) {
	log.Println("Calling Control.SetSize()")

	godotCallVoidVector2(o, "set_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetStretchRatio(ratio float64) {
	log.Println("Calling Control.SetStretchRatio()")

	godotCallVoidFloat(o, "set_stretch_ratio", ratio)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetTheme(theme *Theme) {
	log.Println("Calling Control.SetTheme()")

	godotCallVoidObject(o, "set_theme", &theme.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetTooltip(tooltip string) {
	log.Println("Calling Control.SetTooltip()")

	godotCallVoidString(o, "set_tooltip", tooltip)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetVGrowDirection(direction int64) {
	log.Println("Calling Control.SetVGrowDirection()")

	godotCallVoidInt(o, "set_v_grow_direction", direction)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetVSizeFlags(flags int64) {
	log.Println("Calling Control.SetVSizeFlags()")

	godotCallVoidInt(o, "set_v_size_flags", flags)
	log.Println("  Function successfully completed.")

}

/*
   Display a Control as modal. Control must be a subwindow. Modal controls capture the input signals until closed or the area outside them is accessed. When a modal control loses focus, or the ESC key is pressed, they automatically hide. Modal controls are used extensively for popup dialogs and menus.
*/
func (o *Control) ShowModal(exclusive bool) {
	log.Println("Calling Control.ShowModal()")

	godotCallVoidBool(o, "show_modal", exclusive)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) WarpMouse(toPosition *Vector2) {
	log.Println("Calling Control.WarpMouse()")

	godotCallVoidVector2(o, "warp_mouse", toPosition)
	log.Println("  Function successfully completed.")

}

/*
   ControlImplementer is an interface for Control objects.
*/
type ControlImplementer interface {
	Class
}

/*
   Convex polygon shape resource, which can be added to a [PhysicsBody] or area.
*/
type ConvexPolygonShape struct {
	Shape
}

func (o *ConvexPolygonShape) baseClass() string {
	return "ConvexPolygonShape"
}

/*
   Undocumented
*/
func (o *ConvexPolygonShape) GetPoints() *PoolVector3Array {
	log.Println("Calling ConvexPolygonShape.GetPoints()")

	returnValue := godotCallPoolVector3Array(o, "get_points")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ConvexPolygonShape) SetPoints(points *PoolVector3Array) {
	log.Println("Calling ConvexPolygonShape.SetPoints()")

	godotCallVoidPoolVector3Array(o, "set_points", points)
	log.Println("  Function successfully completed.")

}

/*
   ConvexPolygonShapeImplementer is an interface for ConvexPolygonShape objects.
*/
type ConvexPolygonShapeImplementer interface {
	Class
}

/*
   Convex Polygon Shape for 2D physics. A convex polygon, whatever its shape, is internally decomposed into as many convex polygons as needed to ensure all collision checks against it are always done on convex polygons (which are faster to check). The main difference between a [code]ConvexPolygonShape2D[/code] and a [ConcavePolygonShape2D] is that a concave polygon assumes it is concave and uses a more complex method of collision detection, and a convex one forces itself to be convex in order to speed up collision detection.
*/
type ConvexPolygonShape2D struct {
	Shape2D
}

func (o *ConvexPolygonShape2D) baseClass() string {
	return "ConvexPolygonShape2D"
}

/*
   Undocumented
*/
func (o *ConvexPolygonShape2D) GetPoints() *PoolVector2Array {
	log.Println("Calling ConvexPolygonShape2D.GetPoints()")

	returnValue := godotCallPoolVector2Array(o, "get_points")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Currently, this method does nothing.
*/
func (o *ConvexPolygonShape2D) SetPointCloud(pointCloud *PoolVector2Array) {
	log.Println("Calling ConvexPolygonShape2D.SetPointCloud()")

	godotCallVoidPoolVector2Array(o, "set_point_cloud", pointCloud)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ConvexPolygonShape2D) SetPoints(points *PoolVector2Array) {
	log.Println("Calling ConvexPolygonShape2D.SetPoints()")

	godotCallVoidPoolVector2Array(o, "set_points", points)
	log.Println("  Function successfully completed.")

}

/*
   ConvexPolygonShape2DImplementer is an interface for ConvexPolygonShape2D objects.
*/
type ConvexPolygonShape2DImplementer interface {
	Class
}

/*
   A 6-sided 3D texture typically used for faking reflections. It can be used to make an object look as if it's reflecting its surroundings. This usually delivers much better performance than other reflection methods.
*/
type CubeMap struct {
	Resource
}

func (o *CubeMap) baseClass() string {
	return "CubeMap"
}

/*
   Undocumented
*/
func (o *CubeMap) GetFlags() int64 {
	log.Println("Calling CubeMap.GetFlags()")

	returnValue := godotCallInt(o, "get_flags")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [code]CubeMap[/code]'s height.
*/
func (o *CubeMap) GetHeight() int64 {
	log.Println("Calling CubeMap.GetHeight()")

	returnValue := godotCallInt(o, "get_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CubeMap) GetLossyStorageQuality() float64 {
	log.Println("Calling CubeMap.GetLossyStorageQuality()")

	returnValue := godotCallFloat(o, "get_lossy_storage_quality")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an [Image] for a side of the [code]CubeMap[/code] using one of the [code]SIDE_*[/code] constants or an integer 0-5.
*/
func (o *CubeMap) GetSide(side int64) *Image {
	log.Println("Calling CubeMap.GetSide()")

	returnValue := godotCallObjectInt(o, "get_side", side)
	log.Println("  Got return value: ", returnValue)

	var ret Image
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *CubeMap) GetStorage() int64 {
	log.Println("Calling CubeMap.GetStorage()")

	returnValue := godotCallInt(o, "get_storage")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [code]CubeMap[/code]'s width.
*/
func (o *CubeMap) GetWidth() int64 {
	log.Println("Calling CubeMap.GetWidth()")

	returnValue := godotCallInt(o, "get_width")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CubeMap) SetFlags(flags int64) {
	log.Println("Calling CubeMap.SetFlags()")

	godotCallVoidInt(o, "set_flags", flags)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CubeMap) SetLossyStorageQuality(quality float64) {
	log.Println("Calling CubeMap.SetLossyStorageQuality()")

	godotCallVoidFloat(o, "set_lossy_storage_quality", quality)
	log.Println("  Function successfully completed.")

}

/*
   Sets an [Image] for a side of the [code]CubeMap[/code] using one of the [code]SIDE_*[/code] constants or an integer 0-5.
*/
func (o *CubeMap) SetSide(side int64, image *Image) {
	log.Println("Calling CubeMap.SetSide()")

	godotCallVoidIntObject(o, "set_side", side, &image.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CubeMap) SetStorage(mode int64) {
	log.Println("Calling CubeMap.SetStorage()")

	godotCallVoidInt(o, "set_storage", mode)
	log.Println("  Function successfully completed.")

}

/*
   CubeMapImplementer is an interface for CubeMap objects.
*/
type CubeMapImplementer interface {
	Class
}

/*
   Generate an axis-aligned cuboid [PrimitiveMesh].
*/
type CubeMesh struct {
	PrimitiveMesh
}

func (o *CubeMesh) baseClass() string {
	return "CubeMesh"
}

/*
   Undocumented
*/
func (o *CubeMesh) GetSize() *Vector3 {
	log.Println("Calling CubeMesh.GetSize()")

	returnValue := godotCallVector3(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CubeMesh) GetSubdivideDepth() int64 {
	log.Println("Calling CubeMesh.GetSubdivideDepth()")

	returnValue := godotCallInt(o, "get_subdivide_depth")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CubeMesh) GetSubdivideHeight() int64 {
	log.Println("Calling CubeMesh.GetSubdivideHeight()")

	returnValue := godotCallInt(o, "get_subdivide_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CubeMesh) GetSubdivideWidth() int64 {
	log.Println("Calling CubeMesh.GetSubdivideWidth()")

	returnValue := godotCallInt(o, "get_subdivide_width")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CubeMesh) SetSize(size *Vector3) {
	log.Println("Calling CubeMesh.SetSize()")

	godotCallVoidVector3(o, "set_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CubeMesh) SetSubdivideDepth(divisions int64) {
	log.Println("Calling CubeMesh.SetSubdivideDepth()")

	godotCallVoidInt(o, "set_subdivide_depth", divisions)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CubeMesh) SetSubdivideHeight(divisions int64) {
	log.Println("Calling CubeMesh.SetSubdivideHeight()")

	godotCallVoidInt(o, "set_subdivide_height", divisions)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CubeMesh) SetSubdivideWidth(subdivide int64) {
	log.Println("Calling CubeMesh.SetSubdivideWidth()")

	godotCallVoidInt(o, "set_subdivide_width", subdivide)
	log.Println("  Function successfully completed.")

}

/*
   CubeMeshImplementer is an interface for CubeMesh objects.
*/
type CubeMeshImplementer interface {
	Class
}

/*
   A curve that can be saved and re-used for other objects. By default it ranges between [code]0[/code] and [code]1[/code] on the y-axis and positions points relative to the [code]0.5[/code] y-position.
*/
type Curve struct {
	Resource
}

func (o *Curve) baseClass() string {
	return "Curve"
}

/*
   Undocumented
*/
func (o *Curve) X_GetData() *Array {
	log.Println("Calling Curve.X_GetData()")

	returnValue := godotCallArray(o, "_get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Curve) X_SetData(data *Array) {
	log.Println("Calling Curve.X_SetData()")

	godotCallVoidArray(o, "_set_data", data)
	log.Println("  Function successfully completed.")

}

/*
   Adds a point to the curve. For each side, if the [code]*_mode[/code] is [code]TANGENT_LINEAR[/code], the [code]*_tangent[/code] angle (in degrees) uses the slope of the curve halfway to the adjacent point. Allows custom assignments to the [code]*_tangent[/code] angle if [code]*_mode[/code] is set to [code]TANGENT_FREE[/code].
*/
func (o *Curve) AddPoint(position *Vector2, leftTangent float64, rightTangent float64, leftMode int64, rightMode int64) int64 {
	log.Println("Calling Curve.AddPoint()")

	returnValue := godotCallIntVector2FloatFloatIntInt(o, "add_point", position, leftTangent, rightTangent, leftMode, rightMode)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Recomputes the baked cache of points for the curve.
*/
func (o *Curve) Bake() {
	log.Println("Calling Curve.Bake()")

	godotCallVoid(o, "bake")
	log.Println("  Function successfully completed.")

}

/*
   Removes points that are closer than [code]CMP_EPSILON[/code] (0.00001) units to their neighbor on the curve.
*/
func (o *Curve) CleanDupes() {
	log.Println("Calling Curve.CleanDupes()")

	godotCallVoid(o, "clean_dupes")
	log.Println("  Function successfully completed.")

}

/*
   Removes all points from the curve.
*/
func (o *Curve) ClearPoints() {
	log.Println("Calling Curve.ClearPoints()")

	godotCallVoid(o, "clear_points")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve) GetBakeResolution() int64 {
	log.Println("Calling Curve.GetBakeResolution()")

	returnValue := godotCallInt(o, "get_bake_resolution")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Curve) GetMaxValue() float64 {
	log.Println("Calling Curve.GetMaxValue()")

	returnValue := godotCallFloat(o, "get_max_value")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Curve) GetMinValue() float64 {
	log.Println("Calling Curve.GetMinValue()")

	returnValue := godotCallFloat(o, "get_min_value")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the left [code]TangentMode[/code] for the point at [code]index[/code].
*/
func (o *Curve) GetPointLeftMode(index int64) int64 {
	log.Println("Calling Curve.GetPointLeftMode()")

	returnValue := godotCallIntInt(o, "get_point_left_mode", index)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the left tangent angle (in degrees) for the point at [code]index[/code].
*/
func (o *Curve) GetPointLeftTangent(index int64) float64 {
	log.Println("Calling Curve.GetPointLeftTangent()")

	returnValue := godotCallFloatInt(o, "get_point_left_tangent", index)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the curve coordinates for the point at [code]index[/code].
*/
func (o *Curve) GetPointPosition(index int64) *Vector2 {
	log.Println("Calling Curve.GetPointPosition()")

	returnValue := godotCallVector2Int(o, "get_point_position", index)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the right [code]TangentMode[/code] for the point at [code]index[/code].
*/
func (o *Curve) GetPointRightMode(index int64) int64 {
	log.Println("Calling Curve.GetPointRightMode()")

	returnValue := godotCallIntInt(o, "get_point_right_mode", index)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the right tangent angle (in degrees) for the point at [code]index[/code].
*/
func (o *Curve) GetPointRightTangent(index int64) float64 {
	log.Println("Calling Curve.GetPointRightTangent()")

	returnValue := godotCallFloatInt(o, "get_point_right_tangent", index)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the y value for the point that would exist at x-position [code]offset[/code] along the curve.
*/
func (o *Curve) Interpolate(offset float64) float64 {
	log.Println("Calling Curve.Interpolate()")

	returnValue := godotCallFloatFloat(o, "interpolate", offset)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the y value for the point that would exist at x-position [code]offset[/code] along the curve using the baked cache. Bakes the curve's points if not already baked.
*/
func (o *Curve) InterpolateBaked(offset float64) float64 {
	log.Println("Calling Curve.InterpolateBaked()")

	returnValue := godotCallFloatFloat(o, "interpolate_baked", offset)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes the point at [code]index[/code] from the curve.
*/
func (o *Curve) RemovePoint(index int64) {
	log.Println("Calling Curve.RemovePoint()")

	godotCallVoidInt(o, "remove_point", index)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve) SetBakeResolution(resolution int64) {
	log.Println("Calling Curve.SetBakeResolution()")

	godotCallVoidInt(o, "set_bake_resolution", resolution)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve) SetMaxValue(max float64) {
	log.Println("Calling Curve.SetMaxValue()")

	godotCallVoidFloat(o, "set_max_value", max)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve) SetMinValue(min float64) {
	log.Println("Calling Curve.SetMinValue()")

	godotCallVoidFloat(o, "set_min_value", min)
	log.Println("  Function successfully completed.")

}

/*
   Sets the left [code]TangentMode[/code] for the point at [code]index[/code] to [code]mode[/code].
*/
func (o *Curve) SetPointLeftMode(index int64, mode int64) {
	log.Println("Calling Curve.SetPointLeftMode()")

	godotCallVoidIntInt(o, "set_point_left_mode", index, mode)
	log.Println("  Function successfully completed.")

}

/*
   Sets the left tangent angle for the point at [code]index[/code] to [code]tangent[/code].
*/
func (o *Curve) SetPointLeftTangent(index int64, tangent float64) {
	log.Println("Calling Curve.SetPointLeftTangent()")

	godotCallVoidIntFloat(o, "set_point_left_tangent", index, tangent)
	log.Println("  Function successfully completed.")

}

/*
   Sets the offset from [code]0.5[/code]
*/
func (o *Curve) SetPointOffset(index int64, offset float64) int64 {
	log.Println("Calling Curve.SetPointOffset()")

	returnValue := godotCallIntIntFloat(o, "set_point_offset", index, offset)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the right [code]TangentMode[/code] for the point at [code]index[/code] to [code]mode[/code].
*/
func (o *Curve) SetPointRightMode(index int64, mode int64) {
	log.Println("Calling Curve.SetPointRightMode()")

	godotCallVoidIntInt(o, "set_point_right_mode", index, mode)
	log.Println("  Function successfully completed.")

}

/*
   Sets the right tangent angle for the point at [code]index[/code] to [code]tangent[/code].
*/
func (o *Curve) SetPointRightTangent(index int64, tangent float64) {
	log.Println("Calling Curve.SetPointRightTangent()")

	godotCallVoidIntFloat(o, "set_point_right_tangent", index, tangent)
	log.Println("  Function successfully completed.")

}

/*
   Assigns the vertical position [code]y[/code] to the point at [code]index[/code].
*/
func (o *Curve) SetPointValue(index int64, y float64) {
	log.Println("Calling Curve.SetPointValue()")

	godotCallVoidIntFloat(o, "set_point_value", index, y)
	log.Println("  Function successfully completed.")

}

/*
   CurveImplementer is an interface for Curve objects.
*/
type CurveImplementer interface {
	Class
}

/*
   This class describes a Bezier curve in 2D space. It is mainly used to give a shape to a [Path2D], but can be manually sampled for other purposes. It keeps a cache of precalculated points along the curve, to speed further calculations up.
*/
type Curve2D struct {
	Resource
}

func (o *Curve2D) baseClass() string {
	return "Curve2D"
}

/*
   Undocumented
*/
func (o *Curve2D) X_GetData() *Dictionary {
	log.Println("Calling Curve2D.X_GetData()")

	returnValue := godotCallDictionary(o, "_get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Curve2D) X_SetData(arg0 *Dictionary) {
	log.Println("Calling Curve2D.X_SetData()")

	godotCallVoidDictionary(o, "_set_data", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Adds a point to a curve, at "position", with control points "in" and "out". If "at_position" is given, the point is inserted before the point number "at_position", moving that point (and every point after) after the inserted point. If "at_position" is not given, or is an illegal value (at_position <0 or at_position >= [method get_point_count]), the point will be appended at the end of the point list.
*/
func (o *Curve2D) AddPoint(position *Vector2, in *Vector2, out *Vector2, atPosition int64) {
	log.Println("Calling Curve2D.AddPoint()")

	godotCallVoidVector2Vector2Vector2Int(o, "add_point", position, in, out, atPosition)
	log.Println("  Function successfully completed.")

}

/*
   Removes all points from the curve.
*/
func (o *Curve2D) ClearPoints() {
	log.Println("Calling Curve2D.ClearPoints()")

	godotCallVoid(o, "clear_points")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve2D) GetBakeInterval() float64 {
	log.Println("Calling Curve2D.GetBakeInterval()")

	returnValue := godotCallFloat(o, "get_bake_interval")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the total length of the curve, based on the cached points. Given enough density (see [method set_bake_interval]), it should be approximate enough.
*/
func (o *Curve2D) GetBakedLength() float64 {
	log.Println("Calling Curve2D.GetBakedLength()")

	returnValue := godotCallFloat(o, "get_baked_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the cache of points as a [PoolVector2Array].
*/
func (o *Curve2D) GetBakedPoints() *PoolVector2Array {
	log.Println("Calling Curve2D.GetBakedPoints()")

	returnValue := godotCallPoolVector2Array(o, "get_baked_points")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of points describing the curve.
*/
func (o *Curve2D) GetPointCount() int64 {
	log.Println("Calling Curve2D.GetPointCount()")

	returnValue := godotCallInt(o, "get_point_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) GetPointIn(idx int64) *Vector2 {
	log.Println("Calling Curve2D.GetPointIn()")

	returnValue := godotCallVector2Int(o, "get_point_in", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) GetPointOut(idx int64) *Vector2 {
	log.Println("Calling Curve2D.GetPointOut()")

	returnValue := godotCallVector2Int(o, "get_point_out", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) GetPointPosition(idx int64) *Vector2 {
	log.Println("Calling Curve2D.GetPointPosition()")

	returnValue := godotCallVector2Int(o, "get_point_position", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position between the vertex "idx" and the vertex "idx"+1, where "t" controls if the point is the first vertex (t = 0.0), the last vertex (t = 1.0), or in between. Values of "t" outside the range (0.0 >= t <=1) give strange, but predictable results. If "idx" is out of bounds it is truncated to the first or last vertex, and "t" is ignored. If the curve has no points, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) Interpolate(idx int64, t float64) *Vector2 {
	log.Println("Calling Curve2D.Interpolate()")

	returnValue := godotCallVector2IntFloat(o, "interpolate", idx, t)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a point within the curve at position "offset", where "offset" is measured as a pixel distance along the curve. To do that, it finds the two cached points where the "offset" lies between, then interpolates the values. This interpolation is cubic if "cubic" is set to true, or linear if set to false. Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
*/
func (o *Curve2D) InterpolateBaked(offset float64, cubic bool) *Vector2 {
	log.Println("Calling Curve2D.InterpolateBaked()")

	returnValue := godotCallVector2FloatBool(o, "interpolate_baked", offset, cubic)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position at the vertex "fofs". It calls [method interpolate] using the integer part of fofs as "idx", and its fractional part as "t".
*/
func (o *Curve2D) Interpolatef(fofs float64) *Vector2 {
	log.Println("Calling Curve2D.Interpolatef()")

	returnValue := godotCallVector2Float(o, "interpolatef", fofs)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Deletes the point "idx" from the curve. Sends an error to the console if "idx" is out of bounds.
*/
func (o *Curve2D) RemovePoint(idx int64) {
	log.Println("Calling Curve2D.RemovePoint()")

	godotCallVoidInt(o, "remove_point", idx)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve2D) SetBakeInterval(distance float64) {
	log.Println("Calling Curve2D.SetBakeInterval()")

	godotCallVoidFloat(o, "set_bake_interval", distance)
	log.Println("  Function successfully completed.")

}

/*
   Sets the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve2D) SetPointIn(idx int64, position *Vector2) {
	log.Println("Calling Curve2D.SetPointIn()")

	godotCallVoidIntVector2(o, "set_point_in", idx, position)
	log.Println("  Function successfully completed.")

}

/*
   Sets the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve2D) SetPointOut(idx int64, position *Vector2) {
	log.Println("Calling Curve2D.SetPointOut()")

	godotCallVoidIntVector2(o, "set_point_out", idx, position)
	log.Println("  Function successfully completed.")

}

/*
   Sets the position for the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve2D) SetPointPosition(idx int64, position *Vector2) {
	log.Println("Calling Curve2D.SetPointPosition()")

	godotCallVoidIntVector2(o, "set_point_position", idx, position)
	log.Println("  Function successfully completed.")

}

/*
   Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts. This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough. "max_stages" controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care! "tolerance_degrees" controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
*/
func (o *Curve2D) Tessellate(maxStages int64, toleranceDegrees float64) *PoolVector2Array {
	log.Println("Calling Curve2D.Tessellate()")

	returnValue := godotCallPoolVector2ArrayIntFloat(o, "tessellate", maxStages, toleranceDegrees)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Curve2DImplementer is an interface for Curve2D objects.
*/
type Curve2DImplementer interface {
	Class
}

/*
   This class describes a Bezier curve in 3D space. It is mainly used to give a shape to a [Path], but can be manually sampled for other purposes. It keeps a cache of precalculated points along the curve, to speed further calculations up.
*/
type Curve3D struct {
	Resource
}

func (o *Curve3D) baseClass() string {
	return "Curve3D"
}

/*
   Undocumented
*/
func (o *Curve3D) X_GetData() *Dictionary {
	log.Println("Calling Curve3D.X_GetData()")

	returnValue := godotCallDictionary(o, "_get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Curve3D) X_SetData(arg0 *Dictionary) {
	log.Println("Calling Curve3D.X_SetData()")

	godotCallVoidDictionary(o, "_set_data", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Adds a point to a curve, at "position", with control points "in" and "out". If "at_position" is given, the point is inserted before the point number "at_position", moving that point (and every point after) after the inserted point. If "at_position" is not given, or is an illegal value (at_position <0 or at_position >= [method get_point_count]), the point will be appended at the end of the point list.
*/
func (o *Curve3D) AddPoint(position *Vector3, in *Vector3, out *Vector3, atPosition int64) {
	log.Println("Calling Curve3D.AddPoint()")

	godotCallVoidVector3Vector3Vector3Int(o, "add_point", position, in, out, atPosition)
	log.Println("  Function successfully completed.")

}

/*
   Removes all points from the curve.
*/
func (o *Curve3D) ClearPoints() {
	log.Println("Calling Curve3D.ClearPoints()")

	godotCallVoid(o, "clear_points")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve3D) GetBakeInterval() float64 {
	log.Println("Calling Curve3D.GetBakeInterval()")

	returnValue := godotCallFloat(o, "get_bake_interval")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the total length of the curve, based on the cached points. Given enough density (see [method set_bake_interval]), it should be approximate enough.
*/
func (o *Curve3D) GetBakedLength() float64 {
	log.Println("Calling Curve3D.GetBakedLength()")

	returnValue := godotCallFloat(o, "get_baked_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the cache of points as a [PoolVector3Array].
*/
func (o *Curve3D) GetBakedPoints() *PoolVector3Array {
	log.Println("Calling Curve3D.GetBakedPoints()")

	returnValue := godotCallPoolVector3Array(o, "get_baked_points")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the cache of tilts as a [RealArray].
*/
func (o *Curve3D) GetBakedTilts() *PoolRealArray {
	log.Println("Calling Curve3D.GetBakedTilts()")

	returnValue := godotCallPoolRealArray(o, "get_baked_tilts")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of points describing the curve.
*/
func (o *Curve3D) GetPointCount() int64 {
	log.Println("Calling Curve3D.GetPointCount()")

	returnValue := godotCallInt(o, "get_point_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) GetPointIn(idx int64) *Vector3 {
	log.Println("Calling Curve3D.GetPointIn()")

	returnValue := godotCallVector3Int(o, "get_point_in", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) GetPointOut(idx int64) *Vector3 {
	log.Println("Calling Curve3D.GetPointOut()")

	returnValue := godotCallVector3Int(o, "get_point_out", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) GetPointPosition(idx int64) *Vector3 {
	log.Println("Calling Curve3D.GetPointPosition()")

	returnValue := godotCallVector3Int(o, "get_point_position", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the tilt angle in radians for the point "idx". If the index is out of bounds, the function sends an error to the console, and returns 0.
*/
func (o *Curve3D) GetPointTilt(idx int64) float64 {
	log.Println("Calling Curve3D.GetPointTilt()")

	returnValue := godotCallFloatInt(o, "get_point_tilt", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position between the vertex "idx" and the vertex "idx"+1, where "t" controls if the point is the first vertex (t = 0.0), the last vertex (t = 1.0), or in between. Values of "t" outside the range (0.0 >= t <=1) give strange, but predictable results. If "idx" is out of bounds it is truncated to the first or last vertex, and "t" is ignored. If the curve has no points, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) Interpolate(idx int64, t float64) *Vector3 {
	log.Println("Calling Curve3D.Interpolate()")

	returnValue := godotCallVector3IntFloat(o, "interpolate", idx, t)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a point within the curve at position "offset", where "offset" is measured as a distance in 3D units along the curve. To do that, it finds the two cached points where the "offset" lies between, then interpolates the values. This interpolation is cubic if "cubic" is set to true, or linear if set to false. Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
*/
func (o *Curve3D) InterpolateBaked(offset float64, cubic bool) *Vector3 {
	log.Println("Calling Curve3D.InterpolateBaked()")

	returnValue := godotCallVector3FloatBool(o, "interpolate_baked", offset, cubic)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the position at the vertex "fofs". It calls [method interpolate] using the integer part of fofs as "idx", and its fractional part as "t".
*/
func (o *Curve3D) Interpolatef(fofs float64) *Vector3 {
	log.Println("Calling Curve3D.Interpolatef()")

	returnValue := godotCallVector3Float(o, "interpolatef", fofs)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Deletes the point "idx" from the curve. Sends an error to the console if "idx" is out of bounds.
*/
func (o *Curve3D) RemovePoint(idx int64) {
	log.Println("Calling Curve3D.RemovePoint()")

	godotCallVoidInt(o, "remove_point", idx)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve3D) SetBakeInterval(distance float64) {
	log.Println("Calling Curve3D.SetBakeInterval()")

	godotCallVoidFloat(o, "set_bake_interval", distance)
	log.Println("  Function successfully completed.")

}

/*
   Sets the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve3D) SetPointIn(idx int64, position *Vector3) {
	log.Println("Calling Curve3D.SetPointIn()")

	godotCallVoidIntVector3(o, "set_point_in", idx, position)
	log.Println("  Function successfully completed.")

}

/*
   Sets the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve3D) SetPointOut(idx int64, position *Vector3) {
	log.Println("Calling Curve3D.SetPointOut()")

	godotCallVoidIntVector3(o, "set_point_out", idx, position)
	log.Println("  Function successfully completed.")

}

/*
   Sets the position for the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve3D) SetPointPosition(idx int64, position *Vector3) {
	log.Println("Calling Curve3D.SetPointPosition()")

	godotCallVoidIntVector3(o, "set_point_position", idx, position)
	log.Println("  Function successfully completed.")

}

/*
   Sets the tilt angle in radians for the point "idx". If the index is out of bounds, the function sends an error to the console. The tilt controls the rotation along the look-at axis an object traveling the path would have. In the case of a curve controlling a [PathFollow], this tilt is an offset over the natural tilt the PathFollow calculates.
*/
func (o *Curve3D) SetPointTilt(idx int64, tilt float64) {
	log.Println("Calling Curve3D.SetPointTilt()")

	godotCallVoidIntFloat(o, "set_point_tilt", idx, tilt)
	log.Println("  Function successfully completed.")

}

/*
   Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts. This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough. "max_stages" controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care! "tolerance_degrees" controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
*/
func (o *Curve3D) Tessellate(maxStages int64, toleranceDegrees float64) *PoolVector3Array {
	log.Println("Calling Curve3D.Tessellate()")

	returnValue := godotCallPoolVector3ArrayIntFloat(o, "tessellate", maxStages, toleranceDegrees)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Curve3DImplementer is an interface for Curve3D objects.
*/
type Curve3DImplementer interface {
	Class
}

/*
   Renders a given [Curve] provided to it. Simplifies the task of drawing curves and/or saving them as image files.
*/
type CurveTexture struct {
	Texture
}

func (o *CurveTexture) baseClass() string {
	return "CurveTexture"
}

/*
   Undocumented
*/
func (o *CurveTexture) X_Update() {
	log.Println("Calling CurveTexture.X_Update()")

	godotCallVoid(o, "_update")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CurveTexture) GetCurve() *Curve {
	log.Println("Calling CurveTexture.GetCurve()")

	returnValue := godotCallObject(o, "get_curve")
	log.Println("  Got return value: ", returnValue)

	var ret Curve
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *CurveTexture) SetCurve(curve *Curve) {
	log.Println("Calling CurveTexture.SetCurve()")

	godotCallVoidObject(o, "set_curve", &curve.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CurveTexture) SetWidth(width int64) {
	log.Println("Calling CurveTexture.SetWidth()")

	godotCallVoidInt(o, "set_width", width)
	log.Println("  Function successfully completed.")

}

/*
   CurveTextureImplementer is an interface for CurveTexture objects.
*/
type CurveTextureImplementer interface {
	Class
}

/*
   Class representing a cylindrical [PrimitiveMesh].
*/
type CylinderMesh struct {
	PrimitiveMesh
}

func (o *CylinderMesh) baseClass() string {
	return "CylinderMesh"
}

/*
   Undocumented
*/
func (o *CylinderMesh) GetBottomRadius() float64 {
	log.Println("Calling CylinderMesh.GetBottomRadius()")

	returnValue := godotCallFloat(o, "get_bottom_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CylinderMesh) GetHeight() float64 {
	log.Println("Calling CylinderMesh.GetHeight()")

	returnValue := godotCallFloat(o, "get_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CylinderMesh) GetRadialSegments() int64 {
	log.Println("Calling CylinderMesh.GetRadialSegments()")

	returnValue := godotCallInt(o, "get_radial_segments")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CylinderMesh) GetRings() int64 {
	log.Println("Calling CylinderMesh.GetRings()")

	returnValue := godotCallInt(o, "get_rings")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CylinderMesh) GetTopRadius() float64 {
	log.Println("Calling CylinderMesh.GetTopRadius()")

	returnValue := godotCallFloat(o, "get_top_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *CylinderMesh) SetBottomRadius(radius float64) {
	log.Println("Calling CylinderMesh.SetBottomRadius()")

	godotCallVoidFloat(o, "set_bottom_radius", radius)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CylinderMesh) SetHeight(height float64) {
	log.Println("Calling CylinderMesh.SetHeight()")

	godotCallVoidFloat(o, "set_height", height)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CylinderMesh) SetRadialSegments(segments int64) {
	log.Println("Calling CylinderMesh.SetRadialSegments()")

	godotCallVoidInt(o, "set_radial_segments", segments)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CylinderMesh) SetRings(rings int64) {
	log.Println("Calling CylinderMesh.SetRings()")

	godotCallVoidInt(o, "set_rings", rings)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *CylinderMesh) SetTopRadius(radius float64) {
	log.Println("Calling CylinderMesh.SetTopRadius()")

	godotCallVoidFloat(o, "set_top_radius", radius)
	log.Println("  Function successfully completed.")

}

/*
   CylinderMeshImplementer is an interface for CylinderMesh objects.
*/
type CylinderMeshImplementer interface {
	Class
}

/*
   Damped spring constraint for 2D physics. This resembles a spring joint that always wants to go back to a given length.
*/
type DampedSpringJoint2D struct {
	Joint2D
}

func (o *DampedSpringJoint2D) baseClass() string {
	return "DampedSpringJoint2D"
}

/*
   Undocumented
*/
func (o *DampedSpringJoint2D) GetDamping() float64 {
	log.Println("Calling DampedSpringJoint2D.GetDamping()")

	returnValue := godotCallFloat(o, "get_damping")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DampedSpringJoint2D) GetLength() float64 {
	log.Println("Calling DampedSpringJoint2D.GetLength()")

	returnValue := godotCallFloat(o, "get_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DampedSpringJoint2D) GetRestLength() float64 {
	log.Println("Calling DampedSpringJoint2D.GetRestLength()")

	returnValue := godotCallFloat(o, "get_rest_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DampedSpringJoint2D) GetStiffness() float64 {
	log.Println("Calling DampedSpringJoint2D.GetStiffness()")

	returnValue := godotCallFloat(o, "get_stiffness")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DampedSpringJoint2D) SetDamping(damping float64) {
	log.Println("Calling DampedSpringJoint2D.SetDamping()")

	godotCallVoidFloat(o, "set_damping", damping)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *DampedSpringJoint2D) SetLength(length float64) {
	log.Println("Calling DampedSpringJoint2D.SetLength()")

	godotCallVoidFloat(o, "set_length", length)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *DampedSpringJoint2D) SetRestLength(restLength float64) {
	log.Println("Calling DampedSpringJoint2D.SetRestLength()")

	godotCallVoidFloat(o, "set_rest_length", restLength)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *DampedSpringJoint2D) SetStiffness(stiffness float64) {
	log.Println("Calling DampedSpringJoint2D.SetStiffness()")

	godotCallVoidFloat(o, "set_stiffness", stiffness)
	log.Println("  Function successfully completed.")

}

/*
   DampedSpringJoint2DImplementer is an interface for DampedSpringJoint2D objects.
*/
type DampedSpringJoint2DImplementer interface {
	Class
}

/*
   A DirectionalLight is a type of [Light] node that emits light constantly in one direction (the negative z axis of the node). It is used lights with strong intensity that are located far away from the scene to model sunlight or moonlight. The worldspace location of the DirectionalLight transform (origin) is ignored, only the basis is used do determine light direction.
*/
type DirectionalLight struct {
	Light
}

func (o *DirectionalLight) baseClass() string {
	return "DirectionalLight"
}

/*
   Undocumented
*/
func (o *DirectionalLight) GetShadowDepthRange() int64 {
	log.Println("Calling DirectionalLight.GetShadowDepthRange()")

	returnValue := godotCallInt(o, "get_shadow_depth_range")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DirectionalLight) GetShadowMode() int64 {
	log.Println("Calling DirectionalLight.GetShadowMode()")

	returnValue := godotCallInt(o, "get_shadow_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DirectionalLight) IsBlendSplitsEnabled() bool {
	log.Println("Calling DirectionalLight.IsBlendSplitsEnabled()")

	returnValue := godotCallBool(o, "is_blend_splits_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DirectionalLight) SetBlendSplits(enabled bool) {
	log.Println("Calling DirectionalLight.SetBlendSplits()")

	godotCallVoidBool(o, "set_blend_splits", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *DirectionalLight) SetShadowDepthRange(mode int64) {
	log.Println("Calling DirectionalLight.SetShadowDepthRange()")

	godotCallVoidInt(o, "set_shadow_depth_range", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *DirectionalLight) SetShadowMode(mode int64) {
	log.Println("Calling DirectionalLight.SetShadowMode()")

	godotCallVoidInt(o, "set_shadow_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   DirectionalLightImplementer is an interface for DirectionalLight objects.
*/
type DirectionalLightImplementer interface {
	Class
}

/*
   DynamicFont renders vector font files (such as TTF or OTF) dynamically at runtime instead of using a prerendered texture atlas like [BitmapFont]. This trades the faster loading time of [BitmapFont]s for the ability to change font parameters like size and spacing during runtime. [DynamicFontData] is used for referencing the font file paths.
*/
type DynamicFont struct {
	Font
}

func (o *DynamicFont) baseClass() string {
	return "DynamicFont"
}

/*
   Adds a fallback font.
*/
func (o *DynamicFont) AddFallback(data *DynamicFontData) {
	log.Println("Calling DynamicFont.AddFallback()")

	godotCallVoidObject(o, "add_fallback", &data.Object)
	log.Println("  Function successfully completed.")

}

/*
   Returns the fallback font at index [code]idx[/code].
*/
func (o *DynamicFont) GetFallback(idx int64) *DynamicFontData {
	log.Println("Calling DynamicFont.GetFallback()")

	returnValue := godotCallObjectInt(o, "get_fallback", idx)
	log.Println("  Got return value: ", returnValue)

	var ret DynamicFontData
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of fallback fonts.
*/
func (o *DynamicFont) GetFallbackCount() int64 {
	log.Println("Calling DynamicFont.GetFallbackCount()")

	returnValue := godotCallInt(o, "get_fallback_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DynamicFont) GetFontData() *DynamicFontData {
	log.Println("Calling DynamicFont.GetFontData()")

	returnValue := godotCallObject(o, "get_font_data")
	log.Println("  Got return value: ", returnValue)

	var ret DynamicFontData
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *DynamicFont) GetSize() int64 {
	log.Println("Calling DynamicFont.GetSize()")

	returnValue := godotCallInt(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DynamicFont) GetSpacing(aType int64) int64 {
	log.Println("Calling DynamicFont.GetSpacing()")

	returnValue := godotCallIntInt(o, "get_spacing", aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DynamicFont) GetUseFilter() bool {
	log.Println("Calling DynamicFont.GetUseFilter()")

	returnValue := godotCallBool(o, "get_use_filter")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DynamicFont) GetUseMipmaps() bool {
	log.Println("Calling DynamicFont.GetUseMipmaps()")

	returnValue := godotCallBool(o, "get_use_mipmaps")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes the fallback font at index [code]idx[/code].
*/
func (o *DynamicFont) RemoveFallback(idx int64) {
	log.Println("Calling DynamicFont.RemoveFallback()")

	godotCallVoidInt(o, "remove_fallback", idx)
	log.Println("  Function successfully completed.")

}

/*
   Sets the fallback font at index [code]idx[/code].
*/
func (o *DynamicFont) SetFallback(idx int64, data *DynamicFontData) {
	log.Println("Calling DynamicFont.SetFallback()")

	godotCallVoidIntObject(o, "set_fallback", idx, &data.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *DynamicFont) SetFontData(data *DynamicFontData) {
	log.Println("Calling DynamicFont.SetFontData()")

	godotCallVoidObject(o, "set_font_data", &data.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *DynamicFont) SetSize(data int64) {
	log.Println("Calling DynamicFont.SetSize()")

	godotCallVoidInt(o, "set_size", data)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *DynamicFont) SetSpacing(aType int64, value int64) {
	log.Println("Calling DynamicFont.SetSpacing()")

	godotCallVoidIntInt(o, "set_spacing", aType, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *DynamicFont) SetUseFilter(enable bool) {
	log.Println("Calling DynamicFont.SetUseFilter()")

	godotCallVoidBool(o, "set_use_filter", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *DynamicFont) SetUseMipmaps(enable bool) {
	log.Println("Calling DynamicFont.SetUseMipmaps()")

	godotCallVoidBool(o, "set_use_mipmaps", enable)
	log.Println("  Function successfully completed.")

}

/*
   DynamicFontImplementer is an interface for DynamicFont objects.
*/
type DynamicFontImplementer interface {
	Class
}

/*
   Used with [DynamicFont] to describe the location of a vector font file for dynamic rendering at runtime.
*/
type DynamicFontData struct {
	Resource
}

func (o *DynamicFontData) baseClass() string {
	return "DynamicFontData"
}

/*
   Undocumented
*/
func (o *DynamicFontData) GetFontPath() string {
	log.Println("Calling DynamicFontData.GetFontPath()")

	returnValue := godotCallString(o, "get_font_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *DynamicFontData) SetFontPath(path string) {
	log.Println("Calling DynamicFontData.SetFontPath()")

	godotCallVoidString(o, "set_font_path", path)
	log.Println("  Function successfully completed.")

}

/*
   DynamicFontDataImplementer is an interface for DynamicFontData objects.
*/
type DynamicFontDataImplementer interface {
	Class
}

/*

 */
type EditorExportPlugin struct {
	Reference
}

func (o *EditorExportPlugin) baseClass() string {
	return "EditorExportPlugin"
}

/*

 */
func (o *EditorExportPlugin) X_ExportBegin(features *PoolStringArray, isDebug bool, path string, flags int64) {
	log.Println("Calling EditorExportPlugin.X_ExportBegin()")

	godotCallVoidPoolStringArrayBoolStringInt(o, "_export_begin", features, isDebug, path, flags)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorExportPlugin) X_ExportFile(path string, aType string, features *PoolStringArray) {
	log.Println("Calling EditorExportPlugin.X_ExportFile()")

	godotCallVoidStringStringPoolStringArray(o, "_export_file", path, aType, features)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorExportPlugin) AddFile(path string, file *PoolByteArray, remap bool) {
	log.Println("Calling EditorExportPlugin.AddFile()")

	godotCallVoidStringPoolByteArrayBool(o, "add_file", path, file, remap)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorExportPlugin) AddIosBundleFile(path string) {
	log.Println("Calling EditorExportPlugin.AddIosBundleFile()")

	godotCallVoidString(o, "add_ios_bundle_file", path)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorExportPlugin) AddIosCppCode(code string) {
	log.Println("Calling EditorExportPlugin.AddIosCppCode()")

	godotCallVoidString(o, "add_ios_cpp_code", code)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorExportPlugin) AddIosFramework(path string) {
	log.Println("Calling EditorExportPlugin.AddIosFramework()")

	godotCallVoidString(o, "add_ios_framework", path)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorExportPlugin) AddIosLinkerFlags(flags string) {
	log.Println("Calling EditorExportPlugin.AddIosLinkerFlags()")

	godotCallVoidString(o, "add_ios_linker_flags", flags)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorExportPlugin) AddIosPlistContent(plistContent string) {
	log.Println("Calling EditorExportPlugin.AddIosPlistContent()")

	godotCallVoidString(o, "add_ios_plist_content", plistContent)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorExportPlugin) AddSharedObject(path string, tags *PoolStringArray) {
	log.Println("Calling EditorExportPlugin.AddSharedObject()")

	godotCallVoidStringPoolStringArray(o, "add_shared_object", path, tags)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorExportPlugin) Skip() {
	log.Println("Calling EditorExportPlugin.Skip()")

	godotCallVoid(o, "skip")
	log.Println("  Function successfully completed.")

}

/*
   EditorExportPluginImplementer is an interface for EditorExportPlugin objects.
*/
type EditorExportPluginImplementer interface {
	Class
}

/*

 */
type EditorFileDialog struct {
	ConfirmationDialog
}

func (o *EditorFileDialog) baseClass() string {
	return "EditorFileDialog"
}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ActionPressed() {
	log.Println("Calling EditorFileDialog.X_ActionPressed()")

	godotCallVoid(o, "_action_pressed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_CancelPressed() {
	log.Println("Calling EditorFileDialog.X_CancelPressed()")

	godotCallVoid(o, "_cancel_pressed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_DirEntered(arg0 string) {
	log.Println("Calling EditorFileDialog.X_DirEntered()")

	godotCallVoidString(o, "_dir_entered", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FavoriteMoveDown() {
	log.Println("Calling EditorFileDialog.X_FavoriteMoveDown()")

	godotCallVoid(o, "_favorite_move_down")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FavoriteMoveUp() {
	log.Println("Calling EditorFileDialog.X_FavoriteMoveUp()")

	godotCallVoid(o, "_favorite_move_up")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FavoriteSelected(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_FavoriteSelected()")

	godotCallVoidInt(o, "_favorite_selected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FavoriteToggled(arg0 bool) {
	log.Println("Calling EditorFileDialog.X_FavoriteToggled()")

	godotCallVoidBool(o, "_favorite_toggled", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FileEntered(arg0 string) {
	log.Println("Calling EditorFileDialog.X_FileEntered()")

	godotCallVoidString(o, "_file_entered", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_FilterSelected(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_FilterSelected()")

	godotCallVoidInt(o, "_filter_selected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_GoBack() {
	log.Println("Calling EditorFileDialog.X_GoBack()")

	godotCallVoid(o, "_go_back")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_GoForward() {
	log.Println("Calling EditorFileDialog.X_GoForward()")

	godotCallVoid(o, "_go_forward")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_GoUp() {
	log.Println("Calling EditorFileDialog.X_GoUp()")

	godotCallVoid(o, "_go_up")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ItemDbSelected(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_ItemDbSelected()")

	godotCallVoidInt(o, "_item_db_selected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ItemListItemRmbSelected(arg0 int64, arg1 *Vector2) {
	log.Println("Calling EditorFileDialog.X_ItemListItemRmbSelected()")

	godotCallVoidIntVector2(o, "_item_list_item_rmb_selected", arg0, arg1)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ItemListRmbClicked(arg0 *Vector2) {
	log.Println("Calling EditorFileDialog.X_ItemListRmbClicked()")

	godotCallVoidVector2(o, "_item_list_rmb_clicked", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ItemMenuIdPressed(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_ItemMenuIdPressed()")

	godotCallVoidInt(o, "_item_menu_id_pressed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ItemSelected(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_ItemSelected()")

	godotCallVoidInt(o, "_item_selected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ItemsClearSelection() {
	log.Println("Calling EditorFileDialog.X_ItemsClearSelection()")

	godotCallVoid(o, "_items_clear_selection")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_MakeDir() {
	log.Println("Calling EditorFileDialog.X_MakeDir()")

	godotCallVoid(o, "_make_dir")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_MakeDirConfirm() {
	log.Println("Calling EditorFileDialog.X_MakeDirConfirm()")

	godotCallVoid(o, "_make_dir_confirm")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_RecentSelected(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_RecentSelected()")

	godotCallVoidInt(o, "_recent_selected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_SaveConfirmPressed() {
	log.Println("Calling EditorFileDialog.X_SaveConfirmPressed()")

	godotCallVoid(o, "_save_confirm_pressed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_SelectDrive(arg0 int64) {
	log.Println("Calling EditorFileDialog.X_SelectDrive()")

	godotCallVoidInt(o, "_select_drive", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ThumbnailDone(arg0 string, arg1 *Texture, arg2 *Variant) {
	log.Println("Calling EditorFileDialog.X_ThumbnailDone()")

	godotCallVoidStringObjectVariant(o, "_thumbnail_done", arg0, &arg1.Object, arg2)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_ThumbnailResult(arg0 string, arg1 *Texture, arg2 *Variant) {
	log.Println("Calling EditorFileDialog.X_ThumbnailResult()")

	godotCallVoidStringObjectVariant(o, "_thumbnail_result", arg0, &arg1.Object, arg2)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_UnhandledInput(arg0 *InputEvent) {
	log.Println("Calling EditorFileDialog.X_UnhandledInput()")

	godotCallVoidObject(o, "_unhandled_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_UpdateDir() {
	log.Println("Calling EditorFileDialog.X_UpdateDir()")

	godotCallVoid(o, "_update_dir")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) X_UpdateFileList() {
	log.Println("Calling EditorFileDialog.X_UpdateFileList()")

	godotCallVoid(o, "_update_file_list")
	log.Println("  Function successfully completed.")

}

/*
   Adds a comma-delimited file extension filter option to the [code]EditorFileDialog[/code] with an optional semi-colon-delimited label. Example: "*.tscn, *.scn; Scenes", results in filter text "Scenes (*.tscn, *.scn)".
*/
func (o *EditorFileDialog) AddFilter(filter string) {
	log.Println("Calling EditorFileDialog.AddFilter()")

	godotCallVoidString(o, "add_filter", filter)
	log.Println("  Function successfully completed.")

}

/*
   Removes all filters except for "All Files (*)".
*/
func (o *EditorFileDialog) ClearFilters() {
	log.Println("Calling EditorFileDialog.ClearFilters()")

	godotCallVoid(o, "clear_filters")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) GetAccess() int64 {
	log.Println("Calling EditorFileDialog.GetAccess()")

	returnValue := godotCallInt(o, "get_access")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorFileDialog) GetCurrentDir() string {
	log.Println("Calling EditorFileDialog.GetCurrentDir()")

	returnValue := godotCallString(o, "get_current_dir")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorFileDialog) GetCurrentFile() string {
	log.Println("Calling EditorFileDialog.GetCurrentFile()")

	returnValue := godotCallString(o, "get_current_file")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorFileDialog) GetCurrentPath() string {
	log.Println("Calling EditorFileDialog.GetCurrentPath()")

	returnValue := godotCallString(o, "get_current_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorFileDialog) GetDisplayMode() int64 {
	log.Println("Calling EditorFileDialog.GetDisplayMode()")

	returnValue := godotCallInt(o, "get_display_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorFileDialog) GetMode() int64 {
	log.Println("Calling EditorFileDialog.GetMode()")

	returnValue := godotCallInt(o, "get_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [code]VBoxContainer[/code] used to display the file system.
*/
func (o *EditorFileDialog) GetVbox() *VBoxContainer {
	log.Println("Calling EditorFileDialog.GetVbox()")

	returnValue := godotCallObject(o, "get_vbox")
	log.Println("  Got return value: ", returnValue)

	var ret VBoxContainer
	ret.owner = returnValue.owner
	return &ret

}

/*
   Notify the [code]EditorFileDialog[/code] that its view of the data is no longer accurate. Updates the view contents on next view update.
*/
func (o *EditorFileDialog) Invalidate() {
	log.Println("Calling EditorFileDialog.Invalidate()")

	godotCallVoid(o, "invalidate")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) IsOverwriteWarningDisabled() bool {
	log.Println("Calling EditorFileDialog.IsOverwriteWarningDisabled()")

	returnValue := godotCallBool(o, "is_overwrite_warning_disabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorFileDialog) IsShowingHiddenFiles() bool {
	log.Println("Calling EditorFileDialog.IsShowingHiddenFiles()")

	returnValue := godotCallBool(o, "is_showing_hidden_files")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *EditorFileDialog) SetAccess(access int64) {
	log.Println("Calling EditorFileDialog.SetAccess()")

	godotCallVoidInt(o, "set_access", access)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) SetCurrentDir(dir string) {
	log.Println("Calling EditorFileDialog.SetCurrentDir()")

	godotCallVoidString(o, "set_current_dir", dir)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) SetCurrentFile(file string) {
	log.Println("Calling EditorFileDialog.SetCurrentFile()")

	godotCallVoidString(o, "set_current_file", file)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) SetCurrentPath(path string) {
	log.Println("Calling EditorFileDialog.SetCurrentPath()")

	godotCallVoidString(o, "set_current_path", path)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) SetDisableOverwriteWarning(disable bool) {
	log.Println("Calling EditorFileDialog.SetDisableOverwriteWarning()")

	godotCallVoidBool(o, "set_disable_overwrite_warning", disable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) SetDisplayMode(mode int64) {
	log.Println("Calling EditorFileDialog.SetDisplayMode()")

	godotCallVoidInt(o, "set_display_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) SetMode(mode int64) {
	log.Println("Calling EditorFileDialog.SetMode()")

	godotCallVoidInt(o, "set_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorFileDialog) SetShowHiddenFiles(show bool) {
	log.Println("Calling EditorFileDialog.SetShowHiddenFiles()")

	godotCallVoidBool(o, "set_show_hidden_files", show)
	log.Println("  Function successfully completed.")

}

/*
   EditorFileDialogImplementer is an interface for EditorFileDialog objects.
*/
type EditorFileDialogImplementer interface {
	Class
}

/*
   This object holds information of all resources in the filesystem, their types, etc.
*/
type EditorFileSystem struct {
	Node
}

func (o *EditorFileSystem) baseClass() string {
	return "EditorFileSystem"
}

/*
   Get the type of the file, given the full path.
*/
func (o *EditorFileSystem) GetFileType(path string) string {
	log.Println("Calling EditorFileSystem.GetFileType()")

	returnValue := godotCallStringString(o, "get_file_type", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the root directory object.
*/
func (o *EditorFileSystem) GetFilesystem() *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystem.GetFilesystem()")

	returnValue := godotCallObject(o, "get_filesystem")
	log.Println("  Got return value: ", returnValue)

	var ret EditorFileSystemDirectory
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns a view into the filesystem at [code]path[/code].
*/
func (o *EditorFileSystem) GetFilesystemPath(path string) *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystem.GetFilesystemPath()")

	returnValue := godotCallObjectString(o, "get_filesystem_path", path)
	log.Println("  Got return value: ", returnValue)

	var ret EditorFileSystemDirectory
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the scan progress for 0 to 1 if the FS is being scanned.
*/
func (o *EditorFileSystem) GetScanningProgress() float64 {
	log.Println("Calling EditorFileSystem.GetScanningProgress()")

	returnValue := godotCallFloat(o, "get_scanning_progress")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return true of the filesystem is being scanned.
*/
func (o *EditorFileSystem) IsScanning() bool {
	log.Println("Calling EditorFileSystem.IsScanning()")

	returnValue := godotCallBool(o, "is_scanning")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Scan the filesystem for changes.
*/
func (o *EditorFileSystem) Scan() {
	log.Println("Calling EditorFileSystem.Scan()")

	godotCallVoid(o, "scan")
	log.Println("  Function successfully completed.")

}

/*
   Check if the source of any imported resource changed.
*/
func (o *EditorFileSystem) ScanSources() {
	log.Println("Calling EditorFileSystem.ScanSources()")

	godotCallVoid(o, "scan_sources")
	log.Println("  Function successfully completed.")

}

/*
   Update a file information. Call this if an external program (not Godot) modified the file.
*/
func (o *EditorFileSystem) UpdateFile(path string) {
	log.Println("Calling EditorFileSystem.UpdateFile()")

	godotCallVoidString(o, "update_file", path)
	log.Println("  Function successfully completed.")

}

/*
   EditorFileSystemImplementer is an interface for EditorFileSystem objects.
*/
type EditorFileSystemImplementer interface {
	Class
}

/*
   A more generalized, low-level variation of the directory concept.
*/
type EditorFileSystemDirectory struct {
	Object
}

func (o *EditorFileSystemDirectory) baseClass() string {
	return "EditorFileSystemDirectory"
}

/*
   Returns the index of the directory with name [code]name[/code] or [code]-1[/code] if not found.
*/
func (o *EditorFileSystemDirectory) FindDirIndex(name string) int64 {
	log.Println("Calling EditorFileSystemDirectory.FindDirIndex()")

	returnValue := godotCallIntString(o, "find_dir_index", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the index of the file with name [code]name[/code] or [code]-1[/code] if not found.
*/
func (o *EditorFileSystemDirectory) FindFileIndex(name string) int64 {
	log.Println("Calling EditorFileSystemDirectory.FindFileIndex()")

	returnValue := godotCallIntString(o, "find_file_index", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the name of the file at index [code]idx[/code].
*/
func (o *EditorFileSystemDirectory) GetFile(idx int64) string {
	log.Println("Calling EditorFileSystemDirectory.GetFile()")

	returnValue := godotCallStringInt(o, "get_file", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of files in this directory.
*/
func (o *EditorFileSystemDirectory) GetFileCount() int64 {
	log.Println("Calling EditorFileSystemDirectory.GetFileCount()")

	returnValue := godotCallInt(o, "get_file_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the file at index [code]idx[/code] imported properly.
*/
func (o *EditorFileSystemDirectory) GetFileImportIsValid(idx int64) bool {
	log.Println("Calling EditorFileSystemDirectory.GetFileImportIsValid()")

	returnValue := godotCallBoolInt(o, "get_file_import_is_valid", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the path to the file at index [code]idx[/code].
*/
func (o *EditorFileSystemDirectory) GetFilePath(idx int64) string {
	log.Println("Calling EditorFileSystemDirectory.GetFilePath()")

	returnValue := godotCallStringInt(o, "get_file_path", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the file extension of the file at index [code]idx[/code].
*/
func (o *EditorFileSystemDirectory) GetFileType(idx int64) string {
	log.Println("Calling EditorFileSystemDirectory.GetFileType()")

	returnValue := godotCallStringInt(o, "get_file_type", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the name of this directory.
*/
func (o *EditorFileSystemDirectory) GetName() string {
	log.Println("Calling EditorFileSystemDirectory.GetName()")

	returnValue := godotCallString(o, "get_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the parent directory for this directory or null if called on a directory at [code]res://[/code] or [code]user://[/code].
*/
func (o *EditorFileSystemDirectory) GetParent() *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystemDirectory.GetParent()")

	returnValue := godotCallObject(o, "get_parent")
	log.Println("  Got return value: ", returnValue)

	var ret EditorFileSystemDirectory
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the path to this directory.
*/
func (o *EditorFileSystemDirectory) GetPath() string {
	log.Println("Calling EditorFileSystemDirectory.GetPath()")

	returnValue := godotCallString(o, "get_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the subdirectory at index [code]idx[/code].
*/
func (o *EditorFileSystemDirectory) GetSubdir(idx int64) *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystemDirectory.GetSubdir()")

	returnValue := godotCallObjectInt(o, "get_subdir", idx)
	log.Println("  Got return value: ", returnValue)

	var ret EditorFileSystemDirectory
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of subdirectories in this directory.
*/
func (o *EditorFileSystemDirectory) GetSubdirCount() int64 {
	log.Println("Calling EditorFileSystemDirectory.GetSubdirCount()")

	returnValue := godotCallInt(o, "get_subdir_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   EditorFileSystemDirectoryImplementer is an interface for EditorFileSystemDirectory objects.
*/
type EditorFileSystemDirectoryImplementer interface {
	Class
}

/*
   EditorImportPlugins provide a way to extend the editor's resource import functionality. Use them to import resources from custom files or to provide alternatives to the editor's existing importers. Register your [EditorPlugin] with [method EditorPlugin.add_import_plugin]. EditorImportPlugins work by associating with specific file extensions and a resource type. See [method get_recognized_extension] and [method get_resource_type]). They may optionally specify some import presets that affect the import process. EditorImportPlugins are responsible for creating the resources and saving them in the [code].import[/code] directory. Below is an example EditorImportPlugin that imports a [Mesh] from a file with the extension ".special" or ".spec": [codeblock] tool extends EditorImportPlugin func get_importer_name(): return "my.special.plugin" func get_visible_name(): return "Special Mesh Importer" func get_recognized_extensions(): return ["special", "spec"] func get_save_extension(): return "mesh" func get_resource_type(): return "Mesh" func get_preset_count(): return 1 func get_preset_name(i): return "Default" func get_import_options(i): return [{"name": "my_option", "default_value": false}] func load(src, dst, opts, r_platform_variants, r_gen_files): var file = File.new() if file.open(src, File.READ) != OK: return FAILED var mesh = Mesh.new() var save = dst + "." + get_save_extension() ResourceSaver.save(file, mesh) return OK [/codeblock]
*/
type EditorImportPlugin struct {
	Reference
}

func (o *EditorImportPlugin) baseClass() string {
	return "EditorImportPlugin"
}

/*
   Get the options and default values for the preset at this index. Returns an Array of Dictionaries with the following keys: "name", "default_value", "property_hint" (optional), "hint_string" (optional), "usage" (optional).
*/
func (o *EditorImportPlugin) GetImportOptions(preset int64) *Array {
	log.Println("Calling EditorImportPlugin.GetImportOptions()")

	returnValue := godotCallArrayInt(o, "get_import_options", preset)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the unique name of the importer.
*/
func (o *EditorImportPlugin) GetImporterName() string {
	log.Println("Calling EditorImportPlugin.GetImporterName()")

	returnValue := godotCallString(o, "get_importer_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) GetOptionVisibility(option string, options *Dictionary) bool {
	log.Println("Calling EditorImportPlugin.GetOptionVisibility()")

	returnValue := godotCallBoolStringDictionary(o, "get_option_visibility", option, options)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the number of initial presets defined by the plugin. Use [method get_import_options] to get the default options for the preset and [method get_preset_name] to get the name of the preset.
*/
func (o *EditorImportPlugin) GetPresetCount() int64 {
	log.Println("Calling EditorImportPlugin.GetPresetCount()")

	returnValue := godotCallInt(o, "get_preset_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the name of the options preset at this index.
*/
func (o *EditorImportPlugin) GetPresetName(preset int64) string {
	log.Println("Calling EditorImportPlugin.GetPresetName()")

	returnValue := godotCallStringInt(o, "get_preset_name", preset)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the list of file extensions to associate with this loader (case insensitive). e.g. ["obj"].
*/
func (o *EditorImportPlugin) GetRecognizedExtensions() *Array {
	log.Println("Calling EditorImportPlugin.GetRecognizedExtensions()")

	returnValue := godotCallArray(o, "get_recognized_extensions")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the godot resource type associated with this loader. e.g. "Mesh" or "Animation".
*/
func (o *EditorImportPlugin) GetResourceType() string {
	log.Println("Calling EditorImportPlugin.GetResourceType()")

	returnValue := godotCallString(o, "get_resource_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the extension used to save this resource in the [code].import[/code] directory.
*/
func (o *EditorImportPlugin) GetSaveExtension() string {
	log.Println("Calling EditorImportPlugin.GetSaveExtension()")

	returnValue := godotCallString(o, "get_save_extension")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the name to display in the import window.
*/
func (o *EditorImportPlugin) GetVisibleName() string {
	log.Println("Calling EditorImportPlugin.GetVisibleName()")

	returnValue := godotCallString(o, "get_visible_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) Import(sourceFile string, savePath string, options *Dictionary, rPlatformVariants *Array, rGenFiles *Array) int64 {
	log.Println("Calling EditorImportPlugin.Import()")

	returnValue := godotCallIntStringStringDictionaryArrayArray(o, "import", sourceFile, savePath, options, rPlatformVariants, rGenFiles)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   EditorImportPluginImplementer is an interface for EditorImportPlugin objects.
*/
type EditorImportPluginImplementer interface {
	Class
}

/*
   Editor interface. Allows saving and (re-)loading scenes, rendering mesh previews, inspecting and editing resources and objects and provides access to [EditorSettings], [EditorFileSystem], [EditorResourcePreview]\ er, [ScriptEditor], the editor viewport, as well as information about scenes. Also see [EditorPlugin] and [EditorScript].
*/
type EditorInterface struct {
	Node
}

func (o *EditorInterface) baseClass() string {
	return "EditorInterface"
}

/*
   Edits the given [Resource].
*/
func (o *EditorInterface) EditResource(resource *Resource) {
	log.Println("Calling EditorInterface.EditResource()")

	godotCallVoidObject(o, "edit_resource", &resource.Object)
	log.Println("  Function successfully completed.")

}

/*
   Returns the base [Control].
*/
func (o *EditorInterface) GetBaseControl() *Control {
	log.Println("Calling EditorInterface.GetBaseControl()")

	returnValue := godotCallObject(o, "get_base_control")
	log.Println("  Got return value: ", returnValue)

	var ret Control
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the edited scene's root [Node].
*/
func (o *EditorInterface) GetEditedSceneRoot() *Node {
	log.Println("Calling EditorInterface.GetEditedSceneRoot()")

	returnValue := godotCallObject(o, "get_edited_scene_root")
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the [EditorSettings].
*/
func (o *EditorInterface) GetEditorSettings() *EditorSettings {
	log.Println("Calling EditorInterface.GetEditorSettings()")

	returnValue := godotCallObject(o, "get_editor_settings")
	log.Println("  Got return value: ", returnValue)

	var ret EditorSettings
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the editor [Viewport].
*/
func (o *EditorInterface) GetEditorViewport() *Control {
	log.Println("Calling EditorInterface.GetEditorViewport()")

	returnValue := godotCallObject(o, "get_editor_viewport")
	log.Println("  Got return value: ", returnValue)

	var ret Control
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns an [Array] of the currently opened scenes.
*/
func (o *EditorInterface) GetOpenScenes() *Array {
	log.Println("Calling EditorInterface.GetOpenScenes()")

	returnValue := godotCallArray(o, "get_open_scenes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [EditorFileSystem].
*/
func (o *EditorInterface) GetResourceFilesystem() *EditorFileSystem {
	log.Println("Calling EditorInterface.GetResourceFilesystem()")

	returnValue := godotCallObject(o, "get_resource_filesystem")
	log.Println("  Got return value: ", returnValue)

	var ret EditorFileSystem
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the [EditorResourcePreview]\ er.
*/
func (o *EditorInterface) GetResourcePreviewer() *EditorResourcePreview {
	log.Println("Calling EditorInterface.GetResourcePreviewer()")

	returnValue := godotCallObject(o, "get_resource_previewer")
	log.Println("  Got return value: ", returnValue)

	var ret EditorResourcePreview
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the [ScriptEditor].
*/
func (o *EditorInterface) GetScriptEditor() *ScriptEditor {
	log.Println("Calling EditorInterface.GetScriptEditor()")

	returnValue := godotCallObject(o, "get_script_editor")
	log.Println("  Got return value: ", returnValue)

	var ret ScriptEditor
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *EditorInterface) GetSelectedPath() string {
	log.Println("Calling EditorInterface.GetSelectedPath()")

	returnValue := godotCallString(o, "get_selected_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [EditorSelection].
*/
func (o *EditorInterface) GetSelection() *EditorSelection {
	log.Println("Calling EditorInterface.GetSelection()")

	returnValue := godotCallObject(o, "get_selection")
	log.Println("  Got return value: ", returnValue)

	var ret EditorSelection
	ret.owner = returnValue.owner
	return &ret

}

/*
   Shows the given property on the given [code]object[/code] in the Editor's Inspector dock.
*/
func (o *EditorInterface) InspectObject(object *Object, forProperty string) {
	log.Println("Calling EditorInterface.InspectObject()")

	godotCallVoidObjectString(o, "inspect_object", object, forProperty)
	log.Println("  Function successfully completed.")

}

/*
   Returns mesh previews rendered at the given size as an [Array] of [Texture]s.
*/
func (o *EditorInterface) MakeMeshPreviews(meshes *Array, previewSize int64) *Array {
	log.Println("Calling EditorInterface.MakeMeshPreviews()")

	returnValue := godotCallArrayArrayInt(o, "make_mesh_previews", meshes, previewSize)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Opens the scene at the given path.
*/
func (o *EditorInterface) OpenSceneFromPath(sceneFilepath string) {
	log.Println("Calling EditorInterface.OpenSceneFromPath()")

	godotCallVoidString(o, "open_scene_from_path", sceneFilepath)
	log.Println("  Function successfully completed.")

}

/*
   Reloads the scene at the given path.
*/
func (o *EditorInterface) ReloadSceneFromPath(sceneFilepath string) {
	log.Println("Calling EditorInterface.ReloadSceneFromPath()")

	godotCallVoidString(o, "reload_scene_from_path", sceneFilepath)
	log.Println("  Function successfully completed.")

}

/*
   Saves the scene. Returns either OK or ERR_CANT_CREATE. See [@GlobalScope] constants.
*/
func (o *EditorInterface) SaveScene() int64 {
	log.Println("Calling EditorInterface.SaveScene()")

	returnValue := godotCallInt(o, "save_scene")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Saves the scene as a file at [code]path[/code].
*/
func (o *EditorInterface) SaveSceneAs(path string, withPreview bool) {
	log.Println("Calling EditorInterface.SaveSceneAs()")

	godotCallVoidStringBool(o, "save_scene_as", path, withPreview)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorInterface) SelectFile(pFile string) {
	log.Println("Calling EditorInterface.SelectFile()")

	godotCallVoidString(o, "select_file", pFile)
	log.Println("  Function successfully completed.")

}

/*
   EditorInterfaceImplementer is an interface for EditorInterface objects.
*/
type EditorInterfaceImplementer interface {
	Class
}

/*
   Plugins are used by the editor to extend functionality. The most common types of plugins are those which edit a given node or resource type, import plugins and export plugins.
*/
type EditorPlugin struct {
	Node
}

func (o *EditorPlugin) baseClass() string {
	return "EditorPlugin"
}

/*
   Add a control to the bottom panel (together with Output, Debug, Animation, etc). Returns a reference to the button added. It's up to you to hide/show the button when needed. If your plugin is being removed, also make sure to remove your control by calling [method remove_control_from_bottom_panel].
*/
func (o *EditorPlugin) AddControlToBottomPanel(control *Object, title string) *ToolButton {
	log.Println("Calling EditorPlugin.AddControlToBottomPanel()")

	returnValue := godotCallObjectObjectString(o, "add_control_to_bottom_panel", control, title)
	log.Println("  Got return value: ", returnValue)

	var ret ToolButton
	ret.owner = returnValue.owner
	return &ret

}

/*
   Add a custom control to a container (see CONTAINER_* enum). There are many locations where custom controls can be added in the editor UI. Please remember that you have to manage the visibility of your custom controls yourself (and likely hide it after adding it). If your plugin is being removed, also make sure to remove your custom controls too.
*/
func (o *EditorPlugin) AddControlToContainer(container int64, control *Object) {
	log.Println("Calling EditorPlugin.AddControlToContainer()")

	godotCallVoidIntObject(o, "add_control_to_container", container, control)
	log.Println("  Function successfully completed.")

}

/*
   Add the control to a specific dock slot (see DOCK_* enum for options). If the dock is repositioned and as long as the plugin is active, the editor will save the dock position on further sessions. If your plugin is being removed, also make sure to remove your control by calling [method remove_control_from_docks].
*/
func (o *EditorPlugin) AddControlToDock(slot int64, control *Object) {
	log.Println("Calling EditorPlugin.AddControlToDock()")

	godotCallVoidIntObject(o, "add_control_to_dock", slot, control)
	log.Println("  Function successfully completed.")

}

/*
   Add a custom type, which will appear in the list of nodes or resources. An icon can be optionally passed. When given node or resource is selected, the base type will be instanced (ie, "Spatial", "Control", "Resource"), then the script will be loaded and set to this object. You can use the [method EditorPlugin.handles] to check if your custom object is being edited by checking the script or using 'is' keyword. During run-time, this will be a simple object with a script so this function does not need to be called then.
*/
func (o *EditorPlugin) AddCustomType(aType string, base string, script *Script, icon *Texture) {
	log.Println("Calling EditorPlugin.AddCustomType()")

	godotCallVoidStringStringObjectObject(o, "add_custom_type", aType, base, &script.Object, &icon.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) AddExportPlugin(exporter *EditorExportPlugin) {
	log.Println("Calling EditorPlugin.AddExportPlugin()")

	godotCallVoidObject(o, "add_export_plugin", &exporter.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) AddImportPlugin(importer *EditorImportPlugin) {
	log.Println("Calling EditorPlugin.AddImportPlugin()")

	godotCallVoidObject(o, "add_import_plugin", &importer.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) AddSceneImportPlugin(sceneImporter *EditorSceneImporter) {
	log.Println("Calling EditorPlugin.AddSceneImportPlugin()")

	godotCallVoidObject(o, "add_scene_import_plugin", &sceneImporter.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) AddToolSubmenuItem(name string, submenu *Object) {
	log.Println("Calling EditorPlugin.AddToolSubmenuItem()")

	godotCallVoidStringObject(o, "add_tool_submenu_item", name, submenu)
	log.Println("  Function successfully completed.")

}

/*
   This method is called when the editor is about to save the project, switch to another tab, etc. It asks the plugin to apply any pending state changes to ensure consistency. This is used, for example, in shader editors to let the plugin know that it must apply the shader code being written by the user to the object.
*/
func (o *EditorPlugin) ApplyChanges() {
	log.Println("Calling EditorPlugin.ApplyChanges()")

	godotCallVoid(o, "apply_changes")
	log.Println("  Function successfully completed.")

}

/*
   Clear all the state and reset the object being edited to zero. This ensures your plugin does not keep editing a currently existing node, or a node from the wrong scene.
*/
func (o *EditorPlugin) Clear() {
	log.Println("Calling EditorPlugin.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   This is used for plugins that create gizmos used by the spatial editor. Just check that the node passed in the "for_spatial" argument matches your plugin.
*/
func (o *EditorPlugin) CreateSpatialGizmo(forSpatial *Spatial) *EditorSpatialGizmo {
	log.Println("Calling EditorPlugin.CreateSpatialGizmo()")

	returnValue := godotCallObjectObject(o, "create_spatial_gizmo", &forSpatial.Object)
	log.Println("  Got return value: ", returnValue)

	var ret EditorSpatialGizmo
	ret.owner = returnValue.owner
	return &ret

}

/*
   This function is used for plugins that edit specific object types (nodes or resources). It requests the editor to edit the given object.
*/
func (o *EditorPlugin) Edit(object *Object) {
	log.Println("Calling EditorPlugin.Edit()")

	godotCallVoidObject(o, "edit", object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) ForwardCanvasGuiInput(event *InputEvent) bool {
	log.Println("Calling EditorPlugin.ForwardCanvasGuiInput()")

	returnValue := godotCallBoolObject(o, "forward_canvas_gui_input", &event.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EditorPlugin) ForwardDrawOverViewport(overlay *Control) {
	log.Println("Calling EditorPlugin.ForwardDrawOverViewport()")

	godotCallVoidObject(o, "forward_draw_over_viewport", &overlay.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) ForwardForceDrawOverViewport(overlay *Control) {
	log.Println("Calling EditorPlugin.ForwardForceDrawOverViewport()")

	godotCallVoidObject(o, "forward_force_draw_over_viewport", &overlay.Object)
	log.Println("  Function successfully completed.")

}

/*
   Implement this function if you are interested in 3D view screen input events. It will be called only if currently selected node is handled by your plugin. If you would like to always gets those input events then additionally use [method set_input_forwarding_always_enabled].
*/
func (o *EditorPlugin) ForwardSpatialGuiInput(camera *Camera, event *InputEvent) bool {
	log.Println("Calling EditorPlugin.ForwardSpatialGuiInput()")

	returnValue := godotCallBoolObjectObject(o, "forward_spatial_gui_input", &camera.Object, &event.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   This is for editors that edit script based objects. You can return a list of breakpoints in the format (script:line), for example: res://path_to_script.gd:25
*/
func (o *EditorPlugin) GetBreakpoints() *PoolStringArray {
	log.Println("Calling EditorPlugin.GetBreakpoints()")

	returnValue := godotCallPoolStringArray(o, "get_breakpoints")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EditorPlugin) GetEditorInterface() *EditorInterface {
	log.Println("Calling EditorPlugin.GetEditorInterface()")

	returnValue := godotCallObject(o, "get_editor_interface")
	log.Println("  Got return value: ", returnValue)

	var ret EditorInterface
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *EditorPlugin) GetPluginIcon() *Object {
	log.Println("Calling EditorPlugin.GetPluginIcon()")

	returnValue := godotCallObject(o, "get_plugin_icon")
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *EditorPlugin) GetPluginName() string {
	log.Println("Calling EditorPlugin.GetPluginName()")

	returnValue := godotCallString(o, "get_plugin_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the state of your plugin editor. This is used when saving the scene (so state is kept when opening it again) and for switching tabs (so state can be restored when the tab returns).
*/
func (o *EditorPlugin) GetState() *Dictionary {
	log.Println("Calling EditorPlugin.GetState()")

	returnValue := godotCallDictionary(o, "get_state")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the undo/redo object. Most actions in the editor can be undoable, so use this object to make sure this happens when it's worth it.
*/
func (o *EditorPlugin) GetUndoRedo() *UndoRedo {
	log.Println("Calling EditorPlugin.GetUndoRedo()")

	returnValue := godotCallObject(o, "get_undo_redo")
	log.Println("  Got return value: ", returnValue)

	var ret UndoRedo
	ret.owner = returnValue.owner
	return &ret

}

/*
   Get the GUI layout of the plugin. This is used to save the project's editor layout when the [method EditorPlugin.queue_save_layout] is called or the editor layout was changed(For example changing the position of a dock).
*/
func (o *EditorPlugin) GetWindowLayout(layout *ConfigFile) {
	log.Println("Calling EditorPlugin.GetWindowLayout()")

	godotCallVoidObject(o, "get_window_layout", &layout.Object)
	log.Println("  Function successfully completed.")

}

/*
   Implement this function if your plugin edits a specific type of object (Resource or Node). If you return true, then you will get the functions [method EditorPlugin.edit] and [method EditorPlugin.make_visible] called when the editor requests them.
*/
func (o *EditorPlugin) Handles(object *Object) bool {
	log.Println("Calling EditorPlugin.Handles()")

	returnValue := godotCallBoolObject(o, "handles", object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return true if this is a main screen editor plugin (it goes in the main screen selector together with 2D, 3D, Script).
*/
func (o *EditorPlugin) HasMainScreen() bool {
	log.Println("Calling EditorPlugin.HasMainScreen()")

	returnValue := godotCallBool(o, "has_main_screen")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EditorPlugin) HideBottomPanel() {
	log.Println("Calling EditorPlugin.HideBottomPanel()")

	godotCallVoid(o, "hide_bottom_panel")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) MakeBottomPanelItemVisible(item *Object) {
	log.Println("Calling EditorPlugin.MakeBottomPanelItemVisible()")

	godotCallVoidObject(o, "make_bottom_panel_item_visible", item)
	log.Println("  Function successfully completed.")

}

/*
   This function will be called when the editor is requested to become visible. It is used for plugins that edit a specific object type. Remember that you have to manage the visibility of all your editor controls manually.
*/
func (o *EditorPlugin) MakeVisible(visible bool) {
	log.Println("Calling EditorPlugin.MakeVisible()")

	godotCallVoidBool(o, "make_visible", visible)
	log.Println("  Function successfully completed.")

}

/*
   Queue save the project's editor layout.
*/
func (o *EditorPlugin) QueueSaveLayout() {
	log.Println("Calling EditorPlugin.QueueSaveLayout()")

	godotCallVoid(o, "queue_save_layout")
	log.Println("  Function successfully completed.")

}

/*
   Remove the control from the bottom panel. Don't forget to call this if you added one, so the editor can remove it cleanly.
*/
func (o *EditorPlugin) RemoveControlFromBottomPanel(control *Object) {
	log.Println("Calling EditorPlugin.RemoveControlFromBottomPanel()")

	godotCallVoidObject(o, "remove_control_from_bottom_panel", control)
	log.Println("  Function successfully completed.")

}

/*
   Remove the control from the dock. Don't forget to call this if you added one, so the editor can save the layout and remove it cleanly.
*/
func (o *EditorPlugin) RemoveControlFromDocks(control *Object) {
	log.Println("Calling EditorPlugin.RemoveControlFromDocks()")

	godotCallVoidObject(o, "remove_control_from_docks", control)
	log.Println("  Function successfully completed.")

}

/*
   Remove a custom type added by [method EditorPlugin.add_custom_type]
*/
func (o *EditorPlugin) RemoveCustomType(aType string) {
	log.Println("Calling EditorPlugin.RemoveCustomType()")

	godotCallVoidString(o, "remove_custom_type", aType)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) RemoveExportPlugin(exporter *EditorExportPlugin) {
	log.Println("Calling EditorPlugin.RemoveExportPlugin()")

	godotCallVoidObject(o, "remove_export_plugin", &exporter.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) RemoveImportPlugin(importer *EditorImportPlugin) {
	log.Println("Calling EditorPlugin.RemoveImportPlugin()")

	godotCallVoidObject(o, "remove_import_plugin", &importer.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) RemoveSceneImportPlugin(sceneImporter *EditorSceneImporter) {
	log.Println("Calling EditorPlugin.RemoveSceneImportPlugin()")

	godotCallVoidObject(o, "remove_scene_import_plugin", &sceneImporter.Object)
	log.Println("  Function successfully completed.")

}

/*
   This method is called after the editor saves the project or when it's closed. It asks the plugin to save edited external scenes/resources.
*/
func (o *EditorPlugin) SaveExternalData() {
	log.Println("Calling EditorPlugin.SaveExternalData()")

	godotCallVoid(o, "save_external_data")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) SetForceDrawOverForwardingEnabled() {
	log.Println("Calling EditorPlugin.SetForceDrawOverForwardingEnabled()")

	godotCallVoid(o, "set_force_draw_over_forwarding_enabled")
	log.Println("  Function successfully completed.")

}

/*
   Use this method if you always want to receive inputs from 3D view screen inside [method forward_spatial_gui_input]. It might be especially usable if your plugin will want to use raycast in the scene.
*/
func (o *EditorPlugin) SetInputEventForwardingAlwaysEnabled() {
	log.Println("Calling EditorPlugin.SetInputEventForwardingAlwaysEnabled()")

	godotCallVoid(o, "set_input_event_forwarding_always_enabled")
	log.Println("  Function successfully completed.")

}

/*
   Restore the state saved by [method EditorPlugin.get_state].
*/
func (o *EditorPlugin) SetState(state *Dictionary) {
	log.Println("Calling EditorPlugin.SetState()")

	godotCallVoidDictionary(o, "set_state", state)
	log.Println("  Function successfully completed.")

}

/*
   Restore the plugin GUI layout saved by [method EditorPlugin.get_window_layout].
*/
func (o *EditorPlugin) SetWindowLayout(layout *ConfigFile) {
	log.Println("Calling EditorPlugin.SetWindowLayout()")

	godotCallVoidObject(o, "set_window_layout", &layout.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorPlugin) UpdateOverlays() int64 {
	log.Println("Calling EditorPlugin.UpdateOverlays()")

	returnValue := godotCallInt(o, "update_overlays")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   EditorPluginImplementer is an interface for EditorPlugin objects.
*/
type EditorPluginImplementer interface {
	Class
}

/*

 */
type EditorResourceConversionPlugin struct {
	Reference
}

func (o *EditorResourceConversionPlugin) baseClass() string {
	return "EditorResourceConversionPlugin"
}

/*

 */
func (o *EditorResourceConversionPlugin) X_Convert(resource *Resource) *Resource {
	log.Println("Calling EditorResourceConversionPlugin.X_Convert()")

	returnValue := godotCallObjectObject(o, "_convert", &resource.Object)
	log.Println("  Got return value: ", returnValue)

	var ret Resource
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *EditorResourceConversionPlugin) X_ConvertsTo() string {
	log.Println("Calling EditorResourceConversionPlugin.X_ConvertsTo()")

	returnValue := godotCallString(o, "_converts_to")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   EditorResourceConversionPluginImplementer is an interface for EditorResourceConversionPlugin objects.
*/
type EditorResourceConversionPluginImplementer interface {
	Class
}

/*
   This object is used to generate previews for resources of files.
*/
type EditorResourcePreview struct {
	Node
}

func (o *EditorResourcePreview) baseClass() string {
	return "EditorResourcePreview"
}

/*
   Undocumented
*/
func (o *EditorResourcePreview) X_PreviewReady(arg0 string, arg1 *Texture, arg2 int64, arg3 string, arg4 *Variant) {
	log.Println("Calling EditorResourcePreview.X_PreviewReady()")

	godotCallVoidStringObjectIntStringVariant(o, "_preview_ready", arg0, &arg1.Object, arg2, arg3, arg4)
	log.Println("  Function successfully completed.")

}

/*
   Create an own, custom preview generator.
*/
func (o *EditorResourcePreview) AddPreviewGenerator(generator *EditorResourcePreviewGenerator) {
	log.Println("Calling EditorResourcePreview.AddPreviewGenerator()")

	godotCallVoidObject(o, "add_preview_generator", &generator.Object)
	log.Println("  Function successfully completed.")

}

/*
   Check if the resource changed, if so it will be invalidated and the corresponding signal emitted.
*/
func (o *EditorResourcePreview) CheckForInvalidation(path string) {
	log.Println("Calling EditorResourcePreview.CheckForInvalidation()")

	godotCallVoidString(o, "check_for_invalidation", path)
	log.Println("  Function successfully completed.")

}

/*
   Queue a resource being edited for preview (using an instance). Once the preview is ready, your receiver.receiver_func will be called either containing the preview texture or an empty texture (if no preview was possible). Callback must have the format: (path,texture,userdata). Userdata can be anything.
*/
func (o *EditorResourcePreview) QueueEditedResourcePreview(resource *Resource, receiver *Object, receiverFunc string, userdata *Variant) {
	log.Println("Calling EditorResourcePreview.QueueEditedResourcePreview()")

	godotCallVoidObjectObjectStringVariant(o, "queue_edited_resource_preview", &resource.Object, receiver, receiverFunc, userdata)
	log.Println("  Function successfully completed.")

}

/*
   Queue a resource file for preview (using a path). Once the preview is ready, your receiver.receiver_func will be called either containing the preview texture or an empty texture (if no preview was possible). Callback must have the format: (path,texture,userdata). Userdata can be anything.
*/
func (o *EditorResourcePreview) QueueResourcePreview(path string, receiver *Object, receiverFunc string, userdata *Variant) {
	log.Println("Calling EditorResourcePreview.QueueResourcePreview()")

	godotCallVoidStringObjectStringVariant(o, "queue_resource_preview", path, receiver, receiverFunc, userdata)
	log.Println("  Function successfully completed.")

}

/*
   Remove a custom preview generator.
*/
func (o *EditorResourcePreview) RemovePreviewGenerator(generator *EditorResourcePreviewGenerator) {
	log.Println("Calling EditorResourcePreview.RemovePreviewGenerator()")

	godotCallVoidObject(o, "remove_preview_generator", &generator.Object)
	log.Println("  Function successfully completed.")

}

/*
   EditorResourcePreviewImplementer is an interface for EditorResourcePreview objects.
*/
type EditorResourcePreviewImplementer interface {
	Class
}

/*
   Custom code to generate previews. Please check "file_dialog/thumbnail_size" in EditorSettings to find out the right size to do previews at.
*/
type EditorResourcePreviewGenerator struct {
	Reference
}

func (o *EditorResourcePreviewGenerator) baseClass() string {
	return "EditorResourcePreviewGenerator"
}

/*
   Generate a preview from a given resource. This must be always implemented. Returning an empty texture is an OK way to fail and let another generator take care. Care must be taken because this function is always called from a thread (not the main thread).
*/
func (o *EditorResourcePreviewGenerator) Generate(from *Resource) *Texture {
	log.Println("Calling EditorResourcePreviewGenerator.Generate()")

	returnValue := godotCallObjectObject(o, "generate", &from.Object)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Generate a preview directly from a path, implementing this is optional, as default code will load and call generate() Returning an empty texture is an OK way to fail and let another generator take care. Care must be taken because this function is always called from a thread (not the main thread).
*/
func (o *EditorResourcePreviewGenerator) GenerateFromPath(path string) *Texture {
	log.Println("Calling EditorResourcePreviewGenerator.GenerateFromPath()")

	returnValue := godotCallObjectString(o, "generate_from_path", path)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return if your generator supports this resource type.
*/
func (o *EditorResourcePreviewGenerator) Handles(aType string) bool {
	log.Println("Calling EditorResourcePreviewGenerator.Handles()")

	returnValue := godotCallBoolString(o, "handles", aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   EditorResourcePreviewGeneratorImplementer is an interface for EditorResourcePreviewGenerator objects.
*/
type EditorResourcePreviewGeneratorImplementer interface {
	Class
}

/*

 */
type EditorSceneImporter struct {
	Reference
}

func (o *EditorSceneImporter) baseClass() string {
	return "EditorSceneImporter"
}

/*

 */
func (o *EditorSceneImporter) X_GetExtensions() *Array {
	log.Println("Calling EditorSceneImporter.X_GetExtensions()")

	returnValue := godotCallArray(o, "_get_extensions")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EditorSceneImporter) X_GetImportFlags() int64 {
	log.Println("Calling EditorSceneImporter.X_GetImportFlags()")

	returnValue := godotCallInt(o, "_get_import_flags")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EditorSceneImporter) X_ImportAnimation(path string, flags int64, bakeFps int64) *Animation {
	log.Println("Calling EditorSceneImporter.X_ImportAnimation()")

	returnValue := godotCallObjectStringIntInt(o, "_import_animation", path, flags, bakeFps)
	log.Println("  Got return value: ", returnValue)

	var ret Animation
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *EditorSceneImporter) X_ImportScene(path string, flags int64, bakeFps int64) *Node {
	log.Println("Calling EditorSceneImporter.X_ImportScene()")

	returnValue := godotCallObjectStringIntInt(o, "_import_scene", path, flags, bakeFps)
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *EditorSceneImporter) ImportAnimationFromOtherImporter(path string, flags int64, bakeFps int64) *Animation {
	log.Println("Calling EditorSceneImporter.ImportAnimationFromOtherImporter()")

	returnValue := godotCallObjectStringIntInt(o, "import_animation_from_other_importer", path, flags, bakeFps)
	log.Println("  Got return value: ", returnValue)

	var ret Animation
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *EditorSceneImporter) ImportSceneFromOtherImporter(path string, flags int64, bakeFps int64) *Node {
	log.Println("Calling EditorSceneImporter.ImportSceneFromOtherImporter()")

	returnValue := godotCallObjectStringIntInt(o, "import_scene_from_other_importer", path, flags, bakeFps)
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   EditorSceneImporterImplementer is an interface for EditorSceneImporter objects.
*/
type EditorSceneImporterImplementer interface {
	Class
}

/*

 */
type EditorScenePostImport struct {
	Reference
}

func (o *EditorScenePostImport) baseClass() string {
	return "EditorScenePostImport"
}

/*

 */
func (o *EditorScenePostImport) PostImport(scene *Object) {
	log.Println("Calling EditorScenePostImport.PostImport()")

	godotCallVoidObject(o, "post_import", scene)
	log.Println("  Function successfully completed.")

}

/*
   EditorScenePostImportImplementer is an interface for EditorScenePostImport objects.
*/
type EditorScenePostImportImplementer interface {
	Class
}

/*
   Scripts extending this class and implementing its [code]_run()[/code] method can be executed from the Script Editor's [code]File -> Run[/code] menu option (or by pressing [code]CTRL+Shift+X[/code]) while the editor is running. This is useful for adding custom in-editor functionality to Godot. For more complex additions, consider using [EditorPlugin]s instead. Note that extending scripts need to have [code]tool mode[/code] enabled. Example script: [codeblock] tool extends EditorScript func _run(): print("Hello from the Godot Editor!") [/codeblock] Note that the script is run in the Editor context, which means the output is visible in the console window started with the Editor (STDOUT) instead of the usual Godot [i]Output[/i] dock.
*/
type EditorScript struct {
	Reference
}

func (o *EditorScript) baseClass() string {
	return "EditorScript"
}

/*
   This method is executed by the Editor when [code]File -> Run[/code] is used.
*/
func (o *EditorScript) X_Run() {
	log.Println("Calling EditorScript.X_Run()")

	godotCallVoid(o, "_run")
	log.Println("  Function successfully completed.")

}

/*
   Adds [code]node[/code] as a child of the root node in the editor context. WARNING: The implementation of this method is currently disabled.
*/
func (o *EditorScript) AddRootNode(node *Object) {
	log.Println("Calling EditorScript.AddRootNode()")

	godotCallVoidObject(o, "add_root_node", node)
	log.Println("  Function successfully completed.")

}

/*
   Returns the [EditorInterface] singleton instance.
*/
func (o *EditorScript) GetEditorInterface() *EditorInterface {
	log.Println("Calling EditorScript.GetEditorInterface()")

	returnValue := godotCallObject(o, "get_editor_interface")
	log.Println("  Got return value: ", returnValue)

	var ret EditorInterface
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the Editor's currently active scene.
*/
func (o *EditorScript) GetScene() *Node {
	log.Println("Calling EditorScript.GetScene()")

	returnValue := godotCallObject(o, "get_scene")
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   EditorScriptImplementer is an interface for EditorScript objects.
*/
type EditorScriptImplementer interface {
	Class
}

/*
   This object manages the SceneTree selection in the editor.
*/
type EditorSelection struct {
	Object
}

func (o *EditorSelection) baseClass() string {
	return "EditorSelection"
}

/*
   Undocumented
*/
func (o *EditorSelection) X_EmitChange() {
	log.Println("Calling EditorSelection.X_EmitChange()")

	godotCallVoid(o, "_emit_change")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *EditorSelection) X_NodeRemoved(arg0 *Object) {
	log.Println("Calling EditorSelection.X_NodeRemoved()")

	godotCallVoidObject(o, "_node_removed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Add a node to the selection.
*/
func (o *EditorSelection) AddNode(node *Object) {
	log.Println("Calling EditorSelection.AddNode()")

	godotCallVoidObject(o, "add_node", node)
	log.Println("  Function successfully completed.")

}

/*
   Clear the selection.
*/
func (o *EditorSelection) Clear() {
	log.Println("Calling EditorSelection.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Get the list of selected nodes.
*/
func (o *EditorSelection) GetSelectedNodes() *Array {
	log.Println("Calling EditorSelection.GetSelectedNodes()")

	returnValue := godotCallArray(o, "get_selected_nodes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the list of selected nodes, optimized for transform operations (ie, moving them, rotating, etc). This list avoids situations where a node is selected and also chid/grandchild.
*/
func (o *EditorSelection) GetTransformableSelectedNodes() *Array {
	log.Println("Calling EditorSelection.GetTransformableSelectedNodes()")

	returnValue := godotCallArray(o, "get_transformable_selected_nodes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Remove a node from the selection.
*/
func (o *EditorSelection) RemoveNode(node *Object) {
	log.Println("Calling EditorSelection.RemoveNode()")

	godotCallVoidObject(o, "remove_node", node)
	log.Println("  Function successfully completed.")

}

/*
   EditorSelectionImplementer is an interface for EditorSelection objects.
*/
type EditorSelectionImplementer interface {
	Class
}

/*
   Object that holds the project-independent editor settings. These settings are generally visible in the Editor Settings menu. Accessing the settings is done by using the regular [Object] API, such as: [codeblock] settings.set(prop,value) settings.get(prop) list_of_settings = settings.get_property_list() [/codeblock]
*/
type EditorSettings struct {
	Resource
}

func (o *EditorSettings) baseClass() string {
	return "EditorSettings"
}

/*
   Add a custom property info to a property. The dictionary must contain: name:[String](the name of the property) and type:[int](see TYPE_* in [@GlobalScope]), and optionally hint:[int](see PROPERTY_HINT_* in [@GlobalScope]), hint_string:[String]. Example: [codeblock] editor_settings.set("category/property_name", 0) var property_info = { "name": "category/property_name", "type": TYPE_INT, "hint": PROPERTY_HINT_ENUM, "hint_string": "one,two,three" } editor_settings.add_property_info(property_info) [/codeblock]
*/
func (o *EditorSettings) AddPropertyInfo(info *Dictionary) {
	log.Println("Calling EditorSettings.AddPropertyInfo()")

	godotCallVoidDictionary(o, "add_property_info", info)
	log.Println("  Function successfully completed.")

}

/*
   Erase a given setting (pass full property path).
*/
func (o *EditorSettings) Erase(property string) {
	log.Println("Calling EditorSettings.Erase()")

	godotCallVoidString(o, "erase", property)
	log.Println("  Function successfully completed.")

}

/*
   Get the list of favorite directories for this project.
*/
func (o *EditorSettings) GetFavoriteDirs() *PoolStringArray {
	log.Println("Calling EditorSettings.GetFavoriteDirs()")

	returnValue := godotCallPoolStringArray(o, "get_favorite_dirs")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the specific project settings path. Projects all have a unique sub-directory inside the settings path where project specific settings are saved.
*/
func (o *EditorSettings) GetProjectSettingsDir() string {
	log.Println("Calling EditorSettings.GetProjectSettingsDir()")

	returnValue := godotCallString(o, "get_project_settings_dir")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the list of recently visited folders in the file dialog for this project.
*/
func (o *EditorSettings) GetRecentDirs() *PoolStringArray {
	log.Println("Calling EditorSettings.GetRecentDirs()")

	returnValue := godotCallPoolStringArray(o, "get_recent_dirs")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EditorSettings) GetSetting(name string) *Variant {
	log.Println("Calling EditorSettings.GetSetting()")

	returnValue := godotCallVariantString(o, "get_setting", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the global settings path for the engine. Inside this path you can find some standard paths such as: settings/tmp - used for temporary storage of files settings/templates - where export templates are located
*/
func (o *EditorSettings) GetSettingsDir() string {
	log.Println("Calling EditorSettings.GetSettingsDir()")

	returnValue := godotCallString(o, "get_settings_dir")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EditorSettings) HasSetting(name string) bool {
	log.Println("Calling EditorSettings.HasSetting()")

	returnValue := godotCallBoolString(o, "has_setting", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EditorSettings) PropertyCanRevert(name string) bool {
	log.Println("Calling EditorSettings.PropertyCanRevert()")

	returnValue := godotCallBoolString(o, "property_can_revert", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EditorSettings) PropertyGetRevert(name string) *Variant {
	log.Println("Calling EditorSettings.PropertyGetRevert()")

	returnValue := godotCallVariantString(o, "property_get_revert", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Set the list of favorite directories for this project.
*/
func (o *EditorSettings) SetFavoriteDirs(dirs *PoolStringArray) {
	log.Println("Calling EditorSettings.SetFavoriteDirs()")

	godotCallVoidPoolStringArray(o, "set_favorite_dirs", dirs)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorSettings) SetInitialValue(name string, value *Variant, updateCurrent bool) {
	log.Println("Calling EditorSettings.SetInitialValue()")

	godotCallVoidStringVariantBool(o, "set_initial_value", name, value, updateCurrent)
	log.Println("  Function successfully completed.")

}

/*
   Set the list of recently visited folders in the file dialog for this project.
*/
func (o *EditorSettings) SetRecentDirs(dirs *PoolStringArray) {
	log.Println("Calling EditorSettings.SetRecentDirs()")

	godotCallVoidPoolStringArray(o, "set_recent_dirs", dirs)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorSettings) SetSetting(name string, value *Variant) {
	log.Println("Calling EditorSettings.SetSetting()")

	godotCallVoidStringVariant(o, "set_setting", name, value)
	log.Println("  Function successfully completed.")

}

/*
   EditorSettingsImplementer is an interface for EditorSettings objects.
*/
type EditorSettingsImplementer interface {
	Class
}

/*
   Custom gizmo that is used for providing custom visualization and editing (handles) for 3D Spatial objects. These are created by [method EditorPlugin.create_spatial_gizmo].
*/
type EditorSpatialGizmo struct {
	SpatialGizmo
}

func (o *EditorSpatialGizmo) baseClass() string {
	return "EditorSpatialGizmo"
}

/*

 */
func (o *EditorSpatialGizmo) AddCollisionSegments(segments *PoolVector3Array) {
	log.Println("Calling EditorSpatialGizmo.AddCollisionSegments()")

	godotCallVoidPoolVector3Array(o, "add_collision_segments", segments)
	log.Println("  Function successfully completed.")

}

/*
   Add collision triangles to the gizmo for picking. A [TriangleMesh] can be generated from a regular [Mesh] too. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddCollisionTriangles(triangles *TriangleMesh, bounds *AABB) {
	log.Println("Calling EditorSpatialGizmo.AddCollisionTriangles()")

	godotCallVoidObjectAabb(o, "add_collision_triangles", &triangles.Object, bounds)
	log.Println("  Function successfully completed.")

}

/*
   Add a list of handles (points) which can be used to deform the object being edited. There are virtual functions which will be called upon editing of these handles. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddHandles(handles *PoolVector3Array, billboard bool, secondary bool) {
	log.Println("Calling EditorSpatialGizmo.AddHandles()")

	godotCallVoidPoolVector3ArrayBoolBool(o, "add_handles", handles, billboard, secondary)
	log.Println("  Function successfully completed.")

}

/*
   Add lines to the gizmo (as sets of 2 points), with a given material. The lines are used for visualizing the gizmo. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddLines(lines *PoolVector3Array, material *Material, billboard bool) {
	log.Println("Calling EditorSpatialGizmo.AddLines()")

	godotCallVoidPoolVector3ArrayObjectBool(o, "add_lines", lines, &material.Object, billboard)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorSpatialGizmo) AddMesh(mesh *ArrayMesh, billboard bool, skeleton *RID) {
	log.Println("Calling EditorSpatialGizmo.AddMesh()")

	godotCallVoidObjectBoolRid(o, "add_mesh", &mesh.Object, billboard, skeleton)
	log.Println("  Function successfully completed.")

}

/*
   Add an unscaled billboard for visualization. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddUnscaledBillboard(material *Material, defaultScale float64) {
	log.Println("Calling EditorSpatialGizmo.AddUnscaledBillboard()")

	godotCallVoidObjectFloat(o, "add_unscaled_billboard", &material.Object, defaultScale)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorSpatialGizmo) Clear() {
	log.Println("Calling EditorSpatialGizmo.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Commit a handle being edited (handles must have been previously added by [method add_handles]). If the cancel parameter is true, an option to restore the edited value to the original is provided.
*/
func (o *EditorSpatialGizmo) CommitHandle(index int64, restore *Variant, cancel bool) {
	log.Println("Calling EditorSpatialGizmo.CommitHandle()")

	godotCallVoidIntVariantBool(o, "commit_handle", index, restore, cancel)
	log.Println("  Function successfully completed.")

}

/*
   Get the name of an edited handle (handles must have been previously added by [method add_handles]). Handles can be named for reference to the user when editing.
*/
func (o *EditorSpatialGizmo) GetHandleName(index int64) string {
	log.Println("Calling EditorSpatialGizmo.GetHandleName()")

	returnValue := godotCallStringInt(o, "get_handle_name", index)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get actual value of a handle. This value can be anything and used for eventually undoing the motion when calling [method commit_handle]
*/
func (o *EditorSpatialGizmo) GetHandleValue(index int64) *Variant {
	log.Println("Calling EditorSpatialGizmo.GetHandleValue()")

	returnValue := godotCallVariantInt(o, "get_handle_value", index)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   This function is called when the Spatial this gizmo refers to changes (the [method Spatial.update_gizmo] is called).
*/
func (o *EditorSpatialGizmo) Redraw() {
	log.Println("Calling EditorSpatialGizmo.Redraw()")

	godotCallVoid(o, "redraw")
	log.Println("  Function successfully completed.")

}

/*
   This function is used when the user drags a gizmo handle (previously added with [method add_handles]) in screen coordinates. The [Camera] is also provided so screen coordinates can be converted to raycasts.
*/
func (o *EditorSpatialGizmo) SetHandle(index int64, camera *Camera, point *Vector2) {
	log.Println("Calling EditorSpatialGizmo.SetHandle()")

	godotCallVoidIntObjectVector2(o, "set_handle", index, &camera.Object, point)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *EditorSpatialGizmo) SetSpatialNode(node *Object) {
	log.Println("Calling EditorSpatialGizmo.SetSpatialNode()")

	godotCallVoidObject(o, "set_spatial_node", node)
	log.Println("  Function successfully completed.")

}

/*
   EditorSpatialGizmoImplementer is an interface for EditorSpatialGizmo objects.
*/
type EditorSpatialGizmoImplementer interface {
	Class
}

/*

 */
type EncodedObjectAsID struct {
	Reference
}

func (o *EncodedObjectAsID) baseClass() string {
	return "EncodedObjectAsID"
}

/*

 */
func (o *EncodedObjectAsID) GetObjectId() int64 {
	log.Println("Calling EncodedObjectAsID.GetObjectId()")

	returnValue := godotCallInt(o, "get_object_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *EncodedObjectAsID) SetObjectId(id int64) {
	log.Println("Calling EncodedObjectAsID.SetObjectId()")

	godotCallVoidInt(o, "set_object_id", id)
	log.Println("  Function successfully completed.")

}

/*
   EncodedObjectAsIDImplementer is an interface for EncodedObjectAsID objects.
*/
type EncodedObjectAsIDImplementer interface {
	Class
}

/*
   Resource for environment nodes (like [WorldEnvironment]) that define multiple environment operations (such as background [Sky] or [Color], ambient light, fog, depth-of-field...).	These parameters affect the final render of the scene. The order of these operations is: - DOF Blur - Motion Blur - Bloom - Tonemap (auto exposure) - Adjustments
*/
type Environment struct {
	Resource
}

func (o *Environment) baseClass() string {
	return "Environment"
}

/*
   Undocumented
*/
func (o *Environment) GetAdjustmentBrightness() float64 {
	log.Println("Calling Environment.GetAdjustmentBrightness()")

	returnValue := godotCallFloat(o, "get_adjustment_brightness")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetAdjustmentColorCorrection() *Texture {
	log.Println("Calling Environment.GetAdjustmentColorCorrection()")

	returnValue := godotCallObject(o, "get_adjustment_color_correction")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Environment) GetAdjustmentContrast() float64 {
	log.Println("Calling Environment.GetAdjustmentContrast()")

	returnValue := godotCallFloat(o, "get_adjustment_contrast")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetAdjustmentSaturation() float64 {
	log.Println("Calling Environment.GetAdjustmentSaturation()")

	returnValue := godotCallFloat(o, "get_adjustment_saturation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetAmbientLightColor() *Color {
	log.Println("Calling Environment.GetAmbientLightColor()")

	returnValue := godotCallColor(o, "get_ambient_light_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetAmbientLightEnergy() float64 {
	log.Println("Calling Environment.GetAmbientLightEnergy()")

	returnValue := godotCallFloat(o, "get_ambient_light_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetAmbientLightSkyContribution() float64 {
	log.Println("Calling Environment.GetAmbientLightSkyContribution()")

	returnValue := godotCallFloat(o, "get_ambient_light_sky_contribution")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetBackground() int64 {
	log.Println("Calling Environment.GetBackground()")

	returnValue := godotCallInt(o, "get_background")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetBgColor() *Color {
	log.Println("Calling Environment.GetBgColor()")

	returnValue := godotCallColor(o, "get_bg_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetBgEnergy() float64 {
	log.Println("Calling Environment.GetBgEnergy()")

	returnValue := godotCallFloat(o, "get_bg_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetCanvasMaxLayer() int64 {
	log.Println("Calling Environment.GetCanvasMaxLayer()")

	returnValue := godotCallInt(o, "get_canvas_max_layer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetDofBlurFarAmount() float64 {
	log.Println("Calling Environment.GetDofBlurFarAmount()")

	returnValue := godotCallFloat(o, "get_dof_blur_far_amount")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetDofBlurFarDistance() float64 {
	log.Println("Calling Environment.GetDofBlurFarDistance()")

	returnValue := godotCallFloat(o, "get_dof_blur_far_distance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetDofBlurFarQuality() int64 {
	log.Println("Calling Environment.GetDofBlurFarQuality()")

	returnValue := godotCallInt(o, "get_dof_blur_far_quality")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetDofBlurFarTransition() float64 {
	log.Println("Calling Environment.GetDofBlurFarTransition()")

	returnValue := godotCallFloat(o, "get_dof_blur_far_transition")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetDofBlurNearAmount() float64 {
	log.Println("Calling Environment.GetDofBlurNearAmount()")

	returnValue := godotCallFloat(o, "get_dof_blur_near_amount")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetDofBlurNearDistance() float64 {
	log.Println("Calling Environment.GetDofBlurNearDistance()")

	returnValue := godotCallFloat(o, "get_dof_blur_near_distance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetDofBlurNearQuality() int64 {
	log.Println("Calling Environment.GetDofBlurNearQuality()")

	returnValue := godotCallInt(o, "get_dof_blur_near_quality")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetDofBlurNearTransition() float64 {
	log.Println("Calling Environment.GetDofBlurNearTransition()")

	returnValue := godotCallFloat(o, "get_dof_blur_near_transition")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetFogColor() *Color {
	log.Println("Calling Environment.GetFogColor()")

	returnValue := godotCallColor(o, "get_fog_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetFogDepthBegin() float64 {
	log.Println("Calling Environment.GetFogDepthBegin()")

	returnValue := godotCallFloat(o, "get_fog_depth_begin")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetFogDepthCurve() float64 {
	log.Println("Calling Environment.GetFogDepthCurve()")

	returnValue := godotCallFloat(o, "get_fog_depth_curve")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetFogHeightCurve() float64 {
	log.Println("Calling Environment.GetFogHeightCurve()")

	returnValue := godotCallFloat(o, "get_fog_height_curve")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetFogHeightMax() float64 {
	log.Println("Calling Environment.GetFogHeightMax()")

	returnValue := godotCallFloat(o, "get_fog_height_max")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetFogHeightMin() float64 {
	log.Println("Calling Environment.GetFogHeightMin()")

	returnValue := godotCallFloat(o, "get_fog_height_min")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetFogSunAmount() float64 {
	log.Println("Calling Environment.GetFogSunAmount()")

	returnValue := godotCallFloat(o, "get_fog_sun_amount")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetFogSunColor() *Color {
	log.Println("Calling Environment.GetFogSunColor()")

	returnValue := godotCallColor(o, "get_fog_sun_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetFogTransmitCurve() float64 {
	log.Println("Calling Environment.GetFogTransmitCurve()")

	returnValue := godotCallFloat(o, "get_fog_transmit_curve")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetGlowBlendMode() int64 {
	log.Println("Calling Environment.GetGlowBlendMode()")

	returnValue := godotCallInt(o, "get_glow_blend_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetGlowBloom() float64 {
	log.Println("Calling Environment.GetGlowBloom()")

	returnValue := godotCallFloat(o, "get_glow_bloom")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetGlowHdrBleedScale() float64 {
	log.Println("Calling Environment.GetGlowHdrBleedScale()")

	returnValue := godotCallFloat(o, "get_glow_hdr_bleed_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetGlowHdrBleedThreshold() float64 {
	log.Println("Calling Environment.GetGlowHdrBleedThreshold()")

	returnValue := godotCallFloat(o, "get_glow_hdr_bleed_threshold")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetGlowIntensity() float64 {
	log.Println("Calling Environment.GetGlowIntensity()")

	returnValue := godotCallFloat(o, "get_glow_intensity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetGlowStrength() float64 {
	log.Println("Calling Environment.GetGlowStrength()")

	returnValue := godotCallFloat(o, "get_glow_strength")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSky() *Sky {
	log.Println("Calling Environment.GetSky()")

	returnValue := godotCallObject(o, "get_sky")
	log.Println("  Got return value: ", returnValue)

	var ret Sky
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Environment) GetSkyCustomFov() float64 {
	log.Println("Calling Environment.GetSkyCustomFov()")

	returnValue := godotCallFloat(o, "get_sky_custom_fov")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsaoBias() float64 {
	log.Println("Calling Environment.GetSsaoBias()")

	returnValue := godotCallFloat(o, "get_ssao_bias")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsaoBlur() int64 {
	log.Println("Calling Environment.GetSsaoBlur()")

	returnValue := godotCallInt(o, "get_ssao_blur")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsaoColor() *Color {
	log.Println("Calling Environment.GetSsaoColor()")

	returnValue := godotCallColor(o, "get_ssao_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsaoDirectLightAffect() float64 {
	log.Println("Calling Environment.GetSsaoDirectLightAffect()")

	returnValue := godotCallFloat(o, "get_ssao_direct_light_affect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsaoEdgeSharpness() float64 {
	log.Println("Calling Environment.GetSsaoEdgeSharpness()")

	returnValue := godotCallFloat(o, "get_ssao_edge_sharpness")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsaoIntensity() float64 {
	log.Println("Calling Environment.GetSsaoIntensity()")

	returnValue := godotCallFloat(o, "get_ssao_intensity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsaoIntensity2() float64 {
	log.Println("Calling Environment.GetSsaoIntensity2()")

	returnValue := godotCallFloat(o, "get_ssao_intensity2")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsaoQuality() int64 {
	log.Println("Calling Environment.GetSsaoQuality()")

	returnValue := godotCallInt(o, "get_ssao_quality")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsaoRadius() float64 {
	log.Println("Calling Environment.GetSsaoRadius()")

	returnValue := godotCallFloat(o, "get_ssao_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsaoRadius2() float64 {
	log.Println("Calling Environment.GetSsaoRadius2()")

	returnValue := godotCallFloat(o, "get_ssao_radius2")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsrDepthTolerance() float64 {
	log.Println("Calling Environment.GetSsrDepthTolerance()")

	returnValue := godotCallFloat(o, "get_ssr_depth_tolerance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsrFadeIn() float64 {
	log.Println("Calling Environment.GetSsrFadeIn()")

	returnValue := godotCallFloat(o, "get_ssr_fade_in")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsrFadeOut() float64 {
	log.Println("Calling Environment.GetSsrFadeOut()")

	returnValue := godotCallFloat(o, "get_ssr_fade_out")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetSsrMaxSteps() int64 {
	log.Println("Calling Environment.GetSsrMaxSteps()")

	returnValue := godotCallInt(o, "get_ssr_max_steps")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetTonemapAutoExposure() bool {
	log.Println("Calling Environment.GetTonemapAutoExposure()")

	returnValue := godotCallBool(o, "get_tonemap_auto_exposure")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetTonemapAutoExposureGrey() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureGrey()")

	returnValue := godotCallFloat(o, "get_tonemap_auto_exposure_grey")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetTonemapAutoExposureMax() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureMax()")

	returnValue := godotCallFloat(o, "get_tonemap_auto_exposure_max")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetTonemapAutoExposureMin() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureMin()")

	returnValue := godotCallFloat(o, "get_tonemap_auto_exposure_min")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetTonemapAutoExposureSpeed() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureSpeed()")

	returnValue := godotCallFloat(o, "get_tonemap_auto_exposure_speed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetTonemapExposure() float64 {
	log.Println("Calling Environment.GetTonemapExposure()")

	returnValue := godotCallFloat(o, "get_tonemap_exposure")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetTonemapWhite() float64 {
	log.Println("Calling Environment.GetTonemapWhite()")

	returnValue := godotCallFloat(o, "get_tonemap_white")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) GetTonemapper() int64 {
	log.Println("Calling Environment.GetTonemapper()")

	returnValue := godotCallInt(o, "get_tonemapper")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsAdjustmentEnabled() bool {
	log.Println("Calling Environment.IsAdjustmentEnabled()")

	returnValue := godotCallBool(o, "is_adjustment_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsDofBlurFarEnabled() bool {
	log.Println("Calling Environment.IsDofBlurFarEnabled()")

	returnValue := godotCallBool(o, "is_dof_blur_far_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsDofBlurNearEnabled() bool {
	log.Println("Calling Environment.IsDofBlurNearEnabled()")

	returnValue := godotCallBool(o, "is_dof_blur_near_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsFogDepthEnabled() bool {
	log.Println("Calling Environment.IsFogDepthEnabled()")

	returnValue := godotCallBool(o, "is_fog_depth_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsFogEnabled() bool {
	log.Println("Calling Environment.IsFogEnabled()")

	returnValue := godotCallBool(o, "is_fog_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsFogHeightEnabled() bool {
	log.Println("Calling Environment.IsFogHeightEnabled()")

	returnValue := godotCallBool(o, "is_fog_height_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsFogTransmitEnabled() bool {
	log.Println("Calling Environment.IsFogTransmitEnabled()")

	returnValue := godotCallBool(o, "is_fog_transmit_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsGlowBicubicUpscaleEnabled() bool {
	log.Println("Calling Environment.IsGlowBicubicUpscaleEnabled()")

	returnValue := godotCallBool(o, "is_glow_bicubic_upscale_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsGlowEnabled() bool {
	log.Println("Calling Environment.IsGlowEnabled()")

	returnValue := godotCallBool(o, "is_glow_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsGlowLevelEnabled(idx int64) bool {
	log.Println("Calling Environment.IsGlowLevelEnabled()")

	returnValue := godotCallBoolInt(o, "is_glow_level_enabled", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsSsaoEnabled() bool {
	log.Println("Calling Environment.IsSsaoEnabled()")

	returnValue := godotCallBool(o, "is_ssao_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsSsrEnabled() bool {
	log.Println("Calling Environment.IsSsrEnabled()")

	returnValue := godotCallBool(o, "is_ssr_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) IsSsrRough() bool {
	log.Println("Calling Environment.IsSsrRough()")

	returnValue := godotCallBool(o, "is_ssr_rough")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Environment) SetAdjustmentBrightness(brightness float64) {
	log.Println("Calling Environment.SetAdjustmentBrightness()")

	godotCallVoidFloat(o, "set_adjustment_brightness", brightness)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetAdjustmentColorCorrection(colorCorrection *Texture) {
	log.Println("Calling Environment.SetAdjustmentColorCorrection()")

	godotCallVoidObject(o, "set_adjustment_color_correction", &colorCorrection.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetAdjustmentContrast(contrast float64) {
	log.Println("Calling Environment.SetAdjustmentContrast()")

	godotCallVoidFloat(o, "set_adjustment_contrast", contrast)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetAdjustmentEnable(enabled bool) {
	log.Println("Calling Environment.SetAdjustmentEnable()")

	godotCallVoidBool(o, "set_adjustment_enable", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetAdjustmentSaturation(saturation float64) {
	log.Println("Calling Environment.SetAdjustmentSaturation()")

	godotCallVoidFloat(o, "set_adjustment_saturation", saturation)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetAmbientLightColor(color *Color) {
	log.Println("Calling Environment.SetAmbientLightColor()")

	godotCallVoidColor(o, "set_ambient_light_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetAmbientLightEnergy(energy float64) {
	log.Println("Calling Environment.SetAmbientLightEnergy()")

	godotCallVoidFloat(o, "set_ambient_light_energy", energy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetAmbientLightSkyContribution(energy float64) {
	log.Println("Calling Environment.SetAmbientLightSkyContribution()")

	godotCallVoidFloat(o, "set_ambient_light_sky_contribution", energy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetBackground(mode int64) {
	log.Println("Calling Environment.SetBackground()")

	godotCallVoidInt(o, "set_background", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetBgColor(color *Color) {
	log.Println("Calling Environment.SetBgColor()")

	godotCallVoidColor(o, "set_bg_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetBgEnergy(energy float64) {
	log.Println("Calling Environment.SetBgEnergy()")

	godotCallVoidFloat(o, "set_bg_energy", energy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetCanvasMaxLayer(layer int64) {
	log.Println("Calling Environment.SetCanvasMaxLayer()")

	godotCallVoidInt(o, "set_canvas_max_layer", layer)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetDofBlurFarAmount(intensity float64) {
	log.Println("Calling Environment.SetDofBlurFarAmount()")

	godotCallVoidFloat(o, "set_dof_blur_far_amount", intensity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetDofBlurFarDistance(intensity float64) {
	log.Println("Calling Environment.SetDofBlurFarDistance()")

	godotCallVoidFloat(o, "set_dof_blur_far_distance", intensity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetDofBlurFarEnabled(enabled bool) {
	log.Println("Calling Environment.SetDofBlurFarEnabled()")

	godotCallVoidBool(o, "set_dof_blur_far_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetDofBlurFarQuality(intensity int64) {
	log.Println("Calling Environment.SetDofBlurFarQuality()")

	godotCallVoidInt(o, "set_dof_blur_far_quality", intensity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetDofBlurFarTransition(intensity float64) {
	log.Println("Calling Environment.SetDofBlurFarTransition()")

	godotCallVoidFloat(o, "set_dof_blur_far_transition", intensity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetDofBlurNearAmount(intensity float64) {
	log.Println("Calling Environment.SetDofBlurNearAmount()")

	godotCallVoidFloat(o, "set_dof_blur_near_amount", intensity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetDofBlurNearDistance(intensity float64) {
	log.Println("Calling Environment.SetDofBlurNearDistance()")

	godotCallVoidFloat(o, "set_dof_blur_near_distance", intensity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetDofBlurNearEnabled(enabled bool) {
	log.Println("Calling Environment.SetDofBlurNearEnabled()")

	godotCallVoidBool(o, "set_dof_blur_near_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetDofBlurNearQuality(level int64) {
	log.Println("Calling Environment.SetDofBlurNearQuality()")

	godotCallVoidInt(o, "set_dof_blur_near_quality", level)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetDofBlurNearTransition(intensity float64) {
	log.Println("Calling Environment.SetDofBlurNearTransition()")

	godotCallVoidFloat(o, "set_dof_blur_near_transition", intensity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogColor(color *Color) {
	log.Println("Calling Environment.SetFogColor()")

	godotCallVoidColor(o, "set_fog_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogDepthBegin(distance float64) {
	log.Println("Calling Environment.SetFogDepthBegin()")

	godotCallVoidFloat(o, "set_fog_depth_begin", distance)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogDepthCurve(curve float64) {
	log.Println("Calling Environment.SetFogDepthCurve()")

	godotCallVoidFloat(o, "set_fog_depth_curve", curve)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogDepthEnabled(enabled bool) {
	log.Println("Calling Environment.SetFogDepthEnabled()")

	godotCallVoidBool(o, "set_fog_depth_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogEnabled(enabled bool) {
	log.Println("Calling Environment.SetFogEnabled()")

	godotCallVoidBool(o, "set_fog_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogHeightCurve(curve float64) {
	log.Println("Calling Environment.SetFogHeightCurve()")

	godotCallVoidFloat(o, "set_fog_height_curve", curve)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogHeightEnabled(enabled bool) {
	log.Println("Calling Environment.SetFogHeightEnabled()")

	godotCallVoidBool(o, "set_fog_height_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogHeightMax(height float64) {
	log.Println("Calling Environment.SetFogHeightMax()")

	godotCallVoidFloat(o, "set_fog_height_max", height)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogHeightMin(height float64) {
	log.Println("Calling Environment.SetFogHeightMin()")

	godotCallVoidFloat(o, "set_fog_height_min", height)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogSunAmount(amount float64) {
	log.Println("Calling Environment.SetFogSunAmount()")

	godotCallVoidFloat(o, "set_fog_sun_amount", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogSunColor(color *Color) {
	log.Println("Calling Environment.SetFogSunColor()")

	godotCallVoidColor(o, "set_fog_sun_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogTransmitCurve(curve float64) {
	log.Println("Calling Environment.SetFogTransmitCurve()")

	godotCallVoidFloat(o, "set_fog_transmit_curve", curve)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetFogTransmitEnabled(enabled bool) {
	log.Println("Calling Environment.SetFogTransmitEnabled()")

	godotCallVoidBool(o, "set_fog_transmit_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetGlowBicubicUpscale(enabled bool) {
	log.Println("Calling Environment.SetGlowBicubicUpscale()")

	godotCallVoidBool(o, "set_glow_bicubic_upscale", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetGlowBlendMode(mode int64) {
	log.Println("Calling Environment.SetGlowBlendMode()")

	godotCallVoidInt(o, "set_glow_blend_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetGlowBloom(amount float64) {
	log.Println("Calling Environment.SetGlowBloom()")

	godotCallVoidFloat(o, "set_glow_bloom", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetGlowEnabled(enabled bool) {
	log.Println("Calling Environment.SetGlowEnabled()")

	godotCallVoidBool(o, "set_glow_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetGlowHdrBleedScale(scale float64) {
	log.Println("Calling Environment.SetGlowHdrBleedScale()")

	godotCallVoidFloat(o, "set_glow_hdr_bleed_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetGlowHdrBleedThreshold(threshold float64) {
	log.Println("Calling Environment.SetGlowHdrBleedThreshold()")

	godotCallVoidFloat(o, "set_glow_hdr_bleed_threshold", threshold)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetGlowIntensity(intensity float64) {
	log.Println("Calling Environment.SetGlowIntensity()")

	godotCallVoidFloat(o, "set_glow_intensity", intensity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetGlowLevel(idx int64, enabled bool) {
	log.Println("Calling Environment.SetGlowLevel()")

	godotCallVoidIntBool(o, "set_glow_level", idx, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetGlowStrength(strength float64) {
	log.Println("Calling Environment.SetGlowStrength()")

	godotCallVoidFloat(o, "set_glow_strength", strength)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSky(sky *Sky) {
	log.Println("Calling Environment.SetSky()")

	godotCallVoidObject(o, "set_sky", &sky.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSkyCustomFov(scale float64) {
	log.Println("Calling Environment.SetSkyCustomFov()")

	godotCallVoidFloat(o, "set_sky_custom_fov", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsaoBias(bias float64) {
	log.Println("Calling Environment.SetSsaoBias()")

	godotCallVoidFloat(o, "set_ssao_bias", bias)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsaoBlur(mode int64) {
	log.Println("Calling Environment.SetSsaoBlur()")

	godotCallVoidInt(o, "set_ssao_blur", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsaoColor(color *Color) {
	log.Println("Calling Environment.SetSsaoColor()")

	godotCallVoidColor(o, "set_ssao_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsaoDirectLightAffect(amount float64) {
	log.Println("Calling Environment.SetSsaoDirectLightAffect()")

	godotCallVoidFloat(o, "set_ssao_direct_light_affect", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsaoEdgeSharpness(edgeSharpness float64) {
	log.Println("Calling Environment.SetSsaoEdgeSharpness()")

	godotCallVoidFloat(o, "set_ssao_edge_sharpness", edgeSharpness)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsaoEnabled(enabled bool) {
	log.Println("Calling Environment.SetSsaoEnabled()")

	godotCallVoidBool(o, "set_ssao_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsaoIntensity(intensity float64) {
	log.Println("Calling Environment.SetSsaoIntensity()")

	godotCallVoidFloat(o, "set_ssao_intensity", intensity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsaoIntensity2(intensity float64) {
	log.Println("Calling Environment.SetSsaoIntensity2()")

	godotCallVoidFloat(o, "set_ssao_intensity2", intensity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsaoQuality(quality int64) {
	log.Println("Calling Environment.SetSsaoQuality()")

	godotCallVoidInt(o, "set_ssao_quality", quality)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsaoRadius(radius float64) {
	log.Println("Calling Environment.SetSsaoRadius()")

	godotCallVoidFloat(o, "set_ssao_radius", radius)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsaoRadius2(radius float64) {
	log.Println("Calling Environment.SetSsaoRadius2()")

	godotCallVoidFloat(o, "set_ssao_radius2", radius)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsrDepthTolerance(depthTolerance float64) {
	log.Println("Calling Environment.SetSsrDepthTolerance()")

	godotCallVoidFloat(o, "set_ssr_depth_tolerance", depthTolerance)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsrEnabled(enabled bool) {
	log.Println("Calling Environment.SetSsrEnabled()")

	godotCallVoidBool(o, "set_ssr_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsrFadeIn(fadeIn float64) {
	log.Println("Calling Environment.SetSsrFadeIn()")

	godotCallVoidFloat(o, "set_ssr_fade_in", fadeIn)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsrFadeOut(fadeOut float64) {
	log.Println("Calling Environment.SetSsrFadeOut()")

	godotCallVoidFloat(o, "set_ssr_fade_out", fadeOut)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsrMaxSteps(maxSteps int64) {
	log.Println("Calling Environment.SetSsrMaxSteps()")

	godotCallVoidInt(o, "set_ssr_max_steps", maxSteps)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetSsrRough(rough bool) {
	log.Println("Calling Environment.SetSsrRough()")

	godotCallVoidBool(o, "set_ssr_rough", rough)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetTonemapAutoExposure(autoExposure bool) {
	log.Println("Calling Environment.SetTonemapAutoExposure()")

	godotCallVoidBool(o, "set_tonemap_auto_exposure", autoExposure)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetTonemapAutoExposureGrey(exposureGrey float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureGrey()")

	godotCallVoidFloat(o, "set_tonemap_auto_exposure_grey", exposureGrey)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetTonemapAutoExposureMax(exposureMax float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureMax()")

	godotCallVoidFloat(o, "set_tonemap_auto_exposure_max", exposureMax)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetTonemapAutoExposureMin(exposureMin float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureMin()")

	godotCallVoidFloat(o, "set_tonemap_auto_exposure_min", exposureMin)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetTonemapAutoExposureSpeed(exposureSpeed float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureSpeed()")

	godotCallVoidFloat(o, "set_tonemap_auto_exposure_speed", exposureSpeed)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetTonemapExposure(exposure float64) {
	log.Println("Calling Environment.SetTonemapExposure()")

	godotCallVoidFloat(o, "set_tonemap_exposure", exposure)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetTonemapWhite(white float64) {
	log.Println("Calling Environment.SetTonemapWhite()")

	godotCallVoidFloat(o, "set_tonemap_white", white)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Environment) SetTonemapper(mode int64) {
	log.Println("Calling Environment.SetTonemapper()")

	godotCallVoidInt(o, "set_tonemapper", mode)
	log.Println("  Function successfully completed.")

}

/*
   EnvironmentImplementer is an interface for Environment objects.
*/
type EnvironmentImplementer interface {
	Class
}

/*
   FileDialog is a preset dialog used to choose files and directories in the filesystem. It supports filter masks.
*/
type FileDialog struct {
	ConfirmationDialog
}

func (o *FileDialog) baseClass() string {
	return "FileDialog"
}

/*
   Undocumented
*/
func (o *FileDialog) X_ActionPressed() {
	log.Println("Calling FileDialog.X_ActionPressed()")

	godotCallVoid(o, "_action_pressed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_CancelPressed() {
	log.Println("Calling FileDialog.X_CancelPressed()")

	godotCallVoid(o, "_cancel_pressed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_DirEntered(arg0 string) {
	log.Println("Calling FileDialog.X_DirEntered()")

	godotCallVoidString(o, "_dir_entered", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_FileEntered(arg0 string) {
	log.Println("Calling FileDialog.X_FileEntered()")

	godotCallVoidString(o, "_file_entered", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_FilterSelected(arg0 int64) {
	log.Println("Calling FileDialog.X_FilterSelected()")

	godotCallVoidInt(o, "_filter_selected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_GoUp() {
	log.Println("Calling FileDialog.X_GoUp()")

	godotCallVoid(o, "_go_up")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_MakeDir() {
	log.Println("Calling FileDialog.X_MakeDir()")

	godotCallVoid(o, "_make_dir")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_MakeDirConfirm() {
	log.Println("Calling FileDialog.X_MakeDirConfirm()")

	godotCallVoid(o, "_make_dir_confirm")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_SaveConfirmPressed() {
	log.Println("Calling FileDialog.X_SaveConfirmPressed()")

	godotCallVoid(o, "_save_confirm_pressed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_SelectDrive(arg0 int64) {
	log.Println("Calling FileDialog.X_SelectDrive()")

	godotCallVoidInt(o, "_select_drive", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_TreeDbSelected() {
	log.Println("Calling FileDialog.X_TreeDbSelected()")

	godotCallVoid(o, "_tree_db_selected")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_TreeSelected() {
	log.Println("Calling FileDialog.X_TreeSelected()")

	godotCallVoid(o, "_tree_selected")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_UnhandledInput(arg0 *InputEvent) {
	log.Println("Calling FileDialog.X_UnhandledInput()")

	godotCallVoidObject(o, "_unhandled_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_UpdateDir() {
	log.Println("Calling FileDialog.X_UpdateDir()")

	godotCallVoid(o, "_update_dir")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) X_UpdateFileList() {
	log.Println("Calling FileDialog.X_UpdateFileList()")

	godotCallVoid(o, "_update_file_list")
	log.Println("  Function successfully completed.")

}

/*
   Add a custom filter. Filter format is: "mask ; description", example (C++): dialog->add_filter("*.png ; PNG Images");
*/
func (o *FileDialog) AddFilter(filter string) {
	log.Println("Calling FileDialog.AddFilter()")

	godotCallVoidString(o, "add_filter", filter)
	log.Println("  Function successfully completed.")

}

/*
   Clear all the added filters in the dialog.
*/
func (o *FileDialog) ClearFilters() {
	log.Println("Calling FileDialog.ClearFilters()")

	godotCallVoid(o, "clear_filters")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *FileDialog) DeselectItems() {
	log.Println("Calling FileDialog.DeselectItems()")

	godotCallVoid(o, "deselect_items")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) GetAccess() int64 {
	log.Println("Calling FileDialog.GetAccess()")

	returnValue := godotCallInt(o, "get_access")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *FileDialog) GetCurrentDir() string {
	log.Println("Calling FileDialog.GetCurrentDir()")

	returnValue := godotCallString(o, "get_current_dir")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *FileDialog) GetCurrentFile() string {
	log.Println("Calling FileDialog.GetCurrentFile()")

	returnValue := godotCallString(o, "get_current_file")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *FileDialog) GetCurrentPath() string {
	log.Println("Calling FileDialog.GetCurrentPath()")

	returnValue := godotCallString(o, "get_current_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *FileDialog) GetFilters() *PoolStringArray {
	log.Println("Calling FileDialog.GetFilters()")

	returnValue := godotCallPoolStringArray(o, "get_filters")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *FileDialog) GetMode() int64 {
	log.Println("Calling FileDialog.GetMode()")

	returnValue := godotCallInt(o, "get_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the vertical box container of the dialog, custom controls can be added to it.
*/
func (o *FileDialog) GetVbox() *VBoxContainer {
	log.Println("Calling FileDialog.GetVbox()")

	returnValue := godotCallObject(o, "get_vbox")
	log.Println("  Got return value: ", returnValue)

	var ret VBoxContainer
	ret.owner = returnValue.owner
	return &ret

}

/*
   Invalidate and update the current dialog content list.
*/
func (o *FileDialog) Invalidate() {
	log.Println("Calling FileDialog.Invalidate()")

	godotCallVoid(o, "invalidate")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) IsModeOverridingTitle() bool {
	log.Println("Calling FileDialog.IsModeOverridingTitle()")

	returnValue := godotCallBool(o, "is_mode_overriding_title")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *FileDialog) IsShowingHiddenFiles() bool {
	log.Println("Calling FileDialog.IsShowingHiddenFiles()")

	returnValue := godotCallBool(o, "is_showing_hidden_files")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *FileDialog) SetAccess(access int64) {
	log.Println("Calling FileDialog.SetAccess()")

	godotCallVoidInt(o, "set_access", access)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) SetCurrentDir(dir string) {
	log.Println("Calling FileDialog.SetCurrentDir()")

	godotCallVoidString(o, "set_current_dir", dir)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) SetCurrentFile(file string) {
	log.Println("Calling FileDialog.SetCurrentFile()")

	godotCallVoidString(o, "set_current_file", file)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) SetCurrentPath(path string) {
	log.Println("Calling FileDialog.SetCurrentPath()")

	godotCallVoidString(o, "set_current_path", path)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) SetFilters(filters *PoolStringArray) {
	log.Println("Calling FileDialog.SetFilters()")

	godotCallVoidPoolStringArray(o, "set_filters", filters)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) SetMode(mode int64) {
	log.Println("Calling FileDialog.SetMode()")

	godotCallVoidInt(o, "set_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) SetModeOverridesTitle(override bool) {
	log.Println("Calling FileDialog.SetModeOverridesTitle()")

	godotCallVoidBool(o, "set_mode_overrides_title", override)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *FileDialog) SetShowHiddenFiles(show bool) {
	log.Println("Calling FileDialog.SetShowHiddenFiles()")

	godotCallVoidBool(o, "set_show_hidden_files", show)
	log.Println("  Function successfully completed.")

}

/*
   FileDialogImplementer is an interface for FileDialog objects.
*/
type FileDialogImplementer interface {
	Class
}

/*
   Font contains a unicode compatible character set, as well as the ability to draw it with variable width, ascent, descent and kerning. For creating fonts from TTF files (or other font formats), see the editor support for fonts. TODO check wikipedia for graph of ascent/baseline/descent/height/etc.
*/
type Font struct {
	Resource
}

func (o *Font) baseClass() string {
	return "Font"
}

/*
   Draw "string" into a canvas item using the font at a given position, with "modulate" color, and optionally clipping the width. "position" specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
*/
func (o *Font) Draw(canvasItem *RID, position *Vector2, string string, modulate *Color, clipW int64) {
	log.Println("Calling Font.Draw()")

	godotCallVoidRidVector2StringColorInt(o, "draw", canvasItem, position, string, modulate, clipW)
	log.Println("  Function successfully completed.")

}

/*
   Draw character "char" into a canvas item using the font at a given position, with "modulate" color, and optionally kerning if "next" is passed. clipping the width. "position" specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis. The width used by the character is returned, making this function useful for drawing strings character by character.
*/
func (o *Font) DrawChar(canvasItem *RID, position *Vector2, char int64, next int64, modulate *Color) float64 {
	log.Println("Calling Font.DrawChar()")

	returnValue := godotCallFloatRidVector2IntIntColor(o, "draw_char", canvasItem, position, char, next, modulate)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the font ascent (number of pixels above the baseline).
*/
func (o *Font) GetAscent() float64 {
	log.Println("Calling Font.GetAscent()")

	returnValue := godotCallFloat(o, "get_ascent")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the font descent (number of pixels below the baseline).
*/
func (o *Font) GetDescent() float64 {
	log.Println("Calling Font.GetDescent()")

	returnValue := godotCallFloat(o, "get_descent")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the total font height (ascent plus descent) in pixels.
*/
func (o *Font) GetHeight() float64 {
	log.Println("Calling Font.GetHeight()")

	returnValue := godotCallFloat(o, "get_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the size of a string, taking kerning and advance into account.
*/
func (o *Font) GetStringSize(string string) *Vector2 {
	log.Println("Calling Font.GetStringSize()")

	returnValue := godotCallVector2String(o, "get_string_size", string)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Font) IsDistanceFieldHint() bool {
	log.Println("Calling Font.IsDistanceFieldHint()")

	returnValue := godotCallBool(o, "is_distance_field_hint")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   After editing a font (changing size, ascent, char rects, etc.). Call this function to propagate changes to controls that might use it.
*/
func (o *Font) UpdateChanges() {
	log.Println("Calling Font.UpdateChanges()")

	godotCallVoid(o, "update_changes")
	log.Println("  Function successfully completed.")

}

/*
   FontImplementer is an interface for Font objects.
*/
type FontImplementer interface {
	Class
}

/*
   In GDScript, functions are not [i]first-class objects[/i]. This means it is impossible to store them directly as variables, return them from another function, or pass them as arguments. However, by creating a [code]FuncRef[/code] using the [method @GDScript.funcref] function, a reference to a function in a given object can be created, passed around and called.
*/
type FuncRef struct {
	Reference
}

func (o *FuncRef) baseClass() string {
	return "FuncRef"
}

/*
   Calls the referenced function previously set by [method set_function] or [method @GDScript.funcref].
*/
func (o *FuncRef) CallFunc(varArgs ...interface{}) *Variant {
	log.Println("Calling FuncRef.CallFunc()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantVarargs(o, "call_func", varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   The name of the referenced function to call on the object, without parentheses or any parameters.
*/
func (o *FuncRef) SetFunction(name string) {
	log.Println("Calling FuncRef.SetFunction()")

	godotCallVoidString(o, "set_function", name)
	log.Println("  Function successfully completed.")

}

/*
   The object containing the referenced function. This object must be of a type actually inheriting from [Object], not a built-in type such as [int], [Vector2] or [Dictionary].
*/
func (o *FuncRef) SetInstance(instance *Object) {
	log.Println("Calling FuncRef.SetInstance()")

	godotCallVoidObject(o, "set_instance", instance)
	log.Println("  Function successfully completed.")

}

/*
   FuncRefImplementer is an interface for FuncRef objects.
*/
type FuncRefImplementer interface {
	Class
}

/*
   Undocumented
*/
type GDNative struct {
	Reference
}

func (o *GDNative) baseClass() string {
	return "GDNative"
}

/*
   Undocumented
*/
func (o *GDNative) CallNative(callingType string, procedureName string, arguments *Array) *Variant {
	log.Println("Calling GDNative.CallNative()")

	returnValue := godotCallVariantStringStringArray(o, "call_native", callingType, procedureName, arguments)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GDNative) GetLibrary() *GDNativeLibrary {
	log.Println("Calling GDNative.GetLibrary()")

	returnValue := godotCallObject(o, "get_library")
	log.Println("  Got return value: ", returnValue)

	var ret GDNativeLibrary
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *GDNative) Initialize() bool {
	log.Println("Calling GDNative.Initialize()")

	returnValue := godotCallBool(o, "initialize")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GDNative) SetLibrary(library *GDNativeLibrary) {
	log.Println("Calling GDNative.SetLibrary()")

	godotCallVoidObject(o, "set_library", &library.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GDNative) Terminate() bool {
	log.Println("Calling GDNative.Terminate()")

	returnValue := godotCallBool(o, "terminate")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   GDNativeImplementer is an interface for GDNative objects.
*/
type GDNativeImplementer interface {
	Class
}

/*
   Undocumented
*/
type GDNativeLibrary struct {
	Resource
}

func (o *GDNativeLibrary) baseClass() string {
	return "GDNativeLibrary"
}

/*
   Undocumented
*/
func (o *GDNativeLibrary) GetConfigFile() *ConfigFile {
	log.Println("Calling GDNativeLibrary.GetConfigFile()")

	returnValue := godotCallObject(o, "get_config_file")
	log.Println("  Got return value: ", returnValue)

	var ret ConfigFile
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *GDNativeLibrary) GetCurrentDependencies() *PoolStringArray {
	log.Println("Calling GDNativeLibrary.GetCurrentDependencies()")

	returnValue := godotCallPoolStringArray(o, "get_current_dependencies")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GDNativeLibrary) GetCurrentLibraryPath() string {
	log.Println("Calling GDNativeLibrary.GetCurrentLibraryPath()")

	returnValue := godotCallString(o, "get_current_library_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GDNativeLibrary) GetSymbolPrefix() string {
	log.Println("Calling GDNativeLibrary.GetSymbolPrefix()")

	returnValue := godotCallString(o, "get_symbol_prefix")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GDNativeLibrary) IsReloadable() bool {
	log.Println("Calling GDNativeLibrary.IsReloadable()")

	returnValue := godotCallBool(o, "is_reloadable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GDNativeLibrary) IsSingleton() bool {
	log.Println("Calling GDNativeLibrary.IsSingleton()")

	returnValue := godotCallBool(o, "is_singleton")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GDNativeLibrary) SetLoadOnce(loadOnce bool) {
	log.Println("Calling GDNativeLibrary.SetLoadOnce()")

	godotCallVoidBool(o, "set_load_once", loadOnce)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GDNativeLibrary) SetReloadable(reloadable bool) {
	log.Println("Calling GDNativeLibrary.SetReloadable()")

	godotCallVoidBool(o, "set_reloadable", reloadable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GDNativeLibrary) SetSingleton(singleton bool) {
	log.Println("Calling GDNativeLibrary.SetSingleton()")

	godotCallVoidBool(o, "set_singleton", singleton)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GDNativeLibrary) SetSymbolPrefix(symbolPrefix string) {
	log.Println("Calling GDNativeLibrary.SetSymbolPrefix()")

	godotCallVoidString(o, "set_symbol_prefix", symbolPrefix)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GDNativeLibrary) ShouldLoadOnce() bool {
	log.Println("Calling GDNativeLibrary.ShouldLoadOnce()")

	returnValue := godotCallBool(o, "should_load_once")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   GDNativeLibraryImplementer is an interface for GDNativeLibrary objects.
*/
type GDNativeLibraryImplementer interface {
	Class
}

/*
   Undocumented
*/
type GDScript struct {
	Script
}

func (o *GDScript) baseClass() string {
	return "GDScript"
}

/*
   Undocumented
*/
func (o *GDScript) GetAsByteCode() *PoolByteArray {
	log.Println("Calling GDScript.GetAsByteCode()")

	returnValue := godotCallPoolByteArray(o, "get_as_byte_code")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GDScript) New(varArgs ...interface{}) *Object {
	log.Println("Calling GDScript.New()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallObjectVarargs(o, "new", varArgsArray)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   GDScriptImplementer is an interface for GDScript objects.
*/
type GDScriptImplementer interface {
	Class
}

/*
   Undocumented
*/
type GDScriptFunctionState struct {
	Reference
}

func (o *GDScriptFunctionState) baseClass() string {
	return "GDScriptFunctionState"
}

/*
   Undocumented
*/
func (o *GDScriptFunctionState) X_SignalCallback(varArgs ...interface{}) *Variant {
	log.Println("Calling GDScriptFunctionState.X_SignalCallback()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantVarargs(o, "_signal_callback", varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GDScriptFunctionState) IsValid(extendedCheck bool) bool {
	log.Println("Calling GDScriptFunctionState.IsValid()")

	returnValue := godotCallBoolBool(o, "is_valid", extendedCheck)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GDScriptFunctionState) Resume(arg *Variant) *Variant {
	log.Println("Calling GDScriptFunctionState.Resume()")

	returnValue := godotCallVariantVariant(o, "resume", arg)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   GDScriptFunctionStateImplementer is an interface for GDScriptFunctionState objects.
*/
type GDScriptFunctionStateImplementer interface {
	Class
}

/*

 */
type GIProbe struct {
	VisualInstance
}

func (o *GIProbe) baseClass() string {
	return "GIProbe"
}

/*

 */
func (o *GIProbe) Bake(fromNode *Object, createVisualDebug bool) {
	log.Println("Calling GIProbe.Bake()")

	godotCallVoidObjectBool(o, "bake", fromNode, createVisualDebug)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *GIProbe) DebugBake() {
	log.Println("Calling GIProbe.DebugBake()")

	godotCallVoid(o, "debug_bake")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbe) GetBias() float64 {
	log.Println("Calling GIProbe.GetBias()")

	returnValue := godotCallFloat(o, "get_bias")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbe) GetDynamicRange() int64 {
	log.Println("Calling GIProbe.GetDynamicRange()")

	returnValue := godotCallInt(o, "get_dynamic_range")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbe) GetEnergy() float64 {
	log.Println("Calling GIProbe.GetEnergy()")

	returnValue := godotCallFloat(o, "get_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbe) GetExtents() *Vector3 {
	log.Println("Calling GIProbe.GetExtents()")

	returnValue := godotCallVector3(o, "get_extents")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbe) GetNormalBias() float64 {
	log.Println("Calling GIProbe.GetNormalBias()")

	returnValue := godotCallFloat(o, "get_normal_bias")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbe) GetProbeData() *GIProbeData {
	log.Println("Calling GIProbe.GetProbeData()")

	returnValue := godotCallObject(o, "get_probe_data")
	log.Println("  Got return value: ", returnValue)

	var ret GIProbeData
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *GIProbe) GetPropagation() float64 {
	log.Println("Calling GIProbe.GetPropagation()")

	returnValue := godotCallFloat(o, "get_propagation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbe) GetSubdiv() int64 {
	log.Println("Calling GIProbe.GetSubdiv()")

	returnValue := godotCallInt(o, "get_subdiv")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbe) IsCompressed() bool {
	log.Println("Calling GIProbe.IsCompressed()")

	returnValue := godotCallBool(o, "is_compressed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbe) IsInterior() bool {
	log.Println("Calling GIProbe.IsInterior()")

	returnValue := godotCallBool(o, "is_interior")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbe) SetBias(max float64) {
	log.Println("Calling GIProbe.SetBias()")

	godotCallVoidFloat(o, "set_bias", max)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbe) SetCompress(enable bool) {
	log.Println("Calling GIProbe.SetCompress()")

	godotCallVoidBool(o, "set_compress", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbe) SetDynamicRange(max int64) {
	log.Println("Calling GIProbe.SetDynamicRange()")

	godotCallVoidInt(o, "set_dynamic_range", max)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbe) SetEnergy(max float64) {
	log.Println("Calling GIProbe.SetEnergy()")

	godotCallVoidFloat(o, "set_energy", max)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbe) SetExtents(extents *Vector3) {
	log.Println("Calling GIProbe.SetExtents()")

	godotCallVoidVector3(o, "set_extents", extents)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbe) SetInterior(enable bool) {
	log.Println("Calling GIProbe.SetInterior()")

	godotCallVoidBool(o, "set_interior", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbe) SetNormalBias(max float64) {
	log.Println("Calling GIProbe.SetNormalBias()")

	godotCallVoidFloat(o, "set_normal_bias", max)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbe) SetProbeData(data *GIProbeData) {
	log.Println("Calling GIProbe.SetProbeData()")

	godotCallVoidObject(o, "set_probe_data", &data.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbe) SetPropagation(max float64) {
	log.Println("Calling GIProbe.SetPropagation()")

	godotCallVoidFloat(o, "set_propagation", max)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbe) SetSubdiv(subdiv int64) {
	log.Println("Calling GIProbe.SetSubdiv()")

	godotCallVoidInt(o, "set_subdiv", subdiv)
	log.Println("  Function successfully completed.")

}

/*
   GIProbeImplementer is an interface for GIProbe objects.
*/
type GIProbeImplementer interface {
	Class
}

/*

 */
type GIProbeData struct {
	Resource
}

func (o *GIProbeData) baseClass() string {
	return "GIProbeData"
}

/*
   Undocumented
*/
func (o *GIProbeData) GetBias() float64 {
	log.Println("Calling GIProbeData.GetBias()")

	returnValue := godotCallFloat(o, "get_bias")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbeData) GetBounds() *AABB {
	log.Println("Calling GIProbeData.GetBounds()")

	returnValue := godotCallAabb(o, "get_bounds")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbeData) GetCellSize() float64 {
	log.Println("Calling GIProbeData.GetCellSize()")

	returnValue := godotCallFloat(o, "get_cell_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbeData) GetDynamicData() *PoolIntArray {
	log.Println("Calling GIProbeData.GetDynamicData()")

	returnValue := godotCallPoolIntArray(o, "get_dynamic_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbeData) GetDynamicRange() int64 {
	log.Println("Calling GIProbeData.GetDynamicRange()")

	returnValue := godotCallInt(o, "get_dynamic_range")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbeData) GetEnergy() float64 {
	log.Println("Calling GIProbeData.GetEnergy()")

	returnValue := godotCallFloat(o, "get_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbeData) GetNormalBias() float64 {
	log.Println("Calling GIProbeData.GetNormalBias()")

	returnValue := godotCallFloat(o, "get_normal_bias")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbeData) GetPropagation() float64 {
	log.Println("Calling GIProbeData.GetPropagation()")

	returnValue := godotCallFloat(o, "get_propagation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbeData) GetToCellXform() *Transform {
	log.Println("Calling GIProbeData.GetToCellXform()")

	returnValue := godotCallTransform(o, "get_to_cell_xform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbeData) IsCompressed() bool {
	log.Println("Calling GIProbeData.IsCompressed()")

	returnValue := godotCallBool(o, "is_compressed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbeData) IsInterior() bool {
	log.Println("Calling GIProbeData.IsInterior()")

	returnValue := godotCallBool(o, "is_interior")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GIProbeData) SetBias(bias float64) {
	log.Println("Calling GIProbeData.SetBias()")

	godotCallVoidFloat(o, "set_bias", bias)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbeData) SetBounds(bounds *AABB) {
	log.Println("Calling GIProbeData.SetBounds()")

	godotCallVoidAabb(o, "set_bounds", bounds)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbeData) SetCellSize(cellSize float64) {
	log.Println("Calling GIProbeData.SetCellSize()")

	godotCallVoidFloat(o, "set_cell_size", cellSize)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbeData) SetCompress(compress bool) {
	log.Println("Calling GIProbeData.SetCompress()")

	godotCallVoidBool(o, "set_compress", compress)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbeData) SetDynamicData(dynamicData *PoolIntArray) {
	log.Println("Calling GIProbeData.SetDynamicData()")

	godotCallVoidPoolIntArray(o, "set_dynamic_data", dynamicData)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbeData) SetDynamicRange(dynamicRange int64) {
	log.Println("Calling GIProbeData.SetDynamicRange()")

	godotCallVoidInt(o, "set_dynamic_range", dynamicRange)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbeData) SetEnergy(energy float64) {
	log.Println("Calling GIProbeData.SetEnergy()")

	godotCallVoidFloat(o, "set_energy", energy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbeData) SetInterior(interior bool) {
	log.Println("Calling GIProbeData.SetInterior()")

	godotCallVoidBool(o, "set_interior", interior)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbeData) SetNormalBias(bias float64) {
	log.Println("Calling GIProbeData.SetNormalBias()")

	godotCallVoidFloat(o, "set_normal_bias", bias)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbeData) SetPropagation(propagation float64) {
	log.Println("Calling GIProbeData.SetPropagation()")

	godotCallVoidFloat(o, "set_propagation", propagation)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GIProbeData) SetToCellXform(toCellXform *Transform) {
	log.Println("Calling GIProbeData.SetToCellXform()")

	godotCallVoidTransform(o, "set_to_cell_xform", toCellXform)
	log.Println("  Function successfully completed.")

}

/*
   GIProbeDataImplementer is an interface for GIProbeData objects.
*/
type GIProbeDataImplementer interface {
	Class
}

/*
   The first 3 dof axes are linear axes, which represent translation of Bodies, and the latter 3 dof axes represent the angular motion. Each axis can be either locked, or limited.
*/
type Generic6DOFJoint struct {
	Joint
}

func (o *Generic6DOFJoint) baseClass() string {
	return "Generic6DOFJoint"
}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularHiLimitX() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularHiLimitX()")

	returnValue := godotCallFloat(o, "_get_angular_hi_limit_x")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularHiLimitY() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularHiLimitY()")

	returnValue := godotCallFloat(o, "_get_angular_hi_limit_y")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularHiLimitZ() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularHiLimitZ()")

	returnValue := godotCallFloat(o, "_get_angular_hi_limit_z")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularLoLimitX() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularLoLimitX()")

	returnValue := godotCallFloat(o, "_get_angular_lo_limit_x")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularLoLimitY() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularLoLimitY()")

	returnValue := godotCallFloat(o, "_get_angular_lo_limit_y")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_GetAngularLoLimitZ() float64 {
	log.Println("Calling Generic6DOFJoint.X_GetAngularLoLimitZ()")

	returnValue := godotCallFloat(o, "_get_angular_lo_limit_z")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularHiLimitX(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularHiLimitX()")

	godotCallVoidFloat(o, "_set_angular_hi_limit_x", angle)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularHiLimitY(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularHiLimitY()")

	godotCallVoidFloat(o, "_set_angular_hi_limit_y", angle)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularHiLimitZ(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularHiLimitZ()")

	godotCallVoidFloat(o, "_set_angular_hi_limit_z", angle)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularLoLimitX(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularLoLimitX()")

	godotCallVoidFloat(o, "_set_angular_lo_limit_x", angle)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularLoLimitY(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularLoLimitY()")

	godotCallVoidFloat(o, "_set_angular_lo_limit_y", angle)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) X_SetAngularLoLimitZ(angle float64) {
	log.Println("Calling Generic6DOFJoint.X_SetAngularLoLimitZ()")

	godotCallVoidFloat(o, "_set_angular_lo_limit_z", angle)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) GetFlagX(flag int64) bool {
	log.Println("Calling Generic6DOFJoint.GetFlagX()")

	returnValue := godotCallBoolInt(o, "get_flag_x", flag)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) GetFlagY(flag int64) bool {
	log.Println("Calling Generic6DOFJoint.GetFlagY()")

	returnValue := godotCallBoolInt(o, "get_flag_y", flag)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) GetFlagZ(flag int64) bool {
	log.Println("Calling Generic6DOFJoint.GetFlagZ()")

	returnValue := godotCallBoolInt(o, "get_flag_z", flag)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) GetParamX(param int64) float64 {
	log.Println("Calling Generic6DOFJoint.GetParamX()")

	returnValue := godotCallFloatInt(o, "get_param_x", param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) GetParamY(param int64) float64 {
	log.Println("Calling Generic6DOFJoint.GetParamY()")

	returnValue := godotCallFloatInt(o, "get_param_y", param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) GetParamZ(param int64) float64 {
	log.Println("Calling Generic6DOFJoint.GetParamZ()")

	returnValue := godotCallFloatInt(o, "get_param_z", param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) SetFlagX(flag int64, value bool) {
	log.Println("Calling Generic6DOFJoint.SetFlagX()")

	godotCallVoidIntBool(o, "set_flag_x", flag, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) SetFlagY(flag int64, value bool) {
	log.Println("Calling Generic6DOFJoint.SetFlagY()")

	godotCallVoidIntBool(o, "set_flag_y", flag, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) SetFlagZ(flag int64, value bool) {
	log.Println("Calling Generic6DOFJoint.SetFlagZ()")

	godotCallVoidIntBool(o, "set_flag_z", flag, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) SetParamX(param int64, value float64) {
	log.Println("Calling Generic6DOFJoint.SetParamX()")

	godotCallVoidIntFloat(o, "set_param_x", param, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) SetParamY(param int64, value float64) {
	log.Println("Calling Generic6DOFJoint.SetParamY()")

	godotCallVoidIntFloat(o, "set_param_y", param, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Generic6DOFJoint) SetParamZ(param int64, value float64) {
	log.Println("Calling Generic6DOFJoint.SetParamZ()")

	godotCallVoidIntFloat(o, "set_param_z", param, value)
	log.Println("  Function successfully completed.")

}

/*
   Generic6DOFJointImplementer is an interface for Generic6DOFJoint objects.
*/
type Generic6DOFJointImplementer interface {
	Class
}

/*
   Base node for geometry based visual instances. Shares some common functionality like visibility and custom materials.
*/
type GeometryInstance struct {
	VisualInstance
}

func (o *GeometryInstance) baseClass() string {
	return "GeometryInstance"
}

/*
   Undocumented
*/
func (o *GeometryInstance) GetCastShadowsSetting() int64 {
	log.Println("Calling GeometryInstance.GetCastShadowsSetting()")

	returnValue := godotCallInt(o, "get_cast_shadows_setting")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GeometryInstance) GetExtraCullMargin() float64 {
	log.Println("Calling GeometryInstance.GetExtraCullMargin()")

	returnValue := godotCallFloat(o, "get_extra_cull_margin")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GeometryInstance) GetFlag(flag int64) bool {
	log.Println("Calling GeometryInstance.GetFlag()")

	returnValue := godotCallBoolInt(o, "get_flag", flag)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GeometryInstance) GetLodMaxDistance() float64 {
	log.Println("Calling GeometryInstance.GetLodMaxDistance()")

	returnValue := godotCallFloat(o, "get_lod_max_distance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GeometryInstance) GetLodMaxHysteresis() float64 {
	log.Println("Calling GeometryInstance.GetLodMaxHysteresis()")

	returnValue := godotCallFloat(o, "get_lod_max_hysteresis")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GeometryInstance) GetLodMinDistance() float64 {
	log.Println("Calling GeometryInstance.GetLodMinDistance()")

	returnValue := godotCallFloat(o, "get_lod_min_distance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GeometryInstance) GetLodMinHysteresis() float64 {
	log.Println("Calling GeometryInstance.GetLodMinHysteresis()")

	returnValue := godotCallFloat(o, "get_lod_min_hysteresis")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GeometryInstance) GetMaterialOverride() *Material {
	log.Println("Calling GeometryInstance.GetMaterialOverride()")

	returnValue := godotCallObject(o, "get_material_override")
	log.Println("  Got return value: ", returnValue)

	var ret Material
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *GeometryInstance) SetCastShadowsSetting(shadowCastingSetting int64) {
	log.Println("Calling GeometryInstance.SetCastShadowsSetting()")

	godotCallVoidInt(o, "set_cast_shadows_setting", shadowCastingSetting)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GeometryInstance) SetExtraCullMargin(margin float64) {
	log.Println("Calling GeometryInstance.SetExtraCullMargin()")

	godotCallVoidFloat(o, "set_extra_cull_margin", margin)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GeometryInstance) SetFlag(flag int64, value bool) {
	log.Println("Calling GeometryInstance.SetFlag()")

	godotCallVoidIntBool(o, "set_flag", flag, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GeometryInstance) SetLodMaxDistance(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMaxDistance()")

	godotCallVoidFloat(o, "set_lod_max_distance", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GeometryInstance) SetLodMaxHysteresis(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMaxHysteresis()")

	godotCallVoidFloat(o, "set_lod_max_hysteresis", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GeometryInstance) SetLodMinDistance(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMinDistance()")

	godotCallVoidFloat(o, "set_lod_min_distance", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GeometryInstance) SetLodMinHysteresis(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMinHysteresis()")

	godotCallVoidFloat(o, "set_lod_min_hysteresis", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GeometryInstance) SetMaterialOverride(material *Material) {
	log.Println("Calling GeometryInstance.SetMaterialOverride()")

	godotCallVoidObject(o, "set_material_override", &material.Object)
	log.Println("  Function successfully completed.")

}

/*
   GeometryInstanceImplementer is an interface for GeometryInstance objects.
*/
type GeometryInstanceImplementer interface {
	Class
}

/*
   Given a set of colors, this node will interpolate them in order, meaning, that if you have color 1, color 2 and color3, the ramp will interpolate (generate the colors between two colors) from color 1 to color 2 and from color 2 to color 3. Initially the ramp will have 2 colors (black and white), one (black) at ramp lower offset offset 0 and the other (white) at the ramp higher offset 1.
*/
type Gradient struct {
	Resource
}

func (o *Gradient) baseClass() string {
	return "Gradient"
}

/*
   Adds the specified color to the end of the ramp, with the specified offset
*/
func (o *Gradient) AddPoint(offset float64, color *Color) {
	log.Println("Calling Gradient.AddPoint()")

	godotCallVoidFloatColor(o, "add_point", offset, color)
	log.Println("  Function successfully completed.")

}

/*
   Returns the color of the ramp color at index [i]point[/i]
*/
func (o *Gradient) GetColor(point int64) *Color {
	log.Println("Calling Gradient.GetColor()")

	returnValue := godotCallColorInt(o, "get_color", point)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Gradient) GetColors() *PoolColorArray {
	log.Println("Calling Gradient.GetColors()")

	returnValue := godotCallPoolColorArray(o, "get_colors")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the offset of the ramp color at index [i]point[/i]
*/
func (o *Gradient) GetOffset(point int64) float64 {
	log.Println("Calling Gradient.GetOffset()")

	returnValue := godotCallFloatInt(o, "get_offset", point)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Gradient) GetOffsets() *PoolRealArray {
	log.Println("Calling Gradient.GetOffsets()")

	returnValue := godotCallPoolRealArray(o, "get_offsets")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of colors in the ramp
*/
func (o *Gradient) GetPointCount() int64 {
	log.Println("Calling Gradient.GetPointCount()")

	returnValue := godotCallInt(o, "get_point_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the interpolated color specified by [i]offset[/i]
*/
func (o *Gradient) Interpolate(offset float64) *Color {
	log.Println("Calling Gradient.Interpolate()")

	returnValue := godotCallColorFloat(o, "interpolate", offset)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes the color at the index [i]offset[/i]
*/
func (o *Gradient) RemovePoint(offset int64) {
	log.Println("Calling Gradient.RemovePoint()")

	godotCallVoidInt(o, "remove_point", offset)
	log.Println("  Function successfully completed.")

}

/*
   Sets the color of the ramp color at index [i]point[/i]
*/
func (o *Gradient) SetColor(point int64, color *Color) {
	log.Println("Calling Gradient.SetColor()")

	godotCallVoidIntColor(o, "set_color", point, color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Gradient) SetColors(colors *PoolColorArray) {
	log.Println("Calling Gradient.SetColors()")

	godotCallVoidPoolColorArray(o, "set_colors", colors)
	log.Println("  Function successfully completed.")

}

/*
   Sets the offset for the ramp color at index [i]point[/i]
*/
func (o *Gradient) SetOffset(point int64, offset float64) {
	log.Println("Calling Gradient.SetOffset()")

	godotCallVoidIntFloat(o, "set_offset", point, offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Gradient) SetOffsets(offsets *PoolRealArray) {
	log.Println("Calling Gradient.SetOffsets()")

	godotCallVoidPoolRealArray(o, "set_offsets", offsets)
	log.Println("  Function successfully completed.")

}

/*
   GradientImplementer is an interface for Gradient objects.
*/
type GradientImplementer interface {
	Class
}

/*
   Uses a [Gradient] to fill the texture data, the gradient will be filled from left to right using colors obtained from the gradient, this means that the texture does not necessarily represent an exact copy of the gradient, but instead an interpolation of samples obtained from the gradient at fixed steps (see [method set_width]).
*/
type GradientTexture struct {
	Texture
}

func (o *GradientTexture) baseClass() string {
	return "GradientTexture"
}

/*
   Undocumented
*/
func (o *GradientTexture) X_Update() {
	log.Println("Calling GradientTexture.X_Update()")

	godotCallVoid(o, "_update")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GradientTexture) GetGradient() *Gradient {
	log.Println("Calling GradientTexture.GetGradient()")

	returnValue := godotCallObject(o, "get_gradient")
	log.Println("  Got return value: ", returnValue)

	var ret Gradient
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *GradientTexture) SetGradient(gradient *Gradient) {
	log.Println("Calling GradientTexture.SetGradient()")

	godotCallVoidObject(o, "set_gradient", &gradient.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GradientTexture) SetWidth(width int64) {
	log.Println("Calling GradientTexture.SetWidth()")

	godotCallVoidInt(o, "set_width", width)
	log.Println("  Function successfully completed.")

}

/*
   GradientTextureImplementer is an interface for GradientTexture objects.
*/
type GradientTextureImplementer interface {
	Class
}

/*
   GraphEdit manages the showing of GraphNodes it contains, as well as connections and disconnections between them. Signals are sent for each of these two events. Disconnection between GraphNodes slots is disabled by default. It is greatly advised to enable low processor usage mode (see [method OS.set_low_processor_usage_mode]) when using GraphEdits.
*/
type GraphEdit struct {
	Control
}

func (o *GraphEdit) baseClass() string {
	return "GraphEdit"
}

/*
   Undocumented
*/
func (o *GraphEdit) X_ConnectionsLayerDraw() {
	log.Println("Calling GraphEdit.X_ConnectionsLayerDraw()")

	godotCallVoid(o, "_connections_layer_draw")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_GraphNodeMoved(arg0 *Object) {
	log.Println("Calling GraphEdit.X_GraphNodeMoved()")

	godotCallVoidObject(o, "_graph_node_moved", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_GraphNodeRaised(arg0 *Object) {
	log.Println("Calling GraphEdit.X_GraphNodeRaised()")

	godotCallVoidObject(o, "_graph_node_raised", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling GraphEdit.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_ScrollMoved(arg0 float64) {
	log.Println("Calling GraphEdit.X_ScrollMoved()")

	godotCallVoidFloat(o, "_scroll_moved", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_SnapToggled() {
	log.Println("Calling GraphEdit.X_SnapToggled()")

	godotCallVoid(o, "_snap_toggled")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_SnapValueChanged(arg0 float64) {
	log.Println("Calling GraphEdit.X_SnapValueChanged()")

	godotCallVoidFloat(o, "_snap_value_changed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_TopLayerDraw() {
	log.Println("Calling GraphEdit.X_TopLayerDraw()")

	godotCallVoid(o, "_top_layer_draw")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_TopLayerInput(arg0 *InputEvent) {
	log.Println("Calling GraphEdit.X_TopLayerInput()")

	godotCallVoidObject(o, "_top_layer_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_UpdateScrollOffset() {
	log.Println("Calling GraphEdit.X_UpdateScrollOffset()")

	godotCallVoid(o, "_update_scroll_offset")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_ZoomMinus() {
	log.Println("Calling GraphEdit.X_ZoomMinus()")

	godotCallVoid(o, "_zoom_minus")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_ZoomPlus() {
	log.Println("Calling GraphEdit.X_ZoomPlus()")

	godotCallVoid(o, "_zoom_plus")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) X_ZoomReset() {
	log.Println("Calling GraphEdit.X_ZoomReset()")

	godotCallVoid(o, "_zoom_reset")
	log.Println("  Function successfully completed.")

}

/*
   Create a connection between 'from_port' slot of 'from' GraphNode and 'to_port' slot of 'to' GraphNode. If the connection already exists, no connection is created.
*/
func (o *GraphEdit) ConnectNode(from string, fromPort int64, to string, toPort int64) int64 {
	log.Println("Calling GraphEdit.ConnectNode()")

	returnValue := godotCallIntStringIntStringInt(o, "connect_node", from, fromPort, to, toPort)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Remove the connection between 'from_port' slot of 'from' GraphNode and 'to_port' slot of 'to' GraphNode, if connection exists.
*/
func (o *GraphEdit) DisconnectNode(from string, fromPort int64, to string, toPort int64) {
	log.Println("Calling GraphEdit.DisconnectNode()")

	godotCallVoidStringIntStringInt(o, "disconnect_node", from, fromPort, to, toPort)
	log.Println("  Function successfully completed.")

}

/*
   Return an Array containing the list of connections. A connection consists in a structure of the form {from_slot: 0, from: "GraphNode name 0", to_slot: 1, to: "GraphNode name 1" }
*/
func (o *GraphEdit) GetConnectionList() *Array {
	log.Println("Calling GraphEdit.GetConnectionList()")

	returnValue := godotCallArray(o, "get_connection_list")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphEdit) GetScrollOfs() *Vector2 {
	log.Println("Calling GraphEdit.GetScrollOfs()")

	returnValue := godotCallVector2(o, "get_scroll_ofs")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphEdit) GetSnap() int64 {
	log.Println("Calling GraphEdit.GetSnap()")

	returnValue := godotCallInt(o, "get_snap")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphEdit) GetZoom() float64 {
	log.Println("Calling GraphEdit.GetZoom()")

	returnValue := godotCallFloat(o, "get_zoom")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return true if the 'from_port' slot of 'from' GraphNode is connected to the 'to_port' slot of 'to' GraphNode.
*/
func (o *GraphEdit) IsNodeConnected(from string, fromPort int64, to string, toPort int64) bool {
	log.Println("Calling GraphEdit.IsNodeConnected()")

	returnValue := godotCallBoolStringIntStringInt(o, "is_node_connected", from, fromPort, to, toPort)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphEdit) IsRightDisconnectsEnabled() bool {
	log.Println("Calling GraphEdit.IsRightDisconnectsEnabled()")

	returnValue := godotCallBool(o, "is_right_disconnects_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphEdit) IsUsingSnap() bool {
	log.Println("Calling GraphEdit.IsUsingSnap()")

	returnValue := godotCallBool(o, "is_using_snap")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphEdit) SetRightDisconnects(enable bool) {
	log.Println("Calling GraphEdit.SetRightDisconnects()")

	godotCallVoidBool(o, "set_right_disconnects", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) SetScrollOfs(ofs *Vector2) {
	log.Println("Calling GraphEdit.SetScrollOfs()")

	godotCallVoidVector2(o, "set_scroll_ofs", ofs)
	log.Println("  Function successfully completed.")

}

/*
   Sets the specified [code]node[/code] as the one selected.
*/
func (o *GraphEdit) SetSelected(node *Object) {
	log.Println("Calling GraphEdit.SetSelected()")

	godotCallVoidObject(o, "set_selected", node)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) SetSnap(pixels int64) {
	log.Println("Calling GraphEdit.SetSnap()")

	godotCallVoidInt(o, "set_snap", pixels)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) SetUseSnap(enable bool) {
	log.Println("Calling GraphEdit.SetUseSnap()")

	godotCallVoidBool(o, "set_use_snap", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphEdit) SetZoom(pZoom float64) {
	log.Println("Calling GraphEdit.SetZoom()")

	godotCallVoidFloat(o, "set_zoom", pZoom)
	log.Println("  Function successfully completed.")

}

/*
   GraphEditImplementer is an interface for GraphEdit objects.
*/
type GraphEditImplementer interface {
	Class
}

/*
   A GraphNode is a container defined by a title. It can have 1 or more input and output slots, which can be enabled (shown) or disabled (not shown) and have different (incompatible) types. Colors can also be assigned to slots. A tuple of input and output slots is defined for each GUI element included in the GraphNode. Input and output connections are left and right slots, but only enabled slots are counted as connections.
*/
type GraphNode struct {
	Container
}

func (o *GraphNode) baseClass() string {
	return "GraphNode"
}

/*
   Undocumented
*/
func (o *GraphNode) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling GraphNode.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Disable all input and output slots of the GraphNode.
*/
func (o *GraphNode) ClearAllSlots() {
	log.Println("Calling GraphNode.ClearAllSlots()")

	godotCallVoid(o, "clear_all_slots")
	log.Println("  Function successfully completed.")

}

/*
   Disable input and output slot whose index is 'idx'.
*/
func (o *GraphNode) ClearSlot(idx int64) {
	log.Println("Calling GraphNode.ClearSlot()")

	godotCallVoidInt(o, "clear_slot", idx)
	log.Println("  Function successfully completed.")

}

/*
   Return the color of the input connection 'idx'.
*/
func (o *GraphNode) GetConnectionInputColor(idx int64) *Color {
	log.Println("Calling GraphNode.GetConnectionInputColor()")

	returnValue := godotCallColorInt(o, "get_connection_input_color", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the number of enabled input slots (connections) to the GraphNode.
*/
func (o *GraphNode) GetConnectionInputCount() int64 {
	log.Println("Calling GraphNode.GetConnectionInputCount()")

	returnValue := godotCallInt(o, "get_connection_input_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the position of the input connection 'idx'.
*/
func (o *GraphNode) GetConnectionInputPosition(idx int64) *Vector2 {
	log.Println("Calling GraphNode.GetConnectionInputPosition()")

	returnValue := godotCallVector2Int(o, "get_connection_input_position", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the type of the input connection 'idx'.
*/
func (o *GraphNode) GetConnectionInputType(idx int64) int64 {
	log.Println("Calling GraphNode.GetConnectionInputType()")

	returnValue := godotCallIntInt(o, "get_connection_input_type", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the color of the output connection 'idx'.
*/
func (o *GraphNode) GetConnectionOutputColor(idx int64) *Color {
	log.Println("Calling GraphNode.GetConnectionOutputColor()")

	returnValue := godotCallColorInt(o, "get_connection_output_color", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the number of enabled output slots (connections) of the GraphNode.
*/
func (o *GraphNode) GetConnectionOutputCount() int64 {
	log.Println("Calling GraphNode.GetConnectionOutputCount()")

	returnValue := godotCallInt(o, "get_connection_output_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the position of the output connection 'idx'.
*/
func (o *GraphNode) GetConnectionOutputPosition(idx int64) *Vector2 {
	log.Println("Calling GraphNode.GetConnectionOutputPosition()")

	returnValue := godotCallVector2Int(o, "get_connection_output_position", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the type of the output connection 'idx'.
*/
func (o *GraphNode) GetConnectionOutputType(idx int64) int64 {
	log.Println("Calling GraphNode.GetConnectionOutputType()")

	returnValue := godotCallIntInt(o, "get_connection_output_type", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphNode) GetOffset() *Vector2 {
	log.Println("Calling GraphNode.GetOffset()")

	returnValue := godotCallVector2(o, "get_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphNode) GetOverlay() int64 {
	log.Println("Calling GraphNode.GetOverlay()")

	returnValue := godotCallInt(o, "get_overlay")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the color set to 'idx' left (input) slot.
*/
func (o *GraphNode) GetSlotColorLeft(idx int64) *Color {
	log.Println("Calling GraphNode.GetSlotColorLeft()")

	returnValue := godotCallColorInt(o, "get_slot_color_left", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the color set to 'idx' right (output) slot.
*/
func (o *GraphNode) GetSlotColorRight(idx int64) *Color {
	log.Println("Calling GraphNode.GetSlotColorRight()")

	returnValue := godotCallColorInt(o, "get_slot_color_right", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the (integer) type of left (input) 'idx' slot.
*/
func (o *GraphNode) GetSlotTypeLeft(idx int64) int64 {
	log.Println("Calling GraphNode.GetSlotTypeLeft()")

	returnValue := godotCallIntInt(o, "get_slot_type_left", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the (integer) type of right (output) 'idx' slot.
*/
func (o *GraphNode) GetSlotTypeRight(idx int64) int64 {
	log.Println("Calling GraphNode.GetSlotTypeRight()")

	returnValue := godotCallIntInt(o, "get_slot_type_right", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphNode) GetTitle() string {
	log.Println("Calling GraphNode.GetTitle()")

	returnValue := godotCallString(o, "get_title")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphNode) IsCloseButtonVisible() bool {
	log.Println("Calling GraphNode.IsCloseButtonVisible()")

	returnValue := godotCallBool(o, "is_close_button_visible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphNode) IsComment() bool {
	log.Println("Calling GraphNode.IsComment()")

	returnValue := godotCallBool(o, "is_comment")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphNode) IsResizable() bool {
	log.Println("Calling GraphNode.IsResizable()")

	returnValue := godotCallBool(o, "is_resizable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphNode) IsSelected() bool {
	log.Println("Calling GraphNode.IsSelected()")

	returnValue := godotCallBool(o, "is_selected")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return true if left (input) slot 'idx' is enabled. False otherwise.
*/
func (o *GraphNode) IsSlotEnabledLeft(idx int64) bool {
	log.Println("Calling GraphNode.IsSlotEnabledLeft()")

	returnValue := godotCallBoolInt(o, "is_slot_enabled_left", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return true if right (output) slot 'idx' is enabled. False otherwise.
*/
func (o *GraphNode) IsSlotEnabledRight(idx int64) bool {
	log.Println("Calling GraphNode.IsSlotEnabledRight()")

	returnValue := godotCallBoolInt(o, "is_slot_enabled_right", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GraphNode) SetComment(comment bool) {
	log.Println("Calling GraphNode.SetComment()")

	godotCallVoidBool(o, "set_comment", comment)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphNode) SetOffset(offset *Vector2) {
	log.Println("Calling GraphNode.SetOffset()")

	godotCallVoidVector2(o, "set_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphNode) SetOverlay(overlay int64) {
	log.Println("Calling GraphNode.SetOverlay()")

	godotCallVoidInt(o, "set_overlay", overlay)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphNode) SetResizable(resizable bool) {
	log.Println("Calling GraphNode.SetResizable()")

	godotCallVoidBool(o, "set_resizable", resizable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphNode) SetSelected(selected bool) {
	log.Println("Calling GraphNode.SetSelected()")

	godotCallVoidBool(o, "set_selected", selected)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphNode) SetShowCloseButton(show bool) {
	log.Println("Calling GraphNode.SetShowCloseButton()")

	godotCallVoidBool(o, "set_show_close_button", show)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *GraphNode) SetSlot(idx int64, enableLeft bool, typeLeft int64, colorLeft *Color, enableRight bool, typeRight int64, colorRight *Color, customLeft *Texture, customRight *Texture) {
	log.Println("Calling GraphNode.SetSlot()")

	godotCallVoidIntBoolIntColorBoolIntColorObjectObject(o, "set_slot", idx, enableLeft, typeLeft, colorLeft, enableRight, typeRight, colorRight, &customLeft.Object, &customRight.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GraphNode) SetTitle(title string) {
	log.Println("Calling GraphNode.SetTitle()")

	godotCallVoidString(o, "set_title", title)
	log.Println("  Function successfully completed.")

}

/*
   GraphNodeImplementer is an interface for GraphNode objects.
*/
type GraphNodeImplementer interface {
	Class
}

/*
   Grid container will arrange its children in a grid like structure, the grid columns are specified using the [method set_columns] method and the number of rows will be equal to the number of children in the container divided by the number of columns, for example: if the container has 5 children, and 2 columns, there will be 3 rows in the container. Notice that grid layout will preserve the columns and rows for every size of the container.
*/
type GridContainer struct {
	Container
}

func (o *GridContainer) baseClass() string {
	return "GridContainer"
}

/*
   Undocumented
*/
func (o *GridContainer) GetColumns() int64 {
	log.Println("Calling GridContainer.GetColumns()")

	returnValue := godotCallInt(o, "get_columns")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridContainer) SetColumns(columns int64) {
	log.Println("Calling GridContainer.SetColumns()")

	godotCallVoidInt(o, "set_columns", columns)
	log.Println("  Function successfully completed.")

}

/*
   GridContainerImplementer is an interface for GridContainer objects.
*/
type GridContainerImplementer interface {
	Class
}

/*
   Undocumented
*/
type GridMap struct {
	Spatial
}

func (o *GridMap) baseClass() string {
	return "GridMap"
}

/*
   Undocumented
*/
func (o *GridMap) X_UpdateOctantsCallback() {
	log.Println("Calling GridMap.X_UpdateOctantsCallback()")

	godotCallVoid(o, "_update_octants_callback")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) Clear() {
	log.Println("Calling GridMap.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) ClearBakedMeshes() {
	log.Println("Calling GridMap.ClearBakedMeshes()")

	godotCallVoid(o, "clear_baked_meshes")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) GetBakeMeshInstance(idx int64) *RID {
	log.Println("Calling GridMap.GetBakeMeshInstance()")

	returnValue := godotCallRidInt(o, "get_bake_mesh_instance", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetBakeMeshes() *Array {
	log.Println("Calling GridMap.GetBakeMeshes()")

	returnValue := godotCallArray(o, "get_bake_meshes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCellItem(x int64, y int64, z int64) int64 {
	log.Println("Calling GridMap.GetCellItem()")

	returnValue := godotCallIntIntIntInt(o, "get_cell_item", x, y, z)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCellItemOrientation(x int64, y int64, z int64) int64 {
	log.Println("Calling GridMap.GetCellItemOrientation()")

	returnValue := godotCallIntIntIntInt(o, "get_cell_item_orientation", x, y, z)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCellScale() float64 {
	log.Println("Calling GridMap.GetCellScale()")

	returnValue := godotCallFloat(o, "get_cell_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCellSize() *Vector3 {
	log.Println("Calling GridMap.GetCellSize()")

	returnValue := godotCallVector3(o, "get_cell_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCenterX() bool {
	log.Println("Calling GridMap.GetCenterX()")

	returnValue := godotCallBool(o, "get_center_x")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCenterY() bool {
	log.Println("Calling GridMap.GetCenterY()")

	returnValue := godotCallBool(o, "get_center_y")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCenterZ() bool {
	log.Println("Calling GridMap.GetCenterZ()")

	returnValue := godotCallBool(o, "get_center_z")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCollisionLayer() int64 {
	log.Println("Calling GridMap.GetCollisionLayer()")

	returnValue := godotCallInt(o, "get_collision_layer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling GridMap.GetCollisionLayerBit()")

	returnValue := godotCallBoolInt(o, "get_collision_layer_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCollisionMask() int64 {
	log.Println("Calling GridMap.GetCollisionMask()")

	returnValue := godotCallInt(o, "get_collision_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling GridMap.GetCollisionMaskBit()")

	returnValue := godotCallBoolInt(o, "get_collision_mask_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetMeshes() *Array {
	log.Println("Calling GridMap.GetMeshes()")

	returnValue := godotCallArray(o, "get_meshes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetOctantSize() int64 {
	log.Println("Calling GridMap.GetOctantSize()")

	returnValue := godotCallInt(o, "get_octant_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) GetTheme() *MeshLibrary {
	log.Println("Calling GridMap.GetTheme()")

	returnValue := godotCallObject(o, "get_theme")
	log.Println("  Got return value: ", returnValue)

	var ret MeshLibrary
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *GridMap) GetUsedCells() *Array {
	log.Println("Calling GridMap.GetUsedCells()")

	returnValue := godotCallArray(o, "get_used_cells")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) MakeBakedMeshes(genLightmapUv bool, lightmapUvTexelSize float64) {
	log.Println("Calling GridMap.MakeBakedMeshes()")

	godotCallVoidBoolFloat(o, "make_baked_meshes", genLightmapUv, lightmapUvTexelSize)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) MapToWorld(x int64, y int64, z int64) *Vector3 {
	log.Println("Calling GridMap.MapToWorld()")

	returnValue := godotCallVector3IntIntInt(o, "map_to_world", x, y, z)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GridMap) ResourceChanged(resource *Resource) {
	log.Println("Calling GridMap.ResourceChanged()")

	godotCallVoidObject(o, "resource_changed", &resource.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetCellItem(x int64, y int64, z int64, item int64, orientation int64) {
	log.Println("Calling GridMap.SetCellItem()")

	godotCallVoidIntIntIntIntInt(o, "set_cell_item", x, y, z, item, orientation)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetCellScale(scale float64) {
	log.Println("Calling GridMap.SetCellScale()")

	godotCallVoidFloat(o, "set_cell_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetCellSize(size *Vector3) {
	log.Println("Calling GridMap.SetCellSize()")

	godotCallVoidVector3(o, "set_cell_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetCenterX(enable bool) {
	log.Println("Calling GridMap.SetCenterX()")

	godotCallVoidBool(o, "set_center_x", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetCenterY(enable bool) {
	log.Println("Calling GridMap.SetCenterY()")

	godotCallVoidBool(o, "set_center_y", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetCenterZ(enable bool) {
	log.Println("Calling GridMap.SetCenterZ()")

	godotCallVoidBool(o, "set_center_z", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetClip(enabled bool, clipabove bool, floor int64, axis int64) {
	log.Println("Calling GridMap.SetClip()")

	godotCallVoidBoolBoolIntInt(o, "set_clip", enabled, clipabove, floor, axis)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetCollisionLayer(layer int64) {
	log.Println("Calling GridMap.SetCollisionLayer()")

	godotCallVoidInt(o, "set_collision_layer", layer)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling GridMap.SetCollisionLayerBit()")

	godotCallVoidIntBool(o, "set_collision_layer_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetCollisionMask(mask int64) {
	log.Println("Calling GridMap.SetCollisionMask()")

	godotCallVoidInt(o, "set_collision_mask", mask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling GridMap.SetCollisionMaskBit()")

	godotCallVoidIntBool(o, "set_collision_mask_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetOctantSize(size int64) {
	log.Println("Calling GridMap.SetOctantSize()")

	godotCallVoidInt(o, "set_octant_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) SetTheme(theme *MeshLibrary) {
	log.Println("Calling GridMap.SetTheme()")

	godotCallVoidObject(o, "set_theme", &theme.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GridMap) WorldToMap(pos *Vector3) *Vector3 {
	log.Println("Calling GridMap.WorldToMap()")

	returnValue := godotCallVector3Vector3(o, "world_to_map", pos)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   GridMapImplementer is an interface for GridMap objects.
*/
type GridMapImplementer interface {
	Class
}

/*
   Groove constraint for 2D physics. This is useful for making a body "slide" through a segment placed in another.
*/
type GrooveJoint2D struct {
	Joint2D
}

func (o *GrooveJoint2D) baseClass() string {
	return "GrooveJoint2D"
}

/*
   Undocumented
*/
func (o *GrooveJoint2D) GetInitialOffset() float64 {
	log.Println("Calling GrooveJoint2D.GetInitialOffset()")

	returnValue := godotCallFloat(o, "get_initial_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GrooveJoint2D) GetLength() float64 {
	log.Println("Calling GrooveJoint2D.GetLength()")

	returnValue := godotCallFloat(o, "get_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *GrooveJoint2D) SetInitialOffset(offset float64) {
	log.Println("Calling GrooveJoint2D.SetInitialOffset()")

	godotCallVoidFloat(o, "set_initial_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *GrooveJoint2D) SetLength(length float64) {
	log.Println("Calling GrooveJoint2D.SetLength()")

	godotCallVoidFloat(o, "set_length", length)
	log.Println("  Function successfully completed.")

}

/*
   GrooveJoint2DImplementer is an interface for GrooveJoint2D objects.
*/
type GrooveJoint2DImplementer interface {
	Class
}

/*
   Horizontal box container. See [BoxContainer].
*/
type HBoxContainer struct {
	BoxContainer
}

func (o *HBoxContainer) baseClass() string {
	return "HBoxContainer"
}

/*
   HBoxContainerImplementer is an interface for HBoxContainer objects.
*/
type HBoxContainerImplementer interface {
	Class
}

/*
   Horizontal scroll bar. See [ScrollBar]. This one goes from left (min) to right (max).
*/
type HScrollBar struct {
	ScrollBar
}

func (o *HScrollBar) baseClass() string {
	return "HScrollBar"
}

/*
   HScrollBarImplementer is an interface for HScrollBar objects.
*/
type HScrollBarImplementer interface {
	Class
}

/*
   Horizontal separator. See [Separator]. It is used to separate objects vertically, though (but it looks horizontal!).
*/
type HSeparator struct {
	Separator
}

func (o *HSeparator) baseClass() string {
	return "HSeparator"
}

/*
   HSeparatorImplementer is an interface for HSeparator objects.
*/
type HSeparatorImplementer interface {
	Class
}

/*
   Horizontal slider. See [Slider]. This one goes from left (min) to right (max).
*/
type HSlider struct {
	Slider
}

func (o *HSlider) baseClass() string {
	return "HSlider"
}

/*
   HSliderImplementer is an interface for HSlider objects.
*/
type HSliderImplementer interface {
	Class
}

/*
   Horizontal split container. See [SplitContainer]. This goes from left to right.
*/
type HSplitContainer struct {
	SplitContainer
}

func (o *HSplitContainer) baseClass() string {
	return "HSplitContainer"
}

/*
   HSplitContainerImplementer is an interface for HSplitContainer objects.
*/
type HSplitContainerImplementer interface {
	Class
}

/*
   Hyper-text transfer protocol client (sometimes called "User Agent"). Used to make HTTP requests to download web content, upload files and other data or to communicate with various services, among other use cases. Note that this client only needs to connect to a host once (see [method connect_to_host]) to send multiple requests. Because of this, methods that take URLs usually take just the part after the host instead of the full URL, as the client is already connected to a host. See [method request] for a full example and to get started. A [code]HTTPClient[/code] should be reused between multiple requests or to connect to different hosts instead of creating one client per request. Supports SSL and SSL server certificate verification. HTTP status codes in the 2xx range indicate success, 3xx redirection (i.e. "try again, but over here"), 4xx something was wrong with the request, and 5xx something went wrong on the server's side. For more information on HTTP, see https://developer.mozilla.org/en-US/docs/Web/HTTP (or read RFC 2616 to get it straight from the source: https://tools.ietf.org/html/rfc2616).
*/
type HTTPClient struct {
	Reference
}

func (o *HTTPClient) baseClass() string {
	return "HTTPClient"
}

/*
   Closes the current connection, allowing reuse of this [code]HTTPClient[/code].
*/
func (o *HTTPClient) Close() {
	log.Println("Calling HTTPClient.Close()")

	godotCallVoid(o, "close")
	log.Println("  Function successfully completed.")

}

/*
   Connect to a host. This needs to be done before any requests are sent. The host should not have http:// prepended but will strip the protocol identifier if provided. If no [code]port[/code] is specified (or [code]-1[/code] is used), it is automatically set to 80 for HTTP and 443 for HTTPS (if [code]use_ssl[/code] is enabled). [code]verify_host[/code] will check the SSL identity of the host if set to [code]true[/code].
*/
func (o *HTTPClient) ConnectToHost(host string, port int64, useSsl bool, verifyHost bool) int64 {
	log.Println("Calling HTTPClient.ConnectToHost()")

	returnValue := godotCallIntStringIntBoolBool(o, "connect_to_host", host, port, useSsl, verifyHost)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPClient) GetConnection() *StreamPeer {
	log.Println("Calling HTTPClient.GetConnection()")

	returnValue := godotCallObject(o, "get_connection")
	log.Println("  Got return value: ", returnValue)

	var ret StreamPeer
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the response's body length.
*/
func (o *HTTPClient) GetResponseBodyLength() int64 {
	log.Println("Calling HTTPClient.GetResponseBodyLength()")

	returnValue := godotCallInt(o, "get_response_body_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the response's HTTP status code.
*/
func (o *HTTPClient) GetResponseCode() int64 {
	log.Println("Calling HTTPClient.GetResponseCode()")

	returnValue := godotCallInt(o, "get_response_code")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the response headers.
*/
func (o *HTTPClient) GetResponseHeaders() *PoolStringArray {
	log.Println("Calling HTTPClient.GetResponseHeaders()")

	returnValue := godotCallPoolStringArray(o, "get_response_headers")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns all response headers as dictionary where the case-sensitivity of the keys and values is kept like the server delivers it. A value is a simple String, this string can have more than one value where "; " is used as separator. Structure: ("key":"value1; value2") Example: (content-length:12), (Content-Type:application/json; charset=UTF-8)
*/
func (o *HTTPClient) GetResponseHeadersAsDictionary() *Dictionary {
	log.Println("Calling HTTPClient.GetResponseHeadersAsDictionary()")

	returnValue := godotCallDictionary(o, "get_response_headers_as_dictionary")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a STATUS_* enum constant. Need to call [method poll] in order to get status updates.
*/
func (o *HTTPClient) GetStatus() int64 {
	log.Println("Calling HTTPClient.GetStatus()")

	returnValue := godotCallInt(o, "get_status")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] this [code]HTTPClient[/code] has a response available.
*/
func (o *HTTPClient) HasResponse() bool {
	log.Println("Calling HTTPClient.HasResponse()")

	returnValue := godotCallBool(o, "has_response")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPClient) IsBlockingModeEnabled() bool {
	log.Println("Calling HTTPClient.IsBlockingModeEnabled()")

	returnValue := godotCallBool(o, "is_blocking_mode_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] this [code]HTTPClient[/code] has a response that is chunked.
*/
func (o *HTTPClient) IsResponseChunked() bool {
	log.Println("Calling HTTPClient.IsResponseChunked()")

	returnValue := godotCallBool(o, "is_response_chunked")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   This needs to be called in order to have any request processed. Check results with [method get_status]
*/
func (o *HTTPClient) Poll() int64 {
	log.Println("Calling HTTPClient.Poll()")

	returnValue := godotCallInt(o, "poll")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Generates a GET/POST application/x-www-form-urlencoded style query string from a provided dictionary, e.g.: [codeblock] var fields = {"username": "user", "password": "pass"} String queryString = httpClient.query_string_from_dict(fields) returns:= "username=user&password=pass" [/codeblock]
*/
func (o *HTTPClient) QueryStringFromDict(fields *Dictionary) string {
	log.Println("Calling HTTPClient.QueryStringFromDict()")

	returnValue := godotCallStringDictionary(o, "query_string_from_dict", fields)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Reads one chunk from the response.
*/
func (o *HTTPClient) ReadResponseBodyChunk() *PoolByteArray {
	log.Println("Calling HTTPClient.ReadResponseBodyChunk()")

	returnValue := godotCallPoolByteArray(o, "read_response_body_chunk")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sends a request to the connected host. The URL parameter is just the part after the host, so for [code]http://somehost.com/index.php[/code], it is [code]index.php[/code]. Headers are HTTP request headers. For available HTTP methods, see [code]METHOD_*[/code]. To create a POST request with query strings to push to the server, do: [codeblock] var fields = {"username" : "user", "password" : "pass"} var queryString = httpClient.query_string_from_dict(fields) var headers = ["Content-Type: application/x-www-form-urlencoded", "Content-Length: " + str(queryString.length())] var result = httpClient.request(httpClient.METHOD_POST, "index.php", headers, queryString) [/codeblock]
*/
func (o *HTTPClient) Request(method int64, url string, headers *PoolStringArray, body string) int64 {
	log.Println("Calling HTTPClient.Request()")

	returnValue := godotCallIntIntStringPoolStringArrayString(o, "request", method, url, headers, body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sends a raw request to the connected host. The URL parameter is just the part after the host, so for [code]http://somehost.com/index.php[/code], it is [code]index.php[/code]. Headers are HTTP request headers. For available HTTP methods, see [code]METHOD_*[/code]. Sends the body data raw, as a byte array and does not encode it in any way.
*/
func (o *HTTPClient) RequestRaw(method int64, url string, headers *PoolStringArray, body *PoolByteArray) int64 {
	log.Println("Calling HTTPClient.RequestRaw()")

	returnValue := godotCallIntIntStringPoolStringArrayPoolByteArray(o, "request_raw", method, url, headers, body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPClient) SetBlockingMode(enabled bool) {
	log.Println("Calling HTTPClient.SetBlockingMode()")

	godotCallVoidBool(o, "set_blocking_mode", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *HTTPClient) SetConnection(connection *StreamPeer) {
	log.Println("Calling HTTPClient.SetConnection()")

	godotCallVoidObject(o, "set_connection", &connection.Object)
	log.Println("  Function successfully completed.")

}

/*
   Sets the size of the buffer used and maximum bytes to read per iteration. see [method read_response_body_chunk]
*/
func (o *HTTPClient) SetReadChunkSize(bytes int64) {
	log.Println("Calling HTTPClient.SetReadChunkSize()")

	godotCallVoidInt(o, "set_read_chunk_size", bytes)
	log.Println("  Function successfully completed.")

}

/*
   HTTPClientImplementer is an interface for HTTPClient objects.
*/
type HTTPClientImplementer interface {
	Class
}

/*
   A node with the ability to send HTTP requests. Uses [HTTPClient] internally. Can be used to make HTTP requests, i.e. download or upload files or web content via HTTP.
*/
type HTTPRequest struct {
	Node
}

func (o *HTTPRequest) baseClass() string {
	return "HTTPRequest"
}

/*
   Undocumented
*/
func (o *HTTPRequest) X_RedirectRequest(arg0 string) {
	log.Println("Calling HTTPRequest.X_RedirectRequest()")

	godotCallVoidString(o, "_redirect_request", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *HTTPRequest) X_RequestDone(arg0 int64, arg1 int64, arg2 *PoolStringArray, arg3 *PoolByteArray) {
	log.Println("Calling HTTPRequest.X_RequestDone()")

	godotCallVoidIntIntPoolStringArrayPoolByteArray(o, "_request_done", arg0, arg1, arg2, arg3)
	log.Println("  Function successfully completed.")

}

/*
   Cancels the current request.
*/
func (o *HTTPRequest) CancelRequest() {
	log.Println("Calling HTTPRequest.CancelRequest()")

	godotCallVoid(o, "cancel_request")
	log.Println("  Function successfully completed.")

}

/*
   Returns the response body length.
*/
func (o *HTTPRequest) GetBodySize() int64 {
	log.Println("Calling HTTPRequest.GetBodySize()")

	returnValue := godotCallInt(o, "get_body_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPRequest) GetBodySizeLimit() int64 {
	log.Println("Calling HTTPRequest.GetBodySizeLimit()")

	returnValue := godotCallInt(o, "get_body_size_limit")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPRequest) GetDownloadFile() string {
	log.Println("Calling HTTPRequest.GetDownloadFile()")

	returnValue := godotCallString(o, "get_download_file")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the amount of bytes this HTTPRequest downloaded.
*/
func (o *HTTPRequest) GetDownloadedBytes() int64 {
	log.Println("Calling HTTPRequest.GetDownloadedBytes()")

	returnValue := godotCallInt(o, "get_downloaded_bytes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the current status of the underlying [HTTPClient]. See [code]STATUS_*[/code] enum on [HTTPClient].
*/
func (o *HTTPRequest) GetHttpClientStatus() int64 {
	log.Println("Calling HTTPRequest.GetHttpClientStatus()")

	returnValue := godotCallInt(o, "get_http_client_status")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPRequest) GetMaxRedirects() int64 {
	log.Println("Calling HTTPRequest.GetMaxRedirects()")

	returnValue := godotCallInt(o, "get_max_redirects")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPRequest) IsUsingThreads() bool {
	log.Println("Calling HTTPRequest.IsUsingThreads()")

	returnValue := godotCallBool(o, "is_using_threads")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *HTTPRequest) Request(url string, customHeaders *PoolStringArray, sslValidateDomain bool, method int64, requestData string) int64 {
	log.Println("Calling HTTPRequest.Request()")

	returnValue := godotCallIntStringPoolStringArrayBoolIntString(o, "request", url, customHeaders, sslValidateDomain, method, requestData)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPRequest) SetBodySizeLimit(bytes int64) {
	log.Println("Calling HTTPRequest.SetBodySizeLimit()")

	godotCallVoidInt(o, "set_body_size_limit", bytes)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *HTTPRequest) SetDownloadFile(path string) {
	log.Println("Calling HTTPRequest.SetDownloadFile()")

	godotCallVoidString(o, "set_download_file", path)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *HTTPRequest) SetMaxRedirects(amount int64) {
	log.Println("Calling HTTPRequest.SetMaxRedirects()")

	godotCallVoidInt(o, "set_max_redirects", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *HTTPRequest) SetUseThreads(enable bool) {
	log.Println("Calling HTTPRequest.SetUseThreads()")

	godotCallVoidBool(o, "set_use_threads", enable)
	log.Println("  Function successfully completed.")

}

/*
   HTTPRequestImplementer is an interface for HTTPRequest objects.
*/
type HTTPRequestImplementer interface {
	Class
}

/*
   Normally uses the z-axis of body A as the hinge axis, another axis can be specified when adding it manually though.
*/
type HingeJoint struct {
	Joint
}

func (o *HingeJoint) baseClass() string {
	return "HingeJoint"
}

/*
   Undocumented
*/
func (o *HingeJoint) X_GetLowerLimit() float64 {
	log.Println("Calling HingeJoint.X_GetLowerLimit()")

	returnValue := godotCallFloat(o, "_get_lower_limit")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HingeJoint) X_GetUpperLimit() float64 {
	log.Println("Calling HingeJoint.X_GetUpperLimit()")

	returnValue := godotCallFloat(o, "_get_upper_limit")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HingeJoint) X_SetLowerLimit(lowerLimit float64) {
	log.Println("Calling HingeJoint.X_SetLowerLimit()")

	godotCallVoidFloat(o, "_set_lower_limit", lowerLimit)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *HingeJoint) X_SetUpperLimit(upperLimit float64) {
	log.Println("Calling HingeJoint.X_SetUpperLimit()")

	godotCallVoidFloat(o, "_set_upper_limit", upperLimit)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *HingeJoint) GetFlag(flag int64) bool {
	log.Println("Calling HingeJoint.GetFlag()")

	returnValue := godotCallBoolInt(o, "get_flag", flag)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HingeJoint) GetParam(param int64) float64 {
	log.Println("Calling HingeJoint.GetParam()")

	returnValue := godotCallFloatInt(o, "get_param", param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *HingeJoint) SetFlag(flag int64, enabled bool) {
	log.Println("Calling HingeJoint.SetFlag()")

	godotCallVoidIntBool(o, "set_flag", flag, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *HingeJoint) SetParam(param int64, value float64) {
	log.Println("Calling HingeJoint.SetParam()")

	godotCallVoidIntFloat(o, "set_param", param, value)
	log.Println("  Function successfully completed.")

}

/*
   HingeJointImplementer is an interface for HingeJoint objects.
*/
type HingeJointImplementer interface {
	Class
}

func newSingletonIP() *ip {
	obj := &ip{}
	name := C.CString("IP")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   IP contains support functions for the Internet Protocol (IP). TCP/IP support is in different classes (see [StreamPeerTCP] and [TCP_Server]). IP provides DNS hostname resolution support, both blocking and threaded.
*/
var IP = newSingletonIP()

/*
   IP contains support functions for the Internet Protocol (IP). TCP/IP support is in different classes (see [StreamPeerTCP] and [TCP_Server]). IP provides DNS hostname resolution support, both blocking and threaded.
*/
type ip struct {
	Object
}

func (o *ip) baseClass() string {
	return "IP"
}

/*
   Removes all of a "hostname"'s cached references. If no "hostname" is given then all cached IP addresses are removed.
*/
func (o *ip) ClearCache(hostname string) {
	log.Println("Calling IP.ClearCache()")

	godotCallVoidString(o, "clear_cache", hostname)
	log.Println("  Function successfully completed.")

}

/*
   Removes a given item "id" from the queue. This should be used to free a queue after it has completed to enable more queries to happen.
*/
func (o *ip) EraseResolveItem(id int64) {
	log.Println("Calling IP.EraseResolveItem()")

	godotCallVoidInt(o, "erase_resolve_item", id)
	log.Println("  Function successfully completed.")

}

/*
   Returns all of the user's current IPv4 and IPv6 addresses as an array.
*/
func (o *ip) GetLocalAddresses() *Array {
	log.Println("Calling IP.GetLocalAddresses()")

	returnValue := godotCallArray(o, "get_local_addresses")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a queued hostname's IP address, given its queue "id". Returns an empty string on error or if resolution hasn't happened yet (see [method get_resolve_item_status]).
*/
func (o *ip) GetResolveItemAddress(id int64) string {
	log.Println("Calling IP.GetResolveItemAddress()")

	returnValue := godotCallStringInt(o, "get_resolve_item_address", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a queued hostname's status as a RESOLVER_STATUS_* constant, given its queue "id".
*/
func (o *ip) GetResolveItemStatus(id int64) int64 {
	log.Println("Calling IP.GetResolveItemStatus()")

	returnValue := godotCallIntInt(o, "get_resolve_item_status", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a given hostname's IPv4 or IPv6 address when resolved (blocking-type method). The address type returned depends on the TYPE_* constant given as "ip_type".
*/
func (o *ip) ResolveHostname(host string, ipType int64) string {
	log.Println("Calling IP.ResolveHostname()")

	returnValue := godotCallStringStringInt(o, "resolve_hostname", host, ipType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Creates a queue item to resolve a hostname to an IPv4 or IPv6 address depending on the TYPE_* constant given as "ip_type". Returns the queue ID if successful, or RESOLVER_INVALID_ID on error.
*/
func (o *ip) ResolveHostnameQueueItem(host string, ipType int64) int64 {
	log.Println("Calling IP.ResolveHostnameQueueItem()")

	returnValue := godotCallIntStringInt(o, "resolve_hostname_queue_item", host, ipType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Unix-specific implementation of IP support functions. See [IP].
*/
type IP_Unix struct {
	ip
}

func (o *IP_Unix) baseClass() string {
	return "IP_Unix"
}

/*
   IP_UnixImplementer is an interface for IP_Unix objects.
*/
type IP_UnixImplementer interface {
	Class
}

/*
   Native image datatype. Contains image data, which can be converted to a [Texture], and several functions to interact with it. The maximum width and height for an [code]Image[/code] is 16384 pixels.
*/
type Image struct {
	Resource
}

func (o *Image) baseClass() string {
	return "Image"
}

/*
   Undocumented
*/
func (o *Image) X_GetData() *Dictionary {
	log.Println("Calling Image.X_GetData()")

	returnValue := godotCallDictionary(o, "_get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Image) X_SetData(data *Dictionary) {
	log.Println("Calling Image.X_SetData()")

	godotCallVoidDictionary(o, "_set_data", data)
	log.Println("  Function successfully completed.")

}

/*
   Alpha-blends [code]src_rect[/code] from [code]src[/code] image to this image at coordinates [code]dest[/code].
*/
func (o *Image) BlendRect(src *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlendRect()")

	godotCallVoidObjectRect2Vector2(o, "blend_rect", &src.Object, srcRect, dst)
	log.Println("  Function successfully completed.")

}

/*
   Alpha-blends [code]src_rect[/code] from [code]src[/code] image to this image using [code]mask[/code] image at coordinates [code]dst[/code]. Alpha channels are required for both [code]src[/code] and [code]mask[/code]. [code]dst[/code] pixels and [code]src[/code] pixels will blend if the corresponding mask pixel's alpha value is not 0. [code]src[/code] image and [code]mask[/code] image [b]must[/b] have the same size (width and height) but they can have different formats.
*/
func (o *Image) BlendRectMask(src *Image, mask *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlendRectMask()")

	godotCallVoidObjectObjectRect2Vector2(o, "blend_rect_mask", &src.Object, &mask.Object, srcRect, dst)
	log.Println("  Function successfully completed.")

}

/*
   Copies [code]src_rect[/code] from [code]src[/code] image to this image at coordinates [code]dst[/code].
*/
func (o *Image) BlitRect(src *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlitRect()")

	godotCallVoidObjectRect2Vector2(o, "blit_rect", &src.Object, srcRect, dst)
	log.Println("  Function successfully completed.")

}

/*
   Blits [code]src_rect[/code] area from [code]src[/code] image to this image at the coordinates given by [code]dst[/code]. [code]src[/code] pixel is copied onto [code]dst[/code] if the corresponding [code]mask[/code] pixel's alpha value is not 0. [code]src[/code] image and [code]mask[/code] image [b]must[/b] have the same size (width and height) but they can have different formats.
*/
func (o *Image) BlitRectMask(src *Image, mask *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlitRectMask()")

	godotCallVoidObjectObjectRect2Vector2(o, "blit_rect_mask", &src.Object, &mask.Object, srcRect, dst)
	log.Println("  Function successfully completed.")

}

/*
   Removes the image's mipmaps.
*/
func (o *Image) ClearMipmaps() {
	log.Println("Calling Image.ClearMipmaps()")

	godotCallVoid(o, "clear_mipmaps")
	log.Println("  Function successfully completed.")

}

/*
   Compresses the image to use less memory. Can not directly access pixel data while the image is compressed. Returns error if the chosen compression mode is not available. See [code]COMPRESS_*[/code] constants.
*/
func (o *Image) Compress(mode int64, source int64, lossyQuality float64) int64 {
	log.Println("Calling Image.Compress()")

	returnValue := godotCallIntIntIntFloat(o, "compress", mode, source, lossyQuality)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Converts the image's format. See [code]FORMAT_*[/code] constants.
*/
func (o *Image) Convert(format int64) {
	log.Println("Calling Image.Convert()")

	godotCallVoidInt(o, "convert", format)
	log.Println("  Function successfully completed.")

}

/*
   Copies [code]src[/code] image to this image.
*/
func (o *Image) CopyFrom(src *Image) {
	log.Println("Calling Image.CopyFrom()")

	godotCallVoidObject(o, "copy_from", &src.Object)
	log.Println("  Function successfully completed.")

}

/*
   Creates an empty image of given size and format. See [code]FORMAT_*[/code] constants. If [code]use_mipmaps[/code] is true then generate mipmaps for this image. See the [code]generate_mipmaps[/code] method.
*/
func (o *Image) Create(width int64, height int64, useMipmaps bool, format int64) {
	log.Println("Calling Image.Create()")

	godotCallVoidIntIntBoolInt(o, "create", width, height, useMipmaps, format)
	log.Println("  Function successfully completed.")

}

/*
   Creates a new image of given size and format. See [code]FORMAT_*[/code] constants. Fills the image with the given raw data. If [code]use_mipmaps[/code] is true then generate mipmaps for this image. See the [code]generate_mipmaps[/code] method.
*/
func (o *Image) CreateFromData(width int64, height int64, useMipmaps bool, format int64, data *PoolByteArray) {
	log.Println("Calling Image.CreateFromData()")

	godotCallVoidIntIntBoolIntPoolByteArray(o, "create_from_data", width, height, useMipmaps, format, data)
	log.Println("  Function successfully completed.")

}

/*
   Crops the image to the given [code]width[/code] and [code]height[/code]. If the specified size is larger than the current size, the extra area is filled with black pixels.
*/
func (o *Image) Crop(width int64, height int64) {
	log.Println("Calling Image.Crop()")

	godotCallVoidIntInt(o, "crop", width, height)
	log.Println("  Function successfully completed.")

}

/*
   Decompresses the image if it is compressed. Returns an error if decompress function is not available.
*/
func (o *Image) Decompress() int64 {
	log.Println("Calling Image.Decompress()")

	returnValue := godotCallInt(o, "decompress")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns ALPHA_BLEND if the image has data for alpha values. Returns ALPHA_BIT if all the alpha values are below a certain threshold or the maximum value. Returns ALPHA_NONE if no data for alpha values is found.
*/
func (o *Image) DetectAlpha() int64 {
	log.Println("Calling Image.DetectAlpha()")

	returnValue := godotCallInt(o, "detect_alpha")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Stretches the image and enlarges it by a factor of 2. No interpolation is done.
*/
func (o *Image) ExpandX2Hq2X() {
	log.Println("Calling Image.ExpandX2Hq2X()")

	godotCallVoid(o, "expand_x2_hq2x")
	log.Println("  Function successfully completed.")

}

/*
   Fills the image with a given [Color].
*/
func (o *Image) Fill(color *Color) {
	log.Println("Calling Image.Fill()")

	godotCallVoidColor(o, "fill", color)
	log.Println("  Function successfully completed.")

}

/*
   Blends low-alpha pixels with nearby pixels.
*/
func (o *Image) FixAlphaEdges() {
	log.Println("Calling Image.FixAlphaEdges()")

	godotCallVoid(o, "fix_alpha_edges")
	log.Println("  Function successfully completed.")

}

/*
   Flips the image horizontally.
*/
func (o *Image) FlipX() {
	log.Println("Calling Image.FlipX()")

	godotCallVoid(o, "flip_x")
	log.Println("  Function successfully completed.")

}

/*
   Flips the image vertically.
*/
func (o *Image) FlipY() {
	log.Println("Calling Image.FlipY()")

	godotCallVoid(o, "flip_y")
	log.Println("  Function successfully completed.")

}

/*
   Generates mipmaps for the image. Mipmaps are pre-calculated and lower resolution copies of the image. Mipmaps are automatically used if the image needs to be scaled down when rendered. This improves image quality and the performance of the rendering. Returns an error if the image is compressed, in a custom format or if the image's width/height is 0.
*/
func (o *Image) GenerateMipmaps() int64 {
	log.Println("Calling Image.GenerateMipmaps()")

	returnValue := godotCallInt(o, "generate_mipmaps")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the image's raw data.
*/
func (o *Image) GetData() *PoolByteArray {
	log.Println("Calling Image.GetData()")

	returnValue := godotCallPoolByteArray(o, "get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the image’s format. See [code]FORMAT_*[/code] constants.
*/
func (o *Image) GetFormat() int64 {
	log.Println("Calling Image.GetFormat()")

	returnValue := godotCallInt(o, "get_format")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the image's height.
*/
func (o *Image) GetHeight() int64 {
	log.Println("Calling Image.GetHeight()")

	returnValue := godotCallInt(o, "get_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the offset where the image's mipmap with index [code]mipmap[/code] is stored in the [code]data[/code] dictionary.
*/
func (o *Image) GetMipmapOffset(mipmap int64) int64 {
	log.Println("Calling Image.GetMipmapOffset()")

	returnValue := godotCallIntInt(o, "get_mipmap_offset", mipmap)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the color of the pixel at [code](x, y)[/code] if the image is locked. If the image is unlocked it always returns a [Color] with the value [code](0, 0, 0, 1.0)[/code].
*/
func (o *Image) GetPixel(x int64, y int64) *Color {
	log.Println("Calling Image.GetPixel()")

	returnValue := godotCallColorIntInt(o, "get_pixel", x, y)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a new image that is a copy of the image's area specified with [code]rect[/code].
*/
func (o *Image) GetRect(rect *Rect2) *Image {
	log.Println("Calling Image.GetRect()")

	returnValue := godotCallObjectRect2(o, "get_rect", rect)
	log.Println("  Got return value: ", returnValue)

	var ret Image
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the image's size (width and height).
*/
func (o *Image) GetSize() *Vector2 {
	log.Println("Calling Image.GetSize()")

	returnValue := godotCallVector2(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a [Rect2] enclosing the visible portion of the image.
*/
func (o *Image) GetUsedRect() *Rect2 {
	log.Println("Calling Image.GetUsedRect()")

	returnValue := godotCallRect2(o, "get_used_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the image's width.
*/
func (o *Image) GetWidth() int64 {
	log.Println("Calling Image.GetWidth()")

	returnValue := godotCallInt(o, "get_width")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the image has generated mipmaps.
*/
func (o *Image) HasMipmaps() bool {
	log.Println("Calling Image.HasMipmaps()")

	returnValue := godotCallBool(o, "has_mipmaps")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the image is compressed.
*/
func (o *Image) IsCompressed() bool {
	log.Println("Calling Image.IsCompressed()")

	returnValue := godotCallBool(o, "is_compressed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the image has no data.
*/
func (o *Image) IsEmpty() bool {
	log.Println("Calling Image.IsEmpty()")

	returnValue := godotCallBool(o, "is_empty")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if all the image's pixels have an alpha value of 0. Returns [code]false[/code] if any pixel has an alpha value higher than 0.
*/
func (o *Image) IsInvisible() bool {
	log.Println("Calling Image.IsInvisible()")

	returnValue := godotCallBool(o, "is_invisible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Loads an image from file [code]path[/code].
*/
func (o *Image) Load(path string) int64 {
	log.Println("Calling Image.Load()")

	returnValue := godotCallIntString(o, "load", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Image) LoadJpgFromBuffer(buffer *PoolByteArray) int64 {
	log.Println("Calling Image.LoadJpgFromBuffer()")

	returnValue := godotCallIntPoolByteArray(o, "load_jpg_from_buffer", buffer)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Image) LoadPngFromBuffer(buffer *PoolByteArray) int64 {
	log.Println("Calling Image.LoadPngFromBuffer()")

	returnValue := godotCallIntPoolByteArray(o, "load_png_from_buffer", buffer)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Locks the data for writing access.
*/
func (o *Image) Lock() {
	log.Println("Calling Image.Lock()")

	godotCallVoid(o, "lock")
	log.Println("  Function successfully completed.")

}

/*
   Converts the image's data to represent coordinates on a 3D plane. This is used when the image represents a normalmap. A normalmap can add lots of detail to a 3D surface without increasing the polygon count.
*/
func (o *Image) NormalmapToXy() {
	log.Println("Calling Image.NormalmapToXy()")

	godotCallVoid(o, "normalmap_to_xy")
	log.Println("  Function successfully completed.")

}

/*
   Multiplies color values with alpha values. Resulting color values for a pixel are [code](color * alpha)/256[/code].
*/
func (o *Image) PremultiplyAlpha() {
	log.Println("Calling Image.PremultiplyAlpha()")

	godotCallVoid(o, "premultiply_alpha")
	log.Println("  Function successfully completed.")

}

/*
   Resizes the image to the given [code]width[/code] and [code]height[/code]. New pixels are calculated using [code]interpolation[/code]. See [code]interpolation[/code] constants.
*/
func (o *Image) Resize(width int64, height int64, interpolation int64) {
	log.Println("Calling Image.Resize()")

	godotCallVoidIntIntInt(o, "resize", width, height, interpolation)
	log.Println("  Function successfully completed.")

}

/*
   Resizes the image to the nearest power of 2 for the width and height. If [code]square[/code] is [code]true[/code] then set width and height to be the same.
*/
func (o *Image) ResizeToPo2(square bool) {
	log.Println("Calling Image.ResizeToPo2()")

	godotCallVoidBool(o, "resize_to_po2", square)
	log.Println("  Function successfully completed.")

}

/*
   Saves the image as a PNG file to [code]path[/code].
*/
func (o *Image) SavePng(path string) int64 {
	log.Println("Calling Image.SavePng()")

	returnValue := godotCallIntString(o, "save_png", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the [Color] of the pixel at [code](x, y)[/code] if the image is locked. Example: [codeblock] var img = Image.new() img.create(img_width, img_height, false, Image.FORMAT_RGBA8) img.lock() img.set_pixel(x, y, color) # Works img.unlock() img.set_pixel(x, y, color) # Does not have an effect [/codeblock]
*/
func (o *Image) SetPixel(x int64, y int64, color *Color) {
	log.Println("Calling Image.SetPixel()")

	godotCallVoidIntIntColor(o, "set_pixel", x, y, color)
	log.Println("  Function successfully completed.")

}

/*
   Shrinks the image by a factor of 2.
*/
func (o *Image) ShrinkX2() {
	log.Println("Calling Image.ShrinkX2()")

	godotCallVoid(o, "shrink_x2")
	log.Println("  Function successfully completed.")

}

/*
   Converts the raw data from the sRGB colorspace to a linear scale.
*/
func (o *Image) SrgbToLinear() {
	log.Println("Calling Image.SrgbToLinear()")

	godotCallVoid(o, "srgb_to_linear")
	log.Println("  Function successfully completed.")

}

/*
   Unlocks the data and prevents changes.
*/
func (o *Image) Unlock() {
	log.Println("Calling Image.Unlock()")

	godotCallVoid(o, "unlock")
	log.Println("  Function successfully completed.")

}

/*
   ImageImplementer is an interface for Image objects.
*/
type ImageImplementer interface {
	Class
}

/*
   A [Texture] based on an [Image]. Can be created from an [Image] with [method create_from_image].
*/
type ImageTexture struct {
	Texture
}

func (o *ImageTexture) baseClass() string {
	return "ImageTexture"
}

/*
   Undocumented
*/
func (o *ImageTexture) X_ReloadHook(rid *RID) {
	log.Println("Calling ImageTexture.X_ReloadHook()")

	godotCallVoidRid(o, "_reload_hook", rid)
	log.Println("  Function successfully completed.")

}

/*
   Create a new [code]ImageTexture[/code] with "width" and "height". "format" one of [Image].FORMAT_*. "flags" one or more of [Texture].FLAG_*.
*/
func (o *ImageTexture) Create(width int64, height int64, format int64, flags int64) {
	log.Println("Calling ImageTexture.Create()")

	godotCallVoidIntIntIntInt(o, "create", width, height, format, flags)
	log.Println("  Function successfully completed.")

}

/*
   Create a new [code]ImageTexture[/code] from an [Image] with "flags" from [Texture].FLAG_*.
*/
func (o *ImageTexture) CreateFromImage(image *Image, flags int64) {
	log.Println("Calling ImageTexture.CreateFromImage()")

	godotCallVoidObjectInt(o, "create_from_image", &image.Object, flags)
	log.Println("  Function successfully completed.")

}

/*
   Return the format of the [code]ImageTexture[/code], one of [Image].FORMAT_*.
*/
func (o *ImageTexture) GetFormat() int64 {
	log.Println("Calling ImageTexture.GetFormat()")

	returnValue := godotCallInt(o, "get_format")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ImageTexture) GetLossyStorageQuality() float64 {
	log.Println("Calling ImageTexture.GetLossyStorageQuality()")

	returnValue := godotCallFloat(o, "get_lossy_storage_quality")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ImageTexture) GetStorage() int64 {
	log.Println("Calling ImageTexture.GetStorage()")

	returnValue := godotCallInt(o, "get_storage")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Load an [code]ImageTexture[/code].
*/
func (o *ImageTexture) Load(path string) {
	log.Println("Calling ImageTexture.Load()")

	godotCallVoidString(o, "load", path)
	log.Println("  Function successfully completed.")

}

/*
   Set the [Image] of this [code]ImageTexture[/code].
*/
func (o *ImageTexture) SetData(image *Image) {
	log.Println("Calling ImageTexture.SetData()")

	godotCallVoidObject(o, "set_data", &image.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ImageTexture) SetLossyStorageQuality(quality float64) {
	log.Println("Calling ImageTexture.SetLossyStorageQuality()")

	godotCallVoidFloat(o, "set_lossy_storage_quality", quality)
	log.Println("  Function successfully completed.")

}

/*
   Resizes the [code]ImageTexture[/code] to the specified dimensions.
*/
func (o *ImageTexture) SetSizeOverride(size *Vector2) {
	log.Println("Calling ImageTexture.SetSizeOverride()")

	godotCallVoidVector2(o, "set_size_override", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ImageTexture) SetStorage(mode int64) {
	log.Println("Calling ImageTexture.SetStorage()")

	godotCallVoidInt(o, "set_storage", mode)
	log.Println("  Function successfully completed.")

}

/*
   ImageTextureImplementer is an interface for ImageTexture objects.
*/
type ImageTextureImplementer interface {
	Class
}

/*
   Draws simple geometry from code. Uses a drawing mode similar to OpenGL 1.x.
*/
type ImmediateGeometry struct {
	GeometryInstance
}

func (o *ImmediateGeometry) baseClass() string {
	return "ImmediateGeometry"
}

/*
   Simple helper to draw a uvsphere, with given latitudes, longitude and radius.
*/
func (o *ImmediateGeometry) AddSphere(lats int64, lons int64, radius float64, addUv bool) {
	log.Println("Calling ImmediateGeometry.AddSphere()")

	godotCallVoidIntIntFloatBool(o, "add_sphere", lats, lons, radius, addUv)
	log.Println("  Function successfully completed.")

}

/*
   Adds a vertex with the currently set color/uv/etc.
*/
func (o *ImmediateGeometry) AddVertex(position *Vector3) {
	log.Println("Calling ImmediateGeometry.AddVertex()")

	godotCallVoidVector3(o, "add_vertex", position)
	log.Println("  Function successfully completed.")

}

/*
   Begin drawing (And optionally pass a texture override). When done call end(). For more information on how this works, search for glBegin() glEnd() references. For the type of primitive, use the [Mesh].PRIMITIVE_* enumerations.
*/
func (o *ImmediateGeometry) Begin(primitive int64, texture *Texture) {
	log.Println("Calling ImmediateGeometry.Begin()")

	godotCallVoidIntObject(o, "begin", primitive, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Clears everything that was drawn using begin/end.
*/
func (o *ImmediateGeometry) Clear() {
	log.Println("Calling ImmediateGeometry.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Ends a drawing context and displays the results.
*/
func (o *ImmediateGeometry) End() {
	log.Println("Calling ImmediateGeometry.End()")

	godotCallVoid(o, "end")
	log.Println("  Function successfully completed.")

}

/*
   The current drawing color.
*/
func (o *ImmediateGeometry) SetColor(color *Color) {
	log.Println("Calling ImmediateGeometry.SetColor()")

	godotCallVoidColor(o, "set_color", color)
	log.Println("  Function successfully completed.")

}

/*
   The next vertex's normal.
*/
func (o *ImmediateGeometry) SetNormal(normal *Vector3) {
	log.Println("Calling ImmediateGeometry.SetNormal()")

	godotCallVoidVector3(o, "set_normal", normal)
	log.Println("  Function successfully completed.")

}

/*
   The next vertex's tangent (and binormal facing).
*/
func (o *ImmediateGeometry) SetTangent(tangent *Plane) {
	log.Println("Calling ImmediateGeometry.SetTangent()")

	godotCallVoidPlane(o, "set_tangent", tangent)
	log.Println("  Function successfully completed.")

}

/*
   The next vertex's UV.
*/
func (o *ImmediateGeometry) SetUv(uv *Vector2) {
	log.Println("Calling ImmediateGeometry.SetUv()")

	godotCallVoidVector2(o, "set_uv", uv)
	log.Println("  Function successfully completed.")

}

/*
   The next vertex's second layer UV.
*/
func (o *ImmediateGeometry) SetUv2(uv *Vector2) {
	log.Println("Calling ImmediateGeometry.SetUv2()")

	godotCallVoidVector2(o, "set_uv2", uv)
	log.Println("  Function successfully completed.")

}

/*
   ImmediateGeometryImplementer is an interface for ImmediateGeometry objects.
*/
type ImmediateGeometryImplementer interface {
	Class
}

func newSingletonInput() *input {
	obj := &input{}
	name := C.CString("Input")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   A Singleton that deals with inputs. This includes key presses, mouse buttons and movement, joypads, and input actions. Actions and their events can be set in the Project Settings / Input Map tab. Or be set with [InputMap].
*/
var Input = newSingletonInput()

/*
   A Singleton that deals with inputs. This includes key presses, mouse buttons and movement, joypads, and input actions. Actions and their events can be set in the Project Settings / Input Map tab. Or be set with [InputMap].
*/
type input struct {
	Object
}

func (o *input) baseClass() string {
	return "Input"
}

/*
   This will simulate pressing the specified action.
*/
func (o *input) ActionPress(action string) {
	log.Println("Calling Input.ActionPress()")

	godotCallVoidString(o, "action_press", action)
	log.Println("  Function successfully completed.")

}

/*
   If the specified action is already pressed, this will release it.
*/
func (o *input) ActionRelease(action string) {
	log.Println("Calling Input.ActionRelease()")

	godotCallVoidString(o, "action_release", action)
	log.Println("  Function successfully completed.")

}

/*
   Add a new mapping entry (in SDL2 format) to the mapping database. Optionally update already connected devices.
*/
func (o *input) AddJoyMapping(mapping string, updateExisting bool) {
	log.Println("Calling Input.AddJoyMapping()")

	godotCallVoidStringBool(o, "add_joy_mapping", mapping, updateExisting)
	log.Println("  Function successfully completed.")

}

/*
   If the device has an accelerometer, this will return the movement.
*/
func (o *input) GetAccelerometer() *Vector3 {
	log.Println("Calling Input.GetAccelerometer()")

	returnValue := godotCallVector3(o, "get_accelerometer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an [Array] containing the device IDs of all currently connected joypads.
*/
func (o *input) GetConnectedJoypads() *Array {
	log.Println("Calling Input.GetConnectedJoypads()")

	returnValue := godotCallArray(o, "get_connected_joypads")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *input) GetGravity() *Vector3 {
	log.Println("Calling Input.GetGravity()")

	returnValue := godotCallVector3(o, "get_gravity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If the device has a gyroscope, this will return the rate of rotation in rad/s around a device's x, y, and z axis.
*/
func (o *input) GetGyroscope() *Vector3 {
	log.Println("Calling Input.GetGyroscope()")

	returnValue := godotCallVector3(o, "get_gyroscope")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the current value of the joypad axis at given index (see [code]JOY_*[/code] constants in [@GlobalScope])
*/
func (o *input) GetJoyAxis(device int64, axis int64) float64 {
	log.Println("Calling Input.GetJoyAxis()")

	returnValue := godotCallFloatIntInt(o, "get_joy_axis", device, axis)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *input) GetJoyAxisIndexFromString(axis string) int64 {
	log.Println("Calling Input.GetJoyAxisIndexFromString()")

	returnValue := godotCallIntString(o, "get_joy_axis_index_from_string", axis)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *input) GetJoyAxisString(axisIndex int64) string {
	log.Println("Calling Input.GetJoyAxisString()")

	returnValue := godotCallStringInt(o, "get_joy_axis_string", axisIndex)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *input) GetJoyButtonIndexFromString(button string) int64 {
	log.Println("Calling Input.GetJoyButtonIndexFromString()")

	returnValue := godotCallIntString(o, "get_joy_button_index_from_string", button)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *input) GetJoyButtonString(buttonIndex int64) string {
	log.Println("Calling Input.GetJoyButtonString()")

	returnValue := godotCallStringInt(o, "get_joy_button_string", buttonIndex)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a SDL2 compatible device guid on platforms that use gamepad remapping. Returns "Default Gamepad" otherwise.
*/
func (o *input) GetJoyGuid(device int64) string {
	log.Println("Calling Input.GetJoyGuid()")

	returnValue := godotCallStringInt(o, "get_joy_guid", device)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the name of the joypad at the specified device index
*/
func (o *input) GetJoyName(device int64) string {
	log.Println("Calling Input.GetJoyName()")

	returnValue := godotCallStringInt(o, "get_joy_name", device)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the duration of the current vibration effect in seconds.
*/
func (o *input) GetJoyVibrationDuration(device int64) float64 {
	log.Println("Calling Input.GetJoyVibrationDuration()")

	returnValue := godotCallFloatInt(o, "get_joy_vibration_duration", device)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the strength of the joypad vibration: x is the strength of the weak motor, and y is the strength of the strong motor.
*/
func (o *input) GetJoyVibrationStrength(device int64) *Vector2 {
	log.Println("Calling Input.GetJoyVibrationStrength()")

	returnValue := godotCallVector2Int(o, "get_joy_vibration_strength", device)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the mouse speed for the last time the cursor was moved, and this until the next frame where the mouse moves. This means that even if the mouse is not moving, this function will still return the value of the last motion.
*/
func (o *input) GetLastMouseSpeed() *Vector2 {
	log.Println("Calling Input.GetLastMouseSpeed()")

	returnValue := godotCallVector2(o, "get_last_mouse_speed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If the device has a magnetometer, this will return the magnetic field strength in micro-Tesla for all axes.
*/
func (o *input) GetMagnetometer() *Vector3 {
	log.Println("Calling Input.GetMagnetometer()")

	returnValue := godotCallVector3(o, "get_magnetometer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns mouse buttons as a bitmask. If multiple mouse buttons are pressed at the same time the bits are added together.
*/
func (o *input) GetMouseButtonMask() int64 {
	log.Println("Calling Input.GetMouseButtonMask()")

	returnValue := godotCallInt(o, "get_mouse_button_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the mouse mode. See the constants for more information.
*/
func (o *input) GetMouseMode() int64 {
	log.Println("Calling Input.GetMouseMode()")

	returnValue := godotCallInt(o, "get_mouse_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] when you start pressing the action event.
*/
func (o *input) IsActionJustPressed(action string) bool {
	log.Println("Calling Input.IsActionJustPressed()")

	returnValue := godotCallBoolString(o, "is_action_just_pressed", action)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] when you stop pressing the action event.
*/
func (o *input) IsActionJustReleased(action string) bool {
	log.Println("Calling Input.IsActionJustReleased()")

	returnValue := godotCallBoolString(o, "is_action_just_released", action)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if you are pressing the action event.
*/
func (o *input) IsActionPressed(action string) bool {
	log.Println("Calling Input.IsActionPressed()")

	returnValue := godotCallBoolString(o, "is_action_pressed", action)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if you are pressing the joypad button. (see [code]JOY_*[/code] constants in [@GlobalScope])
*/
func (o *input) IsJoyButtonPressed(device int64, button int64) bool {
	log.Println("Calling Input.IsJoyButtonPressed()")

	returnValue := godotCallBoolIntInt(o, "is_joy_button_pressed", device, button)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the system knows the specified device. This means that it sets all button and axis indices exactly as defined in the [code]JOY_*[/code] constants (see [@GlobalScope]). Unknown joypads are not expected to match these constants, but you can still retrieve events from them.
*/
func (o *input) IsJoyKnown(device int64) bool {
	log.Println("Calling Input.IsJoyKnown()")

	returnValue := godotCallBoolInt(o, "is_joy_known", device)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if you are pressing the key. You can pass [code]KEY_*[/code], which are pre-defined constants listed in [@GlobalScope].
*/
func (o *input) IsKeyPressed(scancode int64) bool {
	log.Println("Calling Input.IsKeyPressed()")

	returnValue := godotCallBoolInt(o, "is_key_pressed", scancode)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if you are pressing the mouse button. You can pass [code]BUTTON_*[/code], which are pre-defined constants listed in [@GlobalScope].
*/
func (o *input) IsMouseButtonPressed(button int64) bool {
	log.Println("Calling Input.IsMouseButtonPressed()")

	returnValue := godotCallBoolInt(o, "is_mouse_button_pressed", button)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *input) JoyConnectionChanged(device int64, connected bool, name string, guid string) {
	log.Println("Calling Input.JoyConnectionChanged()")

	godotCallVoidIntBoolStringString(o, "joy_connection_changed", device, connected, name, guid)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *input) ParseInputEvent(event *InputEvent) {
	log.Println("Calling Input.ParseInputEvent()")

	godotCallVoidObject(o, "parse_input_event", &event.Object)
	log.Println("  Function successfully completed.")

}

/*
   Removes all mappings from the internal db that match the given uid.
*/
func (o *input) RemoveJoyMapping(guid string) {
	log.Println("Calling Input.RemoveJoyMapping()")

	godotCallVoidString(o, "remove_joy_mapping", guid)
	log.Println("  Function successfully completed.")

}

/*
   Set a custom mouse cursor image, which is only visible inside the game window. The hotspot can also be specified. See enum [code]CURSOR_*[/code] for the list of shapes.
*/
func (o *input) SetCustomMouseCursor(image *Resource, shape int64, hotspot *Vector2) {
	log.Println("Calling Input.SetCustomMouseCursor()")

	godotCallVoidObjectIntVector2(o, "set_custom_mouse_cursor", &image.Object, shape, hotspot)
	log.Println("  Function successfully completed.")

}

/*
   Set the mouse mode. See the constants for more information.
*/
func (o *input) SetMouseMode(mode int64) {
	log.Println("Calling Input.SetMouseMode()")

	godotCallVoidInt(o, "set_mouse_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Starts to vibrate the joypad. Joypads usually come with two rumble motors, a strong and a weak one. weak_magnitude is the strength of the weak motor (between 0 and 1) and strong_magnitude is the strength of the strong motor (between 0 and 1). duration is the duration of the effect in seconds (a duration of 0 will try to play the vibration indefinitely). Note that not every hardware is compatible with long effect durations, it is recommended to restart an effect if in need to play it for more than a few seconds.
*/
func (o *input) StartJoyVibration(device int64, weakMagnitude float64, strongMagnitude float64, duration float64) {
	log.Println("Calling Input.StartJoyVibration()")

	godotCallVoidIntFloatFloatFloat(o, "start_joy_vibration", device, weakMagnitude, strongMagnitude, duration)
	log.Println("  Function successfully completed.")

}

/*
   Stops the vibration of the joypad.
*/
func (o *input) StopJoyVibration(device int64) {
	log.Println("Calling Input.StopJoyVibration()")

	godotCallVoidInt(o, "stop_joy_vibration", device)
	log.Println("  Function successfully completed.")

}

/*
   Sets the mouse position to the specified vector.
*/
func (o *input) WarpMousePosition(to *Vector2) {
	log.Println("Calling Input.WarpMousePosition()")

	godotCallVoidVector2(o, "warp_mouse_position", to)
	log.Println("  Function successfully completed.")

}

/*
   Default implementation of the [Input] class, used internally by the editor and games for default input management.
*/
type InputDefault struct {
	input
}

func (o *InputDefault) baseClass() string {
	return "InputDefault"
}

/*
   InputDefaultImplementer is an interface for InputDefault objects.
*/
type InputDefaultImplementer interface {
	Class
}

/*
   Base class of all sort of input event. See [method Node._input].
*/
type InputEvent struct {
	Resource
}

func (o *InputEvent) baseClass() string {
	return "InputEvent"
}

/*
   Returns [code]true[/code] if this event matches [code]event[/code].
*/
func (o *InputEvent) ActionMatch(event *InputEvent) bool {
	log.Println("Calling InputEvent.ActionMatch()")

	returnValue := godotCallBoolObject(o, "action_match", &event.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a [String] representation of the event.
*/
func (o *InputEvent) AsText() string {
	log.Println("Calling InputEvent.AsText()")

	returnValue := godotCallString(o, "as_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEvent) GetDevice() int64 {
	log.Println("Calling InputEvent.GetDevice()")

	returnValue := godotCallInt(o, "get_device")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if this input event matches a pre-defined action of any type.
*/
func (o *InputEvent) IsAction(action string) bool {
	log.Println("Calling InputEvent.IsAction()")

	returnValue := godotCallBoolString(o, "is_action", action)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the given action is being pressed (and is not an echo event for KEY events). Not relevant for the event types [code]MOUSE_MOTION[/code], [code]SCREEN_DRAG[/code] or [code]NONE[/code].
*/
func (o *InputEvent) IsActionPressed(action string) bool {
	log.Println("Calling InputEvent.IsActionPressed()")

	returnValue := godotCallBoolString(o, "is_action_pressed", action)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the given action is released (i.e. not pressed). Not relevant for the event types [code]MOUSE_MOTION[/code], [code]SCREEN_DRAG[/code] or [code]NONE[/code].
*/
func (o *InputEvent) IsActionReleased(action string) bool {
	log.Println("Calling InputEvent.IsActionReleased()")

	returnValue := godotCallBoolString(o, "is_action_released", action)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if this input event's type is one of the [code]InputEvent[/code] constants.
*/
func (o *InputEvent) IsActionType() bool {
	log.Println("Calling InputEvent.IsActionType()")

	returnValue := godotCallBool(o, "is_action_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if this input event is an echo event (only for events of type KEY).
*/
func (o *InputEvent) IsEcho() bool {
	log.Println("Calling InputEvent.IsEcho()")

	returnValue := godotCallBool(o, "is_echo")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if this input event is pressed. Not relevant for the event types [code]MOUSE_MOTION[/code], [code]SCREEN_DRAG[/code] or [code]NONE[/code].
*/
func (o *InputEvent) IsPressed() bool {
	log.Println("Calling InputEvent.IsPressed()")

	returnValue := godotCallBool(o, "is_pressed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEvent) SetDevice(device int64) {
	log.Println("Calling InputEvent.SetDevice()")

	godotCallVoidInt(o, "set_device", device)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *InputEvent) ShortcutMatch(event *InputEvent) bool {
	log.Println("Calling InputEvent.ShortcutMatch()")

	returnValue := godotCallBoolObject(o, "shortcut_match", &event.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *InputEvent) XformedBy(xform *Transform2D, localOfs *Vector2) *InputEvent {
	log.Println("Calling InputEvent.XformedBy()")

	returnValue := godotCallObjectTransform2DVector2(o, "xformed_by", xform, localOfs)
	log.Println("  Got return value: ", returnValue)

	var ret InputEvent
	ret.owner = returnValue.owner
	return &ret

}

/*
   InputEventImplementer is an interface for InputEvent objects.
*/
type InputEventImplementer interface {
	Class
}

/*
   Contains a generic action which can be targeted from several type of inputs. Actions can be created from the project settings menu [code]Project > Project Settings > Input Map[/code]. See [method Node._input].
*/
type InputEventAction struct {
	InputEvent
}

func (o *InputEventAction) baseClass() string {
	return "InputEventAction"
}

/*
   Undocumented
*/
func (o *InputEventAction) GetAction() string {
	log.Println("Calling InputEventAction.GetAction()")

	returnValue := godotCallString(o, "get_action")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventAction) SetAction(action string) {
	log.Println("Calling InputEventAction.SetAction()")

	godotCallVoidString(o, "set_action", action)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventAction) SetPressed(pressed bool) {
	log.Println("Calling InputEventAction.SetPressed()")

	godotCallVoidBool(o, "set_pressed", pressed)
	log.Println("  Function successfully completed.")

}

/*
   InputEventActionImplementer is an interface for InputEventAction objects.
*/
type InputEventActionImplementer interface {
	Class
}

/*

 */
type InputEventGesture struct {
	InputEventWithModifiers
}

func (o *InputEventGesture) baseClass() string {
	return "InputEventGesture"
}

/*
   Undocumented
*/
func (o *InputEventGesture) GetPosition() *Vector2 {
	log.Println("Calling InputEventGesture.GetPosition()")

	returnValue := godotCallVector2(o, "get_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventGesture) SetPosition(position *Vector2) {
	log.Println("Calling InputEventGesture.SetPosition()")

	godotCallVoidVector2(o, "set_position", position)
	log.Println("  Function successfully completed.")

}

/*
   InputEventGestureImplementer is an interface for InputEventGesture objects.
*/
type InputEventGestureImplementer interface {
	Class
}

/*
   Input event type for gamepad buttons. For joysticks see [InputEventJoypadMotion].
*/
type InputEventJoypadButton struct {
	InputEvent
}

func (o *InputEventJoypadButton) baseClass() string {
	return "InputEventJoypadButton"
}

/*
   Undocumented
*/
func (o *InputEventJoypadButton) GetButtonIndex() int64 {
	log.Println("Calling InputEventJoypadButton.GetButtonIndex()")

	returnValue := godotCallInt(o, "get_button_index")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventJoypadButton) GetPressure() float64 {
	log.Println("Calling InputEventJoypadButton.GetPressure()")

	returnValue := godotCallFloat(o, "get_pressure")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventJoypadButton) SetButtonIndex(buttonIndex int64) {
	log.Println("Calling InputEventJoypadButton.SetButtonIndex()")

	godotCallVoidInt(o, "set_button_index", buttonIndex)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventJoypadButton) SetPressed(pressed bool) {
	log.Println("Calling InputEventJoypadButton.SetPressed()")

	godotCallVoidBool(o, "set_pressed", pressed)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventJoypadButton) SetPressure(pressure float64) {
	log.Println("Calling InputEventJoypadButton.SetPressure()")

	godotCallVoidFloat(o, "set_pressure", pressure)
	log.Println("  Function successfully completed.")

}

/*
   InputEventJoypadButtonImplementer is an interface for InputEventJoypadButton objects.
*/
type InputEventJoypadButtonImplementer interface {
	Class
}

/*
   Stores information about joystick motions. One [code]InputEventJoypadMotion[/code] represents one axis at a time.
*/
type InputEventJoypadMotion struct {
	InputEvent
}

func (o *InputEventJoypadMotion) baseClass() string {
	return "InputEventJoypadMotion"
}

/*
   Undocumented
*/
func (o *InputEventJoypadMotion) GetAxis() int64 {
	log.Println("Calling InputEventJoypadMotion.GetAxis()")

	returnValue := godotCallInt(o, "get_axis")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventJoypadMotion) GetAxisValue() float64 {
	log.Println("Calling InputEventJoypadMotion.GetAxisValue()")

	returnValue := godotCallFloat(o, "get_axis_value")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventJoypadMotion) SetAxis(axis int64) {
	log.Println("Calling InputEventJoypadMotion.SetAxis()")

	godotCallVoidInt(o, "set_axis", axis)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventJoypadMotion) SetAxisValue(axisValue float64) {
	log.Println("Calling InputEventJoypadMotion.SetAxisValue()")

	godotCallVoidFloat(o, "set_axis_value", axisValue)
	log.Println("  Function successfully completed.")

}

/*
   InputEventJoypadMotionImplementer is an interface for InputEventJoypadMotion objects.
*/
type InputEventJoypadMotionImplementer interface {
	Class
}

/*
   Stores key presses on the keyboard. Supports key presses, key releases and [member echo] events.
*/
type InputEventKey struct {
	InputEventWithModifiers
}

func (o *InputEventKey) baseClass() string {
	return "InputEventKey"
}

/*
   Undocumented
*/
func (o *InputEventKey) GetScancode() int64 {
	log.Println("Calling InputEventKey.GetScancode()")

	returnValue := godotCallInt(o, "get_scancode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *InputEventKey) GetScancodeWithModifiers() int64 {
	log.Println("Calling InputEventKey.GetScancodeWithModifiers()")

	returnValue := godotCallInt(o, "get_scancode_with_modifiers")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventKey) GetUnicode() int64 {
	log.Println("Calling InputEventKey.GetUnicode()")

	returnValue := godotCallInt(o, "get_unicode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventKey) SetEcho(echo bool) {
	log.Println("Calling InputEventKey.SetEcho()")

	godotCallVoidBool(o, "set_echo", echo)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventKey) SetPressed(pressed bool) {
	log.Println("Calling InputEventKey.SetPressed()")

	godotCallVoidBool(o, "set_pressed", pressed)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventKey) SetScancode(scancode int64) {
	log.Println("Calling InputEventKey.SetScancode()")

	godotCallVoidInt(o, "set_scancode", scancode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventKey) SetUnicode(unicode int64) {
	log.Println("Calling InputEventKey.SetUnicode()")

	godotCallVoidInt(o, "set_unicode", unicode)
	log.Println("  Function successfully completed.")

}

/*
   InputEventKeyImplementer is an interface for InputEventKey objects.
*/
type InputEventKeyImplementer interface {
	Class
}

/*

 */
type InputEventMagnifyGesture struct {
	InputEventGesture
}

func (o *InputEventMagnifyGesture) baseClass() string {
	return "InputEventMagnifyGesture"
}

/*
   Undocumented
*/
func (o *InputEventMagnifyGesture) GetFactor() float64 {
	log.Println("Calling InputEventMagnifyGesture.GetFactor()")

	returnValue := godotCallFloat(o, "get_factor")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventMagnifyGesture) SetFactor(factor float64) {
	log.Println("Calling InputEventMagnifyGesture.SetFactor()")

	godotCallVoidFloat(o, "set_factor", factor)
	log.Println("  Function successfully completed.")

}

/*
   InputEventMagnifyGestureImplementer is an interface for InputEventMagnifyGesture objects.
*/
type InputEventMagnifyGestureImplementer interface {
	Class
}

/*
   Stores general mouse events information.
*/
type InputEventMouse struct {
	InputEventWithModifiers
}

func (o *InputEventMouse) baseClass() string {
	return "InputEventMouse"
}

/*
   Undocumented
*/
func (o *InputEventMouse) GetButtonMask() int64 {
	log.Println("Calling InputEventMouse.GetButtonMask()")

	returnValue := godotCallInt(o, "get_button_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventMouse) GetGlobalPosition() *Vector2 {
	log.Println("Calling InputEventMouse.GetGlobalPosition()")

	returnValue := godotCallVector2(o, "get_global_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventMouse) GetPosition() *Vector2 {
	log.Println("Calling InputEventMouse.GetPosition()")

	returnValue := godotCallVector2(o, "get_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventMouse) SetButtonMask(buttonMask int64) {
	log.Println("Calling InputEventMouse.SetButtonMask()")

	godotCallVoidInt(o, "set_button_mask", buttonMask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventMouse) SetGlobalPosition(globalPosition *Vector2) {
	log.Println("Calling InputEventMouse.SetGlobalPosition()")

	godotCallVoidVector2(o, "set_global_position", globalPosition)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventMouse) SetPosition(position *Vector2) {
	log.Println("Calling InputEventMouse.SetPosition()")

	godotCallVoidVector2(o, "set_position", position)
	log.Println("  Function successfully completed.")

}

/*
   InputEventMouseImplementer is an interface for InputEventMouse objects.
*/
type InputEventMouseImplementer interface {
	Class
}

/*
   Contains mouse click information. See [method Node._input].
*/
type InputEventMouseButton struct {
	InputEventMouse
}

func (o *InputEventMouseButton) baseClass() string {
	return "InputEventMouseButton"
}

/*
   Undocumented
*/
func (o *InputEventMouseButton) GetButtonIndex() int64 {
	log.Println("Calling InputEventMouseButton.GetButtonIndex()")

	returnValue := godotCallInt(o, "get_button_index")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventMouseButton) GetFactor() float64 {
	log.Println("Calling InputEventMouseButton.GetFactor()")

	returnValue := godotCallFloat(o, "get_factor")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventMouseButton) IsDoubleclick() bool {
	log.Println("Calling InputEventMouseButton.IsDoubleclick()")

	returnValue := godotCallBool(o, "is_doubleclick")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventMouseButton) SetButtonIndex(buttonIndex int64) {
	log.Println("Calling InputEventMouseButton.SetButtonIndex()")

	godotCallVoidInt(o, "set_button_index", buttonIndex)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventMouseButton) SetDoubleclick(doubleclick bool) {
	log.Println("Calling InputEventMouseButton.SetDoubleclick()")

	godotCallVoidBool(o, "set_doubleclick", doubleclick)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventMouseButton) SetFactor(factor float64) {
	log.Println("Calling InputEventMouseButton.SetFactor()")

	godotCallVoidFloat(o, "set_factor", factor)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventMouseButton) SetPressed(pressed bool) {
	log.Println("Calling InputEventMouseButton.SetPressed()")

	godotCallVoidBool(o, "set_pressed", pressed)
	log.Println("  Function successfully completed.")

}

/*
   InputEventMouseButtonImplementer is an interface for InputEventMouseButton objects.
*/
type InputEventMouseButtonImplementer interface {
	Class
}

/*
   Contains mouse motion information. Supports relative, absolute positions and speed. See [method Node._input].
*/
type InputEventMouseMotion struct {
	InputEventMouse
}

func (o *InputEventMouseMotion) baseClass() string {
	return "InputEventMouseMotion"
}

/*
   Undocumented
*/
func (o *InputEventMouseMotion) GetRelative() *Vector2 {
	log.Println("Calling InputEventMouseMotion.GetRelative()")

	returnValue := godotCallVector2(o, "get_relative")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventMouseMotion) GetSpeed() *Vector2 {
	log.Println("Calling InputEventMouseMotion.GetSpeed()")

	returnValue := godotCallVector2(o, "get_speed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventMouseMotion) SetRelative(relative *Vector2) {
	log.Println("Calling InputEventMouseMotion.SetRelative()")

	godotCallVoidVector2(o, "set_relative", relative)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventMouseMotion) SetSpeed(speed *Vector2) {
	log.Println("Calling InputEventMouseMotion.SetSpeed()")

	godotCallVoidVector2(o, "set_speed", speed)
	log.Println("  Function successfully completed.")

}

/*
   InputEventMouseMotionImplementer is an interface for InputEventMouseMotion objects.
*/
type InputEventMouseMotionImplementer interface {
	Class
}

/*

 */
type InputEventPanGesture struct {
	InputEventGesture
}

func (o *InputEventPanGesture) baseClass() string {
	return "InputEventPanGesture"
}

/*
   Undocumented
*/
func (o *InputEventPanGesture) GetDelta() *Vector2 {
	log.Println("Calling InputEventPanGesture.GetDelta()")

	returnValue := godotCallVector2(o, "get_delta")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventPanGesture) SetDelta(delta *Vector2) {
	log.Println("Calling InputEventPanGesture.SetDelta()")

	godotCallVoidVector2(o, "set_delta", delta)
	log.Println("  Function successfully completed.")

}

/*
   InputEventPanGestureImplementer is an interface for InputEventPanGesture objects.
*/
type InputEventPanGestureImplementer interface {
	Class
}

/*
   Contains screen drag information. See [method Node._input].
*/
type InputEventScreenDrag struct {
	InputEvent
}

func (o *InputEventScreenDrag) baseClass() string {
	return "InputEventScreenDrag"
}

/*
   Undocumented
*/
func (o *InputEventScreenDrag) GetIndex() int64 {
	log.Println("Calling InputEventScreenDrag.GetIndex()")

	returnValue := godotCallInt(o, "get_index")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventScreenDrag) GetPosition() *Vector2 {
	log.Println("Calling InputEventScreenDrag.GetPosition()")

	returnValue := godotCallVector2(o, "get_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventScreenDrag) GetRelative() *Vector2 {
	log.Println("Calling InputEventScreenDrag.GetRelative()")

	returnValue := godotCallVector2(o, "get_relative")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventScreenDrag) GetSpeed() *Vector2 {
	log.Println("Calling InputEventScreenDrag.GetSpeed()")

	returnValue := godotCallVector2(o, "get_speed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventScreenDrag) SetIndex(index int64) {
	log.Println("Calling InputEventScreenDrag.SetIndex()")

	godotCallVoidInt(o, "set_index", index)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventScreenDrag) SetPosition(position *Vector2) {
	log.Println("Calling InputEventScreenDrag.SetPosition()")

	godotCallVoidVector2(o, "set_position", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventScreenDrag) SetRelative(relative *Vector2) {
	log.Println("Calling InputEventScreenDrag.SetRelative()")

	godotCallVoidVector2(o, "set_relative", relative)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventScreenDrag) SetSpeed(speed *Vector2) {
	log.Println("Calling InputEventScreenDrag.SetSpeed()")

	godotCallVoidVector2(o, "set_speed", speed)
	log.Println("  Function successfully completed.")

}

/*
   InputEventScreenDragImplementer is an interface for InputEventScreenDrag objects.
*/
type InputEventScreenDragImplementer interface {
	Class
}

/*
   Stores multi-touch press/release information. Supports touch press, touch release and [member index] for multi-touch count and order.
*/
type InputEventScreenTouch struct {
	InputEvent
}

func (o *InputEventScreenTouch) baseClass() string {
	return "InputEventScreenTouch"
}

/*
   Undocumented
*/
func (o *InputEventScreenTouch) GetIndex() int64 {
	log.Println("Calling InputEventScreenTouch.GetIndex()")

	returnValue := godotCallInt(o, "get_index")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventScreenTouch) GetPosition() *Vector2 {
	log.Println("Calling InputEventScreenTouch.GetPosition()")

	returnValue := godotCallVector2(o, "get_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventScreenTouch) SetIndex(index int64) {
	log.Println("Calling InputEventScreenTouch.SetIndex()")

	godotCallVoidInt(o, "set_index", index)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventScreenTouch) SetPosition(position *Vector2) {
	log.Println("Calling InputEventScreenTouch.SetPosition()")

	godotCallVoidVector2(o, "set_position", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventScreenTouch) SetPressed(pressed bool) {
	log.Println("Calling InputEventScreenTouch.SetPressed()")

	godotCallVoidBool(o, "set_pressed", pressed)
	log.Println("  Function successfully completed.")

}

/*
   InputEventScreenTouchImplementer is an interface for InputEventScreenTouch objects.
*/
type InputEventScreenTouchImplementer interface {
	Class
}

/*
   Contains keys events information with modifiers support like [code]SHIFT[/code] or [code]ALT[/code]. See [method Node._input].
*/
type InputEventWithModifiers struct {
	InputEvent
}

func (o *InputEventWithModifiers) baseClass() string {
	return "InputEventWithModifiers"
}

/*
   Undocumented
*/
func (o *InputEventWithModifiers) GetAlt() bool {
	log.Println("Calling InputEventWithModifiers.GetAlt()")

	returnValue := godotCallBool(o, "get_alt")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventWithModifiers) GetCommand() bool {
	log.Println("Calling InputEventWithModifiers.GetCommand()")

	returnValue := godotCallBool(o, "get_command")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventWithModifiers) GetControl() bool {
	log.Println("Calling InputEventWithModifiers.GetControl()")

	returnValue := godotCallBool(o, "get_control")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventWithModifiers) GetMetakey() bool {
	log.Println("Calling InputEventWithModifiers.GetMetakey()")

	returnValue := godotCallBool(o, "get_metakey")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventWithModifiers) GetShift() bool {
	log.Println("Calling InputEventWithModifiers.GetShift()")

	returnValue := godotCallBool(o, "get_shift")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InputEventWithModifiers) SetAlt(enable bool) {
	log.Println("Calling InputEventWithModifiers.SetAlt()")

	godotCallVoidBool(o, "set_alt", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventWithModifiers) SetCommand(enable bool) {
	log.Println("Calling InputEventWithModifiers.SetCommand()")

	godotCallVoidBool(o, "set_command", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventWithModifiers) SetControl(enable bool) {
	log.Println("Calling InputEventWithModifiers.SetControl()")

	godotCallVoidBool(o, "set_control", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventWithModifiers) SetMetakey(enable bool) {
	log.Println("Calling InputEventWithModifiers.SetMetakey()")

	godotCallVoidBool(o, "set_metakey", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InputEventWithModifiers) SetShift(enable bool) {
	log.Println("Calling InputEventWithModifiers.SetShift()")

	godotCallVoidBool(o, "set_shift", enable)
	log.Println("  Function successfully completed.")

}

/*
   InputEventWithModifiersImplementer is an interface for InputEventWithModifiers objects.
*/
type InputEventWithModifiersImplementer interface {
	Class
}

func newSingletonInputMap() *inputMap {
	obj := &inputMap{}
	name := C.CString("InputMap")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Manages all [InputEventAction] which can be created/modified from the project settings menu [code]Project > Project Settings > Input Map[/code] or in code with [method add_action] and [method action_add_event]. See [method Node._input].
*/
var InputMap = newSingletonInputMap()

/*
   Manages all [InputEventAction] which can be created/modified from the project settings menu [code]Project > Project Settings > Input Map[/code] or in code with [method add_action] and [method action_add_event]. See [method Node._input].
*/
type inputMap struct {
	Object
}

func (o *inputMap) baseClass() string {
	return "InputMap"
}

/*
   Adds an [InputEvent] to an action. This [InputEvent] will trigger the action.
*/
func (o *inputMap) ActionAddEvent(action string, event *InputEvent) {
	log.Println("Calling InputMap.ActionAddEvent()")

	godotCallVoidStringObject(o, "action_add_event", action, &event.Object)
	log.Println("  Function successfully completed.")

}

/*
   Removes an [InputEvent] from an action.
*/
func (o *inputMap) ActionEraseEvent(action string, event *InputEvent) {
	log.Println("Calling InputMap.ActionEraseEvent()")

	godotCallVoidStringObject(o, "action_erase_event", action, &event.Object)
	log.Println("  Function successfully completed.")

}

/*
   Returns [true] if an action has an [InputEvent] associated with it.
*/
func (o *inputMap) ActionHasEvent(action string, event *InputEvent) bool {
	log.Println("Calling InputMap.ActionHasEvent()")

	returnValue := godotCallBoolStringObject(o, "action_has_event", action, &event.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Adds an (empty) action to the [code]InputMap[/code]. An [InputEvent] can then be added to this action with [method action_add_event].
*/
func (o *inputMap) AddAction(action string) {
	log.Println("Calling InputMap.AddAction()")

	godotCallVoidString(o, "add_action", action)
	log.Println("  Function successfully completed.")

}

/*
   Removes an action from the [code]InputMap[/code].
*/
func (o *inputMap) EraseAction(action string) {
	log.Println("Calling InputMap.EraseAction()")

	godotCallVoidString(o, "erase_action", action)
	log.Println("  Function successfully completed.")

}

/*
   Returns [true] if the given event is part of an existing action. This method ignores keyboard modifiers if the given [InputEvent] is not pressed (for proper release detection). See [method action_has_event] if you don't want this behavior.
*/
func (o *inputMap) EventIsAction(event *InputEvent, action string) bool {
	log.Println("Calling InputMap.EventIsAction()")

	returnValue := godotCallBoolObjectString(o, "event_is_action", &event.Object, action)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an array of [InputEvent]s associated with a given action.
*/
func (o *inputMap) GetActionList(action string) *Array {
	log.Println("Calling InputMap.GetActionList()")

	returnValue := godotCallArrayString(o, "get_action_list", action)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an array of all actions in the [code]InputMap[/code].
*/
func (o *inputMap) GetActions() *Array {
	log.Println("Calling InputMap.GetActions()")

	returnValue := godotCallArray(o, "get_actions")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the [code]InputMap[/code] has a registered action with the given name.
*/
func (o *inputMap) HasAction(action string) bool {
	log.Println("Calling InputMap.HasAction()")

	returnValue := godotCallBoolString(o, "has_action", action)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Clears all [InputEventAction] in the [code]InputMap[/code] and load it anew from [ProjectSettings].
*/
func (o *inputMap) LoadFromGlobals() {
	log.Println("Calling InputMap.LoadFromGlobals()")

	godotCallVoid(o, "load_from_globals")
	log.Println("  Function successfully completed.")

}

/*
   Turning on the option [b]Load As Placeholder[/b] for an instanced scene in the editor causes it to be replaced by an InstacePlaceholder when running the game. This makes it possible to delay actually loading the scene until calling [method replace_by_instance]. This is useful to avoid loading large scenes all at once by loading parts of it selectively. The InstancePlaceholder does not have a transform. This causes any child nodes to be positioned relatively to the Viewport from point (0,0), rather than their parent as displayed in the editor. Replacing the placeholder with a scene with a transform will transform children relatively to their parent again.
*/
type InstancePlaceholder struct {
	Node
}

func (o *InstancePlaceholder) baseClass() string {
	return "InstancePlaceholder"
}

/*
   Retrieve the path to the [PackedScene] resource file that is loaded by default when calling [method replace_by_instance].
*/
func (o *InstancePlaceholder) GetInstancePath() string {
	log.Println("Calling InstancePlaceholder.GetInstancePath()")

	returnValue := godotCallString(o, "get_instance_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *InstancePlaceholder) GetStoredValues(withOrder bool) *Dictionary {
	log.Println("Calling InstancePlaceholder.GetStoredValues()")

	returnValue := godotCallDictionaryBool(o, "get_stored_values", withOrder)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Replace this placeholder by the scene handed as an argument, or the original scene if no argument is given. As for all resources, the scene is loaded only if it's not loaded already. By manually loading the scene beforehand, delays caused by this function can be avoided.
*/
func (o *InstancePlaceholder) ReplaceByInstance(customScene *PackedScene) {
	log.Println("Calling InstancePlaceholder.ReplaceByInstance()")

	godotCallVoidObject(o, "replace_by_instance", &customScene.Object)
	log.Println("  Function successfully completed.")

}

/*
   InstancePlaceholderImplementer is an interface for InstancePlaceholder objects.
*/
type InstancePlaceholderImplementer interface {
	Class
}

/*

 */
type InterpolatedCamera struct {
	Camera
}

func (o *InterpolatedCamera) baseClass() string {
	return "InterpolatedCamera"
}

/*
   Undocumented
*/
func (o *InterpolatedCamera) GetSpeed() float64 {
	log.Println("Calling InterpolatedCamera.GetSpeed()")

	returnValue := godotCallFloat(o, "get_speed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InterpolatedCamera) GetTargetPath() *NodePath {
	log.Println("Calling InterpolatedCamera.GetTargetPath()")

	returnValue := godotCallNodePath(o, "get_target_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InterpolatedCamera) IsInterpolationEnabled() bool {
	log.Println("Calling InterpolatedCamera.IsInterpolationEnabled()")

	returnValue := godotCallBool(o, "is_interpolation_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *InterpolatedCamera) SetInterpolationEnabled(targetPath bool) {
	log.Println("Calling InterpolatedCamera.SetInterpolationEnabled()")

	godotCallVoidBool(o, "set_interpolation_enabled", targetPath)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InterpolatedCamera) SetSpeed(speed float64) {
	log.Println("Calling InterpolatedCamera.SetSpeed()")

	godotCallVoidFloat(o, "set_speed", speed)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *InterpolatedCamera) SetTarget(target *Object) {
	log.Println("Calling InterpolatedCamera.SetTarget()")

	godotCallVoidObject(o, "set_target", target)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *InterpolatedCamera) SetTargetPath(targetPath *NodePath) {
	log.Println("Calling InterpolatedCamera.SetTargetPath()")

	godotCallVoidNodePath(o, "set_target_path", targetPath)
	log.Println("  Function successfully completed.")

}

/*
   InterpolatedCameraImplementer is an interface for InterpolatedCamera objects.
*/
type InterpolatedCameraImplementer interface {
	Class
}

/*
   This control provides a selectable list of items that may be in a single (or multiple columns) with option of text, icons, or both text and icon. Tooltips are supported and may be different for every item in the list. Selectable items in the list may be selected or deselected and multiple selection may be enabled. Selection with right mouse button may also be enabled to allow use of popup context menus. Items may also be 'activated' with a double click (or Enter key).
*/
type ItemList struct {
	Control
}

func (o *ItemList) baseClass() string {
	return "ItemList"
}

/*
   Undocumented
*/
func (o *ItemList) X_GetItems() *Array {
	log.Println("Calling ItemList.X_GetItems()")

	returnValue := godotCallArray(o, "_get_items")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ItemList) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling ItemList.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) X_ScrollChanged(arg0 float64) {
	log.Println("Calling ItemList.X_ScrollChanged()")

	godotCallVoidFloat(o, "_scroll_changed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) X_SetItems(arg0 *Array) {
	log.Println("Calling ItemList.X_SetItems()")

	godotCallVoidArray(o, "_set_items", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Adds an item to the item list with no text, only an icon.
*/
func (o *ItemList) AddIconItem(icon *Texture, selectable bool) {
	log.Println("Calling ItemList.AddIconItem()")

	godotCallVoidObjectBool(o, "add_icon_item", &icon.Object, selectable)
	log.Println("  Function successfully completed.")

}

/*
   Adds an item to the item list with specified text. Specify an icon of null for a list item with no icon. If selectable is true the list item will be selectable.
*/
func (o *ItemList) AddItem(text string, icon *Texture, selectable bool) {
	log.Println("Calling ItemList.AddItem()")

	godotCallVoidStringObjectBool(o, "add_item", text, &icon.Object, selectable)
	log.Println("  Function successfully completed.")

}

/*
   Remove all items from the list.
*/
func (o *ItemList) Clear() {
	log.Println("Calling ItemList.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Ensure selection is visible, adjusting the scroll position as necessary.
*/
func (o *ItemList) EnsureCurrentIsVisible() {
	log.Println("Calling ItemList.EnsureCurrentIsVisible()")

	godotCallVoid(o, "ensure_current_is_visible")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) GetAllowRmbSelect() bool {
	log.Println("Calling ItemList.GetAllowRmbSelect()")

	returnValue := godotCallBool(o, "get_allow_rmb_select")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ItemList) GetFixedColumnWidth() int64 {
	log.Println("Calling ItemList.GetFixedColumnWidth()")

	returnValue := godotCallInt(o, "get_fixed_column_width")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ItemList) GetFixedIconSize() *Vector2 {
	log.Println("Calling ItemList.GetFixedIconSize()")

	returnValue := godotCallVector2(o, "get_fixed_icon_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ItemList) GetIconMode() int64 {
	log.Println("Calling ItemList.GetIconMode()")

	returnValue := godotCallInt(o, "get_icon_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ItemList) GetIconScale() float64 {
	log.Println("Calling ItemList.GetIconScale()")

	returnValue := godotCallFloat(o, "get_icon_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Given a position within the control return the item (if any) at that point.
*/
func (o *ItemList) GetItemAtPosition(position *Vector2, exact bool) int64 {
	log.Println("Calling ItemList.GetItemAtPosition()")

	returnValue := godotCallIntVector2Bool(o, "get_item_at_position", position, exact)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return count of items currently in the item list.
*/
func (o *ItemList) GetItemCount() int64 {
	log.Println("Calling ItemList.GetItemCount()")

	returnValue := godotCallInt(o, "get_item_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *ItemList) GetItemCustomBgColor(idx int64) *Color {
	log.Println("Calling ItemList.GetItemCustomBgColor()")

	returnValue := godotCallColorInt(o, "get_item_custom_bg_color", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *ItemList) GetItemIcon(idx int64) *Texture {
	log.Println("Calling ItemList.GetItemIcon()")

	returnValue := godotCallObjectInt(o, "get_item_icon", idx)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *ItemList) GetItemIconRegion(idx int64) *Rect2 {
	log.Println("Calling ItemList.GetItemIconRegion()")

	returnValue := godotCallRect2Int(o, "get_item_icon_region", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *ItemList) GetItemMetadata(idx int64) *Variant {
	log.Println("Calling ItemList.GetItemMetadata()")

	returnValue := godotCallVariantInt(o, "get_item_metadata", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the text for specified item index.
*/
func (o *ItemList) GetItemText(idx int64) string {
	log.Println("Calling ItemList.GetItemText()")

	returnValue := godotCallStringInt(o, "get_item_text", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return tooltip hint for specified item index.
*/
func (o *ItemList) GetItemTooltip(idx int64) string {
	log.Println("Calling ItemList.GetItemTooltip()")

	returnValue := godotCallStringInt(o, "get_item_tooltip", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ItemList) GetMaxColumns() int64 {
	log.Println("Calling ItemList.GetMaxColumns()")

	returnValue := godotCallInt(o, "get_max_columns")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ItemList) GetMaxTextLines() int64 {
	log.Println("Calling ItemList.GetMaxTextLines()")

	returnValue := godotCallInt(o, "get_max_text_lines")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ItemList) GetSelectMode() int64 {
	log.Println("Calling ItemList.GetSelectMode()")

	returnValue := godotCallInt(o, "get_select_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the list of selected indexes.
*/
func (o *ItemList) GetSelectedItems() *PoolIntArray {
	log.Println("Calling ItemList.GetSelectedItems()")

	returnValue := godotCallPoolIntArray(o, "get_selected_items")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the current vertical scroll bar for the List.
*/
func (o *ItemList) GetVScroll() *VScrollBar {
	log.Println("Calling ItemList.GetVScroll()")

	returnValue := godotCallObject(o, "get_v_scroll")
	log.Println("  Got return value: ", returnValue)

	var ret VScrollBar
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *ItemList) HasAutoHeight() bool {
	log.Println("Calling ItemList.HasAutoHeight()")

	returnValue := godotCallBool(o, "has_auto_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether or not the item at the specified index is disabled
*/
func (o *ItemList) IsItemDisabled(idx int64) bool {
	log.Println("Calling ItemList.IsItemDisabled()")

	returnValue := godotCallBoolInt(o, "is_item_disabled", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether or not the item at the specified index is selectable.
*/
func (o *ItemList) IsItemSelectable(idx int64) bool {
	log.Println("Calling ItemList.IsItemSelectable()")

	returnValue := godotCallBoolInt(o, "is_item_selectable", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether the tooltip is enabled for specified item index.
*/
func (o *ItemList) IsItemTooltipEnabled(idx int64) bool {
	log.Println("Calling ItemList.IsItemTooltipEnabled()")

	returnValue := godotCallBoolInt(o, "is_item_tooltip_enabled", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ItemList) IsSameColumnWidth() bool {
	log.Println("Calling ItemList.IsSameColumnWidth()")

	returnValue := godotCallBool(o, "is_same_column_width")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether or not item at the specified index is currently selected.
*/
func (o *ItemList) IsSelected(idx int64) bool {
	log.Println("Calling ItemList.IsSelected()")

	returnValue := godotCallBoolInt(o, "is_selected", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Remove item at specified index from the list.
*/
func (o *ItemList) RemoveItem(idx int64) {
	log.Println("Calling ItemList.RemoveItem()")

	godotCallVoidInt(o, "remove_item", idx)
	log.Println("  Function successfully completed.")

}

/*
   Select the item at the specified index. Note: This method does not trigger the item selection signal.
*/
func (o *ItemList) Select(idx int64, single bool) {
	log.Println("Calling ItemList.Select()")

	godotCallVoidIntBool(o, "select", idx, single)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) SetAllowRmbSelect(allow bool) {
	log.Println("Calling ItemList.SetAllowRmbSelect()")

	godotCallVoidBool(o, "set_allow_rmb_select", allow)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) SetAutoHeight(enable bool) {
	log.Println("Calling ItemList.SetAutoHeight()")

	godotCallVoidBool(o, "set_auto_height", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) SetFixedColumnWidth(width int64) {
	log.Println("Calling ItemList.SetFixedColumnWidth()")

	godotCallVoidInt(o, "set_fixed_column_width", width)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) SetFixedIconSize(size *Vector2) {
	log.Println("Calling ItemList.SetFixedIconSize()")

	godotCallVoidVector2(o, "set_fixed_icon_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) SetIconMode(mode int64) {
	log.Println("Calling ItemList.SetIconMode()")

	godotCallVoidInt(o, "set_icon_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) SetIconScale(scale float64) {
	log.Println("Calling ItemList.SetIconScale()")

	godotCallVoidFloat(o, "set_icon_scale", scale)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ItemList) SetItemCustomBgColor(idx int64, customBgColor *Color) {
	log.Println("Calling ItemList.SetItemCustomBgColor()")

	godotCallVoidIntColor(o, "set_item_custom_bg_color", idx, customBgColor)
	log.Println("  Function successfully completed.")

}

/*
   Disable (or enable) item at specified index. Disabled items are not be selectable and do not fire activation (Enter or double-click) signals.
*/
func (o *ItemList) SetItemDisabled(idx int64, disabled bool) {
	log.Println("Calling ItemList.SetItemDisabled()")

	godotCallVoidIntBool(o, "set_item_disabled", idx, disabled)
	log.Println("  Function successfully completed.")

}

/*
   Set (or replace) icon of the item at the specified index.
*/
func (o *ItemList) SetItemIcon(idx int64, icon *Texture) {
	log.Println("Calling ItemList.SetItemIcon()")

	godotCallVoidIntObject(o, "set_item_icon", idx, &icon.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ItemList) SetItemIconRegion(idx int64, rect *Rect2) {
	log.Println("Calling ItemList.SetItemIconRegion()")

	godotCallVoidIntRect2(o, "set_item_icon_region", idx, rect)
	log.Println("  Function successfully completed.")

}

/*
   Sets a value (of any type) to be stored with the item at the specified index.
*/
func (o *ItemList) SetItemMetadata(idx int64, metadata *Variant) {
	log.Println("Calling ItemList.SetItemMetadata()")

	godotCallVoidIntVariant(o, "set_item_metadata", idx, metadata)
	log.Println("  Function successfully completed.")

}

/*
   Allow or disallow selection of the item at the specified index.
*/
func (o *ItemList) SetItemSelectable(idx int64, selectable bool) {
	log.Println("Calling ItemList.SetItemSelectable()")

	godotCallVoidIntBool(o, "set_item_selectable", idx, selectable)
	log.Println("  Function successfully completed.")

}

/*
   Sets text of item at specified index.
*/
func (o *ItemList) SetItemText(idx int64, text string) {
	log.Println("Calling ItemList.SetItemText()")

	godotCallVoidIntString(o, "set_item_text", idx, text)
	log.Println("  Function successfully completed.")

}

/*
   Sets tooltip hint for item at specified index.
*/
func (o *ItemList) SetItemTooltip(idx int64, tooltip string) {
	log.Println("Calling ItemList.SetItemTooltip()")

	godotCallVoidIntString(o, "set_item_tooltip", idx, tooltip)
	log.Println("  Function successfully completed.")

}

/*
   Sets whether the tooltip is enabled for specified item index.
*/
func (o *ItemList) SetItemTooltipEnabled(idx int64, enable bool) {
	log.Println("Calling ItemList.SetItemTooltipEnabled()")

	godotCallVoidIntBool(o, "set_item_tooltip_enabled", idx, enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) SetMaxColumns(amount int64) {
	log.Println("Calling ItemList.SetMaxColumns()")

	godotCallVoidInt(o, "set_max_columns", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) SetMaxTextLines(lines int64) {
	log.Println("Calling ItemList.SetMaxTextLines()")

	godotCallVoidInt(o, "set_max_text_lines", lines)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) SetSameColumnWidth(enable bool) {
	log.Println("Calling ItemList.SetSameColumnWidth()")

	godotCallVoidBool(o, "set_same_column_width", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ItemList) SetSelectMode(mode int64) {
	log.Println("Calling ItemList.SetSelectMode()")

	godotCallVoidInt(o, "set_select_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Sorts items in the list by their text.
*/
func (o *ItemList) SortItemsByText() {
	log.Println("Calling ItemList.SortItemsByText()")

	godotCallVoid(o, "sort_items_by_text")
	log.Println("  Function successfully completed.")

}

/*
   Ensure item at specified index is not selected.
*/
func (o *ItemList) Unselect(idx int64) {
	log.Println("Calling ItemList.Unselect()")

	godotCallVoidInt(o, "unselect", idx)
	log.Println("  Function successfully completed.")

}

/*
   ItemListImplementer is an interface for ItemList objects.
*/
type ItemListImplementer interface {
	Class
}

/*
   Returned by [method JSON.parse], [code]JSONParseResult[/code] contains decoded JSON or error information if JSON source not successfully parsed. You can check if JSON source was successfully parsed with [code]if json_result.error == OK[/code].
*/
type JSONParseResult struct {
	Reference
}

func (o *JSONParseResult) baseClass() string {
	return "JSONParseResult"
}

/*
   Undocumented
*/
func (o *JSONParseResult) GetError() int64 {
	log.Println("Calling JSONParseResult.GetError()")

	returnValue := godotCallInt(o, "get_error")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *JSONParseResult) GetErrorLine() int64 {
	log.Println("Calling JSONParseResult.GetErrorLine()")

	returnValue := godotCallInt(o, "get_error_line")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *JSONParseResult) GetErrorString() string {
	log.Println("Calling JSONParseResult.GetErrorString()")

	returnValue := godotCallString(o, "get_error_string")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *JSONParseResult) GetResult() *Variant {
	log.Println("Calling JSONParseResult.GetResult()")

	returnValue := godotCallVariant(o, "get_result")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *JSONParseResult) SetError(error int64) {
	log.Println("Calling JSONParseResult.SetError()")

	godotCallVoidInt(o, "set_error", error)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *JSONParseResult) SetErrorLine(errorLine int64) {
	log.Println("Calling JSONParseResult.SetErrorLine()")

	godotCallVoidInt(o, "set_error_line", errorLine)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *JSONParseResult) SetErrorString(errorString string) {
	log.Println("Calling JSONParseResult.SetErrorString()")

	godotCallVoidString(o, "set_error_string", errorString)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *JSONParseResult) SetResult(result *Variant) {
	log.Println("Calling JSONParseResult.SetResult()")

	godotCallVoidVariant(o, "set_result", result)
	log.Println("  Function successfully completed.")

}

/*
   JSONParseResultImplementer is an interface for JSONParseResult objects.
*/
type JSONParseResultImplementer interface {
	Class
}

func newSingletonJavaScript() *javaScript {
	obj := &javaScript{}
	name := C.CString("JavaScript")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   The JavaScript singleton is implemented only in HTML5 export. It's used to access the browser's JavaScript context. This allows interaction with embedding pages or calling third-party JavaScript APIs.
*/
var JavaScript = newSingletonJavaScript()

/*
   The JavaScript singleton is implemented only in HTML5 export. It's used to access the browser's JavaScript context. This allows interaction with embedding pages or calling third-party JavaScript APIs.
*/
type javaScript struct {
	Object
}

func (o *javaScript) baseClass() string {
	return "JavaScript"
}

/*
   Execute the string [code]code[/code] as JavaScript code within the browser window. This is a call to the actual global JavaScript function [code]eval()[/code]. If [code]use_global_execution_context[/code] is [code]true[/code], the code will be evaluated in the global execution context. Otherwise, it is evaluated in the execution context of a function within the engine's runtime environment.
*/
func (o *javaScript) Eval(code string, useGlobalExecutionContext bool) *Variant {
	log.Println("Calling JavaScript.Eval()")

	returnValue := godotCallVariantStringBool(o, "eval", code, useGlobalExecutionContext)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   All 3D joints link two nodes, has a priority, and can decide if the two bodies of the nodes should be able to collide with each other
*/
type Joint struct {
	Spatial
}

func (o *Joint) baseClass() string {
	return "Joint"
}

/*
   Undocumented
*/
func (o *Joint) GetExcludeNodesFromCollision() bool {
	log.Println("Calling Joint.GetExcludeNodesFromCollision()")

	returnValue := godotCallBool(o, "get_exclude_nodes_from_collision")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Joint) GetNodeA() *NodePath {
	log.Println("Calling Joint.GetNodeA()")

	returnValue := godotCallNodePath(o, "get_node_a")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Joint) GetNodeB() *NodePath {
	log.Println("Calling Joint.GetNodeB()")

	returnValue := godotCallNodePath(o, "get_node_b")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Joint) GetSolverPriority() int64 {
	log.Println("Calling Joint.GetSolverPriority()")

	returnValue := godotCallInt(o, "get_solver_priority")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Joint) SetExcludeNodesFromCollision(enable bool) {
	log.Println("Calling Joint.SetExcludeNodesFromCollision()")

	godotCallVoidBool(o, "set_exclude_nodes_from_collision", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Joint) SetNodeA(node *NodePath) {
	log.Println("Calling Joint.SetNodeA()")

	godotCallVoidNodePath(o, "set_node_a", node)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Joint) SetNodeB(node *NodePath) {
	log.Println("Calling Joint.SetNodeB()")

	godotCallVoidNodePath(o, "set_node_b", node)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Joint) SetSolverPriority(priority int64) {
	log.Println("Calling Joint.SetSolverPriority()")

	godotCallVoidInt(o, "set_solver_priority", priority)
	log.Println("  Function successfully completed.")

}

/*
   JointImplementer is an interface for Joint objects.
*/
type JointImplementer interface {
	Class
}

/*
   Base node for all joint constraints in 2D physics. Joints take 2 bodies and apply a custom constraint.
*/
type Joint2D struct {
	Node2D
}

func (o *Joint2D) baseClass() string {
	return "Joint2D"
}

/*
   Undocumented
*/
func (o *Joint2D) GetBias() float64 {
	log.Println("Calling Joint2D.GetBias()")

	returnValue := godotCallFloat(o, "get_bias")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Joint2D) GetExcludeNodesFromCollision() bool {
	log.Println("Calling Joint2D.GetExcludeNodesFromCollision()")

	returnValue := godotCallBool(o, "get_exclude_nodes_from_collision")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Joint2D) GetNodeA() *NodePath {
	log.Println("Calling Joint2D.GetNodeA()")

	returnValue := godotCallNodePath(o, "get_node_a")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Joint2D) GetNodeB() *NodePath {
	log.Println("Calling Joint2D.GetNodeB()")

	returnValue := godotCallNodePath(o, "get_node_b")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Joint2D) SetBias(bias float64) {
	log.Println("Calling Joint2D.SetBias()")

	godotCallVoidFloat(o, "set_bias", bias)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Joint2D) SetExcludeNodesFromCollision(enable bool) {
	log.Println("Calling Joint2D.SetExcludeNodesFromCollision()")

	godotCallVoidBool(o, "set_exclude_nodes_from_collision", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Joint2D) SetNodeA(node *NodePath) {
	log.Println("Calling Joint2D.SetNodeA()")

	godotCallVoidNodePath(o, "set_node_a", node)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Joint2D) SetNodeB(node *NodePath) {
	log.Println("Calling Joint2D.SetNodeB()")

	godotCallVoidNodePath(o, "set_node_b", node)
	log.Println("  Function successfully completed.")

}

/*
   Joint2DImplementer is an interface for Joint2D objects.
*/
type Joint2DImplementer interface {
	Class
}

/*
   Kinematic bodies are special types of bodies that are meant to be user-controlled. They are not affected by physics at all (to other types of bodies, such a character or a rigid body, these are the same as a static body). They have however, two main uses: Simulated Motion: When these bodies are moved manually, either from code or from an AnimationPlayer (with process mode set to fixed), the physics will automatically compute an estimate of their linear and angular velocity. This makes them very useful for moving platforms or other AnimationPlayer-controlled objects (like a door, a bridge that opens, etc). Kinematic Characters: KinematicBody also has an API for moving objects (the [method move_and_collide] and [method move_and_slide] methods) while performing collision tests. This makes them really useful to implement characters that collide against a world, but that don't require advanced physics.
*/
type KinematicBody struct {
	PhysicsBody
}

func (o *KinematicBody) baseClass() string {
	return "KinematicBody"
}

/*
   Undocumented
*/
func (o *KinematicBody) GetAxisLock(axis int64) bool {
	log.Println("Calling KinematicBody.GetAxisLock()")

	returnValue := godotCallBoolInt(o, "get_axis_lock", axis)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the velocity of the floor. Only updates when calling [method move_and_slide].
*/
func (o *KinematicBody) GetFloorVelocity() *Vector3 {
	log.Println("Calling KinematicBody.GetFloorVelocity()")

	returnValue := godotCallVector3(o, "get_floor_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicBody) GetSafeMargin() float64 {
	log.Println("Calling KinematicBody.GetSafeMargin()")

	returnValue := godotCallFloat(o, "get_safe_margin")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a [KinematicCollision], which contains information about a collision that occurred during the last [method move_and_slide] call. Since the body can collide several times in a single call to [method move_and_slide], you must specify the index of the collision in the range 0 to ([method get_slide_count] - 1).
*/
func (o *KinematicBody) GetSlideCollision(slideIdx int64) *KinematicCollision {
	log.Println("Calling KinematicBody.GetSlideCollision()")

	returnValue := godotCallObjectInt(o, "get_slide_collision", slideIdx)
	log.Println("  Got return value: ", returnValue)

	var ret KinematicCollision
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of times the body collided and changed direction during the last call to [method move_and_slide].
*/
func (o *KinematicBody) GetSlideCount() int64 {
	log.Println("Calling KinematicBody.GetSlideCount()")

	returnValue := godotCallInt(o, "get_slide_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the body is on the ceiling. Only updates when calling [method move_and_slide].
*/
func (o *KinematicBody) IsOnCeiling() bool {
	log.Println("Calling KinematicBody.IsOnCeiling()")

	returnValue := godotCallBool(o, "is_on_ceiling")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the body is on the floor. Only updates when calling [method move_and_slide].
*/
func (o *KinematicBody) IsOnFloor() bool {
	log.Println("Calling KinematicBody.IsOnFloor()")

	returnValue := godotCallBool(o, "is_on_floor")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the body is on a wall. Only updates when calling [method move_and_slide].
*/
func (o *KinematicBody) IsOnWall() bool {
	log.Println("Calling KinematicBody.IsOnWall()")

	returnValue := godotCallBool(o, "is_on_wall")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Moves the body along the vector [code]rel_vec[/code]. The body will stop if it collides. Returns a [KinematicCollision], which contains information about the collision.
*/
func (o *KinematicBody) MoveAndCollide(relVec *Vector3) *KinematicCollision {
	log.Println("Calling KinematicBody.MoveAndCollide()")

	returnValue := godotCallObjectVector3(o, "move_and_collide", relVec)
	log.Println("  Got return value: ", returnValue)

	var ret KinematicCollision
	ret.owner = returnValue.owner
	return &ret

}

/*
   Moves the body along a vector. If the body collides with another, it will slide along the other body rather than stop immediately. If the other body is a [code]KinematicBody[/code] or [RigidBody], it will also be affected by the motion of the other body. You can use this to make moving or rotating platforms, or to make nodes push other nodes. [code]linear_velocity[/code] is a value in pixels per second. Unlike in for example [method move_and_collide], you should [i]not[/i] multiply it with [code]delta[/code] — this is done by the method. [code]floor_normal[/code] is the up direction, used to determine what is a wall and what is a floor or a ceiling. If set to the default value of [code]Vector3(0, 0, 0)[/code], everything is considered a wall. This is useful for topdown games. If the body is standing on a slope and the horizontal speed (relative to the floor's speed) goes below [code]slope_stop_min_velocity[/code], the body will stop completely. This prevents the body from sliding down slopes when you include gravity in [code]linear_velocity[/code]. When set to lower values, the body will not be able to stand still on steep slopes. If the body collides, it will change direction a maximum of [code]max_slides[/code] times before it stops. [code]floor_max_angle[/code] is the maximum angle (in radians) where a slope is still considered a floor (or a ceiling), rather than a wall. The default value equals 45 degrees. Returns the movement that remained when the body stopped. To get more detailed information about collisions that occurred, use [method get_slide_collision].
*/
func (o *KinematicBody) MoveAndSlide(linearVelocity *Vector3, floorNormal *Vector3, slopeStopMinVelocity float64, maxSlides int64, floorMaxAngle float64) *Vector3 {
	log.Println("Calling KinematicBody.MoveAndSlide()")

	returnValue := godotCallVector3Vector3Vector3FloatIntFloat(o, "move_and_slide", linearVelocity, floorNormal, slopeStopMinVelocity, maxSlides, floorMaxAngle)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicBody) SetAxisLock(axis int64, lock bool) {
	log.Println("Calling KinematicBody.SetAxisLock()")

	godotCallVoidIntBool(o, "set_axis_lock", axis, lock)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *KinematicBody) SetSafeMargin(pixels float64) {
	log.Println("Calling KinematicBody.SetSafeMargin()")

	godotCallVoidFloat(o, "set_safe_margin", pixels)
	log.Println("  Function successfully completed.")

}

/*
   Checks for collisions without moving the body. Virtually sets the node's position, scale and rotation to that of the given [Transform], then tries to move the body along the vector [code]rel_vec[/code]. Returns [code]true[/code] if a collision would occur.
*/
func (o *KinematicBody) TestMove(from *Transform, relVec *Vector3) bool {
	log.Println("Calling KinematicBody.TestMove()")

	returnValue := godotCallBoolTransformVector3(o, "test_move", from, relVec)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   KinematicBodyImplementer is an interface for KinematicBody objects.
*/
type KinematicBodyImplementer interface {
	Class
}

/*
   Kinematic bodies are special types of bodies that are meant to be user-controlled. They are not affected by physics at all (to other types of bodies, such a character or a rigid body, these are the same as a static body). They have however, two main uses: Simulated Motion: When these bodies are moved manually, either from code or from an AnimationPlayer (with process mode set to fixed), the physics will automatically compute an estimate of their linear and angular velocity. This makes them very useful for moving platforms or other AnimationPlayer-controlled objects (like a door, a bridge that opens, etc). Kinematic Characters: KinematicBody2D also has an API for moving objects (the [method move_and_collide] and [method move_and_slide] methods) while performing collision tests. This makes them really useful to implement characters that collide against a world, but that don't require advanced physics.
*/
type KinematicBody2D struct {
	PhysicsBody2D
}

func (o *KinematicBody2D) baseClass() string {
	return "KinematicBody2D"
}

/*
   Returns the velocity of the floor. Only updates when calling [method move_and_slide].
*/
func (o *KinematicBody2D) GetFloorVelocity() *Vector2 {
	log.Println("Calling KinematicBody2D.GetFloorVelocity()")

	returnValue := godotCallVector2(o, "get_floor_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicBody2D) GetSafeMargin() float64 {
	log.Println("Calling KinematicBody2D.GetSafeMargin()")

	returnValue := godotCallFloat(o, "get_safe_margin")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a [KinematicCollision2D], which contains information about a collision that occurred during the last [method move_and_slide] call. Since the body can collide several times in a single call to [method move_and_slide], you must specify the index of the collision in the range 0 to ([method get_slide_count] - 1).
*/
func (o *KinematicBody2D) GetSlideCollision(slideIdx int64) *KinematicCollision2D {
	log.Println("Calling KinematicBody2D.GetSlideCollision()")

	returnValue := godotCallObjectInt(o, "get_slide_collision", slideIdx)
	log.Println("  Got return value: ", returnValue)

	var ret KinematicCollision2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of times the body collided and changed direction during the last call to [method move_and_slide].
*/
func (o *KinematicBody2D) GetSlideCount() int64 {
	log.Println("Calling KinematicBody2D.GetSlideCount()")

	returnValue := godotCallInt(o, "get_slide_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the body is on the ceiling. Only updates when calling [method move_and_slide].
*/
func (o *KinematicBody2D) IsOnCeiling() bool {
	log.Println("Calling KinematicBody2D.IsOnCeiling()")

	returnValue := godotCallBool(o, "is_on_ceiling")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the body is on the floor. Only updates when calling [method move_and_slide].
*/
func (o *KinematicBody2D) IsOnFloor() bool {
	log.Println("Calling KinematicBody2D.IsOnFloor()")

	returnValue := godotCallBool(o, "is_on_floor")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the body is on a wall. Only updates when calling [method move_and_slide].
*/
func (o *KinematicBody2D) IsOnWall() bool {
	log.Println("Calling KinematicBody2D.IsOnWall()")

	returnValue := godotCallBool(o, "is_on_wall")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Moves the body along the vector [code]rel_vec[/code]. The body will stop if it collides. Returns a [KinematicCollision2D], which contains information about the collision.
*/
func (o *KinematicBody2D) MoveAndCollide(relVec *Vector2) *KinematicCollision2D {
	log.Println("Calling KinematicBody2D.MoveAndCollide()")

	returnValue := godotCallObjectVector2(o, "move_and_collide", relVec)
	log.Println("  Got return value: ", returnValue)

	var ret KinematicCollision2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Moves the body along a vector. If the body collides with another, it will slide along the other body rather than stop immediately. If the other body is a [code]KinematicBody2D[/code] or [RigidBody2D], it will also be affected by the motion of the other body. You can use this to make moving or rotating platforms, or to make nodes push other nodes. [code]linear_velocity[/code] is a value in pixels per second. Unlike in for example [method move_and_collide], you should [i]not[/i] multiply it with [code]delta[/code] — this is done by the method. [code]floor_normal[/code] is the up direction, used to determine what is a wall and what is a floor or a ceiling. If set to the default value of [code]Vector2(0, 0)[/code], everything is considered a wall. This is useful for topdown games. If the body is standing on a slope and the horizontal speed (relative to the floor's speed) goes below [code]slope_stop_min_velocity[/code], the body will stop completely. This prevents the body from sliding down slopes when you include gravity in [code]linear_velocity[/code]. When set to lower values, the body will not be able to stand still on steep slopes. If the body collides, it will change direction a maximum of [code]max_bounces[/code] times before it stops. [code]floor_max_angle[/code] is the maximum angle (in radians) where a slope is still considered a floor (or a ceiling), rather than a wall. The default value equals 45 degrees. Returns the movement that remained when the body stopped. To get more detailed information about collisions that occurred, use [method get_slide_collision].
*/
func (o *KinematicBody2D) MoveAndSlide(linearVelocity *Vector2, floorNormal *Vector2, slopeStopMinVelocity float64, maxBounces int64, floorMaxAngle float64) *Vector2 {
	log.Println("Calling KinematicBody2D.MoveAndSlide()")

	returnValue := godotCallVector2Vector2Vector2FloatIntFloat(o, "move_and_slide", linearVelocity, floorNormal, slopeStopMinVelocity, maxBounces, floorMaxAngle)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicBody2D) SetSafeMargin(pixels float64) {
	log.Println("Calling KinematicBody2D.SetSafeMargin()")

	godotCallVoidFloat(o, "set_safe_margin", pixels)
	log.Println("  Function successfully completed.")

}

/*
   Checks for collisions without moving the body. Virtually sets the node's position, scale and rotation to that of the given [Transform2D], then tries to move the body along the vector [code]rel_vec[/code]. Returns [code]true[/code] if a collision would occur.
*/
func (o *KinematicBody2D) TestMove(from *Transform2D, relVec *Vector2) bool {
	log.Println("Calling KinematicBody2D.TestMove()")

	returnValue := godotCallBoolTransform2DVector2(o, "test_move", from, relVec)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   KinematicBody2DImplementer is an interface for KinematicBody2D objects.
*/
type KinematicBody2DImplementer interface {
	Class
}

/*
   Contains collision data for KinematicBody collisions. When a [KinematicBody] is moved using [method KinematicBody.move_and_collide], it stops if it detects a collision with another body. If a collision is detected, a KinematicCollision object is returned. This object contains information about the collision, including the colliding object, the remaining motion, and the collision position. This information can be used to calculate a collision response.
*/
type KinematicCollision struct {
	Reference
}

func (o *KinematicCollision) baseClass() string {
	return "KinematicCollision"
}

/*
   Undocumented
*/
func (o *KinematicCollision) GetCollider() *Object {
	log.Println("Calling KinematicCollision.GetCollider()")

	returnValue := godotCallObject(o, "get_collider")
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *KinematicCollision) GetColliderId() int64 {
	log.Println("Calling KinematicCollision.GetColliderId()")

	returnValue := godotCallInt(o, "get_collider_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision) GetColliderMetadata() *Variant {
	log.Println("Calling KinematicCollision.GetColliderMetadata()")

	returnValue := godotCallVariant(o, "get_collider_metadata")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision) GetColliderShape() *Object {
	log.Println("Calling KinematicCollision.GetColliderShape()")

	returnValue := godotCallObject(o, "get_collider_shape")
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *KinematicCollision) GetColliderShapeIndex() int64 {
	log.Println("Calling KinematicCollision.GetColliderShapeIndex()")

	returnValue := godotCallInt(o, "get_collider_shape_index")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision) GetColliderVelocity() *Vector3 {
	log.Println("Calling KinematicCollision.GetColliderVelocity()")

	returnValue := godotCallVector3(o, "get_collider_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision) GetLocalShape() *Object {
	log.Println("Calling KinematicCollision.GetLocalShape()")

	returnValue := godotCallObject(o, "get_local_shape")
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *KinematicCollision) GetNormal() *Vector3 {
	log.Println("Calling KinematicCollision.GetNormal()")

	returnValue := godotCallVector3(o, "get_normal")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision) GetPosition() *Vector3 {
	log.Println("Calling KinematicCollision.GetPosition()")

	returnValue := godotCallVector3(o, "get_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision) GetRemainder() *Vector3 {
	log.Println("Calling KinematicCollision.GetRemainder()")

	returnValue := godotCallVector3(o, "get_remainder")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision) GetTravel() *Vector3 {
	log.Println("Calling KinematicCollision.GetTravel()")

	returnValue := godotCallVector3(o, "get_travel")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   KinematicCollisionImplementer is an interface for KinematicCollision objects.
*/
type KinematicCollisionImplementer interface {
	Class
}

/*
   Contains collision data for KinematicBody2D collisions. When a [KinematicBody2D] is moved using [method KinematicBody2D.move_and_collide], it stops if it detects a collision with another body. If a collision is detected, a KinematicCollision2D object is returned. This object contains information about the collision, including the colliding object, the remaining motion, and the collision position. This information can be used to calculate a collision response.
*/
type KinematicCollision2D struct {
	Reference
}

func (o *KinematicCollision2D) baseClass() string {
	return "KinematicCollision2D"
}

/*
   Undocumented
*/
func (o *KinematicCollision2D) GetCollider() *Object {
	log.Println("Calling KinematicCollision2D.GetCollider()")

	returnValue := godotCallObject(o, "get_collider")
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *KinematicCollision2D) GetColliderId() int64 {
	log.Println("Calling KinematicCollision2D.GetColliderId()")

	returnValue := godotCallInt(o, "get_collider_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision2D) GetColliderMetadata() *Variant {
	log.Println("Calling KinematicCollision2D.GetColliderMetadata()")

	returnValue := godotCallVariant(o, "get_collider_metadata")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision2D) GetColliderShape() *Object {
	log.Println("Calling KinematicCollision2D.GetColliderShape()")

	returnValue := godotCallObject(o, "get_collider_shape")
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *KinematicCollision2D) GetColliderShapeIndex() int64 {
	log.Println("Calling KinematicCollision2D.GetColliderShapeIndex()")

	returnValue := godotCallInt(o, "get_collider_shape_index")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision2D) GetColliderVelocity() *Vector2 {
	log.Println("Calling KinematicCollision2D.GetColliderVelocity()")

	returnValue := godotCallVector2(o, "get_collider_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision2D) GetLocalShape() *Object {
	log.Println("Calling KinematicCollision2D.GetLocalShape()")

	returnValue := godotCallObject(o, "get_local_shape")
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *KinematicCollision2D) GetNormal() *Vector2 {
	log.Println("Calling KinematicCollision2D.GetNormal()")

	returnValue := godotCallVector2(o, "get_normal")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision2D) GetPosition() *Vector2 {
	log.Println("Calling KinematicCollision2D.GetPosition()")

	returnValue := godotCallVector2(o, "get_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision2D) GetRemainder() *Vector2 {
	log.Println("Calling KinematicCollision2D.GetRemainder()")

	returnValue := godotCallVector2(o, "get_remainder")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *KinematicCollision2D) GetTravel() *Vector2 {
	log.Println("Calling KinematicCollision2D.GetTravel()")

	returnValue := godotCallVector2(o, "get_travel")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   KinematicCollision2DImplementer is an interface for KinematicCollision2D objects.
*/
type KinematicCollision2DImplementer interface {
	Class
}

/*
   Label displays plain text on the screen. It gives you control over the horizontal and vertical alignment, and can wrap the text inside the node's bounding rectangle. It doesn't support bold, italics or other formatting. For that, use [RichTextLabel] instead. Note that contrarily to most other [Control]s, Label's [member Control.mouse_filter] defaults to MOUSE_FILTER_IGNORE (i.e. it doesn't react to mouse input events).
*/
type Label struct {
	Control
}

func (o *Label) baseClass() string {
	return "Label"
}

/*
   Undocumented
*/
func (o *Label) GetAlign() int64 {
	log.Println("Calling Label.GetAlign()")

	returnValue := godotCallInt(o, "get_align")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the amount of lines of text the Label has.
*/
func (o *Label) GetLineCount() int64 {
	log.Println("Calling Label.GetLineCount()")

	returnValue := godotCallInt(o, "get_line_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the font size in pixels.
*/
func (o *Label) GetLineHeight() int64 {
	log.Println("Calling Label.GetLineHeight()")

	returnValue := godotCallInt(o, "get_line_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Label) GetLinesSkipped() int64 {
	log.Println("Calling Label.GetLinesSkipped()")

	returnValue := godotCallInt(o, "get_lines_skipped")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Label) GetMaxLinesVisible() int64 {
	log.Println("Calling Label.GetMaxLinesVisible()")

	returnValue := godotCallInt(o, "get_max_lines_visible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Label) GetPercentVisible() float64 {
	log.Println("Calling Label.GetPercentVisible()")

	returnValue := godotCallFloat(o, "get_percent_visible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Label) GetText() string {
	log.Println("Calling Label.GetText()")

	returnValue := godotCallString(o, "get_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the total length of the text.
*/
func (o *Label) GetTotalCharacterCount() int64 {
	log.Println("Calling Label.GetTotalCharacterCount()")

	returnValue := godotCallInt(o, "get_total_character_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Label) GetValign() int64 {
	log.Println("Calling Label.GetValign()")

	returnValue := godotCallInt(o, "get_valign")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Label) GetVisibleCharacters() int64 {
	log.Println("Calling Label.GetVisibleCharacters()")

	returnValue := godotCallInt(o, "get_visible_characters")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of lines shown. Useful if the [code]Label[/code] 's height cannot currently display all lines.
*/
func (o *Label) GetVisibleLineCount() int64 {
	log.Println("Calling Label.GetVisibleLineCount()")

	returnValue := godotCallInt(o, "get_visible_line_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Label) HasAutowrap() bool {
	log.Println("Calling Label.HasAutowrap()")

	returnValue := godotCallBool(o, "has_autowrap")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Label) IsClippingText() bool {
	log.Println("Calling Label.IsClippingText()")

	returnValue := godotCallBool(o, "is_clipping_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Label) IsUppercase() bool {
	log.Println("Calling Label.IsUppercase()")

	returnValue := godotCallBool(o, "is_uppercase")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Label) SetAlign(align int64) {
	log.Println("Calling Label.SetAlign()")

	godotCallVoidInt(o, "set_align", align)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Label) SetAutowrap(enable bool) {
	log.Println("Calling Label.SetAutowrap()")

	godotCallVoidBool(o, "set_autowrap", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Label) SetClipText(enable bool) {
	log.Println("Calling Label.SetClipText()")

	godotCallVoidBool(o, "set_clip_text", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Label) SetLinesSkipped(linesSkipped int64) {
	log.Println("Calling Label.SetLinesSkipped()")

	godotCallVoidInt(o, "set_lines_skipped", linesSkipped)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Label) SetMaxLinesVisible(linesVisible int64) {
	log.Println("Calling Label.SetMaxLinesVisible()")

	godotCallVoidInt(o, "set_max_lines_visible", linesVisible)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Label) SetPercentVisible(percentVisible float64) {
	log.Println("Calling Label.SetPercentVisible()")

	godotCallVoidFloat(o, "set_percent_visible", percentVisible)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Label) SetText(text string) {
	log.Println("Calling Label.SetText()")

	godotCallVoidString(o, "set_text", text)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Label) SetUppercase(enable bool) {
	log.Println("Calling Label.SetUppercase()")

	godotCallVoidBool(o, "set_uppercase", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Label) SetValign(valign int64) {
	log.Println("Calling Label.SetValign()")

	godotCallVoidInt(o, "set_valign", valign)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Label) SetVisibleCharacters(amount int64) {
	log.Println("Calling Label.SetVisibleCharacters()")

	godotCallVoidInt(o, "set_visible_characters", amount)
	log.Println("  Function successfully completed.")

}

/*
   LabelImplementer is an interface for Label objects.
*/
type LabelImplementer interface {
	Class
}

/*
   A Texture capable of storing many smaller Textures with offsets. You can dynamically add pieces([Texture]) to this [code]LargeTexture[/code] using different offsets.
*/
type LargeTexture struct {
	Texture
}

func (o *LargeTexture) baseClass() string {
	return "LargeTexture"
}

/*
   Undocumented
*/
func (o *LargeTexture) X_GetData() *Array {
	log.Println("Calling LargeTexture.X_GetData()")

	returnValue := godotCallArray(o, "_get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LargeTexture) X_SetData(data *Array) {
	log.Println("Calling LargeTexture.X_SetData()")

	godotCallVoidArray(o, "_set_data", data)
	log.Println("  Function successfully completed.")

}

/*
   Add another [Texture] to this [code]LargeTexture[/code], starting on offset "ofs".
*/
func (o *LargeTexture) AddPiece(ofs *Vector2, texture *Texture) int64 {
	log.Println("Calling LargeTexture.AddPiece()")

	returnValue := godotCallIntVector2Object(o, "add_piece", ofs, &texture.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Clears the [code]LargeTexture[/code].
*/
func (o *LargeTexture) Clear() {
	log.Println("Calling LargeTexture.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Returns the number of pieces currently in this [code]LargeTexture[/code].
*/
func (o *LargeTexture) GetPieceCount() int64 {
	log.Println("Calling LargeTexture.GetPieceCount()")

	returnValue := godotCallInt(o, "get_piece_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the offset of the piece with index "idx".
*/
func (o *LargeTexture) GetPieceOffset(idx int64) *Vector2 {
	log.Println("Calling LargeTexture.GetPieceOffset()")

	returnValue := godotCallVector2Int(o, "get_piece_offset", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [Texture] of the piece with index "idx".
*/
func (o *LargeTexture) GetPieceTexture(idx int64) *Texture {
	log.Println("Calling LargeTexture.GetPieceTexture()")

	returnValue := godotCallObjectInt(o, "get_piece_texture", idx)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Sets the offset of the piece with index "idx" to "ofs".
*/
func (o *LargeTexture) SetPieceOffset(idx int64, ofs *Vector2) {
	log.Println("Calling LargeTexture.SetPieceOffset()")

	godotCallVoidIntVector2(o, "set_piece_offset", idx, ofs)
	log.Println("  Function successfully completed.")

}

/*
   Sets the [Texture] of the piece with index "idx" to "ofs".
*/
func (o *LargeTexture) SetPieceTexture(idx int64, texture *Texture) {
	log.Println("Calling LargeTexture.SetPieceTexture()")

	godotCallVoidIntObject(o, "set_piece_texture", idx, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Sets the size of this [code]LargeTexture[/code].
*/
func (o *LargeTexture) SetSize(size *Vector2) {
	log.Println("Calling LargeTexture.SetSize()")

	godotCallVoidVector2(o, "set_size", size)
	log.Println("  Function successfully completed.")

}

/*
   LargeTextureImplementer is an interface for LargeTexture objects.
*/
type LargeTextureImplementer interface {
	Class
}

/*
   Light is the abstract base class for light nodes, so it shouldn't be used directly (It can't be instanced). Other types of light nodes inherit from it. Light contains the common variables and parameters used for lighting.
*/
type Light struct {
	VisualInstance
}

func (o *Light) baseClass() string {
	return "Light"
}

/*
   Undocumented
*/
func (o *Light) GetBakeMode() int64 {
	log.Println("Calling Light.GetBakeMode()")

	returnValue := godotCallInt(o, "get_bake_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light) GetColor() *Color {
	log.Println("Calling Light.GetColor()")

	returnValue := godotCallColor(o, "get_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light) GetCullMask() int64 {
	log.Println("Calling Light.GetCullMask()")

	returnValue := godotCallInt(o, "get_cull_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light) GetParam(param int64) float64 {
	log.Println("Calling Light.GetParam()")

	returnValue := godotCallFloatInt(o, "get_param", param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light) GetShadowColor() *Color {
	log.Println("Calling Light.GetShadowColor()")

	returnValue := godotCallColor(o, "get_shadow_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light) GetShadowReverseCullFace() bool {
	log.Println("Calling Light.GetShadowReverseCullFace()")

	returnValue := godotCallBool(o, "get_shadow_reverse_cull_face")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light) HasShadow() bool {
	log.Println("Calling Light.HasShadow()")

	returnValue := godotCallBool(o, "has_shadow")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light) IsEditorOnly() bool {
	log.Println("Calling Light.IsEditorOnly()")

	returnValue := godotCallBool(o, "is_editor_only")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light) IsNegative() bool {
	log.Println("Calling Light.IsNegative()")

	returnValue := godotCallBool(o, "is_negative")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light) SetBakeMode(bakeMode int64) {
	log.Println("Calling Light.SetBakeMode()")

	godotCallVoidInt(o, "set_bake_mode", bakeMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light) SetColor(color *Color) {
	log.Println("Calling Light.SetColor()")

	godotCallVoidColor(o, "set_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light) SetCullMask(cullMask int64) {
	log.Println("Calling Light.SetCullMask()")

	godotCallVoidInt(o, "set_cull_mask", cullMask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light) SetEditorOnly(editorOnly bool) {
	log.Println("Calling Light.SetEditorOnly()")

	godotCallVoidBool(o, "set_editor_only", editorOnly)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light) SetNegative(enabled bool) {
	log.Println("Calling Light.SetNegative()")

	godotCallVoidBool(o, "set_negative", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light) SetParam(param int64, value float64) {
	log.Println("Calling Light.SetParam()")

	godotCallVoidIntFloat(o, "set_param", param, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light) SetShadow(enabled bool) {
	log.Println("Calling Light.SetShadow()")

	godotCallVoidBool(o, "set_shadow", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light) SetShadowColor(shadowColor *Color) {
	log.Println("Calling Light.SetShadowColor()")

	godotCallVoidColor(o, "set_shadow_color", shadowColor)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light) SetShadowReverseCullFace(enable bool) {
	log.Println("Calling Light.SetShadowReverseCullFace()")

	godotCallVoidBool(o, "set_shadow_reverse_cull_face", enable)
	log.Println("  Function successfully completed.")

}

/*
   LightImplementer is an interface for Light objects.
*/
type LightImplementer interface {
	Class
}

/*
   Casts light in a 2D environment. Light is defined by a (usually grayscale) texture, a color, an energy value, a mode (see constants), and various other parameters (range and shadows-related). Note that Light2D can be used as a mask.
*/
type Light2D struct {
	Node2D
}

func (o *Light2D) baseClass() string {
	return "Light2D"
}

/*
   Undocumented
*/
func (o *Light2D) GetColor() *Color {
	log.Println("Calling Light2D.GetColor()")

	returnValue := godotCallColor(o, "get_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetEnergy() float64 {
	log.Println("Calling Light2D.GetEnergy()")

	returnValue := godotCallFloat(o, "get_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetHeight() float64 {
	log.Println("Calling Light2D.GetHeight()")

	returnValue := godotCallFloat(o, "get_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetItemCullMask() int64 {
	log.Println("Calling Light2D.GetItemCullMask()")

	returnValue := godotCallInt(o, "get_item_cull_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetItemShadowCullMask() int64 {
	log.Println("Calling Light2D.GetItemShadowCullMask()")

	returnValue := godotCallInt(o, "get_item_shadow_cull_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetLayerRangeMax() int64 {
	log.Println("Calling Light2D.GetLayerRangeMax()")

	returnValue := godotCallInt(o, "get_layer_range_max")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetLayerRangeMin() int64 {
	log.Println("Calling Light2D.GetLayerRangeMin()")

	returnValue := godotCallInt(o, "get_layer_range_min")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetMode() int64 {
	log.Println("Calling Light2D.GetMode()")

	returnValue := godotCallInt(o, "get_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetShadowBufferSize() int64 {
	log.Println("Calling Light2D.GetShadowBufferSize()")

	returnValue := godotCallInt(o, "get_shadow_buffer_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetShadowColor() *Color {
	log.Println("Calling Light2D.GetShadowColor()")

	returnValue := godotCallColor(o, "get_shadow_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetShadowFilter() int64 {
	log.Println("Calling Light2D.GetShadowFilter()")

	returnValue := godotCallInt(o, "get_shadow_filter")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetShadowGradientLength() float64 {
	log.Println("Calling Light2D.GetShadowGradientLength()")

	returnValue := godotCallFloat(o, "get_shadow_gradient_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetShadowSmooth() float64 {
	log.Println("Calling Light2D.GetShadowSmooth()")

	returnValue := godotCallFloat(o, "get_shadow_smooth")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetTexture() *Texture {
	log.Println("Calling Light2D.GetTexture()")

	returnValue := godotCallObject(o, "get_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Light2D) GetTextureOffset() *Vector2 {
	log.Println("Calling Light2D.GetTextureOffset()")

	returnValue := godotCallVector2(o, "get_texture_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetTextureScale() float64 {
	log.Println("Calling Light2D.GetTextureScale()")

	returnValue := godotCallFloat(o, "get_texture_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetZRangeMax() int64 {
	log.Println("Calling Light2D.GetZRangeMax()")

	returnValue := godotCallInt(o, "get_z_range_max")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) GetZRangeMin() int64 {
	log.Println("Calling Light2D.GetZRangeMin()")

	returnValue := godotCallInt(o, "get_z_range_min")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) IsEditorOnly() bool {
	log.Println("Calling Light2D.IsEditorOnly()")

	returnValue := godotCallBool(o, "is_editor_only")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) IsEnabled() bool {
	log.Println("Calling Light2D.IsEnabled()")

	returnValue := godotCallBool(o, "is_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) IsShadowEnabled() bool {
	log.Println("Calling Light2D.IsShadowEnabled()")

	returnValue := godotCallBool(o, "is_shadow_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Light2D) SetColor(color *Color) {
	log.Println("Calling Light2D.SetColor()")

	godotCallVoidColor(o, "set_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetEditorOnly(editorOnly bool) {
	log.Println("Calling Light2D.SetEditorOnly()")

	godotCallVoidBool(o, "set_editor_only", editorOnly)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetEnabled(enabled bool) {
	log.Println("Calling Light2D.SetEnabled()")

	godotCallVoidBool(o, "set_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetEnergy(energy float64) {
	log.Println("Calling Light2D.SetEnergy()")

	godotCallVoidFloat(o, "set_energy", energy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetHeight(height float64) {
	log.Println("Calling Light2D.SetHeight()")

	godotCallVoidFloat(o, "set_height", height)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetItemCullMask(itemCullMask int64) {
	log.Println("Calling Light2D.SetItemCullMask()")

	godotCallVoidInt(o, "set_item_cull_mask", itemCullMask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetItemShadowCullMask(itemShadowCullMask int64) {
	log.Println("Calling Light2D.SetItemShadowCullMask()")

	godotCallVoidInt(o, "set_item_shadow_cull_mask", itemShadowCullMask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetLayerRangeMax(layer int64) {
	log.Println("Calling Light2D.SetLayerRangeMax()")

	godotCallVoidInt(o, "set_layer_range_max", layer)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetLayerRangeMin(layer int64) {
	log.Println("Calling Light2D.SetLayerRangeMin()")

	godotCallVoidInt(o, "set_layer_range_min", layer)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetMode(mode int64) {
	log.Println("Calling Light2D.SetMode()")

	godotCallVoidInt(o, "set_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetShadowBufferSize(size int64) {
	log.Println("Calling Light2D.SetShadowBufferSize()")

	godotCallVoidInt(o, "set_shadow_buffer_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetShadowColor(shadowColor *Color) {
	log.Println("Calling Light2D.SetShadowColor()")

	godotCallVoidColor(o, "set_shadow_color", shadowColor)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetShadowEnabled(enabled bool) {
	log.Println("Calling Light2D.SetShadowEnabled()")

	godotCallVoidBool(o, "set_shadow_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetShadowFilter(filter int64) {
	log.Println("Calling Light2D.SetShadowFilter()")

	godotCallVoidInt(o, "set_shadow_filter", filter)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetShadowGradientLength(multiplier float64) {
	log.Println("Calling Light2D.SetShadowGradientLength()")

	godotCallVoidFloat(o, "set_shadow_gradient_length", multiplier)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetShadowSmooth(smooth float64) {
	log.Println("Calling Light2D.SetShadowSmooth()")

	godotCallVoidFloat(o, "set_shadow_smooth", smooth)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetTexture(texture *Texture) {
	log.Println("Calling Light2D.SetTexture()")

	godotCallVoidObject(o, "set_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetTextureOffset(textureOffset *Vector2) {
	log.Println("Calling Light2D.SetTextureOffset()")

	godotCallVoidVector2(o, "set_texture_offset", textureOffset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetTextureScale(textureScale float64) {
	log.Println("Calling Light2D.SetTextureScale()")

	godotCallVoidFloat(o, "set_texture_scale", textureScale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetZRangeMax(z int64) {
	log.Println("Calling Light2D.SetZRangeMax()")

	godotCallVoidInt(o, "set_z_range_max", z)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Light2D) SetZRangeMin(z int64) {
	log.Println("Calling Light2D.SetZRangeMin()")

	godotCallVoidInt(o, "set_z_range_min", z)
	log.Println("  Function successfully completed.")

}

/*
   Light2DImplementer is an interface for Light2D objects.
*/
type Light2DImplementer interface {
	Class
}

/*
   Occludes light cast by a Light2D, casting shadows. The LightOccluder2D must be provided with an [OccluderPolygon2D] in order for the shadow to be computed.
*/
type LightOccluder2D struct {
	Node2D
}

func (o *LightOccluder2D) baseClass() string {
	return "LightOccluder2D"
}

/*
   Undocumented
*/
func (o *LightOccluder2D) X_PolyChanged() {
	log.Println("Calling LightOccluder2D.X_PolyChanged()")

	godotCallVoid(o, "_poly_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LightOccluder2D) GetOccluderLightMask() int64 {
	log.Println("Calling LightOccluder2D.GetOccluderLightMask()")

	returnValue := godotCallInt(o, "get_occluder_light_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LightOccluder2D) GetOccluderPolygon() *OccluderPolygon2D {
	log.Println("Calling LightOccluder2D.GetOccluderPolygon()")

	returnValue := godotCallObject(o, "get_occluder_polygon")
	log.Println("  Got return value: ", returnValue)

	var ret OccluderPolygon2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *LightOccluder2D) SetOccluderLightMask(mask int64) {
	log.Println("Calling LightOccluder2D.SetOccluderLightMask()")

	godotCallVoidInt(o, "set_occluder_light_mask", mask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LightOccluder2D) SetOccluderPolygon(polygon *OccluderPolygon2D) {
	log.Println("Calling LightOccluder2D.SetOccluderPolygon()")

	godotCallVoidObject(o, "set_occluder_polygon", &polygon.Object)
	log.Println("  Function successfully completed.")

}

/*
   LightOccluder2DImplementer is an interface for LightOccluder2D objects.
*/
type LightOccluder2DImplementer interface {
	Class
}

/*
   A line through several points in 2D space.
*/
type Line2D struct {
	Node2D
}

func (o *Line2D) baseClass() string {
	return "Line2D"
}

/*
   Undocumented
*/
func (o *Line2D) X_GradientChanged() {
	log.Println("Calling Line2D.X_GradientChanged()")

	godotCallVoid(o, "_gradient_changed")
	log.Println("  Function successfully completed.")

}

/*
   Add a point at the [code]position[/code]. Appends the point at the end of the line.
*/
func (o *Line2D) AddPoint(position *Vector2) {
	log.Println("Calling Line2D.AddPoint()")

	godotCallVoidVector2(o, "add_point", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) GetBeginCapMode() int64 {
	log.Println("Calling Line2D.GetBeginCapMode()")

	returnValue := godotCallInt(o, "get_begin_cap_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Line2D) GetDefaultColor() *Color {
	log.Println("Calling Line2D.GetDefaultColor()")

	returnValue := godotCallColor(o, "get_default_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Line2D) GetEndCapMode() int64 {
	log.Println("Calling Line2D.GetEndCapMode()")

	returnValue := godotCallInt(o, "get_end_cap_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Line2D) GetGradient() *Gradient {
	log.Println("Calling Line2D.GetGradient()")

	returnValue := godotCallObject(o, "get_gradient")
	log.Println("  Got return value: ", returnValue)

	var ret Gradient
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Line2D) GetJointMode() int64 {
	log.Println("Calling Line2D.GetJointMode()")

	returnValue := godotCallInt(o, "get_joint_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the Line2D's amount of points.
*/
func (o *Line2D) GetPointCount() int64 {
	log.Println("Calling Line2D.GetPointCount()")

	returnValue := godotCallInt(o, "get_point_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns point [code]i[/code]'s position.
*/
func (o *Line2D) GetPointPosition(i int64) *Vector2 {
	log.Println("Calling Line2D.GetPointPosition()")

	returnValue := godotCallVector2Int(o, "get_point_position", i)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Line2D) GetPoints() *PoolVector2Array {
	log.Println("Calling Line2D.GetPoints()")

	returnValue := godotCallPoolVector2Array(o, "get_points")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Line2D) GetRoundPrecision() int64 {
	log.Println("Calling Line2D.GetRoundPrecision()")

	returnValue := godotCallInt(o, "get_round_precision")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Line2D) GetSharpLimit() float64 {
	log.Println("Calling Line2D.GetSharpLimit()")

	returnValue := godotCallFloat(o, "get_sharp_limit")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Line2D) GetTexture() *Texture {
	log.Println("Calling Line2D.GetTexture()")

	returnValue := godotCallObject(o, "get_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Line2D) GetTextureMode() int64 {
	log.Println("Calling Line2D.GetTextureMode()")

	returnValue := godotCallInt(o, "get_texture_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Line2D) GetWidth() float64 {
	log.Println("Calling Line2D.GetWidth()")

	returnValue := godotCallFloat(o, "get_width")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Remove the point at index [code]i[/code] from the line.
*/
func (o *Line2D) RemovePoint(i int64) {
	log.Println("Calling Line2D.RemovePoint()")

	godotCallVoidInt(o, "remove_point", i)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) SetBeginCapMode(mode int64) {
	log.Println("Calling Line2D.SetBeginCapMode()")

	godotCallVoidInt(o, "set_begin_cap_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) SetDefaultColor(color *Color) {
	log.Println("Calling Line2D.SetDefaultColor()")

	godotCallVoidColor(o, "set_default_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) SetEndCapMode(mode int64) {
	log.Println("Calling Line2D.SetEndCapMode()")

	godotCallVoidInt(o, "set_end_cap_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) SetGradient(color *Gradient) {
	log.Println("Calling Line2D.SetGradient()")

	godotCallVoidObject(o, "set_gradient", &color.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) SetJointMode(mode int64) {
	log.Println("Calling Line2D.SetJointMode()")

	godotCallVoidInt(o, "set_joint_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Overwrites the position in point [code]i[/code] with the supplied [code]position[/code].
*/
func (o *Line2D) SetPointPosition(i int64, position *Vector2) {
	log.Println("Calling Line2D.SetPointPosition()")

	godotCallVoidIntVector2(o, "set_point_position", i, position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) SetPoints(points *PoolVector2Array) {
	log.Println("Calling Line2D.SetPoints()")

	godotCallVoidPoolVector2Array(o, "set_points", points)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) SetRoundPrecision(precision int64) {
	log.Println("Calling Line2D.SetRoundPrecision()")

	godotCallVoidInt(o, "set_round_precision", precision)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) SetSharpLimit(limit float64) {
	log.Println("Calling Line2D.SetSharpLimit()")

	godotCallVoidFloat(o, "set_sharp_limit", limit)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) SetTexture(texture *Texture) {
	log.Println("Calling Line2D.SetTexture()")

	godotCallVoidObject(o, "set_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) SetTextureMode(mode int64) {
	log.Println("Calling Line2D.SetTextureMode()")

	godotCallVoidInt(o, "set_texture_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Line2D) SetWidth(width float64) {
	log.Println("Calling Line2D.SetWidth()")

	godotCallVoidFloat(o, "set_width", width)
	log.Println("  Function successfully completed.")

}

/*
   Line2DImplementer is an interface for Line2D objects.
*/
type Line2DImplementer interface {
	Class
}

/*
   LineEdit provides a single line string editor, used for text fields.
*/
type LineEdit struct {
	Control
}

func (o *LineEdit) baseClass() string {
	return "LineEdit"
}

/*
   Undocumented
*/
func (o *LineEdit) X_EditorSettingsChanged() {
	log.Println("Calling LineEdit.X_EditorSettingsChanged()")

	godotCallVoid(o, "_editor_settings_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling LineEdit.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) X_ToggleDrawCaret() {
	log.Println("Calling LineEdit.X_ToggleDrawCaret()")

	godotCallVoid(o, "_toggle_draw_caret")
	log.Println("  Function successfully completed.")

}

/*
   Adds [code]text[/code] after the cursor. If the resulting value is longer than [member max_length], nothing happens.
*/
func (o *LineEdit) AppendAtCursor(text string) {
	log.Println("Calling LineEdit.AppendAtCursor()")

	godotCallVoidString(o, "append_at_cursor", text)
	log.Println("  Function successfully completed.")

}

/*
   Erases the [LineEdit] text.
*/
func (o *LineEdit) Clear() {
	log.Println("Calling LineEdit.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) CursorGetBlinkEnabled() bool {
	log.Println("Calling LineEdit.CursorGetBlinkEnabled()")

	returnValue := godotCallBool(o, "cursor_get_blink_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineEdit) CursorGetBlinkSpeed() float64 {
	log.Println("Calling LineEdit.CursorGetBlinkSpeed()")

	returnValue := godotCallFloat(o, "cursor_get_blink_speed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineEdit) CursorSetBlinkEnabled(enabled bool) {
	log.Println("Calling LineEdit.CursorSetBlinkEnabled()")

	godotCallVoidBool(o, "cursor_set_blink_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) CursorSetBlinkSpeed(blinkSpeed float64) {
	log.Println("Calling LineEdit.CursorSetBlinkSpeed()")

	godotCallVoidFloat(o, "cursor_set_blink_speed", blinkSpeed)
	log.Println("  Function successfully completed.")

}

/*
   Clears the current selection.
*/
func (o *LineEdit) Deselect() {
	log.Println("Calling LineEdit.Deselect()")

	godotCallVoid(o, "deselect")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) GetAlign() int64 {
	log.Println("Calling LineEdit.GetAlign()")

	returnValue := godotCallInt(o, "get_align")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineEdit) GetCursorPosition() int64 {
	log.Println("Calling LineEdit.GetCursorPosition()")

	returnValue := godotCallInt(o, "get_cursor_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineEdit) GetExpandToTextLength() bool {
	log.Println("Calling LineEdit.GetExpandToTextLength()")

	returnValue := godotCallBool(o, "get_expand_to_text_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineEdit) GetMaxLength() int64 {
	log.Println("Calling LineEdit.GetMaxLength()")

	returnValue := godotCallInt(o, "get_max_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [PopupMenu] of this [code]LineEdit[/code]. By default, this menu is displayed when right-clicking on the [LineEdit].
*/
func (o *LineEdit) GetMenu() *PopupMenu {
	log.Println("Calling LineEdit.GetMenu()")

	returnValue := godotCallObject(o, "get_menu")
	log.Println("  Got return value: ", returnValue)

	var ret PopupMenu
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *LineEdit) GetPlaceholder() string {
	log.Println("Calling LineEdit.GetPlaceholder()")

	returnValue := godotCallString(o, "get_placeholder")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineEdit) GetPlaceholderAlpha() float64 {
	log.Println("Calling LineEdit.GetPlaceholderAlpha()")

	returnValue := godotCallFloat(o, "get_placeholder_alpha")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineEdit) GetText() string {
	log.Println("Calling LineEdit.GetText()")

	returnValue := godotCallString(o, "get_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineEdit) IsContextMenuEnabled() bool {
	log.Println("Calling LineEdit.IsContextMenuEnabled()")

	returnValue := godotCallBool(o, "is_context_menu_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineEdit) IsEditable() bool {
	log.Println("Calling LineEdit.IsEditable()")

	returnValue := godotCallBool(o, "is_editable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineEdit) IsSecret() bool {
	log.Println("Calling LineEdit.IsSecret()")

	returnValue := godotCallBool(o, "is_secret")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Executes a given action as defined in the MENU_* enum.
*/
func (o *LineEdit) MenuOption(option int64) {
	log.Println("Calling LineEdit.MenuOption()")

	godotCallVoidInt(o, "menu_option", option)
	log.Println("  Function successfully completed.")

}

/*
   Selects characters inside [LineEdit] between [code]from[/code] and [code]to[/code]. By default [code]from[/code] is at the beginning and [code]to[/code] at the end. [codeblock] text = "Welcome" select() # Welcome select(4) # ome select(2, 5) # lco [/codeblock]
*/
func (o *LineEdit) Select(from int64, to int64) {
	log.Println("Calling LineEdit.Select()")

	godotCallVoidIntInt(o, "select", from, to)
	log.Println("  Function successfully completed.")

}

/*
   Selects the whole [String].
*/
func (o *LineEdit) SelectAll() {
	log.Println("Calling LineEdit.SelectAll()")

	godotCallVoid(o, "select_all")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) SetAlign(align int64) {
	log.Println("Calling LineEdit.SetAlign()")

	godotCallVoidInt(o, "set_align", align)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) SetContextMenuEnabled(enable bool) {
	log.Println("Calling LineEdit.SetContextMenuEnabled()")

	godotCallVoidBool(o, "set_context_menu_enabled", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) SetCursorPosition(position int64) {
	log.Println("Calling LineEdit.SetCursorPosition()")

	godotCallVoidInt(o, "set_cursor_position", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) SetEditable(enabled bool) {
	log.Println("Calling LineEdit.SetEditable()")

	godotCallVoidBool(o, "set_editable", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) SetExpandToTextLength(enabled bool) {
	log.Println("Calling LineEdit.SetExpandToTextLength()")

	godotCallVoidBool(o, "set_expand_to_text_length", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) SetMaxLength(chars int64) {
	log.Println("Calling LineEdit.SetMaxLength()")

	godotCallVoidInt(o, "set_max_length", chars)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) SetPlaceholder(text string) {
	log.Println("Calling LineEdit.SetPlaceholder()")

	godotCallVoidString(o, "set_placeholder", text)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) SetPlaceholderAlpha(alpha float64) {
	log.Println("Calling LineEdit.SetPlaceholderAlpha()")

	godotCallVoidFloat(o, "set_placeholder_alpha", alpha)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) SetSecret(enabled bool) {
	log.Println("Calling LineEdit.SetSecret()")

	godotCallVoidBool(o, "set_secret", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineEdit) SetText(text string) {
	log.Println("Calling LineEdit.SetText()")

	godotCallVoidString(o, "set_text", text)
	log.Println("  Function successfully completed.")

}

/*
   LineEditImplementer is an interface for LineEdit objects.
*/
type LineEditImplementer interface {
	Class
}

/*
   Line shape for 2D collisions. It works like a 2D plane and will not allow any body to go to the negative side. Not recommended for rigid bodies, and usually not recommended for static bodies either because it forces checks against it on every frame.
*/
type LineShape2D struct {
	Shape2D
}

func (o *LineShape2D) baseClass() string {
	return "LineShape2D"
}

/*
   Undocumented
*/
func (o *LineShape2D) GetD() float64 {
	log.Println("Calling LineShape2D.GetD()")

	returnValue := godotCallFloat(o, "get_d")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineShape2D) GetNormal() *Vector2 {
	log.Println("Calling LineShape2D.GetNormal()")

	returnValue := godotCallVector2(o, "get_normal")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LineShape2D) SetD(d float64) {
	log.Println("Calling LineShape2D.SetD()")

	godotCallVoidFloat(o, "set_d", d)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LineShape2D) SetNormal(normal *Vector2) {
	log.Println("Calling LineShape2D.SetNormal()")

	godotCallVoidVector2(o, "set_normal", normal)
	log.Println("  Function successfully completed.")

}

/*
   LineShape2DImplementer is an interface for LineShape2D objects.
*/
type LineShape2DImplementer interface {
	Class
}

/*
   This kind of buttons are primarily used when the interaction with the button causes a context change (like linking to a web page).
*/
type LinkButton struct {
	BaseButton
}

func (o *LinkButton) baseClass() string {
	return "LinkButton"
}

/*
   Undocumented
*/
func (o *LinkButton) GetText() string {
	log.Println("Calling LinkButton.GetText()")

	returnValue := godotCallString(o, "get_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LinkButton) GetUnderlineMode() int64 {
	log.Println("Calling LinkButton.GetUnderlineMode()")

	returnValue := godotCallInt(o, "get_underline_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *LinkButton) SetText(text string) {
	log.Println("Calling LinkButton.SetText()")

	godotCallVoidString(o, "set_text", text)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *LinkButton) SetUnderlineMode(underlineMode int64) {
	log.Println("Calling LinkButton.SetUnderlineMode()")

	godotCallVoidInt(o, "set_underline_mode", underlineMode)
	log.Println("  Function successfully completed.")

}

/*
   LinkButtonImplementer is an interface for LinkButton objects.
*/
type LinkButtonImplementer interface {
	Class
}

/*

 */
type Listener struct {
	Spatial
}

func (o *Listener) baseClass() string {
	return "Listener"
}

/*

 */
func (o *Listener) ClearCurrent() {
	log.Println("Calling Listener.ClearCurrent()")

	godotCallVoid(o, "clear_current")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Listener) GetListenerTransform() *Transform {
	log.Println("Calling Listener.GetListenerTransform()")

	returnValue := godotCallTransform(o, "get_listener_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Listener) IsCurrent() bool {
	log.Println("Calling Listener.IsCurrent()")

	returnValue := godotCallBool(o, "is_current")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Listener) MakeCurrent() {
	log.Println("Calling Listener.MakeCurrent()")

	godotCallVoid(o, "make_current")
	log.Println("  Function successfully completed.")

}

/*
   ListenerImplementer is an interface for Listener objects.
*/
type ListenerImplementer interface {
	Class
}

/*
   Main loop is the abstract main loop base class. All other main loop classes are derived from it. Upon application start, a [code]MainLoop[/code] has to be provided to OS, else the application will exit. This happens automatically (and a [SceneTree] is created), unless a main [Script] is supplied, which may or not create and return a [code]MainLoop[/code].
*/
type MainLoop struct {
	Object
}

func (o *MainLoop) baseClass() string {
	return "MainLoop"
}

/*

 */
func (o *MainLoop) X_DropFiles(files *PoolStringArray, screen int64) {
	log.Println("Calling MainLoop.X_DropFiles()")

	godotCallVoidPoolStringArrayInt(o, "_drop_files", files, screen)
	log.Println("  Function successfully completed.")

}

/*
   Called before the program exits.
*/
func (o *MainLoop) X_Finalize() {
	log.Println("Calling MainLoop.X_Finalize()")

	godotCallVoid(o, "_finalize")
	log.Println("  Function successfully completed.")

}

/*
   Called each idle frame with time since last call as an only argument.
*/
func (o *MainLoop) X_Idle(delta float64) {
	log.Println("Calling MainLoop.X_Idle()")

	godotCallVoidFloat(o, "_idle", delta)
	log.Println("  Function successfully completed.")

}

/*
   Called once during initialization.
*/
func (o *MainLoop) X_Initialize() {
	log.Println("Calling MainLoop.X_Initialize()")

	godotCallVoid(o, "_initialize")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MainLoop) X_InputEvent(ev *InputEvent) {
	log.Println("Calling MainLoop.X_InputEvent()")

	godotCallVoidObject(o, "_input_event", &ev.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MainLoop) X_InputText(text string) {
	log.Println("Calling MainLoop.X_InputText()")

	godotCallVoidString(o, "_input_text", text)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MainLoop) X_Iteration(delta float64) {
	log.Println("Calling MainLoop.X_Iteration()")

	godotCallVoidFloat(o, "_iteration", delta)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MainLoop) Finish() {
	log.Println("Calling MainLoop.Finish()")

	godotCallVoid(o, "finish")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MainLoop) Idle(delta float64) bool {
	log.Println("Calling MainLoop.Idle()")

	returnValue := godotCallBoolFloat(o, "idle", delta)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MainLoop) Init() {
	log.Println("Calling MainLoop.Init()")

	godotCallVoid(o, "init")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MainLoop) InputEvent(ev *InputEvent) {
	log.Println("Calling MainLoop.InputEvent()")

	godotCallVoidObject(o, "input_event", &ev.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MainLoop) InputText(text string) {
	log.Println("Calling MainLoop.InputText()")

	godotCallVoidString(o, "input_text", text)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MainLoop) Iteration(delta float64) bool {
	log.Println("Calling MainLoop.Iteration()")

	returnValue := godotCallBoolFloat(o, "iteration", delta)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   MainLoopImplementer is an interface for MainLoop objects.
*/
type MainLoopImplementer interface {
	Class
}

/*
   Simple margin container. Adds a left margin to anything contained.
*/
type MarginContainer struct {
	Container
}

func (o *MarginContainer) baseClass() string {
	return "MarginContainer"
}

/*
   MarginContainerImplementer is an interface for MarginContainer objects.
*/
type MarginContainerImplementer interface {
	Class
}

/*
   Material is a base [Resource] used for coloring and shading geometry. All materials inherit from it and almost all [VisualInstance] derived nodes carry a Material. A few flags and parameters are shared between all material types and are configured here.
*/
type Material struct {
	Resource
}

func (o *Material) baseClass() string {
	return "Material"
}

/*
   Undocumented
*/
func (o *Material) GetNextPass() *Material {
	log.Println("Calling Material.GetNextPass()")

	returnValue := godotCallObject(o, "get_next_pass")
	log.Println("  Got return value: ", returnValue)

	var ret Material
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Material) GetRenderPriority() int64 {
	log.Println("Calling Material.GetRenderPriority()")

	returnValue := godotCallInt(o, "get_render_priority")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Material) SetNextPass(nextPass *Material) {
	log.Println("Calling Material.SetNextPass()")

	godotCallVoidObject(o, "set_next_pass", &nextPass.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Material) SetRenderPriority(priority int64) {
	log.Println("Calling Material.SetRenderPriority()")

	godotCallVoidInt(o, "set_render_priority", priority)
	log.Println("  Function successfully completed.")

}

/*
   MaterialImplementer is an interface for Material objects.
*/
type MaterialImplementer interface {
	Class
}

/*
   Special button that brings up a [PopupMenu] when clicked. That's pretty much all it does, as it's just a helper class when building GUIs.
*/
type MenuButton struct {
	Button
}

func (o *MenuButton) baseClass() string {
	return "MenuButton"
}

/*
   Undocumented
*/
func (o *MenuButton) X_GetItems() *Array {
	log.Println("Calling MenuButton.X_GetItems()")

	returnValue := godotCallArray(o, "_get_items")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MenuButton) X_SetItems(arg0 *Array) {
	log.Println("Calling MenuButton.X_SetItems()")

	godotCallVoidArray(o, "_set_items", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MenuButton) X_UnhandledKeyInput(arg0 *InputEvent) {
	log.Println("Calling MenuButton.X_UnhandledKeyInput()")

	godotCallVoidObject(o, "_unhandled_key_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Return the [PopupMenu] contained in this button.
*/
func (o *MenuButton) GetPopup() *PopupMenu {
	log.Println("Calling MenuButton.GetPopup()")

	returnValue := godotCallObject(o, "get_popup")
	log.Println("  Got return value: ", returnValue)

	var ret PopupMenu
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *MenuButton) SetDisableShortcuts(disabled bool) {
	log.Println("Calling MenuButton.SetDisableShortcuts()")

	godotCallVoidBool(o, "set_disable_shortcuts", disabled)
	log.Println("  Function successfully completed.")

}

/*
   MenuButtonImplementer is an interface for MenuButton objects.
*/
type MenuButtonImplementer interface {
	Class
}

/*
   Mesh is a type of [Resource] that contains vertex-array based geometry, divided in [i]surfaces[/i]. Each surface contains a completely separate array and a material used to draw it. Design wise, a mesh with multiple surfaces is preferred to a single surface, because objects created in 3D editing software commonly contain multiple materials.
*/
type Mesh struct {
	Resource
}

func (o *Mesh) baseClass() string {
	return "Mesh"
}

/*
   Calculate a [ConvexPolygonShape] from the mesh.
*/
func (o *Mesh) CreateConvexShape() *Shape {
	log.Println("Calling Mesh.CreateConvexShape()")

	returnValue := godotCallObject(o, "create_convex_shape")
	log.Println("  Got return value: ", returnValue)

	var ret Shape
	ret.owner = returnValue.owner
	return &ret

}

/*
   Calculate an outline mesh at a defined offset (margin) from the original mesh. Note: Typically returns the vertices in reverse order (e.g. clockwise to anti-clockwise).
*/
func (o *Mesh) CreateOutline(margin float64) *Mesh {
	log.Println("Calling Mesh.CreateOutline()")

	returnValue := godotCallObjectFloat(o, "create_outline", margin)
	log.Println("  Got return value: ", returnValue)

	var ret Mesh
	ret.owner = returnValue.owner
	return &ret

}

/*
   Calculate a [ConcavePolygonShape] from the mesh.
*/
func (o *Mesh) CreateTrimeshShape() *Shape {
	log.Println("Calling Mesh.CreateTrimeshShape()")

	returnValue := godotCallObject(o, "create_trimesh_shape")
	log.Println("  Got return value: ", returnValue)

	var ret Shape
	ret.owner = returnValue.owner
	return &ret

}

/*
   Generate a [TriangleMesh] from the mesh.
*/
func (o *Mesh) GenerateTriangleMesh() *TriangleMesh {
	log.Println("Calling Mesh.GenerateTriangleMesh()")

	returnValue := godotCallObject(o, "generate_triangle_mesh")
	log.Println("  Got return value: ", returnValue)

	var ret TriangleMesh
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns all the vertices that make up the faces of the mesh. Each three vertices represent one triangle.
*/
func (o *Mesh) GetFaces() *PoolVector3Array {
	log.Println("Calling Mesh.GetFaces()")

	returnValue := godotCallPoolVector3Array(o, "get_faces")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Mesh) GetLightmapSizeHint() *Vector2 {
	log.Println("Calling Mesh.GetLightmapSizeHint()")

	returnValue := godotCallVector2(o, "get_lightmap_size_hint")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Mesh) SetLightmapSizeHint(size *Vector2) {
	log.Println("Calling Mesh.SetLightmapSizeHint()")

	godotCallVoidVector2(o, "set_lightmap_size_hint", size)
	log.Println("  Function successfully completed.")

}

/*
   MeshImplementer is an interface for Mesh objects.
*/
type MeshImplementer interface {
	Class
}

/*

 */
type MeshDataTool struct {
	Reference
}

func (o *MeshDataTool) baseClass() string {
	return "MeshDataTool"
}

/*

 */
func (o *MeshDataTool) Clear() {
	log.Println("Calling MeshDataTool.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) CommitToSurface(mesh *ArrayMesh) int64 {
	log.Println("Calling MeshDataTool.CommitToSurface()")

	returnValue := godotCallIntObject(o, "commit_to_surface", &mesh.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) CreateFromSurface(mesh *ArrayMesh, surface int64) int64 {
	log.Println("Calling MeshDataTool.CreateFromSurface()")

	returnValue := godotCallIntObjectInt(o, "create_from_surface", &mesh.Object, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetEdgeCount() int64 {
	log.Println("Calling MeshDataTool.GetEdgeCount()")

	returnValue := godotCallInt(o, "get_edge_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetEdgeFaces(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetEdgeFaces()")

	returnValue := godotCallPoolIntArrayInt(o, "get_edge_faces", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetEdgeMeta(idx int64) *Variant {
	log.Println("Calling MeshDataTool.GetEdgeMeta()")

	returnValue := godotCallVariantInt(o, "get_edge_meta", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetEdgeVertex(idx int64, vertex int64) int64 {
	log.Println("Calling MeshDataTool.GetEdgeVertex()")

	returnValue := godotCallIntIntInt(o, "get_edge_vertex", idx, vertex)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceCount() int64 {
	log.Println("Calling MeshDataTool.GetFaceCount()")

	returnValue := godotCallInt(o, "get_face_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceEdge(idx int64, edge int64) int64 {
	log.Println("Calling MeshDataTool.GetFaceEdge()")

	returnValue := godotCallIntIntInt(o, "get_face_edge", idx, edge)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceMeta(idx int64) *Variant {
	log.Println("Calling MeshDataTool.GetFaceMeta()")

	returnValue := godotCallVariantInt(o, "get_face_meta", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceNormal(idx int64) *Vector3 {
	log.Println("Calling MeshDataTool.GetFaceNormal()")

	returnValue := godotCallVector3Int(o, "get_face_normal", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceVertex(idx int64, vertex int64) int64 {
	log.Println("Calling MeshDataTool.GetFaceVertex()")

	returnValue := godotCallIntIntInt(o, "get_face_vertex", idx, vertex)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFormat() int64 {
	log.Println("Calling MeshDataTool.GetFormat()")

	returnValue := godotCallInt(o, "get_format")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetMaterial() *Material {
	log.Println("Calling MeshDataTool.GetMaterial()")

	returnValue := godotCallObject(o, "get_material")
	log.Println("  Got return value: ", returnValue)

	var ret Material
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *MeshDataTool) GetVertex(idx int64) *Vector3 {
	log.Println("Calling MeshDataTool.GetVertex()")

	returnValue := godotCallVector3Int(o, "get_vertex", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexBones(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetVertexBones()")

	returnValue := godotCallPoolIntArrayInt(o, "get_vertex_bones", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexColor(idx int64) *Color {
	log.Println("Calling MeshDataTool.GetVertexColor()")

	returnValue := godotCallColorInt(o, "get_vertex_color", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexCount() int64 {
	log.Println("Calling MeshDataTool.GetVertexCount()")

	returnValue := godotCallInt(o, "get_vertex_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexEdges(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetVertexEdges()")

	returnValue := godotCallPoolIntArrayInt(o, "get_vertex_edges", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexFaces(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetVertexFaces()")

	returnValue := godotCallPoolIntArrayInt(o, "get_vertex_faces", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexMeta(idx int64) *Variant {
	log.Println("Calling MeshDataTool.GetVertexMeta()")

	returnValue := godotCallVariantInt(o, "get_vertex_meta", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexNormal(idx int64) *Vector3 {
	log.Println("Calling MeshDataTool.GetVertexNormal()")

	returnValue := godotCallVector3Int(o, "get_vertex_normal", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexTangent(idx int64) *Plane {
	log.Println("Calling MeshDataTool.GetVertexTangent()")

	returnValue := godotCallPlaneInt(o, "get_vertex_tangent", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexUv(idx int64) *Vector2 {
	log.Println("Calling MeshDataTool.GetVertexUv()")

	returnValue := godotCallVector2Int(o, "get_vertex_uv", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexUv2(idx int64) *Vector2 {
	log.Println("Calling MeshDataTool.GetVertexUv2()")

	returnValue := godotCallVector2Int(o, "get_vertex_uv2", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexWeights(idx int64) *PoolRealArray {
	log.Println("Calling MeshDataTool.GetVertexWeights()")

	returnValue := godotCallPoolRealArrayInt(o, "get_vertex_weights", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetEdgeMeta(idx int64, meta *Variant) {
	log.Println("Calling MeshDataTool.SetEdgeMeta()")

	godotCallVoidIntVariant(o, "set_edge_meta", idx, meta)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) SetFaceMeta(idx int64, meta *Variant) {
	log.Println("Calling MeshDataTool.SetFaceMeta()")

	godotCallVoidIntVariant(o, "set_face_meta", idx, meta)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) SetMaterial(material *Material) {
	log.Println("Calling MeshDataTool.SetMaterial()")

	godotCallVoidObject(o, "set_material", &material.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) SetVertex(idx int64, vertex *Vector3) {
	log.Println("Calling MeshDataTool.SetVertex()")

	godotCallVoidIntVector3(o, "set_vertex", idx, vertex)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) SetVertexBones(idx int64, bones *PoolIntArray) {
	log.Println("Calling MeshDataTool.SetVertexBones()")

	godotCallVoidIntPoolIntArray(o, "set_vertex_bones", idx, bones)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) SetVertexColor(idx int64, color *Color) {
	log.Println("Calling MeshDataTool.SetVertexColor()")

	godotCallVoidIntColor(o, "set_vertex_color", idx, color)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) SetVertexMeta(idx int64, meta *Variant) {
	log.Println("Calling MeshDataTool.SetVertexMeta()")

	godotCallVoidIntVariant(o, "set_vertex_meta", idx, meta)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) SetVertexNormal(idx int64, normal *Vector3) {
	log.Println("Calling MeshDataTool.SetVertexNormal()")

	godotCallVoidIntVector3(o, "set_vertex_normal", idx, normal)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) SetVertexTangent(idx int64, tangent *Plane) {
	log.Println("Calling MeshDataTool.SetVertexTangent()")

	godotCallVoidIntPlane(o, "set_vertex_tangent", idx, tangent)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) SetVertexUv(idx int64, uv *Vector2) {
	log.Println("Calling MeshDataTool.SetVertexUv()")

	godotCallVoidIntVector2(o, "set_vertex_uv", idx, uv)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) SetVertexUv2(idx int64, uv2 *Vector2) {
	log.Println("Calling MeshDataTool.SetVertexUv2()")

	godotCallVoidIntVector2(o, "set_vertex_uv2", idx, uv2)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshDataTool) SetVertexWeights(idx int64, weights *PoolRealArray) {
	log.Println("Calling MeshDataTool.SetVertexWeights()")

	godotCallVoidIntPoolRealArray(o, "set_vertex_weights", idx, weights)
	log.Println("  Function successfully completed.")

}

/*
   MeshDataToolImplementer is an interface for MeshDataTool objects.
*/
type MeshDataToolImplementer interface {
	Class
}

/*
   MeshInstance is a node that takes a [Mesh] resource and adds it to the current scenario by creating an instance of it. This is the class most often used to get 3D geometry rendered and can be used to instance a single [Mesh] in many places. This allows to reuse geometry and save on resources. When a [Mesh] has to be instanced more than thousands of times at close proximity, consider using a [MultiMesh] in a [MultiMeshInstance] instead.
*/
type MeshInstance struct {
	GeometryInstance
}

func (o *MeshInstance) baseClass() string {
	return "MeshInstance"
}

/*
   Undocumented
*/
func (o *MeshInstance) X_MeshChanged() {
	log.Println("Calling MeshInstance.X_MeshChanged()")

	godotCallVoid(o, "_mesh_changed")
	log.Println("  Function successfully completed.")

}

/*
   This helper creates a [StaticBody] child node with a [ConvexPolygonShape] collision shape calculated from the mesh geometry. It's mainly used for testing.
*/
func (o *MeshInstance) CreateConvexCollision() {
	log.Println("Calling MeshInstance.CreateConvexCollision()")

	godotCallVoid(o, "create_convex_collision")
	log.Println("  Function successfully completed.")

}

/*
   This helper creates a [MeshInstance] child node with gizmos at every vertex calculated from the mesh geometry. It's mainly used for testing.
*/
func (o *MeshInstance) CreateDebugTangents() {
	log.Println("Calling MeshInstance.CreateDebugTangents()")

	godotCallVoid(o, "create_debug_tangents")
	log.Println("  Function successfully completed.")

}

/*
   This helper creates a [StaticBody] child node with a [ConcavePolygonShape] collision shape calculated from the mesh geometry. It's mainly used for testing.
*/
func (o *MeshInstance) CreateTrimeshCollision() {
	log.Println("Calling MeshInstance.CreateTrimeshCollision()")

	godotCallVoid(o, "create_trimesh_collision")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MeshInstance) GetMesh() *Mesh {
	log.Println("Calling MeshInstance.GetMesh()")

	returnValue := godotCallObject(o, "get_mesh")
	log.Println("  Got return value: ", returnValue)

	var ret Mesh
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *MeshInstance) GetSkeletonPath() *NodePath {
	log.Println("Calling MeshInstance.GetSkeletonPath()")

	returnValue := godotCallNodePath(o, "get_skeleton_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [Material] for a surface of the [Mesh] resource.
*/
func (o *MeshInstance) GetSurfaceMaterial(surface int64) *Material {
	log.Println("Calling MeshInstance.GetSurfaceMaterial()")

	returnValue := godotCallObjectInt(o, "get_surface_material", surface)
	log.Println("  Got return value: ", returnValue)

	var ret Material
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *MeshInstance) SetMesh(mesh *Mesh) {
	log.Println("Calling MeshInstance.SetMesh()")

	godotCallVoidObject(o, "set_mesh", &mesh.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MeshInstance) SetSkeletonPath(skeletonPath *NodePath) {
	log.Println("Calling MeshInstance.SetSkeletonPath()")

	godotCallVoidNodePath(o, "set_skeleton_path", skeletonPath)
	log.Println("  Function successfully completed.")

}

/*
   Sets the [Material] for a surface of the [Mesh] resource.
*/
func (o *MeshInstance) SetSurfaceMaterial(surface int64, material *Material) {
	log.Println("Calling MeshInstance.SetSurfaceMaterial()")

	godotCallVoidIntObject(o, "set_surface_material", surface, &material.Object)
	log.Println("  Function successfully completed.")

}

/*
   MeshInstanceImplementer is an interface for MeshInstance objects.
*/
type MeshInstanceImplementer interface {
	Class
}

/*
   Library of meshes. Contains a list of [Mesh] resources, each with name and ID. Useful for GridMap or painting Terrain.
*/
type MeshLibrary struct {
	Resource
}

func (o *MeshLibrary) baseClass() string {
	return "MeshLibrary"
}

/*
   Clear the library.
*/
func (o *MeshLibrary) Clear() {
	log.Println("Calling MeshLibrary.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Create a new item in the library, supplied an id.
*/
func (o *MeshLibrary) CreateItem(id int64) {
	log.Println("Calling MeshLibrary.CreateItem()")

	godotCallVoidInt(o, "create_item", id)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshLibrary) FindItemByName(name string) int64 {
	log.Println("Calling MeshLibrary.FindItemByName()")

	returnValue := godotCallIntString(o, "find_item_by_name", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the list of items.
*/
func (o *MeshLibrary) GetItemList() *PoolIntArray {
	log.Println("Calling MeshLibrary.GetItemList()")

	returnValue := godotCallPoolIntArray(o, "get_item_list")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the mesh of the item.
*/
func (o *MeshLibrary) GetItemMesh(id int64) *Mesh {
	log.Println("Calling MeshLibrary.GetItemMesh()")

	returnValue := godotCallObjectInt(o, "get_item_mesh", id)
	log.Println("  Got return value: ", returnValue)

	var ret Mesh
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the name of the item.
*/
func (o *MeshLibrary) GetItemName(id int64) string {
	log.Println("Calling MeshLibrary.GetItemName()")

	returnValue := godotCallStringInt(o, "get_item_name", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *MeshLibrary) GetItemNavmesh(id int64) *NavigationMesh {
	log.Println("Calling MeshLibrary.GetItemNavmesh()")

	returnValue := godotCallObjectInt(o, "get_item_navmesh", id)
	log.Println("  Got return value: ", returnValue)

	var ret NavigationMesh
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *MeshLibrary) GetItemPreview(id int64) *Texture {
	log.Println("Calling MeshLibrary.GetItemPreview()")

	returnValue := godotCallObjectInt(o, "get_item_preview", id)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *MeshLibrary) GetItemShapes(id int64) *Array {
	log.Println("Calling MeshLibrary.GetItemShapes()")

	returnValue := godotCallArrayInt(o, "get_item_shapes", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get an unused id for a new item.
*/
func (o *MeshLibrary) GetLastUnusedItemId() int64 {
	log.Println("Calling MeshLibrary.GetLastUnusedItemId()")

	returnValue := godotCallInt(o, "get_last_unused_item_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Remove the item.
*/
func (o *MeshLibrary) RemoveItem(id int64) {
	log.Println("Calling MeshLibrary.RemoveItem()")

	godotCallVoidInt(o, "remove_item", id)
	log.Println("  Function successfully completed.")

}

/*
   Set the mesh of the item.
*/
func (o *MeshLibrary) SetItemMesh(id int64, mesh *Mesh) {
	log.Println("Calling MeshLibrary.SetItemMesh()")

	godotCallVoidIntObject(o, "set_item_mesh", id, &mesh.Object)
	log.Println("  Function successfully completed.")

}

/*
   Set the name of the item.
*/
func (o *MeshLibrary) SetItemName(id int64, name string) {
	log.Println("Calling MeshLibrary.SetItemName()")

	godotCallVoidIntString(o, "set_item_name", id, name)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshLibrary) SetItemNavmesh(id int64, navmesh *NavigationMesh) {
	log.Println("Calling MeshLibrary.SetItemNavmesh()")

	godotCallVoidIntObject(o, "set_item_navmesh", id, &navmesh.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshLibrary) SetItemPreview(id int64, texture *Texture) {
	log.Println("Calling MeshLibrary.SetItemPreview()")

	godotCallVoidIntObject(o, "set_item_preview", id, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *MeshLibrary) SetItemShapes(id int64, shapes *Array) {
	log.Println("Calling MeshLibrary.SetItemShapes()")

	godotCallVoidIntArray(o, "set_item_shapes", id, shapes)
	log.Println("  Function successfully completed.")

}

/*
   MeshLibraryImplementer is an interface for MeshLibrary objects.
*/
type MeshLibraryImplementer interface {
	Class
}

/*
   Undocumented
*/
type MobileVRInterface struct {
	ARVRInterface
}

func (o *MobileVRInterface) baseClass() string {
	return "MobileVRInterface"
}

/*
   Undocumented
*/
func (o *MobileVRInterface) GetDisplayToLens() float64 {
	log.Println("Calling MobileVRInterface.GetDisplayToLens()")

	returnValue := godotCallFloat(o, "get_display_to_lens")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MobileVRInterface) GetDisplayWidth() float64 {
	log.Println("Calling MobileVRInterface.GetDisplayWidth()")

	returnValue := godotCallFloat(o, "get_display_width")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MobileVRInterface) GetIod() float64 {
	log.Println("Calling MobileVRInterface.GetIod()")

	returnValue := godotCallFloat(o, "get_iod")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MobileVRInterface) GetK1() float64 {
	log.Println("Calling MobileVRInterface.GetK1()")

	returnValue := godotCallFloat(o, "get_k1")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MobileVRInterface) GetK2() float64 {
	log.Println("Calling MobileVRInterface.GetK2()")

	returnValue := godotCallFloat(o, "get_k2")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MobileVRInterface) GetOversample() float64 {
	log.Println("Calling MobileVRInterface.GetOversample()")

	returnValue := godotCallFloat(o, "get_oversample")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MobileVRInterface) SetDisplayToLens(displayToLens float64) {
	log.Println("Calling MobileVRInterface.SetDisplayToLens()")

	godotCallVoidFloat(o, "set_display_to_lens", displayToLens)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MobileVRInterface) SetDisplayWidth(displayWidth float64) {
	log.Println("Calling MobileVRInterface.SetDisplayWidth()")

	godotCallVoidFloat(o, "set_display_width", displayWidth)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MobileVRInterface) SetIod(iod float64) {
	log.Println("Calling MobileVRInterface.SetIod()")

	godotCallVoidFloat(o, "set_iod", iod)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MobileVRInterface) SetK1(k float64) {
	log.Println("Calling MobileVRInterface.SetK1()")

	godotCallVoidFloat(o, "set_k1", k)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MobileVRInterface) SetK2(k float64) {
	log.Println("Calling MobileVRInterface.SetK2()")

	godotCallVoidFloat(o, "set_k2", k)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MobileVRInterface) SetOversample(oversample float64) {
	log.Println("Calling MobileVRInterface.SetOversample()")

	godotCallVoidFloat(o, "set_oversample", oversample)
	log.Println("  Function successfully completed.")

}

/*
   MobileVRInterfaceImplementer is an interface for MobileVRInterface objects.
*/
type MobileVRInterfaceImplementer interface {
	Class
}

/*
   MultiMesh provides low level mesh instancing. If the amount of [Mesh] instances needed goes from hundreds to thousands (and most need to be visible at close proximity) creating such a large amount of [MeshInstance] nodes may affect performance by using too much CPU or video memory. For this case a MultiMesh becomes very useful, as it can draw thousands of instances with little API overhead. As a drawback, if the instances are too far away of each other, performance may be reduced as every single instance will always rendered (they are spatially indexed as one, for the whole object). Since instances may have any behavior, the AABB used for visibility must be provided by the user.
*/
type MultiMesh struct {
	Resource
}

func (o *MultiMesh) baseClass() string {
	return "MultiMesh"
}

/*
   Undocumented
*/
func (o *MultiMesh) X_GetColorArray() *PoolColorArray {
	log.Println("Calling MultiMesh.X_GetColorArray()")

	returnValue := godotCallPoolColorArray(o, "_get_color_array")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MultiMesh) X_GetTransformArray() *PoolVector3Array {
	log.Println("Calling MultiMesh.X_GetTransformArray()")

	returnValue := godotCallPoolVector3Array(o, "_get_transform_array")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MultiMesh) X_SetColorArray(arg0 *PoolColorArray) {
	log.Println("Calling MultiMesh.X_SetColorArray()")

	godotCallVoidPoolColorArray(o, "_set_color_array", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MultiMesh) X_SetTransformArray(arg0 *PoolVector3Array) {
	log.Println("Calling MultiMesh.X_SetTransformArray()")

	godotCallVoidPoolVector3Array(o, "_set_transform_array", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Return the visibility AABB.
*/
func (o *MultiMesh) GetAabb() *AABB {
	log.Println("Calling MultiMesh.GetAabb()")

	returnValue := godotCallAabb(o, "get_aabb")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MultiMesh) GetColorFormat() int64 {
	log.Println("Calling MultiMesh.GetColorFormat()")

	returnValue := godotCallInt(o, "get_color_format")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the color of a specific instance.
*/
func (o *MultiMesh) GetInstanceColor(instance int64) *Color {
	log.Println("Calling MultiMesh.GetInstanceColor()")

	returnValue := godotCallColorInt(o, "get_instance_color", instance)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MultiMesh) GetInstanceCount() int64 {
	log.Println("Calling MultiMesh.GetInstanceCount()")

	returnValue := godotCallInt(o, "get_instance_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the transform of a specific instance.
*/
func (o *MultiMesh) GetInstanceTransform(instance int64) *Transform {
	log.Println("Calling MultiMesh.GetInstanceTransform()")

	returnValue := godotCallTransformInt(o, "get_instance_transform", instance)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MultiMesh) GetMesh() *Mesh {
	log.Println("Calling MultiMesh.GetMesh()")

	returnValue := godotCallObject(o, "get_mesh")
	log.Println("  Got return value: ", returnValue)

	var ret Mesh
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *MultiMesh) GetTransformFormat() int64 {
	log.Println("Calling MultiMesh.GetTransformFormat()")

	returnValue := godotCallInt(o, "get_transform_format")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *MultiMesh) SetColorFormat(format int64) {
	log.Println("Calling MultiMesh.SetColorFormat()")

	godotCallVoidInt(o, "set_color_format", format)
	log.Println("  Function successfully completed.")

}

/*
   Set the color of a specific instance.
*/
func (o *MultiMesh) SetInstanceColor(instance int64, color *Color) {
	log.Println("Calling MultiMesh.SetInstanceColor()")

	godotCallVoidIntColor(o, "set_instance_color", instance, color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MultiMesh) SetInstanceCount(count int64) {
	log.Println("Calling MultiMesh.SetInstanceCount()")

	godotCallVoidInt(o, "set_instance_count", count)
	log.Println("  Function successfully completed.")

}

/*
   Set the transform for a specific instance.
*/
func (o *MultiMesh) SetInstanceTransform(instance int64, transform *Transform) {
	log.Println("Calling MultiMesh.SetInstanceTransform()")

	godotCallVoidIntTransform(o, "set_instance_transform", instance, transform)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MultiMesh) SetMesh(mesh *Mesh) {
	log.Println("Calling MultiMesh.SetMesh()")

	godotCallVoidObject(o, "set_mesh", &mesh.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *MultiMesh) SetTransformFormat(format int64) {
	log.Println("Calling MultiMesh.SetTransformFormat()")

	godotCallVoidInt(o, "set_transform_format", format)
	log.Println("  Function successfully completed.")

}

/*
   MultiMeshImplementer is an interface for MultiMesh objects.
*/
type MultiMeshImplementer interface {
	Class
}

/*
   [code]MultiMeshInstance[/code] is a specialized node to instance [GeometryInstance]s based on a [MultiMesh] resource. This is useful to optimize the rendering of a high amount of instances of a given mesh (for example tree in a forest or grass strands).
*/
type MultiMeshInstance struct {
	GeometryInstance
}

func (o *MultiMeshInstance) baseClass() string {
	return "MultiMeshInstance"
}

/*
   Undocumented
*/
func (o *MultiMeshInstance) GetMultimesh() *MultiMesh {
	log.Println("Calling MultiMeshInstance.GetMultimesh()")

	returnValue := godotCallObject(o, "get_multimesh")
	log.Println("  Got return value: ", returnValue)

	var ret MultiMesh
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *MultiMeshInstance) SetMultimesh(multimesh *MultiMesh) {
	log.Println("Calling MultiMeshInstance.SetMultimesh()")

	godotCallVoidObject(o, "set_multimesh", &multimesh.Object)
	log.Println("  Function successfully completed.")

}

/*
   MultiMeshInstanceImplementer is an interface for MultiMeshInstance objects.
*/
type MultiMeshInstanceImplementer interface {
	Class
}

/*
   Undocumented
*/
type NativeScript struct {
	Script
}

func (o *NativeScript) baseClass() string {
	return "NativeScript"
}

/*
   Undocumented
*/
func (o *NativeScript) GetClassName() string {
	log.Println("Calling NativeScript.GetClassName()")

	returnValue := godotCallString(o, "get_class_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NativeScript) GetLibrary() *GDNativeLibrary {
	log.Println("Calling NativeScript.GetLibrary()")

	returnValue := godotCallObject(o, "get_library")
	log.Println("  Got return value: ", returnValue)

	var ret GDNativeLibrary
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *NativeScript) New(varArgs ...interface{}) *Object {
	log.Println("Calling NativeScript.New()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallObjectVarargs(o, "new", varArgsArray)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *NativeScript) SetClassName(className string) {
	log.Println("Calling NativeScript.SetClassName()")

	godotCallVoidString(o, "set_class_name", className)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NativeScript) SetLibrary(library *GDNativeLibrary) {
	log.Println("Calling NativeScript.SetLibrary()")

	godotCallVoidObject(o, "set_library", &library.Object)
	log.Println("  Function successfully completed.")

}

/*
   NativeScriptImplementer is an interface for NativeScript objects.
*/
type NativeScriptImplementer interface {
	Class
}

/*
   The Navigation node is used for basic or advanced navigation. By default it will automatically collect all child [code]NavigationMesh[/code] resources, but they can also be added on the fly through scripting. It can be used for generating a simple path between two points or it can be used to ensure that a navigation agent is angled perfectly to the terrain it is navigating.
*/
type Navigation struct {
	Spatial
}

func (o *Navigation) baseClass() string {
	return "Navigation"
}

/*
   Returns the closest navigation point to the point passed.
*/
func (o *Navigation) GetClosestPoint(toPoint *Vector3) *Vector3 {
	log.Println("Calling Navigation.GetClosestPoint()")

	returnValue := godotCallVector3Vector3(o, "get_closest_point", toPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the surface normal of the navigation mesh at the point passed. For instance, if the point passed was at a 45 degree slope it would return something like (0.5,0.5,0). This is useful for rotating a navigation agent in accordance with the [code]NavigationMesh[/code].
*/
func (o *Navigation) GetClosestPointNormal(toPoint *Vector3) *Vector3 {
	log.Println("Calling Navigation.GetClosestPointNormal()")

	returnValue := godotCallVector3Vector3(o, "get_closest_point_normal", toPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the nearest [code]NavigationMeshInstance[/code] to the point passed.
*/
func (o *Navigation) GetClosestPointOwner(toPoint *Vector3) *Object {
	log.Println("Calling Navigation.GetClosestPointOwner()")

	returnValue := godotCallObjectVector3(o, "get_closest_point_owner", toPoint)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the nearest point to the line segment passed. The third optional parameter takes collisions into account.
*/
func (o *Navigation) GetClosestPointToSegment(start *Vector3, end *Vector3, useCollision bool) *Vector3 {
	log.Println("Calling Navigation.GetClosestPointToSegment()")

	returnValue := godotCallVector3Vector3Vector3Bool(o, "get_closest_point_to_segment", start, end, useCollision)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a path of points as a [code]PoolVector3Array[/code]. If [code]optimize[/code] is false the [code]NavigationMesh[/code] agent properties will be taken into account, otherwise it will return the nearest path and ignore agent radius, height, etc.
*/
func (o *Navigation) GetSimplePath(start *Vector3, end *Vector3, optimize bool) *PoolVector3Array {
	log.Println("Calling Navigation.GetSimplePath()")

	returnValue := godotCallPoolVector3ArrayVector3Vector3Bool(o, "get_simple_path", start, end, optimize)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Navigation) GetUpVector() *Vector3 {
	log.Println("Calling Navigation.GetUpVector()")

	returnValue := godotCallVector3(o, "get_up_vector")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Adds a [code]NavigationMesh[/code] to the list of NavigationMesh's in this node. Returns an id. Its position, rotation and scale are associated with the [code]Transform[/code] passed. The [code]Node[/code] (or [code]Object[/code]) that owns this node is an optional parameter.
*/
func (o *Navigation) NavmeshAdd(mesh *NavigationMesh, xform *Transform, owner *Object) int64 {
	log.Println("Calling Navigation.NavmeshAdd()")

	returnValue := godotCallIntObjectTransformObject(o, "navmesh_add", &mesh.Object, xform, owner)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a [code]NavigationMesh[/code] from the list of NavigationMesh's in this node.
*/
func (o *Navigation) NavmeshRemove(id int64) {
	log.Println("Calling Navigation.NavmeshRemove()")

	godotCallVoidInt(o, "navmesh_remove", id)
	log.Println("  Function successfully completed.")

}

/*
   Associates a [code]NavigationMesh[/code]'s id with a [code]Transform[/code]. Its position, rotation and scale are based on the [code]Transform[/code] passed.
*/
func (o *Navigation) NavmeshSetTransform(id int64, xform *Transform) {
	log.Println("Calling Navigation.NavmeshSetTransform()")

	godotCallVoidIntTransform(o, "navmesh_set_transform", id, xform)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Navigation) SetUpVector(up *Vector3) {
	log.Println("Calling Navigation.SetUpVector()")

	godotCallVoidVector3(o, "set_up_vector", up)
	log.Println("  Function successfully completed.")

}

/*
   NavigationImplementer is an interface for Navigation objects.
*/
type NavigationImplementer interface {
	Class
}

/*

 */
type Navigation2D struct {
	Node2D
}

func (o *Navigation2D) baseClass() string {
	return "Navigation2D"
}

/*

 */
func (o *Navigation2D) GetClosestPoint(toPoint *Vector2) *Vector2 {
	log.Println("Calling Navigation2D.GetClosestPoint()")

	returnValue := godotCallVector2Vector2(o, "get_closest_point", toPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Navigation2D) GetClosestPointOwner(toPoint *Vector2) *Object {
	log.Println("Calling Navigation2D.GetClosestPointOwner()")

	returnValue := godotCallObjectVector2(o, "get_closest_point_owner", toPoint)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *Navigation2D) GetSimplePath(start *Vector2, end *Vector2, optimize bool) *PoolVector2Array {
	log.Println("Calling Navigation2D.GetSimplePath()")

	returnValue := godotCallPoolVector2ArrayVector2Vector2Bool(o, "get_simple_path", start, end, optimize)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Navigation2D) NavpolyAdd(mesh *NavigationPolygon, xform *Transform2D, owner *Object) int64 {
	log.Println("Calling Navigation2D.NavpolyAdd()")

	returnValue := godotCallIntObjectTransform2DObject(o, "navpoly_add", &mesh.Object, xform, owner)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Navigation2D) NavpolyRemove(id int64) {
	log.Println("Calling Navigation2D.NavpolyRemove()")

	godotCallVoidInt(o, "navpoly_remove", id)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Navigation2D) NavpolySetTransform(id int64, xform *Transform2D) {
	log.Println("Calling Navigation2D.NavpolySetTransform()")

	godotCallVoidIntTransform2D(o, "navpoly_set_transform", id, xform)
	log.Println("  Function successfully completed.")

}

/*
   Navigation2DImplementer is an interface for Navigation2D objects.
*/
type Navigation2DImplementer interface {
	Class
}

/*

 */
type NavigationMesh struct {
	Resource
}

func (o *NavigationMesh) baseClass() string {
	return "NavigationMesh"
}

/*
   Undocumented
*/
func (o *NavigationMesh) X_GetPolygons() *Array {
	log.Println("Calling NavigationMesh.X_GetPolygons()")

	returnValue := godotCallArray(o, "_get_polygons")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) X_SetPolygons(polygons *Array) {
	log.Println("Calling NavigationMesh.X_SetPolygons()")

	godotCallVoidArray(o, "_set_polygons", polygons)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationMesh) AddPolygon(polygon *PoolIntArray) {
	log.Println("Calling NavigationMesh.AddPolygon()")

	godotCallVoidPoolIntArray(o, "add_polygon", polygon)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationMesh) ClearPolygons() {
	log.Println("Calling NavigationMesh.ClearPolygons()")

	godotCallVoid(o, "clear_polygons")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationMesh) CreateFromMesh(mesh *Mesh) {
	log.Println("Calling NavigationMesh.CreateFromMesh()")

	godotCallVoidObject(o, "create_from_mesh", &mesh.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetAgentHeight() float64 {
	log.Println("Calling NavigationMesh.GetAgentHeight()")

	returnValue := godotCallFloat(o, "get_agent_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetAgentMaxClimb() float64 {
	log.Println("Calling NavigationMesh.GetAgentMaxClimb()")

	returnValue := godotCallFloat(o, "get_agent_max_climb")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetAgentMaxSlope() float64 {
	log.Println("Calling NavigationMesh.GetAgentMaxSlope()")

	returnValue := godotCallFloat(o, "get_agent_max_slope")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetAgentRadius() float64 {
	log.Println("Calling NavigationMesh.GetAgentRadius()")

	returnValue := godotCallFloat(o, "get_agent_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetCellHeight() float64 {
	log.Println("Calling NavigationMesh.GetCellHeight()")

	returnValue := godotCallFloat(o, "get_cell_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetCellSize() float64 {
	log.Println("Calling NavigationMesh.GetCellSize()")

	returnValue := godotCallFloat(o, "get_cell_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetDetailSampleDistance() float64 {
	log.Println("Calling NavigationMesh.GetDetailSampleDistance()")

	returnValue := godotCallFloat(o, "get_detail_sample_distance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetDetailSampleMaxError() float64 {
	log.Println("Calling NavigationMesh.GetDetailSampleMaxError()")

	returnValue := godotCallFloat(o, "get_detail_sample_max_error")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetEdgeMaxError() float64 {
	log.Println("Calling NavigationMesh.GetEdgeMaxError()")

	returnValue := godotCallFloat(o, "get_edge_max_error")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetEdgeMaxLength() float64 {
	log.Println("Calling NavigationMesh.GetEdgeMaxLength()")

	returnValue := godotCallFloat(o, "get_edge_max_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetFilterLedgeSpans() bool {
	log.Println("Calling NavigationMesh.GetFilterLedgeSpans()")

	returnValue := godotCallBool(o, "get_filter_ledge_spans")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetFilterLowHangingObstacles() bool {
	log.Println("Calling NavigationMesh.GetFilterLowHangingObstacles()")

	returnValue := godotCallBool(o, "get_filter_low_hanging_obstacles")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetFilterWalkableLowHeightSpans() bool {
	log.Println("Calling NavigationMesh.GetFilterWalkableLowHeightSpans()")

	returnValue := godotCallBool(o, "get_filter_walkable_low_height_spans")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *NavigationMesh) GetPolygon(idx int64) *PoolIntArray {
	log.Println("Calling NavigationMesh.GetPolygon()")

	returnValue := godotCallPoolIntArrayInt(o, "get_polygon", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *NavigationMesh) GetPolygonCount() int64 {
	log.Println("Calling NavigationMesh.GetPolygonCount()")

	returnValue := godotCallInt(o, "get_polygon_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetRegionMergeSize() float64 {
	log.Println("Calling NavigationMesh.GetRegionMergeSize()")

	returnValue := godotCallFloat(o, "get_region_merge_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetRegionMinSize() float64 {
	log.Println("Calling NavigationMesh.GetRegionMinSize()")

	returnValue := godotCallFloat(o, "get_region_min_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetSamplePartitionType() int64 {
	log.Println("Calling NavigationMesh.GetSamplePartitionType()")

	returnValue := godotCallInt(o, "get_sample_partition_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *NavigationMesh) GetVertices() *PoolVector3Array {
	log.Println("Calling NavigationMesh.GetVertices()")

	returnValue := godotCallPoolVector3Array(o, "get_vertices")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) GetVertsPerPoly() float64 {
	log.Println("Calling NavigationMesh.GetVertsPerPoly()")

	returnValue := godotCallFloat(o, "get_verts_per_poly")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetAgentHeight(agentHeight float64) {
	log.Println("Calling NavigationMesh.SetAgentHeight()")

	godotCallVoidFloat(o, "set_agent_height", agentHeight)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetAgentMaxClimb(agentMaxClimb float64) {
	log.Println("Calling NavigationMesh.SetAgentMaxClimb()")

	godotCallVoidFloat(o, "set_agent_max_climb", agentMaxClimb)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetAgentMaxSlope(agentMaxSlope float64) {
	log.Println("Calling NavigationMesh.SetAgentMaxSlope()")

	godotCallVoidFloat(o, "set_agent_max_slope", agentMaxSlope)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetAgentRadius(agentRadius float64) {
	log.Println("Calling NavigationMesh.SetAgentRadius()")

	godotCallVoidFloat(o, "set_agent_radius", agentRadius)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetCellHeight(cellHeight float64) {
	log.Println("Calling NavigationMesh.SetCellHeight()")

	godotCallVoidFloat(o, "set_cell_height", cellHeight)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetCellSize(cellSize float64) {
	log.Println("Calling NavigationMesh.SetCellSize()")

	godotCallVoidFloat(o, "set_cell_size", cellSize)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetDetailSampleDistance(detailSampleDist float64) {
	log.Println("Calling NavigationMesh.SetDetailSampleDistance()")

	godotCallVoidFloat(o, "set_detail_sample_distance", detailSampleDist)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetDetailSampleMaxError(detailSampleMaxError float64) {
	log.Println("Calling NavigationMesh.SetDetailSampleMaxError()")

	godotCallVoidFloat(o, "set_detail_sample_max_error", detailSampleMaxError)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetEdgeMaxError(edgeMaxError float64) {
	log.Println("Calling NavigationMesh.SetEdgeMaxError()")

	godotCallVoidFloat(o, "set_edge_max_error", edgeMaxError)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetEdgeMaxLength(edgeMaxLength float64) {
	log.Println("Calling NavigationMesh.SetEdgeMaxLength()")

	godotCallVoidFloat(o, "set_edge_max_length", edgeMaxLength)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetFilterLedgeSpans(filterLedgeSpans bool) {
	log.Println("Calling NavigationMesh.SetFilterLedgeSpans()")

	godotCallVoidBool(o, "set_filter_ledge_spans", filterLedgeSpans)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetFilterLowHangingObstacles(filterLowHangingObstacles bool) {
	log.Println("Calling NavigationMesh.SetFilterLowHangingObstacles()")

	godotCallVoidBool(o, "set_filter_low_hanging_obstacles", filterLowHangingObstacles)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetFilterWalkableLowHeightSpans(filterWalkableLowHeightSpans bool) {
	log.Println("Calling NavigationMesh.SetFilterWalkableLowHeightSpans()")

	godotCallVoidBool(o, "set_filter_walkable_low_height_spans", filterWalkableLowHeightSpans)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetRegionMergeSize(regionMergeSize float64) {
	log.Println("Calling NavigationMesh.SetRegionMergeSize()")

	godotCallVoidFloat(o, "set_region_merge_size", regionMergeSize)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetRegionMinSize(regionMinSize float64) {
	log.Println("Calling NavigationMesh.SetRegionMinSize()")

	godotCallVoidFloat(o, "set_region_min_size", regionMinSize)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetSamplePartitionType(samplePartitionType int64) {
	log.Println("Calling NavigationMesh.SetSamplePartitionType()")

	godotCallVoidInt(o, "set_sample_partition_type", samplePartitionType)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationMesh) SetVertices(vertices *PoolVector3Array) {
	log.Println("Calling NavigationMesh.SetVertices()")

	godotCallVoidPoolVector3Array(o, "set_vertices", vertices)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMesh) SetVertsPerPoly(vertsPerPoly float64) {
	log.Println("Calling NavigationMesh.SetVertsPerPoly()")

	godotCallVoidFloat(o, "set_verts_per_poly", vertsPerPoly)
	log.Println("  Function successfully completed.")

}

/*
   NavigationMeshImplementer is an interface for NavigationMesh objects.
*/
type NavigationMeshImplementer interface {
	Class
}

/*

 */
type NavigationMeshInstance struct {
	Spatial
}

func (o *NavigationMeshInstance) baseClass() string {
	return "NavigationMeshInstance"
}

/*
   Undocumented
*/
func (o *NavigationMeshInstance) GetNavigationMesh() *NavigationMesh {
	log.Println("Calling NavigationMeshInstance.GetNavigationMesh()")

	returnValue := godotCallObject(o, "get_navigation_mesh")
	log.Println("  Got return value: ", returnValue)

	var ret NavigationMesh
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *NavigationMeshInstance) IsEnabled() bool {
	log.Println("Calling NavigationMeshInstance.IsEnabled()")

	returnValue := godotCallBool(o, "is_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationMeshInstance) SetEnabled(enabled bool) {
	log.Println("Calling NavigationMeshInstance.SetEnabled()")

	godotCallVoidBool(o, "set_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationMeshInstance) SetNavigationMesh(navmesh *NavigationMesh) {
	log.Println("Calling NavigationMeshInstance.SetNavigationMesh()")

	godotCallVoidObject(o, "set_navigation_mesh", &navmesh.Object)
	log.Println("  Function successfully completed.")

}

/*
   NavigationMeshInstanceImplementer is an interface for NavigationMeshInstance objects.
*/
type NavigationMeshInstanceImplementer interface {
	Class
}

/*

 */
type NavigationPolygon struct {
	Resource
}

func (o *NavigationPolygon) baseClass() string {
	return "NavigationPolygon"
}

/*
   Undocumented
*/
func (o *NavigationPolygon) X_GetOutlines() *Array {
	log.Println("Calling NavigationPolygon.X_GetOutlines()")

	returnValue := godotCallArray(o, "_get_outlines")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationPolygon) X_GetPolygons() *Array {
	log.Println("Calling NavigationPolygon.X_GetPolygons()")

	returnValue := godotCallArray(o, "_get_polygons")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationPolygon) X_SetOutlines(outlines *Array) {
	log.Println("Calling NavigationPolygon.X_SetOutlines()")

	godotCallVoidArray(o, "_set_outlines", outlines)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationPolygon) X_SetPolygons(polygons *Array) {
	log.Println("Calling NavigationPolygon.X_SetPolygons()")

	godotCallVoidArray(o, "_set_polygons", polygons)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationPolygon) AddOutline(outline *PoolVector2Array) {
	log.Println("Calling NavigationPolygon.AddOutline()")

	godotCallVoidPoolVector2Array(o, "add_outline", outline)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationPolygon) AddOutlineAtIndex(outline *PoolVector2Array, index int64) {
	log.Println("Calling NavigationPolygon.AddOutlineAtIndex()")

	godotCallVoidPoolVector2ArrayInt(o, "add_outline_at_index", outline, index)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationPolygon) AddPolygon(polygon *PoolIntArray) {
	log.Println("Calling NavigationPolygon.AddPolygon()")

	godotCallVoidPoolIntArray(o, "add_polygon", polygon)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationPolygon) ClearOutlines() {
	log.Println("Calling NavigationPolygon.ClearOutlines()")

	godotCallVoid(o, "clear_outlines")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationPolygon) ClearPolygons() {
	log.Println("Calling NavigationPolygon.ClearPolygons()")

	godotCallVoid(o, "clear_polygons")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationPolygon) GetOutline(idx int64) *PoolVector2Array {
	log.Println("Calling NavigationPolygon.GetOutline()")

	returnValue := godotCallPoolVector2ArrayInt(o, "get_outline", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) GetOutlineCount() int64 {
	log.Println("Calling NavigationPolygon.GetOutlineCount()")

	returnValue := godotCallInt(o, "get_outline_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) GetPolygon(idx int64) *PoolIntArray {
	log.Println("Calling NavigationPolygon.GetPolygon()")

	returnValue := godotCallPoolIntArrayInt(o, "get_polygon", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) GetPolygonCount() int64 {
	log.Println("Calling NavigationPolygon.GetPolygonCount()")

	returnValue := godotCallInt(o, "get_polygon_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) GetVertices() *PoolVector2Array {
	log.Println("Calling NavigationPolygon.GetVertices()")

	returnValue := godotCallPoolVector2Array(o, "get_vertices")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) MakePolygonsFromOutlines() {
	log.Println("Calling NavigationPolygon.MakePolygonsFromOutlines()")

	godotCallVoid(o, "make_polygons_from_outlines")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationPolygon) RemoveOutline(idx int64) {
	log.Println("Calling NavigationPolygon.RemoveOutline()")

	godotCallVoidInt(o, "remove_outline", idx)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationPolygon) SetOutline(idx int64, outline *PoolVector2Array) {
	log.Println("Calling NavigationPolygon.SetOutline()")

	godotCallVoidIntPoolVector2Array(o, "set_outline", idx, outline)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *NavigationPolygon) SetVertices(vertices *PoolVector2Array) {
	log.Println("Calling NavigationPolygon.SetVertices()")

	godotCallVoidPoolVector2Array(o, "set_vertices", vertices)
	log.Println("  Function successfully completed.")

}

/*
   NavigationPolygonImplementer is an interface for NavigationPolygon objects.
*/
type NavigationPolygonImplementer interface {
	Class
}

/*

 */
type NavigationPolygonInstance struct {
	Node2D
}

func (o *NavigationPolygonInstance) baseClass() string {
	return "NavigationPolygonInstance"
}

/*
   Undocumented
*/
func (o *NavigationPolygonInstance) X_NavpolyChanged() {
	log.Println("Calling NavigationPolygonInstance.X_NavpolyChanged()")

	godotCallVoid(o, "_navpoly_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationPolygonInstance) GetNavigationPolygon() *NavigationPolygon {
	log.Println("Calling NavigationPolygonInstance.GetNavigationPolygon()")

	returnValue := godotCallObject(o, "get_navigation_polygon")
	log.Println("  Got return value: ", returnValue)

	var ret NavigationPolygon
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *NavigationPolygonInstance) IsEnabled() bool {
	log.Println("Calling NavigationPolygonInstance.IsEnabled()")

	returnValue := godotCallBool(o, "is_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NavigationPolygonInstance) SetEnabled(enabled bool) {
	log.Println("Calling NavigationPolygonInstance.SetEnabled()")

	godotCallVoidBool(o, "set_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NavigationPolygonInstance) SetNavigationPolygon(navpoly *NavigationPolygon) {
	log.Println("Calling NavigationPolygonInstance.SetNavigationPolygon()")

	godotCallVoidObject(o, "set_navigation_polygon", &navpoly.Object)
	log.Println("  Function successfully completed.")

}

/*
   NavigationPolygonInstanceImplementer is an interface for NavigationPolygonInstance objects.
*/
type NavigationPolygonInstanceImplementer interface {
	Class
}

/*
   Undocumented
*/
type NetworkedMultiplayerENet struct {
	NetworkedMultiplayerPeer
}

func (o *NetworkedMultiplayerENet) baseClass() string {
	return "NetworkedMultiplayerENet"
}

/*
   Undocumented
*/
func (o *NetworkedMultiplayerENet) CloseConnection() {
	log.Println("Calling NetworkedMultiplayerENet.CloseConnection()")

	godotCallVoid(o, "close_connection")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NetworkedMultiplayerENet) CreateClient(ip string, port int64, inBandwidth int64, outBandwidth int64) int64 {
	log.Println("Calling NetworkedMultiplayerENet.CreateClient()")

	returnValue := godotCallIntStringIntIntInt(o, "create_client", ip, port, inBandwidth, outBandwidth)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NetworkedMultiplayerENet) CreateServer(port int64, maxClients int64, inBandwidth int64, outBandwidth int64) int64 {
	log.Println("Calling NetworkedMultiplayerENet.CreateServer()")

	returnValue := godotCallIntIntIntIntInt(o, "create_server", port, maxClients, inBandwidth, outBandwidth)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NetworkedMultiplayerENet) GetCompressionMode() int64 {
	log.Println("Calling NetworkedMultiplayerENet.GetCompressionMode()")

	returnValue := godotCallInt(o, "get_compression_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NetworkedMultiplayerENet) SetBindIp(ip string) {
	log.Println("Calling NetworkedMultiplayerENet.SetBindIp()")

	godotCallVoidString(o, "set_bind_ip", ip)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NetworkedMultiplayerENet) SetCompressionMode(mode int64) {
	log.Println("Calling NetworkedMultiplayerENet.SetCompressionMode()")

	godotCallVoidInt(o, "set_compression_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   NetworkedMultiplayerENetImplementer is an interface for NetworkedMultiplayerENet objects.
*/
type NetworkedMultiplayerENetImplementer interface {
	Class
}

/*
   Manages the connection to network peers. Assigns unique IDs to each client connected to the server.
*/
type NetworkedMultiplayerPeer struct {
	PacketPeer
}

func (o *NetworkedMultiplayerPeer) baseClass() string {
	return "NetworkedMultiplayerPeer"
}

/*
   Returns the current state of the connection. See [enum ConnectionStatus].
*/
func (o *NetworkedMultiplayerPeer) GetConnectionStatus() int64 {
	log.Println("Calling NetworkedMultiplayerPeer.GetConnectionStatus()")

	returnValue := godotCallInt(o, "get_connection_status")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the ID of the [code]NetworkedMultiplayerPeer[/code] who sent the most recent packet.
*/
func (o *NetworkedMultiplayerPeer) GetPacketPeer() int64 {
	log.Println("Calling NetworkedMultiplayerPeer.GetPacketPeer()")

	returnValue := godotCallInt(o, "get_packet_peer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NetworkedMultiplayerPeer) GetTransferMode() int64 {
	log.Println("Calling NetworkedMultiplayerPeer.GetTransferMode()")

	returnValue := godotCallInt(o, "get_transfer_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the ID of this [code]NetworkedMultiplayerPeer[/code].
*/
func (o *NetworkedMultiplayerPeer) GetUniqueId() int64 {
	log.Println("Calling NetworkedMultiplayerPeer.GetUniqueId()")

	returnValue := godotCallInt(o, "get_unique_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NetworkedMultiplayerPeer) IsRefusingNewConnections() bool {
	log.Println("Calling NetworkedMultiplayerPeer.IsRefusingNewConnections()")

	returnValue := godotCallBool(o, "is_refusing_new_connections")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Waits up to 1 second to receive a new network event.
*/
func (o *NetworkedMultiplayerPeer) Poll() {
	log.Println("Calling NetworkedMultiplayerPeer.Poll()")

	godotCallVoid(o, "poll")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NetworkedMultiplayerPeer) SetRefuseNewConnections(enable bool) {
	log.Println("Calling NetworkedMultiplayerPeer.SetRefuseNewConnections()")

	godotCallVoidBool(o, "set_refuse_new_connections", enable)
	log.Println("  Function successfully completed.")

}

/*
   The peer to which packets will be sent. Default value: [code]0[/code].
*/
func (o *NetworkedMultiplayerPeer) SetTargetPeer(id int64) {
	log.Println("Calling NetworkedMultiplayerPeer.SetTargetPeer()")

	godotCallVoidInt(o, "set_target_peer", id)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NetworkedMultiplayerPeer) SetTransferMode(mode int64) {
	log.Println("Calling NetworkedMultiplayerPeer.SetTransferMode()")

	godotCallVoidInt(o, "set_transfer_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   NetworkedMultiplayerPeerImplementer is an interface for NetworkedMultiplayerPeer objects.
*/
type NetworkedMultiplayerPeerImplementer interface {
	Class
}

/*
   Better known as 9-slice panels, NinePatchRect produces clean panels of any size, based on a small texture. To do so, it splits the texture in a 3 by 3 grid. When you scale the node, it tiles the texture's sides horizontally or vertically, the center on both axes but it doesn't scale or tile the corners.
*/
type NinePatchRect struct {
	Control
}

func (o *NinePatchRect) baseClass() string {
	return "NinePatchRect"
}

/*
   Undocumented
*/
func (o *NinePatchRect) GetHAxisStretchMode() int64 {
	log.Println("Calling NinePatchRect.GetHAxisStretchMode()")

	returnValue := godotCallInt(o, "get_h_axis_stretch_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NinePatchRect) GetPatchMargin(margin int64) int64 {
	log.Println("Calling NinePatchRect.GetPatchMargin()")

	returnValue := godotCallIntInt(o, "get_patch_margin", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NinePatchRect) GetRegionRect() *Rect2 {
	log.Println("Calling NinePatchRect.GetRegionRect()")

	returnValue := godotCallRect2(o, "get_region_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NinePatchRect) GetTexture() *Texture {
	log.Println("Calling NinePatchRect.GetTexture()")

	returnValue := godotCallObject(o, "get_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *NinePatchRect) GetVAxisStretchMode() int64 {
	log.Println("Calling NinePatchRect.GetVAxisStretchMode()")

	returnValue := godotCallInt(o, "get_v_axis_stretch_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NinePatchRect) IsDrawCenterEnabled() bool {
	log.Println("Calling NinePatchRect.IsDrawCenterEnabled()")

	returnValue := godotCallBool(o, "is_draw_center_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *NinePatchRect) SetDrawCenter(drawCenter bool) {
	log.Println("Calling NinePatchRect.SetDrawCenter()")

	godotCallVoidBool(o, "set_draw_center", drawCenter)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NinePatchRect) SetHAxisStretchMode(mode int64) {
	log.Println("Calling NinePatchRect.SetHAxisStretchMode()")

	godotCallVoidInt(o, "set_h_axis_stretch_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NinePatchRect) SetPatchMargin(margin int64, value int64) {
	log.Println("Calling NinePatchRect.SetPatchMargin()")

	godotCallVoidIntInt(o, "set_patch_margin", margin, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NinePatchRect) SetRegionRect(rect *Rect2) {
	log.Println("Calling NinePatchRect.SetRegionRect()")

	godotCallVoidRect2(o, "set_region_rect", rect)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NinePatchRect) SetTexture(texture *Texture) {
	log.Println("Calling NinePatchRect.SetTexture()")

	godotCallVoidObject(o, "set_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *NinePatchRect) SetVAxisStretchMode(mode int64) {
	log.Println("Calling NinePatchRect.SetVAxisStretchMode()")

	godotCallVoidInt(o, "set_v_axis_stretch_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   NinePatchRectImplementer is an interface for NinePatchRect objects.
*/
type NinePatchRectImplementer interface {
	Class
}

/*
   Nodes are Godot's building blocks. They can be assigned as the child of another node, resulting in a tree arrangement. A given node can contain any number of nodes as children with the requirement that all siblings (direct children of a node) should have unique names. A tree of nodes is called a [i]scene[/i]. Scenes can be saved to the disk and then instanced into other scenes. This allows for very high flexibility in the architecture and data model of Godot projects. Nodes can also optionally be added to groups. This makes it possible to access a number of nodes from code (an "enemies" group, for example) to perform grouped actions. [b]Scene tree:[/b] The [SceneTree] contains the active tree of nodes. When a node is added to the scene tree, it receives the NOTIFICATION_ENTER_TREE notification and its [method _enter_tree] callback is triggered. Child nodes are always added [i]after[/i] their parent node, i.e. the [method _enter_tree] callback of a parent node will be triggered before its child's. Once all nodes have been added in the scene tree, they receive the NOTIFICATION_READY notification and their respective [method _ready] callbacks are triggered. For groups of nodes, the [method _ready] callback is called in reverse order, starting with the children and moving up to the parent nodes. This means that when adding a node to the scene tree, the following order will be used for the callbacks: [method _enter_tree] of the parent, [method _enter_tree] of the children, [method _ready] of the children and finally [method _ready] of the parent (recursively for the entire scene tree). [b]Processing:[/b] Nodes can override the "process" state, so that they receive a callback on each frame requesting them to process (do something). Normal processing (callback [method _process], toggled with [method set_process]) happens as fast as possible and is dependent on the frame rate, so the processing time [i]delta[/i] is passed as an argument. Physics processing (callback [method _physics_process], toggled with [method set_physics_process]) happens a fixed number of times per second (60 by default) and is useful for code related to the physics engine. Nodes can also process input events. When present, the [method _input] function will be called for each input that the program receives. In many cases, this can be overkill (unless used for simple projects), and the [method _unhandled_input] function might be preferred; it is called when the input event was not handled by anyone else (typically, GUI [Control] nodes), ensuring that the node only receives the events that were meant for it. To keep track of the scene hierarchy (especially when instancing scenes into other scenes), an "owner" can be set for the node with [method set_owner]. This keeps track of who instanced what. This is mostly useful when writing editors and tools, though. Finally, when a node is freed with [method free] or [method queue_free], it will also free all its children. [b]Networking with nodes:[/b] After connecting to a server (or making one, see [NetworkedMultiplayerENet]) it is possible to use the built-in RPC (remote procedure call) system to communicate over the network. By calling [method rpc] with a method name, it will be called locally and in all connected peers (peers = clients and the server that accepts connections), with behaviour varying depending on the network mode ([method set_network_mode]) of the receiving peer. To identify which node receives the RPC call Godot will use its [NodePath] (make sure node names are the same on all peers).
*/
type Node struct {
	Object
}

func (o *Node) baseClass() string {
	return "Node"
}

/*
   Called when the node enters the [SceneTree] (e.g. upon instancing, scene changing, or after calling [method add_child] in a script). If the node has children, its [method _enter_tree] callback will be called first, and then that of the children. Corresponds to the NOTIFICATION_ENTER_TREE notification in [method Object._notification].
*/
func (o *Node) X_EnterTree() {
	log.Println("Calling Node.X_EnterTree()")

	godotCallVoid(o, "_enter_tree")
	log.Println("  Function successfully completed.")

}

/*
   Called when the node is about to leave the [SceneTree] (e.g. upon freeing, scene changing, or after calling [method remove_child] in a script). If the node has children, its [method _exit_tree] callback will be called last, after all its children have left the tree. Corresponds to the NOTIFICATION_EXIT_TREE notification in [method Object._notification] and signal [signal tree_exiting]. To get notified when the node has already left the active tree, connect to the [signal tree_exited]
*/
func (o *Node) X_ExitTree() {
	log.Println("Calling Node.X_ExitTree()")

	godotCallVoid(o, "_exit_tree")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node) X_GetImportPath() *NodePath {
	log.Println("Calling Node.X_GetImportPath()")

	returnValue := godotCallNodePath(o, "_get_import_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Called when there is an input event. The input event propagates through the node tree until a node consumes it. It is only called if input processing is enabled, which is done automatically if this method is overridden, and can be toggled with [method set_process_input].
*/
func (o *Node) X_Input(event *InputEvent) {
	log.Println("Calling Node.X_Input()")

	godotCallVoidObject(o, "_input", &event.Object)
	log.Println("  Function successfully completed.")

}

/*
   Called during the physics processing step of the main loop. Physics processing means that the frame rate is synced to the physics, i.e. the [code]delta[/code] variable should be constant. It is only called if physics processing is enabled, which is done automatically if this method is overridden, and can be toggled with [method set_physics_process]. Corresponds to the NOTIFICATION_PHYSICS_PROCESS notification in [method Object._notification].
*/
func (o *Node) X_PhysicsProcess(delta float64) {
	log.Println("Calling Node.X_PhysicsProcess()")

	godotCallVoidFloat(o, "_physics_process", delta)
	log.Println("  Function successfully completed.")

}

/*
   Called during the processing step of the main loop. Processing happens at every frame and as fast as possible, so the [code]delta[/code] time since the previous frame is not constant. It is only called if processing is enabled, which is done automatically if this method is overridden, and can be toggled with [method set_process]. Corresponds to the NOTIFICATION_PROCESS notification in [method Object._notification].
*/
func (o *Node) X_Process(delta float64) {
	log.Println("Calling Node.X_Process()")

	godotCallVoidFloat(o, "_process", delta)
	log.Println("  Function successfully completed.")

}

/*
   Called when the node is "ready", i.e. when both the node and its children have entered the scene tree. If the node has children, their [method _ready] callbacks get triggered first, and the parent node will receive the ready notification afterwards. Corresponds to the NOTIFICATION_READY notification in [method Object._notification].
*/
func (o *Node) X_Ready() {
	log.Println("Calling Node.X_Ready()")

	godotCallVoid(o, "_ready")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node) X_SetImportPath(importPath *NodePath) {
	log.Println("Calling Node.X_SetImportPath()")

	godotCallVoidNodePath(o, "_set_import_path", importPath)
	log.Println("  Function successfully completed.")

}

/*
   Propagated to all nodes when the previous InputEvent is not consumed by any nodes. It is only called if unhandled input processing is enabled, which is done automatically if this method is overridden, and can be toggled with [method set_process_unhandled_input].
*/
func (o *Node) X_UnhandledInput(event *InputEvent) {
	log.Println("Calling Node.X_UnhandledInput()")

	godotCallVoidObject(o, "_unhandled_input", &event.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Node) X_UnhandledKeyInput(event *InputEventKey) {
	log.Println("Calling Node.X_UnhandledKeyInput()")

	godotCallVoidObject(o, "_unhandled_key_input", &event.Object)
	log.Println("  Function successfully completed.")

}

/*
   Adds a child node. Nodes can have any number of children, but every child must have a unique name. Child nodes are automatically deleted when the parent node is deleted, so an entire scene can be removed by deleting its topmost node. Setting "legible_unique_name" [code]true[/code] creates child nodes with human-readable names, based on the name of the node being instanced instead of its type.
*/
func (o *Node) AddChild(node *Object, legibleUniqueName bool) {
	log.Println("Calling Node.AddChild()")

	godotCallVoidObjectBool(o, "add_child", node, legibleUniqueName)
	log.Println("  Function successfully completed.")

}

/*
   Adds a child node. The child is placed below the given node in the list of children. Setting "legible_unique_name" [code]true[/code] creates child nodes with human-readable names, based on the name of the node being instanced instead of its type.
*/
func (o *Node) AddChildBelowNode(node *Object, childNode *Object, legibleUniqueName bool) {
	log.Println("Calling Node.AddChildBelowNode()")

	godotCallVoidObjectObjectBool(o, "add_child_below_node", node, childNode, legibleUniqueName)
	log.Println("  Function successfully completed.")

}

/*
   Adds the node to a group. Groups are helpers to name and organize a subset of nodes, for example "enemies" or "collectables". A node can be in any number of groups. Nodes can be assigned a group at any time, but will not be added until they are inside the scene tree (see [method is_inside_tree]).
*/
func (o *Node) AddToGroup(group string, persistent bool) {
	log.Println("Calling Node.AddToGroup()")

	godotCallVoidStringBool(o, "add_to_group", group, persistent)
	log.Println("  Function successfully completed.")

}

/*
   Returns [code]true[/code] if the node can process while the scene tree is paused (see [method set_pause_mode]). Always returns [code]true[/code] if the scene tree is not paused, and [code]false[/code] if the node is not in the tree. FIXME: Why FAIL_COND?
*/
func (o *Node) CanProcess() bool {
	log.Println("Calling Node.CanProcess()")

	returnValue := godotCallBool(o, "can_process")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Duplicates the node, returning a new node. You can fine-tune the behavior using the [code]flags[/code]. See DUPLICATE_* constants.
*/
func (o *Node) Duplicate(flags int64) *Node {
	log.Println("Calling Node.Duplicate()")

	returnValue := godotCallObjectInt(o, "duplicate", flags)
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   Finds a descendant of this node whose name matches [code]mask[/code] as in [method String.match] (i.e. case sensitive, but '*' matches zero or more characters and '?' matches any single character except '.'). Note that it does not match against the full path, just against individual node names.
*/
func (o *Node) FindNode(mask string, recursive bool, owned bool) *Node {
	log.Println("Calling Node.FindNode()")

	returnValue := godotCallObjectStringBoolBool(o, "find_node", mask, recursive, owned)
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns a child node by its index (see [method get_child_count]). This method is often used for iterating all children of a node.
*/
func (o *Node) GetChild(idx int64) *Node {
	log.Println("Calling Node.GetChild()")

	returnValue := godotCallObjectInt(o, "get_child", idx)
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of child nodes.
*/
func (o *Node) GetChildCount() int64 {
	log.Println("Calling Node.GetChildCount()")

	returnValue := godotCallInt(o, "get_child_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an array of references to node's children.
*/
func (o *Node) GetChildren() *Array {
	log.Println("Calling Node.GetChildren()")

	returnValue := godotCallArray(o, "get_children")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node) GetFilename() string {
	log.Println("Calling Node.GetFilename()")

	returnValue := godotCallString(o, "get_filename")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an array listing the groups that the node is a member of.
*/
func (o *Node) GetGroups() *Array {
	log.Println("Calling Node.GetGroups()")

	returnValue := godotCallArray(o, "get_groups")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the node's index, i.e. its position among the siblings of its parent.
*/
func (o *Node) GetIndex() int64 {
	log.Println("Calling Node.GetIndex()")

	returnValue := godotCallInt(o, "get_index")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node) GetName() string {
	log.Println("Calling Node.GetName()")

	returnValue := godotCallString(o, "get_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the peer ID of the network master for this node.
*/
func (o *Node) GetNetworkMaster() int64 {
	log.Println("Calling Node.GetNetworkMaster()")

	returnValue := godotCallInt(o, "get_network_master")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Fetches a node. The [NodePath] can be either a relative path (from the current node) or an absolute path (in the scene tree) to a node. If the path does not exist, a [code]null instance[/code] is returned and attempts to access it will result in an "Attempt to call <method> on a null instance." error. Note: fetching absolute paths only works when the node is inside the scene tree (see [method is_inside_tree]). [i]Example:[/i] Assume your current node is Character and the following tree: [codeblock] /root /root/Character /root/Character/Sword /root/Character/Backpack/Dagger /root/MyGame /root/Swamp/Alligator /root/Swamp/Mosquito /root/Swamp/Goblin [/codeblock] Possible paths are: [codeblock] get_node("Sword") get_node("Backpack/Dagger") get_node("../Swamp/Alligator") get_node("/root/MyGame") [/codeblock]
*/
func (o *Node) GetNode(path *NodePath) *Node {
	log.Println("Calling Node.GetNode()")

	returnValue := godotCallObjectNodePath(o, "get_node", path)
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *Node) GetNodeAndResource(path *NodePath) *Array {
	log.Println("Calling Node.GetNodeAndResource()")

	returnValue := godotCallArrayNodePath(o, "get_node_and_resource", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node) GetOwner() *Node {
	log.Println("Calling Node.GetOwner()")

	returnValue := godotCallObject(o, "get_owner")
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the parent node of the current node, or an empty [code]Node[/code] if the node lacks a parent.
*/
func (o *Node) GetParent() *Node {
	log.Println("Calling Node.GetParent()")

	returnValue := godotCallObject(o, "get_parent")
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the absolute path of the current node. This only works if the current node is inside the scene tree (see [method is_inside_tree]).
*/
func (o *Node) GetPath() *NodePath {
	log.Println("Calling Node.GetPath()")

	returnValue := godotCallNodePath(o, "get_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the relative path from the current node to the specified node in "node" argument. Both nodes must be in the same scene, or the function will fail.
*/
func (o *Node) GetPathTo(node *Object) *NodePath {
	log.Println("Calling Node.GetPathTo()")

	returnValue := godotCallNodePathObject(o, "get_path_to", node)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node) GetPauseMode() int64 {
	log.Println("Calling Node.GetPauseMode()")

	returnValue := godotCallInt(o, "get_pause_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the time elapsed since the last physics-bound frame (see [method _physics_process]). This is always a constant value in physics processing unless the frames per second is changed in [OS].
*/
func (o *Node) GetPhysicsProcessDeltaTime() float64 {
	log.Println("Calling Node.GetPhysicsProcessDeltaTime()")

	returnValue := godotCallFloat(o, "get_physics_process_delta_time")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the node's order in the scene tree branch. For example, if called on the first child node the position is [code]0[/code].
*/
func (o *Node) GetPositionInParent() int64 {
	log.Println("Calling Node.GetPositionInParent()")

	returnValue := godotCallInt(o, "get_position_in_parent")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the time elapsed (in seconds) since the last process callback. This value may vary from frame to frame.
*/
func (o *Node) GetProcessDeltaTime() float64 {
	log.Println("Calling Node.GetProcessDeltaTime()")

	returnValue := godotCallFloat(o, "get_process_delta_time")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Node) GetSceneInstanceLoadPlaceholder() bool {
	log.Println("Calling Node.GetSceneInstanceLoadPlaceholder()")

	returnValue := godotCallBool(o, "get_scene_instance_load_placeholder")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [SceneTree] that contains this node.
*/
func (o *Node) GetTree() *SceneTree {
	log.Println("Calling Node.GetTree()")

	returnValue := godotCallObject(o, "get_tree")
	log.Println("  Got return value: ", returnValue)

	var ret SceneTree
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the node's [Viewport].
*/
func (o *Node) GetViewport() *Viewport {
	log.Println("Calling Node.GetViewport()")

	returnValue := godotCallObject(o, "get_viewport")
	log.Println("  Got return value: ", returnValue)

	var ret Viewport
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns [code]true[/code] if the node that the [NodePath] points to exists.
*/
func (o *Node) HasNode(path *NodePath) bool {
	log.Println("Calling Node.HasNode()")

	returnValue := godotCallBoolNodePath(o, "has_node", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Node) HasNodeAndResource(path *NodePath) bool {
	log.Println("Calling Node.HasNodeAndResource()")

	returnValue := godotCallBoolNodePath(o, "has_node_and_resource", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the given node is a direct or indirect child of the current node.
*/
func (o *Node) IsAParentOf(node *Object) bool {
	log.Println("Calling Node.IsAParentOf()")

	returnValue := godotCallBoolObject(o, "is_a_parent_of", node)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the node is folded (collapsed) in the Scene dock.
*/
func (o *Node) IsDisplayedFolded() bool {
	log.Println("Calling Node.IsDisplayedFolded()")

	returnValue := godotCallBool(o, "is_displayed_folded")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the given node occurs later in the scene hierarchy than the current node.
*/
func (o *Node) IsGreaterThan(node *Object) bool {
	log.Println("Calling Node.IsGreaterThan()")

	returnValue := godotCallBoolObject(o, "is_greater_than", node)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if this node is in the specified group.
*/
func (o *Node) IsInGroup(group string) bool {
	log.Println("Calling Node.IsInGroup()")

	returnValue := godotCallBoolString(o, "is_in_group", group)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if this node is currently inside a [SceneTree].
*/
func (o *Node) IsInsideTree() bool {
	log.Println("Calling Node.IsInsideTree()")

	returnValue := godotCallBool(o, "is_inside_tree")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Node) IsNetworkMaster() bool {
	log.Println("Calling Node.IsNetworkMaster()")

	returnValue := godotCallBool(o, "is_network_master")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if physics processing is enabled (see [method set_physics_process]).
*/
func (o *Node) IsPhysicsProcessing() bool {
	log.Println("Calling Node.IsPhysicsProcessing()")

	returnValue := godotCallBool(o, "is_physics_processing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Node) IsPhysicsProcessingInternal() bool {
	log.Println("Calling Node.IsPhysicsProcessingInternal()")

	returnValue := godotCallBool(o, "is_physics_processing_internal")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if processing is enabled (see [method set_process]).
*/
func (o *Node) IsProcessing() bool {
	log.Println("Calling Node.IsProcessing()")

	returnValue := godotCallBool(o, "is_processing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the node is processing input (see [method set_process_input]).
*/
func (o *Node) IsProcessingInput() bool {
	log.Println("Calling Node.IsProcessingInput()")

	returnValue := godotCallBool(o, "is_processing_input")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Node) IsProcessingInternal() bool {
	log.Println("Calling Node.IsProcessingInternal()")

	returnValue := godotCallBool(o, "is_processing_internal")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the node is processing unhandled input (see [method set_process_unhandled_input]).
*/
func (o *Node) IsProcessingUnhandledInput() bool {
	log.Println("Calling Node.IsProcessingUnhandledInput()")

	returnValue := godotCallBool(o, "is_processing_unhandled_input")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the node is processing unhandled key input (see [method set_process_unhandled_key_input]).
*/
func (o *Node) IsProcessingUnhandledKeyInput() bool {
	log.Println("Calling Node.IsProcessingUnhandledKeyInput()")

	returnValue := godotCallBool(o, "is_processing_unhandled_key_input")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Moves a child node to a different position (order) amongst the other children. Since calls, signals, etc are performed by tree order, changing the order of children nodes may be useful.
*/
func (o *Node) MoveChild(childNode *Object, toPosition int64) {
	log.Println("Calling Node.MoveChild()")

	godotCallVoidObjectInt(o, "move_child", childNode, toPosition)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Node) PrintStrayNodes() {
	log.Println("Calling Node.PrintStrayNodes()")

	godotCallVoid(o, "print_stray_nodes")
	log.Println("  Function successfully completed.")

}

/*
   Prints the scene to stdout. Used mainly for debugging purposes.
*/
func (o *Node) PrintTree() {
	log.Println("Calling Node.PrintTree()")

	godotCallVoid(o, "print_tree")
	log.Println("  Function successfully completed.")

}

/*
   Calls the given method (if present) with the arguments given in [code]args[/code] on this node and recursively on all its children. If the parent_first argument is [code]true[/code] then the method will be called on the current node first, then on all children. If it is [code]false[/code] then the children will be called first.
*/
func (o *Node) PropagateCall(method string, args *Array, parentFirst bool) {
	log.Println("Calling Node.PropagateCall()")

	godotCallVoidStringArrayBool(o, "propagate_call", method, args, parentFirst)
	log.Println("  Function successfully completed.")

}

/*
   Notifies the current node and all its children recursively by calling notification() on all of them.
*/
func (o *Node) PropagateNotification(what int64) {
	log.Println("Calling Node.PropagateNotification()")

	godotCallVoidInt(o, "propagate_notification", what)
	log.Println("  Function successfully completed.")

}

/*
   Queues a node for deletion at the end of the current frame. When deleted, all of its child nodes will be deleted as well. This method ensures it's safe to delete the node, contrary to [method Object.free]. Use [method Object.is_queued_for_deletion] to check whether a node will be deleted at the end of the frame.
*/
func (o *Node) QueueFree() {
	log.Println("Calling Node.QueueFree()")

	godotCallVoid(o, "queue_free")
	log.Println("  Function successfully completed.")

}

/*
   Moves this node to the top of the array of nodes of the parent node. This is often useful in GUIs ([Control] nodes), because their order of drawing depends on their order in the tree.
*/
func (o *Node) Raise() {
	log.Println("Calling Node.Raise()")

	godotCallVoid(o, "raise")
	log.Println("  Function successfully completed.")

}

/*
   Removes a node and sets all its children as children of the parent node (if it exists). All event subscriptions that pass by the removed node will be unsubscribed.
*/
func (o *Node) RemoveAndSkip() {
	log.Println("Calling Node.RemoveAndSkip()")

	godotCallVoid(o, "remove_and_skip")
	log.Println("  Function successfully completed.")

}

/*
   Removes a child node. The node is NOT deleted and must be deleted manually.
*/
func (o *Node) RemoveChild(node *Object) {
	log.Println("Calling Node.RemoveChild()")

	godotCallVoidObject(o, "remove_child", node)
	log.Println("  Function successfully completed.")

}

/*
   Removes a node from a group.
*/
func (o *Node) RemoveFromGroup(group string) {
	log.Println("Calling Node.RemoveFromGroup()")

	godotCallVoidString(o, "remove_from_group", group)
	log.Println("  Function successfully completed.")

}

/*
   Replaces a node in a scene by the given one. Subscriptions that pass through this node will be lost.
*/
func (o *Node) ReplaceBy(node *Object, keepData bool) {
	log.Println("Calling Node.ReplaceBy()")

	godotCallVoidObjectBool(o, "replace_by", node, keepData)
	log.Println("  Function successfully completed.")

}

/*
   Requests that [code]_ready[/code] be called again.
*/
func (o *Node) RequestReady() {
	log.Println("Calling Node.RequestReady()")

	godotCallVoid(o, "request_ready")
	log.Println("  Function successfully completed.")

}

/*
   Sends a remote procedure call request to all peers on the network (and locally), optionally sending additional data as arguments. Call request will be received by nodes with the same [NodePath].
*/
func (o *Node) Rpc(method string, varArgs ...interface{}) *Variant {
	log.Println("Calling Node.Rpc()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantStringVarargs(o, "rpc", method, varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Changes the method's RPC mode (one of RPC_MODE_* constants).
*/
func (o *Node) RpcConfig(method string, mode int64) {
	log.Println("Calling Node.RpcConfig()")

	godotCallVoidStringInt(o, "rpc_config", method, mode)
	log.Println("  Function successfully completed.")

}

/*
   Sends a [method rpc] to a specific peer identified by [i]peer_id[/i].
*/
func (o *Node) RpcId(peerId int64, method string, varArgs ...interface{}) *Variant {
	log.Println("Calling Node.RpcId()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantIntStringVarargs(o, "rpc_id", peerId, method, varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sends a [method rpc] using an unreliable protocol.
*/
func (o *Node) RpcUnreliable(method string, varArgs ...interface{}) *Variant {
	log.Println("Calling Node.RpcUnreliable()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantStringVarargs(o, "rpc_unreliable", method, varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sends a [method rpc] to a specific peer identified by [i]peer_id[/i] using an unreliable protocol.
*/
func (o *Node) RpcUnreliableId(peerId int64, method string, varArgs ...interface{}) *Variant {
	log.Println("Calling Node.RpcUnreliableId()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantIntStringVarargs(o, "rpc_unreliable_id", peerId, method, varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Remotely changes property's value on other peers (and locally).
*/
func (o *Node) Rset(property string, value *Variant) {
	log.Println("Calling Node.Rset()")

	godotCallVoidStringVariant(o, "rset", property, value)
	log.Println("  Function successfully completed.")

}

/*
   Changes the property's RPC mode (one of RPC_MODE_* constants).
*/
func (o *Node) RsetConfig(property string, mode int64) {
	log.Println("Calling Node.RsetConfig()")

	godotCallVoidStringInt(o, "rset_config", property, mode)
	log.Println("  Function successfully completed.")

}

/*
   Remotely changes property's value on a specific peer identified by [i]peer_id[/i].
*/
func (o *Node) RsetId(peerId int64, property string, value *Variant) {
	log.Println("Calling Node.RsetId()")

	godotCallVoidIntStringVariant(o, "rset_id", peerId, property, value)
	log.Println("  Function successfully completed.")

}

/*
   Remotely changes property's value on other peers (and locally) using an unreliable protocol.
*/
func (o *Node) RsetUnreliable(property string, value *Variant) {
	log.Println("Calling Node.RsetUnreliable()")

	godotCallVoidStringVariant(o, "rset_unreliable", property, value)
	log.Println("  Function successfully completed.")

}

/*
   Remotely changes property's value on a specific peer identified by [i]peer_id[/i] using an unreliable protocol.
*/
func (o *Node) RsetUnreliableId(peerId int64, property string, value *Variant) {
	log.Println("Calling Node.RsetUnreliableId()")

	godotCallVoidIntStringVariant(o, "rset_unreliable_id", peerId, property, value)
	log.Println("  Function successfully completed.")

}

/*
   Sets the folded state of the node in the Scene dock.
*/
func (o *Node) SetDisplayFolded(fold bool) {
	log.Println("Calling Node.SetDisplayFolded()")

	godotCallVoidBool(o, "set_display_folded", fold)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node) SetFilename(filename string) {
	log.Println("Calling Node.SetFilename()")

	godotCallVoidString(o, "set_filename", filename)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node) SetName(name string) {
	log.Println("Calling Node.SetName()")

	godotCallVoidString(o, "set_name", name)
	log.Println("  Function successfully completed.")

}

/*
   Sets the node network master to the peer with the given peer ID. The network master is the peer that has authority over it on the network. Inherited from the parent node by default, which ultimately defaults to peer ID 1 (the server).
*/
func (o *Node) SetNetworkMaster(id int64, recursive bool) {
	log.Println("Calling Node.SetNetworkMaster()")

	godotCallVoidIntBool(o, "set_network_master", id, recursive)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node) SetOwner(owner *Object) {
	log.Println("Calling Node.SetOwner()")

	godotCallVoidObject(o, "set_owner", owner)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node) SetPauseMode(mode int64) {
	log.Println("Calling Node.SetPauseMode()")

	godotCallVoidInt(o, "set_pause_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Enables or disables physics (i.e. fixed framerate) processing. When a node is being processed, it will receive a NOTIFICATION_PHYSICS_PROCESS at a fixed (usually 60 fps, see [OS] to change) interval (and the [method _physics_process] callback will be called if exists). Enabled automatically if [method _physics_process] is overridden. Any calls to this before [method _ready] will be ignored.
*/
func (o *Node) SetPhysicsProcess(enable bool) {
	log.Println("Calling Node.SetPhysicsProcess()")

	godotCallVoidBool(o, "set_physics_process", enable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Node) SetPhysicsProcessInternal(enable bool) {
	log.Println("Calling Node.SetPhysicsProcessInternal()")

	godotCallVoidBool(o, "set_physics_process_internal", enable)
	log.Println("  Function successfully completed.")

}

/*
   Enables or disables processing. When a node is being processed, it will receive a NOTIFICATION_PROCESS on every drawn frame (and the [method _process] callback will be called if exists). Enabled automatically if [method _process] is overridden. Any calls to this before [method _ready] will be ignored.
*/
func (o *Node) SetProcess(enable bool) {
	log.Println("Calling Node.SetProcess()")

	godotCallVoidBool(o, "set_process", enable)
	log.Println("  Function successfully completed.")

}

/*
   Enables or disables input processing. This is not required for GUI controls! Enabled automatically if [method _input] is overridden. Any calls to this before [method _ready] will be ignored.
*/
func (o *Node) SetProcessInput(enable bool) {
	log.Println("Calling Node.SetProcessInput()")

	godotCallVoidBool(o, "set_process_input", enable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Node) SetProcessInternal(enable bool) {
	log.Println("Calling Node.SetProcessInternal()")

	godotCallVoidBool(o, "set_process_internal", enable)
	log.Println("  Function successfully completed.")

}

/*
   Enables unhandled input processing. This is not required for GUI controls! It enables the node to receive all input that was not previously handled (usually by a [Control]). Enabled automatically if [method _unhandled_input] is overridden. Any calls to this before [method _ready] will be ignored.
*/
func (o *Node) SetProcessUnhandledInput(enable bool) {
	log.Println("Calling Node.SetProcessUnhandledInput()")

	godotCallVoidBool(o, "set_process_unhandled_input", enable)
	log.Println("  Function successfully completed.")

}

/*
   Enables unhandled key input processing. Enabled automatically if [method _unhandled_key_input] is overridden. Any calls to this before [method _ready] will be ignored.
*/
func (o *Node) SetProcessUnhandledKeyInput(enable bool) {
	log.Println("Calling Node.SetProcessUnhandledKeyInput()")

	godotCallVoidBool(o, "set_process_unhandled_key_input", enable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Node) SetSceneInstanceLoadPlaceholder(loadPlaceholder bool) {
	log.Println("Calling Node.SetSceneInstanceLoadPlaceholder()")

	godotCallVoidBool(o, "set_scene_instance_load_placeholder", loadPlaceholder)
	log.Println("  Function successfully completed.")

}

/*
   NodeImplementer is an interface for Node objects.
*/
type NodeImplementer interface {
	Class
}

/*
   A 2D game object, with a position, rotation and scale. All 2D physics nodes and sprites inherit from Node2D. Use Node2D as a parent node to move, scale and rotate children in a 2D project. Also gives control on the node's render order.
*/
type Node2D struct {
	CanvasItem
}

func (o *Node2D) baseClass() string {
	return "Node2D"
}

/*
   Multiplies the current scale by the 'ratio' vector.
*/
func (o *Node2D) ApplyScale(ratio *Vector2) {
	log.Println("Calling Node2D.ApplyScale()")

	godotCallVoidVector2(o, "apply_scale", ratio)
	log.Println("  Function successfully completed.")

}

/*
   Returns the angle between the node and the 'point' in radians.
*/
func (o *Node2D) GetAngleTo(point *Vector2) float64 {
	log.Println("Calling Node2D.GetAngleTo()")

	returnValue := godotCallFloatVector2(o, "get_angle_to", point)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node2D) GetGlobalPosition() *Vector2 {
	log.Println("Calling Node2D.GetGlobalPosition()")

	returnValue := godotCallVector2(o, "get_global_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node2D) GetGlobalRotation() float64 {
	log.Println("Calling Node2D.GetGlobalRotation()")

	returnValue := godotCallFloat(o, "get_global_rotation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node2D) GetGlobalRotationDegrees() float64 {
	log.Println("Calling Node2D.GetGlobalRotationDegrees()")

	returnValue := godotCallFloat(o, "get_global_rotation_degrees")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node2D) GetGlobalScale() *Vector2 {
	log.Println("Calling Node2D.GetGlobalScale()")

	returnValue := godotCallVector2(o, "get_global_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node2D) GetPosition() *Vector2 {
	log.Println("Calling Node2D.GetPosition()")

	returnValue := godotCallVector2(o, "get_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [Transform2D] relative to this node's parent.
*/
func (o *Node2D) GetRelativeTransformToParent(parent *Object) *Transform2D {
	log.Println("Calling Node2D.GetRelativeTransformToParent()")

	returnValue := godotCallTransform2DObject(o, "get_relative_transform_to_parent", parent)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node2D) GetRotation() float64 {
	log.Println("Calling Node2D.GetRotation()")

	returnValue := godotCallFloat(o, "get_rotation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node2D) GetRotationDegrees() float64 {
	log.Println("Calling Node2D.GetRotationDegrees()")

	returnValue := godotCallFloat(o, "get_rotation_degrees")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node2D) GetScale() *Vector2 {
	log.Println("Calling Node2D.GetScale()")

	returnValue := godotCallVector2(o, "get_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Node2D) GetZIndex() int64 {
	log.Println("Calling Node2D.GetZIndex()")

	returnValue := godotCallInt(o, "get_z_index")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Adds the 'offset' vector to the node's global position.
*/
func (o *Node2D) GlobalTranslate(offset *Vector2) {
	log.Println("Calling Node2D.GlobalTranslate()")

	godotCallVoidVector2(o, "global_translate", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) IsZRelative() bool {
	log.Println("Calling Node2D.IsZRelative()")

	returnValue := godotCallBool(o, "is_z_relative")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Rotates the node so it points towards the 'point'.
*/
func (o *Node2D) LookAt(point *Vector2) {
	log.Println("Calling Node2D.LookAt()")

	godotCallVoidVector2(o, "look_at", point)
	log.Println("  Function successfully completed.")

}

/*
   Applies a local translation on the node's X axis based on the [method Node._process]'s [code]delta[/code]. If [code]scaled[/code] is false, normalizes the movement.
*/
func (o *Node2D) MoveLocalX(delta float64, scaled bool) {
	log.Println("Calling Node2D.MoveLocalX()")

	godotCallVoidFloatBool(o, "move_local_x", delta, scaled)
	log.Println("  Function successfully completed.")

}

/*
   Applies a local translation on the node's Y axis based on the [method Node._process]'s [code]delta[/code]. If [code]scaled[/code] is false, normalizes the movement.
*/
func (o *Node2D) MoveLocalY(delta float64, scaled bool) {
	log.Println("Calling Node2D.MoveLocalY()")

	godotCallVoidFloatBool(o, "move_local_y", delta, scaled)
	log.Println("  Function successfully completed.")

}

/*
   Applies a rotation to the node, in radians, starting from its current rotation.
*/
func (o *Node2D) Rotate(radians float64) {
	log.Println("Calling Node2D.Rotate()")

	godotCallVoidFloat(o, "rotate", radians)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetGlobalPosition(position *Vector2) {
	log.Println("Calling Node2D.SetGlobalPosition()")

	godotCallVoidVector2(o, "set_global_position", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetGlobalRotation(radians float64) {
	log.Println("Calling Node2D.SetGlobalRotation()")

	godotCallVoidFloat(o, "set_global_rotation", radians)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetGlobalRotationDegrees(degrees float64) {
	log.Println("Calling Node2D.SetGlobalRotationDegrees()")

	godotCallVoidFloat(o, "set_global_rotation_degrees", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetGlobalScale(scale *Vector2) {
	log.Println("Calling Node2D.SetGlobalScale()")

	godotCallVoidVector2(o, "set_global_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetGlobalTransform(xform *Transform2D) {
	log.Println("Calling Node2D.SetGlobalTransform()")

	godotCallVoidTransform2D(o, "set_global_transform", xform)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetPosition(position *Vector2) {
	log.Println("Calling Node2D.SetPosition()")

	godotCallVoidVector2(o, "set_position", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetRotation(radians float64) {
	log.Println("Calling Node2D.SetRotation()")

	godotCallVoidFloat(o, "set_rotation", radians)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetRotationDegrees(degrees float64) {
	log.Println("Calling Node2D.SetRotationDegrees()")

	godotCallVoidFloat(o, "set_rotation_degrees", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetScale(scale *Vector2) {
	log.Println("Calling Node2D.SetScale()")

	godotCallVoidVector2(o, "set_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetTransform(xform *Transform2D) {
	log.Println("Calling Node2D.SetTransform()")

	godotCallVoidTransform2D(o, "set_transform", xform)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetZAsRelative(enable bool) {
	log.Println("Calling Node2D.SetZAsRelative()")

	godotCallVoidBool(o, "set_z_as_relative", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Node2D) SetZIndex(zIndex int64) {
	log.Println("Calling Node2D.SetZIndex()")

	godotCallVoidInt(o, "set_z_index", zIndex)
	log.Println("  Function successfully completed.")

}

/*
   Converts a local point's coordinates to global coordinates.
*/
func (o *Node2D) ToGlobal(localPoint *Vector2) *Vector2 {
	log.Println("Calling Node2D.ToGlobal()")

	returnValue := godotCallVector2Vector2(o, "to_global", localPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Converts a global point's coordinates to local coordinates.
*/
func (o *Node2D) ToLocal(globalPoint *Vector2) *Vector2 {
	log.Println("Calling Node2D.ToLocal()")

	returnValue := godotCallVector2Vector2(o, "to_local", globalPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Translates the node by the given [code]offset[/code] in local coordinates.
*/
func (o *Node2D) Translate(offset *Vector2) {
	log.Println("Calling Node2D.Translate()")

	godotCallVoidVector2(o, "translate", offset)
	log.Println("  Function successfully completed.")

}

/*
   Node2DImplementer is an interface for Node2D objects.
*/
type Node2DImplementer interface {
	Class
}

/*
   Base class for all non built-in types. Everything not a built-in type starts the inheritance chain from this class. Objects do not manage memory, if inheriting from one the object will most likely have to be deleted manually (call the [method free] function from the script or delete from C++). Some derivatives add memory management, such as [Reference] (which keeps a reference count and deletes itself automatically when no longer referenced) and [Node], which deletes the children tree when deleted. Objects export properties, which are mainly useful for storage and editing, but not really so much in programming. Properties are exported in [method _get_property_list] and handled in [method _get] and [method _set]. However, scripting languages and C++ have simpler means to export them. Objects also receive notifications ([method _notification]). Notifications are a simple way to notify the object about simple events, so they can all be handled together.
*/
type Object struct {
	owner *C.godot_object
}

func (o *Object) baseClass() string {
	return "Object"
}

/*
   Returns the given property. Returns [code]null[/code] if the [code]property[/code] does not exist.
*/
func (o *Object) X_Get(property string) {
	log.Println("Calling Object.X_Get()")

	godotCallVoidString(o, "_get", property)
	log.Println("  Function successfully completed.")

}

/*
   Returns the object's property list as an [Array] of dictionaries. Dictionaries must contain: name:String, type:int (see TYPE_* enum in [@GlobalScope]) and optionally: hint:int (see PROPERTY_HINT_* in [@GlobalScope]), hint_string:String, usage:int (see PROPERTY_USAGE_* in [@GlobalScope]).
*/
func (o *Object) X_GetPropertyList() *Array {
	log.Println("Calling Object.X_GetPropertyList()")

	returnValue := godotCallArray(o, "_get_property_list")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   The virtual method called upon initialization.
*/
func (o *Object) X_Init() {
	log.Println("Calling Object.X_Init()")

	godotCallVoid(o, "_init")
	log.Println("  Function successfully completed.")

}

/*
   Notify the object internally using an ID.
*/
func (o *Object) X_Notification(what int64) {
	log.Println("Calling Object.X_Notification()")

	godotCallVoidInt(o, "_notification", what)
	log.Println("  Function successfully completed.")

}

/*
   Sets a property. Returns [code]true[/code] if the [code]property[/code] exists.
*/
func (o *Object) X_Set(property string, value *Variant) bool {
	log.Println("Calling Object.X_Set()")

	returnValue := godotCallBoolStringVariant(o, "_set", property, value)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Adds a user-defined [code]signal[/code]. Arguments are optional, but can be added as an [Array] of dictionaries, each containing "name" and "type" (from [@GlobalScope] TYPE_*).
*/
func (o *Object) AddUserSignal(signal string, arguments *Array) {
	log.Println("Calling Object.AddUserSignal()")

	godotCallVoidStringArray(o, "add_user_signal", signal, arguments)
	log.Println("  Function successfully completed.")

}

/*
   Calls the [code]method[/code] on the object and returns a result. Pass parameters as a comma separated list.
*/
func (o *Object) Call(method string, varArgs ...interface{}) *Variant {
	log.Println("Calling Object.Call()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantStringVarargs(o, "call", method, varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Calls the [code]method[/code] on the object during idle time and returns a result. Pass parameters as a comma separated list.
*/
func (o *Object) CallDeferred(method string, varArgs ...interface{}) *Variant {
	log.Println("Calling Object.CallDeferred()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantStringVarargs(o, "call_deferred", method, varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Calls the [code]method[/code] on the object and returns a result. Pass parameters as an [Array].
*/
func (o *Object) Callv(method string, argArray *Array) *Variant {
	log.Println("Calling Object.Callv()")

	returnValue := godotCallVariantStringArray(o, "callv", method, argArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the object can translate strings.
*/
func (o *Object) CanTranslateMessages() bool {
	log.Println("Calling Object.CanTranslateMessages()")

	returnValue := godotCallBool(o, "can_translate_messages")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Connects a [code]signal[/code] to a [code]method[/code] on a [code]target[/code] object. Pass optional [code]binds[/code] to the call. Use [code]flags[/code] to set deferred or one shot connections. See [code]CONNECT_*[/code] constants. A [code]signal[/code] can only be connected once to a [code]method[/code]. It will throw an error if already connected. To avoid this, first use [method is_connected] to check for existing connections.
*/
func (o *Object) Connect(signal string, target *Object, method string, binds *Array, flags int64) int64 {
	log.Println("Calling Object.Connect()")

	returnValue := godotCallIntStringObjectStringArrayInt(o, "connect", signal, target, method, binds, flags)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Disconnects a [code]signal[/code] from a [code]method[/code] on the given [code]target[/code].
*/
func (o *Object) Disconnect(signal string, target *Object, method string) {
	log.Println("Calling Object.Disconnect()")

	godotCallVoidStringObjectString(o, "disconnect", signal, target, method)
	log.Println("  Function successfully completed.")

}

/*
   Emits the given [code]signal[/code].
*/
func (o *Object) EmitSignal(signal string, varArgs ...interface{}) *Variant {
	log.Println("Calling Object.EmitSignal()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantStringVarargs(o, "emit_signal", signal, varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Deletes the object from memory.
*/
func (o *Object) Free() {
	log.Println("Calling Object.Free()")

	godotCallVoid(o, "free")
	log.Println("  Function successfully completed.")

}

/*
   Returns a [Variant] for a [code]property[/code].
*/
func (o *Object) Get(property string) *Variant {
	log.Println("Calling Object.Get()")

	returnValue := godotCallVariantString(o, "get", property)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the object's class as a [String].
*/
func (o *Object) GetClass() string {
	log.Println("Calling Object.GetClass()")

	returnValue := godotCallString(o, "get_class")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an [Array] of dictionaries with information about signals that are connected to the object. Inside each [Dictionary] there are 3 fields: - "source" is a reference to signal emitter. - "signal_name" is name of connected signal. - "method_name" is a name of method to which signal is connected.
*/
func (o *Object) GetIncomingConnections() *Array {
	log.Println("Calling Object.GetIncomingConnections()")

	returnValue := godotCallArray(o, "get_incoming_connections")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Object) GetIndexed(property *NodePath) *Variant {
	log.Println("Calling Object.GetIndexed()")

	returnValue := godotCallVariantNodePath(o, "get_indexed", property)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the object's unique instance ID.
*/
func (o *Object) GetInstanceId() int64 {
	log.Println("Calling Object.GetInstanceId()")

	returnValue := godotCallInt(o, "get_instance_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the object's metadata for the given [code]name[/code].
*/
func (o *Object) GetMeta(name string) *Variant {
	log.Println("Calling Object.GetMeta()")

	returnValue := godotCallVariantString(o, "get_meta", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the object's metadata as a [PoolStringArray].
*/
func (o *Object) GetMetaList() *PoolStringArray {
	log.Println("Calling Object.GetMetaList()")

	returnValue := godotCallPoolStringArray(o, "get_meta_list")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the object's methods and their signatures as an [Array].
*/
func (o *Object) GetMethodList() *Array {
	log.Println("Calling Object.GetMethodList()")

	returnValue := godotCallArray(o, "get_method_list")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the list of properties as an [Array] of dictionaries. Dictionaries contain: name:String, type:int (see TYPE_* enum in [@GlobalScope]) and optionally: hint:int (see PROPERTY_HINT_* in [@GlobalScope]), hint_string:String, usage:int (see PROPERTY_USAGE_* in [@GlobalScope]).
*/
func (o *Object) GetPropertyList() *Array {
	log.Println("Calling Object.GetPropertyList()")

	returnValue := godotCallArray(o, "get_property_list")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the object's [Script] or [code]null[/code] if one doesn't exist.
*/
func (o *Object) GetScript() *Reference {
	log.Println("Calling Object.GetScript()")

	returnValue := godotCallObject(o, "get_script")
	log.Println("  Got return value: ", returnValue)

	var ret Reference
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns an [Array] of connections for the given [code]signal[/code].
*/
func (o *Object) GetSignalConnectionList(signal string) *Array {
	log.Println("Calling Object.GetSignalConnectionList()")

	returnValue := godotCallArrayString(o, "get_signal_connection_list", signal)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the list of signals as an [Array] of dictionaries.
*/
func (o *Object) GetSignalList() *Array {
	log.Println("Calling Object.GetSignalList()")

	returnValue := godotCallArray(o, "get_signal_list")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if a metadata is found with the given [code]name[/code].
*/
func (o *Object) HasMeta(name string) bool {
	log.Println("Calling Object.HasMeta()")

	returnValue := godotCallBoolString(o, "has_meta", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the object contains the given [code]method[/code].
*/
func (o *Object) HasMethod(method string) bool {
	log.Println("Calling Object.HasMethod()")

	returnValue := godotCallBoolString(o, "has_method", method)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the given user-defined [code]signal[/code] exists.
*/
func (o *Object) HasUserSignal(signal string) bool {
	log.Println("Calling Object.HasUserSignal()")

	returnValue := godotCallBoolString(o, "has_user_signal", signal)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if signal emission blocking is enabled.
*/
func (o *Object) IsBlockingSignals() bool {
	log.Println("Calling Object.IsBlockingSignals()")

	returnValue := godotCallBool(o, "is_blocking_signals")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the object inherits from the given [code]type[/code].
*/
func (o *Object) IsClass(aType string) bool {
	log.Println("Calling Object.IsClass()")

	returnValue := godotCallBoolString(o, "is_class", aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if a connection exists for a given [code]signal[/code], [code]target[/code], and [code]method[/code].
*/
func (o *Object) IsConnected(signal string, target *Object, method string) bool {
	log.Println("Calling Object.IsConnected()")

	returnValue := godotCallBoolStringObjectString(o, "is_connected", signal, target, method)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the [code]queue_free[/code] method was called for the object.
*/
func (o *Object) IsQueuedForDeletion() bool {
	log.Println("Calling Object.IsQueuedForDeletion()")

	returnValue := godotCallBool(o, "is_queued_for_deletion")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Notify the object of something.
*/
func (o *Object) Notification(what int64, reversed bool) {
	log.Println("Calling Object.Notification()")

	godotCallVoidIntBool(o, "notification", what, reversed)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Object) PropertyListChangedNotify() {
	log.Println("Calling Object.PropertyListChangedNotify()")

	godotCallVoid(o, "property_list_changed_notify")
	log.Println("  Function successfully completed.")

}

/*
   Set property into the object.
*/
func (o *Object) Set(property string, value *Variant) {
	log.Println("Calling Object.Set()")

	godotCallVoidStringVariant(o, "set", property, value)
	log.Println("  Function successfully completed.")

}

/*
   If set to true, signal emission is blocked.
*/
func (o *Object) SetBlockSignals(enable bool) {
	log.Println("Calling Object.SetBlockSignals()")

	godotCallVoidBool(o, "set_block_signals", enable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Object) SetIndexed(property *NodePath, value *Variant) {
	log.Println("Calling Object.SetIndexed()")

	godotCallVoidNodePathVariant(o, "set_indexed", property, value)
	log.Println("  Function successfully completed.")

}

/*
   Define whether the object can translate strings (with calls to [method tr]). Default is true.
*/
func (o *Object) SetMessageTranslation(enable bool) {
	log.Println("Calling Object.SetMessageTranslation()")

	godotCallVoidBool(o, "set_message_translation", enable)
	log.Println("  Function successfully completed.")

}

/*
   Set a metadata into the object. Metadata is serialized. Metadata can be [i]anything[/i].
*/
func (o *Object) SetMeta(name string, value *Variant) {
	log.Println("Calling Object.SetMeta()")

	godotCallVoidStringVariant(o, "set_meta", name, value)
	log.Println("  Function successfully completed.")

}

/*
   Set a script into the object, scripts extend the object functionality.
*/
func (o *Object) SetScript(script *Reference) {
	log.Println("Calling Object.SetScript()")

	godotCallVoidObject(o, "set_script", &script.Object)
	log.Println("  Function successfully completed.")

}

/*
   Translate a message. Only works if message translation is enabled (which it is by default). See [method set_message_translation].
*/
func (o *Object) Tr(message string) string {
	log.Println("Calling Object.Tr()")

	returnValue := godotCallStringString(o, "tr", message)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Object) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *Object) getOwner() *C.godot_object {
	return o.owner
}

/*
   ObjectImplementer is an interface for Object objects.
*/
type ObjectImplementer interface {
	Class
}

/*
   Editor facility that helps you draw a 2D polygon used as resource for [LightOccluder2D].
*/
type OccluderPolygon2D struct {
	Resource
}

func (o *OccluderPolygon2D) baseClass() string {
	return "OccluderPolygon2D"
}

/*
   Undocumented
*/
func (o *OccluderPolygon2D) GetCullMode() int64 {
	log.Println("Calling OccluderPolygon2D.GetCullMode()")

	returnValue := godotCallInt(o, "get_cull_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *OccluderPolygon2D) GetPolygon() *PoolVector2Array {
	log.Println("Calling OccluderPolygon2D.GetPolygon()")

	returnValue := godotCallPoolVector2Array(o, "get_polygon")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *OccluderPolygon2D) IsClosed() bool {
	log.Println("Calling OccluderPolygon2D.IsClosed()")

	returnValue := godotCallBool(o, "is_closed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *OccluderPolygon2D) SetClosed(closed bool) {
	log.Println("Calling OccluderPolygon2D.SetClosed()")

	godotCallVoidBool(o, "set_closed", closed)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *OccluderPolygon2D) SetCullMode(cullMode int64) {
	log.Println("Calling OccluderPolygon2D.SetCullMode()")

	godotCallVoidInt(o, "set_cull_mode", cullMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *OccluderPolygon2D) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling OccluderPolygon2D.SetPolygon()")

	godotCallVoidPoolVector2Array(o, "set_polygon", polygon)
	log.Println("  Function successfully completed.")

}

/*
   OccluderPolygon2DImplementer is an interface for OccluderPolygon2D objects.
*/
type OccluderPolygon2DImplementer interface {
	Class
}

/*
   An OmniDirectional light is a type of [Light] node that emits lights in all directions. The light is attenuated through the distance and this attenuation can be configured by changing the energy, radius and attenuation parameters of [Light].
*/
type OmniLight struct {
	Light
}

func (o *OmniLight) baseClass() string {
	return "OmniLight"
}

/*
   Undocumented
*/
func (o *OmniLight) GetShadowDetail() int64 {
	log.Println("Calling OmniLight.GetShadowDetail()")

	returnValue := godotCallInt(o, "get_shadow_detail")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *OmniLight) GetShadowMode() int64 {
	log.Println("Calling OmniLight.GetShadowMode()")

	returnValue := godotCallInt(o, "get_shadow_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *OmniLight) SetShadowDetail(detail int64) {
	log.Println("Calling OmniLight.SetShadowDetail()")

	godotCallVoidInt(o, "set_shadow_detail", detail)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *OmniLight) SetShadowMode(mode int64) {
	log.Println("Calling OmniLight.SetShadowMode()")

	godotCallVoidInt(o, "set_shadow_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   OmniLightImplementer is an interface for OmniLight objects.
*/
type OmniLightImplementer interface {
	Class
}

/*
   OptionButton is a type button that provides a selectable list of items when pressed. The item selected becomes the "current" item and is displayed as the button text.
*/
type OptionButton struct {
	Button
}

func (o *OptionButton) baseClass() string {
	return "OptionButton"
}

/*
   Undocumented
*/
func (o *OptionButton) X_GetItems() *Array {
	log.Println("Calling OptionButton.X_GetItems()")

	returnValue := godotCallArray(o, "_get_items")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *OptionButton) X_SelectInt(arg0 int64) {
	log.Println("Calling OptionButton.X_SelectInt()")

	godotCallVoidInt(o, "_select_int", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *OptionButton) X_Selected(arg0 int64) {
	log.Println("Calling OptionButton.X_Selected()")

	godotCallVoidInt(o, "_selected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *OptionButton) X_SetItems(arg0 *Array) {
	log.Println("Calling OptionButton.X_SetItems()")

	godotCallVoidArray(o, "_set_items", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Add an item, with a "texture" icon, text "label" and (optionally) id. If no "id" is passed, "id" becomes the item index. New items are appended at the end.
*/
func (o *OptionButton) AddIconItem(texture *Texture, label string, id int64) {
	log.Println("Calling OptionButton.AddIconItem()")

	godotCallVoidObjectStringInt(o, "add_icon_item", &texture.Object, label, id)
	log.Println("  Function successfully completed.")

}

/*
   Add an item, with text "label" and (optionally) id. If no "id" is passed, "id" becomes the item index. New items are appended at the end.
*/
func (o *OptionButton) AddItem(label string, id int64) {
	log.Println("Calling OptionButton.AddItem()")

	godotCallVoidStringInt(o, "add_item", label, id)
	log.Println("  Function successfully completed.")

}

/*
   Add a separator to the list of items. Separators help to group items. Separator also takes up an index and is appended at the end.
*/
func (o *OptionButton) AddSeparator() {
	log.Println("Calling OptionButton.AddSeparator()")

	godotCallVoid(o, "add_separator")
	log.Println("  Function successfully completed.")

}

/*
   Clear all the items in the [code]OptionButton[/code].
*/
func (o *OptionButton) Clear() {
	log.Println("Calling OptionButton.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Return the amount of items in the OptionButton.
*/
func (o *OptionButton) GetItemCount() int64 {
	log.Println("Calling OptionButton.GetItemCount()")

	returnValue := godotCallInt(o, "get_item_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the icon of the item at index "idx".
*/
func (o *OptionButton) GetItemIcon(idx int64) *Texture {
	log.Println("Calling OptionButton.GetItemIcon()")

	returnValue := godotCallObjectInt(o, "get_item_icon", idx)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the ID of the item at index "idx".
*/
func (o *OptionButton) GetItemId(idx int64) int64 {
	log.Println("Calling OptionButton.GetItemId()")

	returnValue := godotCallIntInt(o, "get_item_id", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *OptionButton) GetItemMetadata(idx int64) *Variant {
	log.Println("Calling OptionButton.GetItemMetadata()")

	returnValue := godotCallVariantInt(o, "get_item_metadata", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the text of the item at index "idx".
*/
func (o *OptionButton) GetItemText(idx int64) string {
	log.Println("Calling OptionButton.GetItemText()")

	returnValue := godotCallStringInt(o, "get_item_text", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the [PopupMenu] contained in this button.
*/
func (o *OptionButton) GetPopup() *PopupMenu {
	log.Println("Calling OptionButton.GetPopup()")

	returnValue := godotCallObject(o, "get_popup")
	log.Println("  Got return value: ", returnValue)

	var ret PopupMenu
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *OptionButton) GetSelected() int64 {
	log.Println("Calling OptionButton.GetSelected()")

	returnValue := godotCallInt(o, "get_selected")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *OptionButton) GetSelectedId() int64 {
	log.Println("Calling OptionButton.GetSelectedId()")

	returnValue := godotCallInt(o, "get_selected_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *OptionButton) GetSelectedMetadata() *Variant {
	log.Println("Calling OptionButton.GetSelectedMetadata()")

	returnValue := godotCallVariant(o, "get_selected_metadata")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *OptionButton) IsItemDisabled(idx int64) bool {
	log.Println("Calling OptionButton.IsItemDisabled()")

	returnValue := godotCallBoolInt(o, "is_item_disabled", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *OptionButton) RemoveItem(idx int64) {
	log.Println("Calling OptionButton.RemoveItem()")

	godotCallVoidInt(o, "remove_item", idx)
	log.Println("  Function successfully completed.")

}

/*
   Select an item by index and make it the current item.
*/
func (o *OptionButton) Select(idx int64) {
	log.Println("Calling OptionButton.Select()")

	godotCallVoidInt(o, "select", idx)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *OptionButton) SetItemDisabled(idx int64, disabled bool) {
	log.Println("Calling OptionButton.SetItemDisabled()")

	godotCallVoidIntBool(o, "set_item_disabled", idx, disabled)
	log.Println("  Function successfully completed.")

}

/*
   Set the icon of an item at index "idx".
*/
func (o *OptionButton) SetItemIcon(idx int64, texture *Texture) {
	log.Println("Calling OptionButton.SetItemIcon()")

	godotCallVoidIntObject(o, "set_item_icon", idx, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Set the ID of an item at index "idx".
*/
func (o *OptionButton) SetItemId(idx int64, id int64) {
	log.Println("Calling OptionButton.SetItemId()")

	godotCallVoidIntInt(o, "set_item_id", idx, id)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *OptionButton) SetItemMetadata(idx int64, metadata *Variant) {
	log.Println("Calling OptionButton.SetItemMetadata()")

	godotCallVoidIntVariant(o, "set_item_metadata", idx, metadata)
	log.Println("  Function successfully completed.")

}

/*
   Set the text of an item at index "idx".
*/
func (o *OptionButton) SetItemText(idx int64, text string) {
	log.Println("Calling OptionButton.SetItemText()")

	godotCallVoidIntString(o, "set_item_text", idx, text)
	log.Println("  Function successfully completed.")

}

/*
   OptionButtonImplementer is an interface for OptionButton objects.
*/
type OptionButtonImplementer interface {
	Class
}

/*

 */
type PCKPacker struct {
	Reference
}

func (o *PCKPacker) baseClass() string {
	return "PCKPacker"
}

/*

 */
func (o *PCKPacker) AddFile(pckPath string, sourcePath string) int64 {
	log.Println("Calling PCKPacker.AddFile()")

	returnValue := godotCallIntStringString(o, "add_file", pckPath, sourcePath)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PCKPacker) Flush(verbose bool) int64 {
	log.Println("Calling PCKPacker.Flush()")

	returnValue := godotCallIntBool(o, "flush", verbose)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PCKPacker) PckStart(pckName string, alignment int64) int64 {
	log.Println("Calling PCKPacker.PckStart()")

	returnValue := godotCallIntStringInt(o, "pck_start", pckName, alignment)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   PCKPackerImplementer is an interface for PCKPacker objects.
*/
type PCKPackerImplementer interface {
	Class
}

/*
   Optimized translation. Uses real-time compressed translations, which results in very small dictionaries.
*/
type PHashTranslation struct {
	Translation
}

func (o *PHashTranslation) baseClass() string {
	return "PHashTranslation"
}

/*

 */
func (o *PHashTranslation) Generate(from *Translation) {
	log.Println("Calling PHashTranslation.Generate()")

	godotCallVoidObject(o, "generate", &from.Object)
	log.Println("  Function successfully completed.")

}

/*
   PHashTranslationImplementer is an interface for PHashTranslation objects.
*/
type PHashTranslationImplementer interface {
	Class
}

/*

 */
type PackedDataContainer struct {
	Resource
}

func (o *PackedDataContainer) baseClass() string {
	return "PackedDataContainer"
}

/*
   Undocumented
*/
func (o *PackedDataContainer) X_GetData() *PoolByteArray {
	log.Println("Calling PackedDataContainer.X_GetData()")

	returnValue := godotCallPoolByteArray(o, "_get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainer) X_IterGet(arg0 *Variant) *Variant {
	log.Println("Calling PackedDataContainer.X_IterGet()")

	returnValue := godotCallVariantVariant(o, "_iter_get", arg0)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainer) X_IterInit(arg0 *Array) *Variant {
	log.Println("Calling PackedDataContainer.X_IterInit()")

	returnValue := godotCallVariantArray(o, "_iter_init", arg0)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainer) X_IterNext(arg0 *Array) *Variant {
	log.Println("Calling PackedDataContainer.X_IterNext()")

	returnValue := godotCallVariantArray(o, "_iter_next", arg0)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainer) X_SetData(arg0 *PoolByteArray) {
	log.Println("Calling PackedDataContainer.X_SetData()")

	godotCallVoidPoolByteArray(o, "_set_data", arg0)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PackedDataContainer) Pack(value *Variant) int64 {
	log.Println("Calling PackedDataContainer.Pack()")

	returnValue := godotCallIntVariant(o, "pack", value)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PackedDataContainer) Size() int64 {
	log.Println("Calling PackedDataContainer.Size()")

	returnValue := godotCallInt(o, "size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   PackedDataContainerImplementer is an interface for PackedDataContainer objects.
*/
type PackedDataContainerImplementer interface {
	Class
}

/*

 */
type PackedDataContainerRef struct {
	Reference
}

func (o *PackedDataContainerRef) baseClass() string {
	return "PackedDataContainerRef"
}

/*
   Undocumented
*/
func (o *PackedDataContainerRef) X_IsDictionary() bool {
	log.Println("Calling PackedDataContainerRef.X_IsDictionary()")

	returnValue := godotCallBool(o, "_is_dictionary")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainerRef) X_IterGet(arg0 *Variant) *Variant {
	log.Println("Calling PackedDataContainerRef.X_IterGet()")

	returnValue := godotCallVariantVariant(o, "_iter_get", arg0)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainerRef) X_IterInit(arg0 *Array) *Variant {
	log.Println("Calling PackedDataContainerRef.X_IterInit()")

	returnValue := godotCallVariantArray(o, "_iter_init", arg0)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedDataContainerRef) X_IterNext(arg0 *Array) *Variant {
	log.Println("Calling PackedDataContainerRef.X_IterNext()")

	returnValue := godotCallVariantArray(o, "_iter_next", arg0)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PackedDataContainerRef) Size() int64 {
	log.Println("Calling PackedDataContainerRef.Size()")

	returnValue := godotCallInt(o, "size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   PackedDataContainerRefImplementer is an interface for PackedDataContainerRef objects.
*/
type PackedDataContainerRefImplementer interface {
	Class
}

/*
   A simplified interface to a scene file. Provides access to operations and checks that can be performed on the scene resource itself. TODO: explain ownership, and that node does not need to own itself
*/
type PackedScene struct {
	Resource
}

func (o *PackedScene) baseClass() string {
	return "PackedScene"
}

/*
   Undocumented
*/
func (o *PackedScene) X_GetBundledScene() *Dictionary {
	log.Println("Calling PackedScene.X_GetBundledScene()")

	returnValue := godotCallDictionary(o, "_get_bundled_scene")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PackedScene) X_SetBundledScene(arg0 *Dictionary) {
	log.Println("Calling PackedScene.X_SetBundledScene()")

	godotCallVoidDictionary(o, "_set_bundled_scene", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Returns [code]true[/code] if the scene file has nodes.
*/
func (o *PackedScene) CanInstance() bool {
	log.Println("Calling PackedScene.CanInstance()")

	returnValue := godotCallBool(o, "can_instance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [code]SceneState[/code] representing the scene file contents.
*/
func (o *PackedScene) GetState() *SceneState {
	log.Println("Calling PackedScene.GetState()")

	returnValue := godotCallObject(o, "get_state")
	log.Println("  Got return value: ", returnValue)

	var ret SceneState
	ret.owner = returnValue.owner
	return &ret

}

/*
   Instantiates the scene's node hierarchy. Triggers child scene instantiation(s). Triggers the [enum Object.NOTIFICATION_INSTANCED] notification on the root node.
*/
func (o *PackedScene) Instance(editState int64) *Node {
	log.Println("Calling PackedScene.Instance()")

	returnValue := godotCallObjectInt(o, "instance", editState)
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   Pack will ignore any sub-nodes not owned by given node. See [method Node.set_owner].
*/
func (o *PackedScene) Pack(path *Object) int64 {
	log.Println("Calling PackedScene.Pack()")

	returnValue := godotCallIntObject(o, "pack", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   PackedSceneImplementer is an interface for PackedScene objects.
*/
type PackedSceneImplementer interface {
	Class
}

/*
   PacketPeer is an abstraction and base class for packet-based protocols (such as UDP). It provides an API for sending and receiving packets both as raw data or variables. This makes it easy to transfer data over a protocol, without having to encode data as low level bytes or having to worry about network ordering.
*/
type PacketPeer struct {
	Reference
}

func (o *PacketPeer) baseClass() string {
	return "PacketPeer"
}

/*
   Return the number of packets currently available in the ring-buffer.
*/
func (o *PacketPeer) GetAvailablePacketCount() int64 {
	log.Println("Calling PacketPeer.GetAvailablePacketCount()")

	returnValue := godotCallInt(o, "get_available_packet_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get a raw packet.
*/
func (o *PacketPeer) GetPacket() *PoolByteArray {
	log.Println("Calling PacketPeer.GetPacket()")

	returnValue := godotCallPoolByteArray(o, "get_packet")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the error state of the last packet received (via [method get_packet] and [method get_var]).
*/
func (o *PacketPeer) GetPacketError() int64 {
	log.Println("Calling PacketPeer.GetPacketError()")

	returnValue := godotCallInt(o, "get_packet_error")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get a Variant.
*/
func (o *PacketPeer) GetVar() *Variant {
	log.Println("Calling PacketPeer.GetVar()")

	returnValue := godotCallVariant(o, "get_var")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PacketPeer) IsObjectDecodingAllowed() bool {
	log.Println("Calling PacketPeer.IsObjectDecodingAllowed()")

	returnValue := godotCallBool(o, "is_object_decoding_allowed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Send a raw packet.
*/
func (o *PacketPeer) PutPacket(buffer *PoolByteArray) int64 {
	log.Println("Calling PacketPeer.PutPacket()")

	returnValue := godotCallIntPoolByteArray(o, "put_packet", buffer)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Send a Variant as a packet.
*/
func (o *PacketPeer) PutVar(variable *Variant) int64 {
	log.Println("Calling PacketPeer.PutVar()")

	returnValue := godotCallIntVariant(o, "put_var", variable)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PacketPeer) SetAllowObjectDecoding(enable bool) {
	log.Println("Calling PacketPeer.SetAllowObjectDecoding()")

	godotCallVoidBool(o, "set_allow_object_decoding", enable)
	log.Println("  Function successfully completed.")

}

/*
   PacketPeerImplementer is an interface for PacketPeer objects.
*/
type PacketPeerImplementer interface {
	Class
}

/*
   PacketStreamPeer provides a wrapper for working using packets over a stream. This allows for using packet based code with StreamPeers. PacketPeerStream implements a custom protocol over the StreamPeer, so the user should not read or write to the wrapped StreamPeer directly.
*/
type PacketPeerStream struct {
	PacketPeer
}

func (o *PacketPeerStream) baseClass() string {
	return "PacketPeerStream"
}

/*
   Undocumented
*/
func (o *PacketPeerStream) GetInputBufferMaxSize() int64 {
	log.Println("Calling PacketPeerStream.GetInputBufferMaxSize()")

	returnValue := godotCallInt(o, "get_input_buffer_max_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PacketPeerStream) GetOutputBufferMaxSize() int64 {
	log.Println("Calling PacketPeerStream.GetOutputBufferMaxSize()")

	returnValue := godotCallInt(o, "get_output_buffer_max_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PacketPeerStream) GetStreamPeer() *StreamPeer {
	log.Println("Calling PacketPeerStream.GetStreamPeer()")

	returnValue := godotCallObject(o, "get_stream_peer")
	log.Println("  Got return value: ", returnValue)

	var ret StreamPeer
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *PacketPeerStream) SetInputBufferMaxSize(maxSizeBytes int64) {
	log.Println("Calling PacketPeerStream.SetInputBufferMaxSize()")

	godotCallVoidInt(o, "set_input_buffer_max_size", maxSizeBytes)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PacketPeerStream) SetOutputBufferMaxSize(maxSizeBytes int64) {
	log.Println("Calling PacketPeerStream.SetOutputBufferMaxSize()")

	godotCallVoidInt(o, "set_output_buffer_max_size", maxSizeBytes)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PacketPeerStream) SetStreamPeer(peer *StreamPeer) {
	log.Println("Calling PacketPeerStream.SetStreamPeer()")

	godotCallVoidObject(o, "set_stream_peer", &peer.Object)
	log.Println("  Function successfully completed.")

}

/*
   PacketPeerStreamImplementer is an interface for PacketPeerStream objects.
*/
type PacketPeerStreamImplementer interface {
	Class
}

/*
   UDP packet peer. Can be used to send raw UDP packets as well as [Variant]s.
*/
type PacketPeerUDP struct {
	PacketPeer
}

func (o *PacketPeerUDP) baseClass() string {
	return "PacketPeerUDP"
}

/*
   Close the UDP socket the [code]PacketPeerUDP[/code] is currently listening on.
*/
func (o *PacketPeerUDP) Close() {
	log.Println("Calling PacketPeerUDP.Close()")

	godotCallVoid(o, "close")
	log.Println("  Function successfully completed.")

}

/*
   Return the IP of the remote peer that sent the last packet(that was received with [method get_packet] or [method get_var]).
*/
func (o *PacketPeerUDP) GetPacketIp() string {
	log.Println("Calling PacketPeerUDP.GetPacketIp()")

	returnValue := godotCallString(o, "get_packet_ip")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the port of the remote peer that sent the last packet(that was received with [method get_packet] or [method get_var]).
*/
func (o *PacketPeerUDP) GetPacketPort() int64 {
	log.Println("Calling PacketPeerUDP.GetPacketPort()")

	returnValue := godotCallInt(o, "get_packet_port")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return whether this [code]PacketPeerUDP[/code] is listening.
*/
func (o *PacketPeerUDP) IsListening() bool {
	log.Println("Calling PacketPeerUDP.IsListening()")

	returnValue := godotCallBool(o, "is_listening")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Make this [code]PacketPeerUDP[/code] listen on the "port" binding to "bind_address" with a buffer size "recv_buf_size". If "bind_address" is set as "*" (default), the peer will listen on all available addresses (both IPv4 and IPv6). If "bind_address" is set as "0.0.0.0" (for IPv4) or "::" (for IPv6), the peer will listen on all available addresses matching that IP type. If "bind_address" is set to any valid address (e.g. "192.168.1.101", "::1", etc), the peer will only listen on the interface with that addresses (or fail if no interface with the given address exists).
*/
func (o *PacketPeerUDP) Listen(port int64, bindAddress string, recvBufSize int64) int64 {
	log.Println("Calling PacketPeerUDP.Listen()")

	returnValue := godotCallIntIntStringInt(o, "listen", port, bindAddress, recvBufSize)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Set the destination address and port for sending packets and variables, a hostname will be resolved using if valid.
*/
func (o *PacketPeerUDP) SetDestAddress(host string, port int64) int64 {
	log.Println("Calling PacketPeerUDP.SetDestAddress()")

	returnValue := godotCallIntStringInt(o, "set_dest_address", host, port)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Wait for a packet to arrive on the listening port, see [method listen].
*/
func (o *PacketPeerUDP) Wait() int64 {
	log.Println("Calling PacketPeerUDP.Wait()")

	returnValue := godotCallInt(o, "wait")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   PacketPeerUDPImplementer is an interface for PacketPeerUDP objects.
*/
type PacketPeerUDPImplementer interface {
	Class
}

/*
   Panel is a [Control] that displays an opaque background. It's commonly used as a parent and container for other types of [Control] nodes.
*/
type Panel struct {
	Control
}

func (o *Panel) baseClass() string {
	return "Panel"
}

/*
   PanelImplementer is an interface for Panel objects.
*/
type PanelImplementer interface {
	Class
}

/*
   Panel container type. This container fits controls inside of the delimited area of a stylebox. It's useful for giving controls an outline.
*/
type PanelContainer struct {
	Container
}

func (o *PanelContainer) baseClass() string {
	return "PanelContainer"
}

/*
   PanelContainerImplementer is an interface for PanelContainer objects.
*/
type PanelContainerImplementer interface {
	Class
}

/*

 */
type PanoramaSky struct {
	Sky
}

func (o *PanoramaSky) baseClass() string {
	return "PanoramaSky"
}

/*
   Undocumented
*/
func (o *PanoramaSky) GetPanorama() *Texture {
	log.Println("Calling PanoramaSky.GetPanorama()")

	returnValue := godotCallObject(o, "get_panorama")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *PanoramaSky) SetPanorama(texture *Texture) {
	log.Println("Calling PanoramaSky.SetPanorama()")

	godotCallVoidObject(o, "set_panorama", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   PanoramaSkyImplementer is an interface for PanoramaSky objects.
*/
type PanoramaSkyImplementer interface {
	Class
}

/*
   A ParallaxBackground uses one or more [ParallaxLayer] child nodes to create a parallax effect. Each [ParallaxLayer] can move at a different speed using [member ParallaxLayer.motion_offset]. This creates an illusion of depth in a 2D game. If not used with a [Camera2D], you must manually calculate the [member scroll_offset].
*/
type ParallaxBackground struct {
	CanvasLayer
}

func (o *ParallaxBackground) baseClass() string {
	return "ParallaxBackground"
}

/*
   Undocumented
*/
func (o *ParallaxBackground) X_CameraMoved(arg0 *Transform2D, arg1 *Vector2) {
	log.Println("Calling ParallaxBackground.X_CameraMoved()")

	godotCallVoidTransform2DVector2(o, "_camera_moved", arg0, arg1)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParallaxBackground) GetLimitBegin() *Vector2 {
	log.Println("Calling ParallaxBackground.GetLimitBegin()")

	returnValue := godotCallVector2(o, "get_limit_begin")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParallaxBackground) GetLimitEnd() *Vector2 {
	log.Println("Calling ParallaxBackground.GetLimitEnd()")

	returnValue := godotCallVector2(o, "get_limit_end")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParallaxBackground) GetScrollBaseOffset() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollBaseOffset()")

	returnValue := godotCallVector2(o, "get_scroll_base_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParallaxBackground) GetScrollBaseScale() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollBaseScale()")

	returnValue := godotCallVector2(o, "get_scroll_base_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParallaxBackground) GetScrollOffset() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollOffset()")

	returnValue := godotCallVector2(o, "get_scroll_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParallaxBackground) IsIgnoreCameraZoom() bool {
	log.Println("Calling ParallaxBackground.IsIgnoreCameraZoom()")

	returnValue := godotCallBool(o, "is_ignore_camera_zoom")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParallaxBackground) SetIgnoreCameraZoom(ignore bool) {
	log.Println("Calling ParallaxBackground.SetIgnoreCameraZoom()")

	godotCallVoidBool(o, "set_ignore_camera_zoom", ignore)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParallaxBackground) SetLimitBegin(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetLimitBegin()")

	godotCallVoidVector2(o, "set_limit_begin", ofs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParallaxBackground) SetLimitEnd(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetLimitEnd()")

	godotCallVoidVector2(o, "set_limit_end", ofs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParallaxBackground) SetScrollBaseOffset(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollBaseOffset()")

	godotCallVoidVector2(o, "set_scroll_base_offset", ofs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParallaxBackground) SetScrollBaseScale(scale *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollBaseScale()")

	godotCallVoidVector2(o, "set_scroll_base_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParallaxBackground) SetScrollOffset(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollOffset()")

	godotCallVoidVector2(o, "set_scroll_offset", ofs)
	log.Println("  Function successfully completed.")

}

/*
   ParallaxBackgroundImplementer is an interface for ParallaxBackground objects.
*/
type ParallaxBackgroundImplementer interface {
	Class
}

/*
   A ParallaxLayer must be the child of a [ParallaxBackground] node. Each ParallaxLayer can be set to move at different speeds relative to the camera movement or the [member ParallaxBackground.scroll_offset] value. This node's children will be affected by its scroll offset.
*/
type ParallaxLayer struct {
	Node2D
}

func (o *ParallaxLayer) baseClass() string {
	return "ParallaxLayer"
}

/*
   Undocumented
*/
func (o *ParallaxLayer) GetMirroring() *Vector2 {
	log.Println("Calling ParallaxLayer.GetMirroring()")

	returnValue := godotCallVector2(o, "get_mirroring")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParallaxLayer) GetMotionOffset() *Vector2 {
	log.Println("Calling ParallaxLayer.GetMotionOffset()")

	returnValue := godotCallVector2(o, "get_motion_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParallaxLayer) GetMotionScale() *Vector2 {
	log.Println("Calling ParallaxLayer.GetMotionScale()")

	returnValue := godotCallVector2(o, "get_motion_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParallaxLayer) SetMirroring(mirror *Vector2) {
	log.Println("Calling ParallaxLayer.SetMirroring()")

	godotCallVoidVector2(o, "set_mirroring", mirror)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParallaxLayer) SetMotionOffset(offset *Vector2) {
	log.Println("Calling ParallaxLayer.SetMotionOffset()")

	godotCallVoidVector2(o, "set_motion_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParallaxLayer) SetMotionScale(scale *Vector2) {
	log.Println("Calling ParallaxLayer.SetMotionScale()")

	godotCallVoidVector2(o, "set_motion_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   ParallaxLayerImplementer is an interface for ParallaxLayer objects.
*/
type ParallaxLayerImplementer interface {
	Class
}

/*
   3D particle node used to create a variety of particle systems and effects. [code]Particles[/code] features an emitter that generates some number of particles at a given rate. Use the [code]process_material[/code] property to add a [ParticlesMaterial] to configure particle appearance and behavior. Alternatively, you can add a [ShaderMaterial] which will be applied to all particles.
*/
type Particles struct {
	GeometryInstance
}

func (o *Particles) baseClass() string {
	return "Particles"
}

/*

 */
func (o *Particles) CaptureAabb() *AABB {
	log.Println("Calling Particles.CaptureAabb()")

	returnValue := godotCallAabb(o, "capture_aabb")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetAmount() int64 {
	log.Println("Calling Particles.GetAmount()")

	returnValue := godotCallInt(o, "get_amount")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetDrawOrder() int64 {
	log.Println("Calling Particles.GetDrawOrder()")

	returnValue := godotCallInt(o, "get_draw_order")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetDrawPassMesh(pass int64) *Mesh {
	log.Println("Calling Particles.GetDrawPassMesh()")

	returnValue := godotCallObjectInt(o, "get_draw_pass_mesh", pass)
	log.Println("  Got return value: ", returnValue)

	var ret Mesh
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Particles) GetDrawPasses() int64 {
	log.Println("Calling Particles.GetDrawPasses()")

	returnValue := godotCallInt(o, "get_draw_passes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetExplosivenessRatio() float64 {
	log.Println("Calling Particles.GetExplosivenessRatio()")

	returnValue := godotCallFloat(o, "get_explosiveness_ratio")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetFixedFps() int64 {
	log.Println("Calling Particles.GetFixedFps()")

	returnValue := godotCallInt(o, "get_fixed_fps")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetFractionalDelta() bool {
	log.Println("Calling Particles.GetFractionalDelta()")

	returnValue := godotCallBool(o, "get_fractional_delta")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetLifetime() float64 {
	log.Println("Calling Particles.GetLifetime()")

	returnValue := godotCallFloat(o, "get_lifetime")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetOneShot() bool {
	log.Println("Calling Particles.GetOneShot()")

	returnValue := godotCallBool(o, "get_one_shot")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetPreProcessTime() float64 {
	log.Println("Calling Particles.GetPreProcessTime()")

	returnValue := godotCallFloat(o, "get_pre_process_time")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetProcessMaterial() *Material {
	log.Println("Calling Particles.GetProcessMaterial()")

	returnValue := godotCallObject(o, "get_process_material")
	log.Println("  Got return value: ", returnValue)

	var ret Material
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Particles) GetRandomnessRatio() float64 {
	log.Println("Calling Particles.GetRandomnessRatio()")

	returnValue := godotCallFloat(o, "get_randomness_ratio")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetSpeedScale() float64 {
	log.Println("Calling Particles.GetSpeedScale()")

	returnValue := godotCallFloat(o, "get_speed_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetUseLocalCoordinates() bool {
	log.Println("Calling Particles.GetUseLocalCoordinates()")

	returnValue := godotCallBool(o, "get_use_local_coordinates")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) GetVisibilityAabb() *AABB {
	log.Println("Calling Particles.GetVisibilityAabb()")

	returnValue := godotCallAabb(o, "get_visibility_aabb")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles) IsEmitting() bool {
	log.Println("Calling Particles.IsEmitting()")

	returnValue := godotCallBool(o, "is_emitting")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Particles) Restart() {
	log.Println("Calling Particles.Restart()")

	godotCallVoid(o, "restart")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetAmount(amount int64) {
	log.Println("Calling Particles.SetAmount()")

	godotCallVoidInt(o, "set_amount", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetDrawOrder(order int64) {
	log.Println("Calling Particles.SetDrawOrder()")

	godotCallVoidInt(o, "set_draw_order", order)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetDrawPassMesh(pass int64, mesh *Mesh) {
	log.Println("Calling Particles.SetDrawPassMesh()")

	godotCallVoidIntObject(o, "set_draw_pass_mesh", pass, &mesh.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetDrawPasses(passes int64) {
	log.Println("Calling Particles.SetDrawPasses()")

	godotCallVoidInt(o, "set_draw_passes", passes)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetEmitting(emitting bool) {
	log.Println("Calling Particles.SetEmitting()")

	godotCallVoidBool(o, "set_emitting", emitting)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetExplosivenessRatio(ratio float64) {
	log.Println("Calling Particles.SetExplosivenessRatio()")

	godotCallVoidFloat(o, "set_explosiveness_ratio", ratio)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetFixedFps(fps int64) {
	log.Println("Calling Particles.SetFixedFps()")

	godotCallVoidInt(o, "set_fixed_fps", fps)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetFractionalDelta(enable bool) {
	log.Println("Calling Particles.SetFractionalDelta()")

	godotCallVoidBool(o, "set_fractional_delta", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetLifetime(secs float64) {
	log.Println("Calling Particles.SetLifetime()")

	godotCallVoidFloat(o, "set_lifetime", secs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetOneShot(enable bool) {
	log.Println("Calling Particles.SetOneShot()")

	godotCallVoidBool(o, "set_one_shot", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetPreProcessTime(secs float64) {
	log.Println("Calling Particles.SetPreProcessTime()")

	godotCallVoidFloat(o, "set_pre_process_time", secs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetProcessMaterial(material *Material) {
	log.Println("Calling Particles.SetProcessMaterial()")

	godotCallVoidObject(o, "set_process_material", &material.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetRandomnessRatio(ratio float64) {
	log.Println("Calling Particles.SetRandomnessRatio()")

	godotCallVoidFloat(o, "set_randomness_ratio", ratio)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetSpeedScale(scale float64) {
	log.Println("Calling Particles.SetSpeedScale()")

	godotCallVoidFloat(o, "set_speed_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetUseLocalCoordinates(enable bool) {
	log.Println("Calling Particles.SetUseLocalCoordinates()")

	godotCallVoidBool(o, "set_use_local_coordinates", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles) SetVisibilityAabb(aabb *AABB) {
	log.Println("Calling Particles.SetVisibilityAabb()")

	godotCallVoidAabb(o, "set_visibility_aabb", aabb)
	log.Println("  Function successfully completed.")

}

/*
   ParticlesImplementer is an interface for Particles objects.
*/
type ParticlesImplementer interface {
	Class
}

/*
   2D particle node used to create a variety of particle systems and effects. [code]Particles2D[/code] features an emitter that generates some number of particles at a given rate. Use the [code]process_material[/code] property to add a [ParticlesMaterial] to configure particle appearance and behavior. Alternatively, you can add a [ShaderMaterial] which will be applied to all particles.
*/
type Particles2D struct {
	Node2D
}

func (o *Particles2D) baseClass() string {
	return "Particles2D"
}

/*

 */
func (o *Particles2D) CaptureRect() *Rect2 {
	log.Println("Calling Particles2D.CaptureRect()")

	returnValue := godotCallRect2(o, "capture_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetAmount() int64 {
	log.Println("Calling Particles2D.GetAmount()")

	returnValue := godotCallInt(o, "get_amount")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetDrawOrder() int64 {
	log.Println("Calling Particles2D.GetDrawOrder()")

	returnValue := godotCallInt(o, "get_draw_order")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetExplosivenessRatio() float64 {
	log.Println("Calling Particles2D.GetExplosivenessRatio()")

	returnValue := godotCallFloat(o, "get_explosiveness_ratio")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetFixedFps() int64 {
	log.Println("Calling Particles2D.GetFixedFps()")

	returnValue := godotCallInt(o, "get_fixed_fps")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetFractionalDelta() bool {
	log.Println("Calling Particles2D.GetFractionalDelta()")

	returnValue := godotCallBool(o, "get_fractional_delta")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetHFrames() int64 {
	log.Println("Calling Particles2D.GetHFrames()")

	returnValue := godotCallInt(o, "get_h_frames")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetLifetime() float64 {
	log.Println("Calling Particles2D.GetLifetime()")

	returnValue := godotCallFloat(o, "get_lifetime")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetNormalMap() *Texture {
	log.Println("Calling Particles2D.GetNormalMap()")

	returnValue := godotCallObject(o, "get_normal_map")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Particles2D) GetOneShot() bool {
	log.Println("Calling Particles2D.GetOneShot()")

	returnValue := godotCallBool(o, "get_one_shot")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetPreProcessTime() float64 {
	log.Println("Calling Particles2D.GetPreProcessTime()")

	returnValue := godotCallFloat(o, "get_pre_process_time")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetProcessMaterial() *Material {
	log.Println("Calling Particles2D.GetProcessMaterial()")

	returnValue := godotCallObject(o, "get_process_material")
	log.Println("  Got return value: ", returnValue)

	var ret Material
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Particles2D) GetRandomnessRatio() float64 {
	log.Println("Calling Particles2D.GetRandomnessRatio()")

	returnValue := godotCallFloat(o, "get_randomness_ratio")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetSpeedScale() float64 {
	log.Println("Calling Particles2D.GetSpeedScale()")

	returnValue := godotCallFloat(o, "get_speed_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetTexture() *Texture {
	log.Println("Calling Particles2D.GetTexture()")

	returnValue := godotCallObject(o, "get_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Particles2D) GetUseLocalCoordinates() bool {
	log.Println("Calling Particles2D.GetUseLocalCoordinates()")

	returnValue := godotCallBool(o, "get_use_local_coordinates")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetVFrames() int64 {
	log.Println("Calling Particles2D.GetVFrames()")

	returnValue := godotCallInt(o, "get_v_frames")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) GetVisibilityRect() *Rect2 {
	log.Println("Calling Particles2D.GetVisibilityRect()")

	returnValue := godotCallRect2(o, "get_visibility_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Particles2D) IsEmitting() bool {
	log.Println("Calling Particles2D.IsEmitting()")

	returnValue := godotCallBool(o, "is_emitting")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Particles2D) Restart() {
	log.Println("Calling Particles2D.Restart()")

	godotCallVoid(o, "restart")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetAmount(amount int64) {
	log.Println("Calling Particles2D.SetAmount()")

	godotCallVoidInt(o, "set_amount", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetDrawOrder(order int64) {
	log.Println("Calling Particles2D.SetDrawOrder()")

	godotCallVoidInt(o, "set_draw_order", order)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetEmitting(emitting bool) {
	log.Println("Calling Particles2D.SetEmitting()")

	godotCallVoidBool(o, "set_emitting", emitting)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetExplosivenessRatio(ratio float64) {
	log.Println("Calling Particles2D.SetExplosivenessRatio()")

	godotCallVoidFloat(o, "set_explosiveness_ratio", ratio)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetFixedFps(fps int64) {
	log.Println("Calling Particles2D.SetFixedFps()")

	godotCallVoidInt(o, "set_fixed_fps", fps)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetFractionalDelta(enable bool) {
	log.Println("Calling Particles2D.SetFractionalDelta()")

	godotCallVoidBool(o, "set_fractional_delta", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetHFrames(frames int64) {
	log.Println("Calling Particles2D.SetHFrames()")

	godotCallVoidInt(o, "set_h_frames", frames)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetLifetime(secs float64) {
	log.Println("Calling Particles2D.SetLifetime()")

	godotCallVoidFloat(o, "set_lifetime", secs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetNormalMap(texture *Texture) {
	log.Println("Calling Particles2D.SetNormalMap()")

	godotCallVoidObject(o, "set_normal_map", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetOneShot(secs bool) {
	log.Println("Calling Particles2D.SetOneShot()")

	godotCallVoidBool(o, "set_one_shot", secs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetPreProcessTime(secs float64) {
	log.Println("Calling Particles2D.SetPreProcessTime()")

	godotCallVoidFloat(o, "set_pre_process_time", secs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetProcessMaterial(material *Material) {
	log.Println("Calling Particles2D.SetProcessMaterial()")

	godotCallVoidObject(o, "set_process_material", &material.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetRandomnessRatio(ratio float64) {
	log.Println("Calling Particles2D.SetRandomnessRatio()")

	godotCallVoidFloat(o, "set_randomness_ratio", ratio)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetSpeedScale(scale float64) {
	log.Println("Calling Particles2D.SetSpeedScale()")

	godotCallVoidFloat(o, "set_speed_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetTexture(texture *Texture) {
	log.Println("Calling Particles2D.SetTexture()")

	godotCallVoidObject(o, "set_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetUseLocalCoordinates(enable bool) {
	log.Println("Calling Particles2D.SetUseLocalCoordinates()")

	godotCallVoidBool(o, "set_use_local_coordinates", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetVFrames(frames int64) {
	log.Println("Calling Particles2D.SetVFrames()")

	godotCallVoidInt(o, "set_v_frames", frames)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Particles2D) SetVisibilityRect(aabb *Rect2) {
	log.Println("Calling Particles2D.SetVisibilityRect()")

	godotCallVoidRect2(o, "set_visibility_rect", aabb)
	log.Println("  Function successfully completed.")

}

/*
   Particles2DImplementer is an interface for Particles2D objects.
*/
type Particles2DImplementer interface {
	Class
}

/*
   ParticlesMaterial defines particle properties and behavior. It is used in the [code]process_material[/code] of [Particles] and [Particles2D] emitter nodes. Some of this material's properties are applied to each particle when emitted, while others can have a [CurveTexture] applied to vary values over the lifetime of the particle.
*/
type ParticlesMaterial struct {
	Material
}

func (o *ParticlesMaterial) baseClass() string {
	return "ParticlesMaterial"
}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetColor() *Color {
	log.Println("Calling ParticlesMaterial.GetColor()")

	returnValue := godotCallColor(o, "get_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetColorRamp() *Texture {
	log.Println("Calling ParticlesMaterial.GetColorRamp()")

	returnValue := godotCallObject(o, "get_color_ramp")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetEmissionBoxExtents() *Vector3 {
	log.Println("Calling ParticlesMaterial.GetEmissionBoxExtents()")

	returnValue := godotCallVector3(o, "get_emission_box_extents")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetEmissionColorTexture() *Texture {
	log.Println("Calling ParticlesMaterial.GetEmissionColorTexture()")

	returnValue := godotCallObject(o, "get_emission_color_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetEmissionNormalTexture() *Texture {
	log.Println("Calling ParticlesMaterial.GetEmissionNormalTexture()")

	returnValue := godotCallObject(o, "get_emission_normal_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetEmissionPointCount() int64 {
	log.Println("Calling ParticlesMaterial.GetEmissionPointCount()")

	returnValue := godotCallInt(o, "get_emission_point_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetEmissionPointTexture() *Texture {
	log.Println("Calling ParticlesMaterial.GetEmissionPointTexture()")

	returnValue := godotCallObject(o, "get_emission_point_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetEmissionShape() int64 {
	log.Println("Calling ParticlesMaterial.GetEmissionShape()")

	returnValue := godotCallInt(o, "get_emission_shape")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetEmissionSphereRadius() float64 {
	log.Println("Calling ParticlesMaterial.GetEmissionSphereRadius()")

	returnValue := godotCallFloat(o, "get_emission_sphere_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetFlag(flag int64) bool {
	log.Println("Calling ParticlesMaterial.GetFlag()")

	returnValue := godotCallBoolInt(o, "get_flag", flag)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetFlatness() float64 {
	log.Println("Calling ParticlesMaterial.GetFlatness()")

	returnValue := godotCallFloat(o, "get_flatness")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetGravity() *Vector3 {
	log.Println("Calling ParticlesMaterial.GetGravity()")

	returnValue := godotCallVector3(o, "get_gravity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetParam(param int64) float64 {
	log.Println("Calling ParticlesMaterial.GetParam()")

	returnValue := godotCallFloatInt(o, "get_param", param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetParamRandomness(param int64) float64 {
	log.Println("Calling ParticlesMaterial.GetParamRandomness()")

	returnValue := godotCallFloatInt(o, "get_param_randomness", param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetParamTexture(param int64) *Texture {
	log.Println("Calling ParticlesMaterial.GetParamTexture()")

	returnValue := godotCallObjectInt(o, "get_param_texture", param)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetSpread() float64 {
	log.Println("Calling ParticlesMaterial.GetSpread()")

	returnValue := godotCallFloat(o, "get_spread")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetTrailColorModifier() *GradientTexture {
	log.Println("Calling ParticlesMaterial.GetTrailColorModifier()")

	returnValue := godotCallObject(o, "get_trail_color_modifier")
	log.Println("  Got return value: ", returnValue)

	var ret GradientTexture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetTrailDivisor() int64 {
	log.Println("Calling ParticlesMaterial.GetTrailDivisor()")

	returnValue := godotCallInt(o, "get_trail_divisor")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) GetTrailSizeModifier() *CurveTexture {
	log.Println("Calling ParticlesMaterial.GetTrailSizeModifier()")

	returnValue := godotCallObject(o, "get_trail_size_modifier")
	log.Println("  Got return value: ", returnValue)

	var ret CurveTexture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetColor(color *Color) {
	log.Println("Calling ParticlesMaterial.SetColor()")

	godotCallVoidColor(o, "set_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetColorRamp(ramp *Texture) {
	log.Println("Calling ParticlesMaterial.SetColorRamp()")

	godotCallVoidObject(o, "set_color_ramp", &ramp.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetEmissionBoxExtents(extents *Vector3) {
	log.Println("Calling ParticlesMaterial.SetEmissionBoxExtents()")

	godotCallVoidVector3(o, "set_emission_box_extents", extents)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetEmissionColorTexture(texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetEmissionColorTexture()")

	godotCallVoidObject(o, "set_emission_color_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetEmissionNormalTexture(texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetEmissionNormalTexture()")

	godotCallVoidObject(o, "set_emission_normal_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetEmissionPointCount(pointCount int64) {
	log.Println("Calling ParticlesMaterial.SetEmissionPointCount()")

	godotCallVoidInt(o, "set_emission_point_count", pointCount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetEmissionPointTexture(texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetEmissionPointTexture()")

	godotCallVoidObject(o, "set_emission_point_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetEmissionShape(shape int64) {
	log.Println("Calling ParticlesMaterial.SetEmissionShape()")

	godotCallVoidInt(o, "set_emission_shape", shape)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetEmissionSphereRadius(radius float64) {
	log.Println("Calling ParticlesMaterial.SetEmissionSphereRadius()")

	godotCallVoidFloat(o, "set_emission_sphere_radius", radius)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetFlag(flag int64, enable bool) {
	log.Println("Calling ParticlesMaterial.SetFlag()")

	godotCallVoidIntBool(o, "set_flag", flag, enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetFlatness(amount float64) {
	log.Println("Calling ParticlesMaterial.SetFlatness()")

	godotCallVoidFloat(o, "set_flatness", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetGravity(accelVec *Vector3) {
	log.Println("Calling ParticlesMaterial.SetGravity()")

	godotCallVoidVector3(o, "set_gravity", accelVec)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetParam(param int64, value float64) {
	log.Println("Calling ParticlesMaterial.SetParam()")

	godotCallVoidIntFloat(o, "set_param", param, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetParamRandomness(param int64, randomness float64) {
	log.Println("Calling ParticlesMaterial.SetParamRandomness()")

	godotCallVoidIntFloat(o, "set_param_randomness", param, randomness)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetParamTexture(param int64, texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetParamTexture()")

	godotCallVoidIntObject(o, "set_param_texture", param, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetSpread(degrees float64) {
	log.Println("Calling ParticlesMaterial.SetSpread()")

	godotCallVoidFloat(o, "set_spread", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetTrailColorModifier(texture *GradientTexture) {
	log.Println("Calling ParticlesMaterial.SetTrailColorModifier()")

	godotCallVoidObject(o, "set_trail_color_modifier", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetTrailDivisor(divisor int64) {
	log.Println("Calling ParticlesMaterial.SetTrailDivisor()")

	godotCallVoidInt(o, "set_trail_divisor", divisor)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ParticlesMaterial) SetTrailSizeModifier(texture *CurveTexture) {
	log.Println("Calling ParticlesMaterial.SetTrailSizeModifier()")

	godotCallVoidObject(o, "set_trail_size_modifier", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   ParticlesMaterialImplementer is an interface for ParticlesMaterial objects.
*/
type ParticlesMaterialImplementer interface {
	Class
}

/*
   This class is a container/Node-ification of a [Curve3D], so it can have [Spatial] properties and [Node] info.
*/
type Path struct {
	Spatial
}

func (o *Path) baseClass() string {
	return "Path"
}

/*
   Undocumented
*/
func (o *Path) X_CurveChanged() {
	log.Println("Calling Path.X_CurveChanged()")

	godotCallVoid(o, "_curve_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Path) GetCurve() *Curve3D {
	log.Println("Calling Path.GetCurve()")

	returnValue := godotCallObject(o, "get_curve")
	log.Println("  Got return value: ", returnValue)

	var ret Curve3D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Path) SetCurve(curve *Curve3D) {
	log.Println("Calling Path.SetCurve()")

	godotCallVoidObject(o, "set_curve", &curve.Object)
	log.Println("  Function successfully completed.")

}

/*
   PathImplementer is an interface for Path objects.
*/
type PathImplementer interface {
	Class
}

/*
   Can have [PathFollow2D] child-nodes moving along the [Curve2D]. See [PathFollow2D] for more information on this usage.
*/
type Path2D struct {
	Node2D
}

func (o *Path2D) baseClass() string {
	return "Path2D"
}

/*
   Undocumented
*/
func (o *Path2D) X_CurveChanged() {
	log.Println("Calling Path2D.X_CurveChanged()")

	godotCallVoid(o, "_curve_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Path2D) GetCurve() *Curve2D {
	log.Println("Calling Path2D.GetCurve()")

	returnValue := godotCallObject(o, "get_curve")
	log.Println("  Got return value: ", returnValue)

	var ret Curve2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Path2D) SetCurve(curve *Curve2D) {
	log.Println("Calling Path2D.SetCurve()")

	godotCallVoidObject(o, "set_curve", &curve.Object)
	log.Println("  Function successfully completed.")

}

/*
   Path2DImplementer is an interface for Path2D objects.
*/
type Path2DImplementer interface {
	Class
}

/*
   This node takes its parent [Path], and returns the coordinates of a point within it, given a distance from the first vertex. It is useful for making other nodes follow a path, without coding the movement pattern. For that, the nodes must be descendants of this node. Then, when setting an offset in this node, the descendant nodes will move accordingly.
*/
type PathFollow struct {
	Spatial
}

func (o *PathFollow) baseClass() string {
	return "PathFollow"
}

/*
   Undocumented
*/
func (o *PathFollow) GetCubicInterpolation() bool {
	log.Println("Calling PathFollow.GetCubicInterpolation()")

	returnValue := godotCallBool(o, "get_cubic_interpolation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow) GetHOffset() float64 {
	log.Println("Calling PathFollow.GetHOffset()")

	returnValue := godotCallFloat(o, "get_h_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow) GetOffset() float64 {
	log.Println("Calling PathFollow.GetOffset()")

	returnValue := godotCallFloat(o, "get_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow) GetRotationMode() int64 {
	log.Println("Calling PathFollow.GetRotationMode()")

	returnValue := godotCallInt(o, "get_rotation_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow) GetUnitOffset() float64 {
	log.Println("Calling PathFollow.GetUnitOffset()")

	returnValue := godotCallFloat(o, "get_unit_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow) GetVOffset() float64 {
	log.Println("Calling PathFollow.GetVOffset()")

	returnValue := godotCallFloat(o, "get_v_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow) HasLoop() bool {
	log.Println("Calling PathFollow.HasLoop()")

	returnValue := godotCallBool(o, "has_loop")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow) SetCubicInterpolation(enable bool) {
	log.Println("Calling PathFollow.SetCubicInterpolation()")

	godotCallVoidBool(o, "set_cubic_interpolation", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow) SetHOffset(hOffset float64) {
	log.Println("Calling PathFollow.SetHOffset()")

	godotCallVoidFloat(o, "set_h_offset", hOffset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow) SetLoop(loop bool) {
	log.Println("Calling PathFollow.SetLoop()")

	godotCallVoidBool(o, "set_loop", loop)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow) SetOffset(offset float64) {
	log.Println("Calling PathFollow.SetOffset()")

	godotCallVoidFloat(o, "set_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow) SetRotationMode(rotationMode int64) {
	log.Println("Calling PathFollow.SetRotationMode()")

	godotCallVoidInt(o, "set_rotation_mode", rotationMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow) SetUnitOffset(unitOffset float64) {
	log.Println("Calling PathFollow.SetUnitOffset()")

	godotCallVoidFloat(o, "set_unit_offset", unitOffset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow) SetVOffset(vOffset float64) {
	log.Println("Calling PathFollow.SetVOffset()")

	godotCallVoidFloat(o, "set_v_offset", vOffset)
	log.Println("  Function successfully completed.")

}

/*
   PathFollowImplementer is an interface for PathFollow objects.
*/
type PathFollowImplementer interface {
	Class
}

/*
   This node takes its parent [Path2D], and returns the coordinates of a point within it, given a distance from the first vertex. It is useful for making other nodes follow a path, without coding the movement pattern. For that, the nodes must be descendants of this node. Then, when setting an offset in this node, the descendant nodes will move accordingly.
*/
type PathFollow2D struct {
	Node2D
}

func (o *PathFollow2D) baseClass() string {
	return "PathFollow2D"
}

/*
   Undocumented
*/
func (o *PathFollow2D) GetCubicInterpolation() bool {
	log.Println("Calling PathFollow2D.GetCubicInterpolation()")

	returnValue := godotCallBool(o, "get_cubic_interpolation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow2D) GetHOffset() float64 {
	log.Println("Calling PathFollow2D.GetHOffset()")

	returnValue := godotCallFloat(o, "get_h_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow2D) GetLookahead() float64 {
	log.Println("Calling PathFollow2D.GetLookahead()")

	returnValue := godotCallFloat(o, "get_lookahead")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow2D) GetOffset() float64 {
	log.Println("Calling PathFollow2D.GetOffset()")

	returnValue := godotCallFloat(o, "get_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow2D) GetUnitOffset() float64 {
	log.Println("Calling PathFollow2D.GetUnitOffset()")

	returnValue := godotCallFloat(o, "get_unit_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow2D) GetVOffset() float64 {
	log.Println("Calling PathFollow2D.GetVOffset()")

	returnValue := godotCallFloat(o, "get_v_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow2D) HasLoop() bool {
	log.Println("Calling PathFollow2D.HasLoop()")

	returnValue := godotCallBool(o, "has_loop")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow2D) IsRotating() bool {
	log.Println("Calling PathFollow2D.IsRotating()")

	returnValue := godotCallBool(o, "is_rotating")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PathFollow2D) SetCubicInterpolation(enable bool) {
	log.Println("Calling PathFollow2D.SetCubicInterpolation()")

	godotCallVoidBool(o, "set_cubic_interpolation", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow2D) SetHOffset(hOffset float64) {
	log.Println("Calling PathFollow2D.SetHOffset()")

	godotCallVoidFloat(o, "set_h_offset", hOffset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow2D) SetLookahead(lookahead float64) {
	log.Println("Calling PathFollow2D.SetLookahead()")

	godotCallVoidFloat(o, "set_lookahead", lookahead)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow2D) SetLoop(loop bool) {
	log.Println("Calling PathFollow2D.SetLoop()")

	godotCallVoidBool(o, "set_loop", loop)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow2D) SetOffset(offset float64) {
	log.Println("Calling PathFollow2D.SetOffset()")

	godotCallVoidFloat(o, "set_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow2D) SetRotate(enable bool) {
	log.Println("Calling PathFollow2D.SetRotate()")

	godotCallVoidBool(o, "set_rotate", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow2D) SetUnitOffset(unitOffset float64) {
	log.Println("Calling PathFollow2D.SetUnitOffset()")

	godotCallVoidFloat(o, "set_unit_offset", unitOffset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PathFollow2D) SetVOffset(vOffset float64) {
	log.Println("Calling PathFollow2D.SetVOffset()")

	godotCallVoidFloat(o, "set_v_offset", vOffset)
	log.Println("  Function successfully completed.")

}

/*
   PathFollow2DImplementer is an interface for PathFollow2D objects.
*/
type PathFollow2DImplementer interface {
	Class
}

func newSingletonPerformance() *performance {
	obj := &performance{}
	name := C.CString("Performance")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   This class provides access to a number of different monitors related to performance, such as memory usage, draw calls, and FPS. These are the same as the values displayed in the [i]Monitor[/i] tab in the editor's [i]Debugger[/i] panel. By using the [method get_monitor] method of this class, you can access this data from your code. Note that a few of these monitors are only available in debug mode and will always return 0 when used in a release build. Many of these monitors are not updated in real-time, so there may be a short delay between changes.
*/
var Performance = newSingletonPerformance()

/*
   This class provides access to a number of different monitors related to performance, such as memory usage, draw calls, and FPS. These are the same as the values displayed in the [i]Monitor[/i] tab in the editor's [i]Debugger[/i] panel. By using the [method get_monitor] method of this class, you can access this data from your code. Note that a few of these monitors are only available in debug mode and will always return 0 when used in a release build. Many of these monitors are not updated in real-time, so there may be a short delay between changes.
*/
type performance struct {
	Object
}

func (o *performance) baseClass() string {
	return "Performance"
}

/*
   Returns the value of one of the available monitors. You should provide one of this class's constants as the argument, like this: [codeblock] print(Performance.get_monitor(Performance.TIME_FPS)) # Prints the FPS to the console [/codeblock]
*/
func (o *performance) GetMonitor(monitor int64) float64 {
	log.Println("Calling Performance.GetMonitor()")

	returnValue := godotCallFloatInt(o, "get_monitor", monitor)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Direct access object to a physics body in the [Physics2DServer]. This object is passed via the direct state callback of rigid/character bodies, and is intended for changing the direct state of that body.
*/
type Physics2DDirectBodyState struct {
	Object
}

func (o *Physics2DDirectBodyState) baseClass() string {
	return "Physics2DDirectBodyState"
}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) GetAngularVelocity() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetAngularVelocity()")

	returnValue := godotCallFloat(o, "get_angular_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the [RID] of the collider.
*/
func (o *Physics2DDirectBodyState) GetContactCollider(contactIdx int64) *RID {
	log.Println("Calling Physics2DDirectBodyState.GetContactCollider()")

	returnValue := godotCallRidInt(o, "get_contact_collider", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the object id of the collider.
*/
func (o *Physics2DDirectBodyState) GetContactColliderId(contactIdx int64) int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderId()")

	returnValue := godotCallIntInt(o, "get_contact_collider_id", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the collider object, this depends on how it was created (will return a scene node if such was used to create it).
*/
func (o *Physics2DDirectBodyState) GetContactColliderObject(contactIdx int64) *Object {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderObject()")

	returnValue := godotCallObjectInt(o, "get_contact_collider_object", contactIdx)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the contact position in the collider.
*/
func (o *Physics2DDirectBodyState) GetContactColliderPosition(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderPosition()")

	returnValue := godotCallVector2Int(o, "get_contact_collider_position", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the collider shape index.
*/
func (o *Physics2DDirectBodyState) GetContactColliderShape(contactIdx int64) int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderShape()")

	returnValue := godotCallIntInt(o, "get_contact_collider_shape", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the metadata of the collided shape. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data].
*/
func (o *Physics2DDirectBodyState) GetContactColliderShapeMetadata(contactIdx int64) *Variant {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderShapeMetadata()")

	returnValue := godotCallVariantInt(o, "get_contact_collider_shape_metadata", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the linear velocity vector at contact point of the collider.
*/
func (o *Physics2DDirectBodyState) GetContactColliderVelocityAtPosition(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderVelocityAtPosition()")

	returnValue := godotCallVector2Int(o, "get_contact_collider_velocity_at_position", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the amount of contacts this body has with other bodies. Note that by default this returns 0 unless bodies are configured to log contacts.
*/
func (o *Physics2DDirectBodyState) GetContactCount() int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactCount()")

	returnValue := godotCallInt(o, "get_contact_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the local normal (of this body) of the contact point.
*/
func (o *Physics2DDirectBodyState) GetContactLocalNormal(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactLocalNormal()")

	returnValue := godotCallVector2Int(o, "get_contact_local_normal", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the local position (of this body) of the contact point.
*/
func (o *Physics2DDirectBodyState) GetContactLocalPosition(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactLocalPosition()")

	returnValue := godotCallVector2Int(o, "get_contact_local_position", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the local shape index of the collision.
*/
func (o *Physics2DDirectBodyState) GetContactLocalShape(contactIdx int64) int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactLocalShape()")

	returnValue := godotCallIntInt(o, "get_contact_local_shape", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) GetInverseInertia() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetInverseInertia()")

	returnValue := godotCallFloat(o, "get_inverse_inertia")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) GetInverseMass() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetInverseMass()")

	returnValue := godotCallFloat(o, "get_inverse_mass")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) GetLinearVelocity() *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetLinearVelocity()")

	returnValue := godotCallVector2(o, "get_linear_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the current state of space, useful for queries.
*/
func (o *Physics2DDirectBodyState) GetSpaceState() *Physics2DDirectSpaceState {
	log.Println("Calling Physics2DDirectBodyState.GetSpaceState()")

	returnValue := godotCallObject(o, "get_space_state")
	log.Println("  Got return value: ", returnValue)

	var ret Physics2DDirectSpaceState
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) GetStep() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetStep()")

	returnValue := godotCallFloat(o, "get_step")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) GetTotalAngularDamp() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetTotalAngularDamp()")

	returnValue := godotCallFloat(o, "get_total_angular_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) GetTotalGravity() *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetTotalGravity()")

	returnValue := godotCallVector2(o, "get_total_gravity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) GetTotalLinearDamp() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetTotalLinearDamp()")

	returnValue := godotCallFloat(o, "get_total_linear_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) GetTransform() *Transform2D {
	log.Println("Calling Physics2DDirectBodyState.GetTransform()")

	returnValue := godotCallTransform2D(o, "get_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Call the built-in force integration code.
*/
func (o *Physics2DDirectBodyState) IntegrateForces() {
	log.Println("Calling Physics2DDirectBodyState.IntegrateForces()")

	godotCallVoid(o, "integrate_forces")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) IsSleeping() bool {
	log.Println("Calling Physics2DDirectBodyState.IsSleeping()")

	returnValue := godotCallBool(o, "is_sleeping")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) SetAngularVelocity(velocity float64) {
	log.Println("Calling Physics2DDirectBodyState.SetAngularVelocity()")

	godotCallVoidFloat(o, "set_angular_velocity", velocity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) SetLinearVelocity(velocity *Vector2) {
	log.Println("Calling Physics2DDirectBodyState.SetLinearVelocity()")

	godotCallVoidVector2(o, "set_linear_velocity", velocity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) SetSleepState(enabled bool) {
	log.Println("Calling Physics2DDirectBodyState.SetSleepState()")

	godotCallVoidBool(o, "set_sleep_state", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Physics2DDirectBodyState) SetTransform(transform *Transform2D) {
	log.Println("Calling Physics2DDirectBodyState.SetTransform()")

	godotCallVoidTransform2D(o, "set_transform", transform)
	log.Println("  Function successfully completed.")

}

/*
   Physics2DDirectBodyStateImplementer is an interface for Physics2DDirectBodyState objects.
*/
type Physics2DDirectBodyStateImplementer interface {
	Class
}

/*
   Software implementation of [Physics2DDirectBodyState]. This object exposes no new methods or properties and should not be used, as [Physics2DDirectBodyState] selects the best implementation available.
*/
type Physics2DDirectBodyStateSW struct {
	Physics2DDirectBodyState
}

func (o *Physics2DDirectBodyStateSW) baseClass() string {
	return "Physics2DDirectBodyStateSW"
}

/*
   Physics2DDirectBodyStateSWImplementer is an interface for Physics2DDirectBodyStateSW objects.
*/
type Physics2DDirectBodyStateSWImplementer interface {
	Class
}

/*
   Direct access object to a space in the [Physics2DServer]. It's used mainly to do queries against objects and areas residing in a given space.
*/
type Physics2DDirectSpaceState struct {
	Object
}

func (o *Physics2DDirectSpaceState) baseClass() string {
	return "Physics2DDirectSpaceState"
}

/*
   Checks how far the shape can travel toward a point. Note that both the shape and the motion are supplied through a [Physics2DShapeQueryParameters] object. The method will return an array with two floats between 0 and 1, both representing a fraction of [code]motion[/code]. The first is how far the shape can move without triggering a collision, and the second is the point at which a collision will occur. If no collision is detected, the returned array will be [1, 1]. If the shape can not move, the array will be empty ([code]dir.empty()==true[/code]).
*/
func (o *Physics2DDirectSpaceState) CastMotion(shape *Physics2DShapeQueryParameters) *Array {
	log.Println("Calling Physics2DDirectSpaceState.CastMotion()")

	returnValue := godotCallArrayObject(o, "cast_motion", &shape.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Checks the intersections of a shape, given through a [Physics2DShapeQueryParameters] object, against the space. The resulting array contains a list of points where the shape intersects another. Like with [method intersect_shape], the number of returned results can be limited to save processing time.
*/
func (o *Physics2DDirectSpaceState) CollideShape(shape *Physics2DShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling Physics2DDirectSpaceState.CollideShape()")

	returnValue := godotCallArrayObjectInt(o, "collide_shape", &shape.Object, maxResults)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Checks the intersections of a shape, given through a [Physics2DShapeQueryParameters] object, against the space. If it collides with more than one shape, the nearest one is selected. Note that this method does not take into account the [code]motion[/code] property of the object. The returned object is a dictionary containing the following fields: [code]collider_id[/code]: The colliding object's ID. [code]linear_velocity[/code]: The colliding object's velocity [Vector2]. If the object is an [Area2D], the result is [code](0, 0)[/code]. [code]metadata[/code]: The intersecting shape's metadata. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data]. [code]normal[/code]: The object's surface normal at the intersection point. [code]point[/code]: The intersection point. [code]rid[/code]: The intersecting object's [RID]. [code]shape[/code]: The shape index of the colliding shape. If the shape did not intersect anything, then an empty dictionary ([code]dir.empty()==true[/code]) is returned instead.
*/
func (o *Physics2DDirectSpaceState) GetRestInfo(shape *Physics2DShapeQueryParameters) *Dictionary {
	log.Println("Calling Physics2DDirectSpaceState.GetRestInfo()")

	returnValue := godotCallDictionaryObject(o, "get_rest_info", &shape.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Checks whether a point is inside any shape. The shapes the point is inside of are returned in an array containing dictionaries with the following fields: [code]collider[/code]: The colliding object. [code]collider_id[/code]: The colliding object's ID. [code]metadata[/code]: The intersecting shape's metadata. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data]. [code]rid[/code]: The intersecting object's [RID]. [code]shape[/code]: The shape index of the colliding shape. Additionally, the method can take an array of objects or [RID]s that are to be excluded from collisions, or a bitmask representing the physics layers to check in.
*/
func (o *Physics2DDirectSpaceState) IntersectPoint(point *Vector2, maxResults int64, exclude *Array, collisionLayer int64) *Array {
	log.Println("Calling Physics2DDirectSpaceState.IntersectPoint()")

	returnValue := godotCallArrayVector2IntArrayInt(o, "intersect_point", point, maxResults, exclude, collisionLayer)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Intersects a ray in a given space. The returned object is a dictionary with the following fields: [code]collider[/code]: The colliding object. [code]collider_id[/code]: The colliding object's ID. [code]metadata[/code]: The intersecting shape's metadata. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data]. [code]normal[/code]: The object's surface normal at the intersection point. [code]position[/code]: The intersection point. [code]rid[/code]: The intersecting object's [RID]. [code]shape[/code]: The shape index of the colliding shape. If the ray did not intersect anything, then an empty dictionary ([code]dir.empty()==true[/code]) is returned instead. Additionally, the method can take an array of objects or [RID]s that are to be excluded from collisions, or a bitmask representing the physics layers to check in.
*/
func (o *Physics2DDirectSpaceState) IntersectRay(from *Vector2, to *Vector2, exclude *Array, collisionLayer int64) *Dictionary {
	log.Println("Calling Physics2DDirectSpaceState.IntersectRay()")

	returnValue := godotCallDictionaryVector2Vector2ArrayInt(o, "intersect_ray", from, to, exclude, collisionLayer)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Checks the intersections of a shape, given through a [Physics2DShapeQueryParameters] object, against the space. Note that this method does not take into account the [code]motion[/code] property of the object. The intersected shapes are returned in an array containing dictionaries with the following fields: [code]collider[/code]: The colliding object. [code]collider_id[/code]: The colliding object's ID. [code]metadata[/code]: The intersecting shape's metadata. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data]. [code]rid[/code]: The intersecting object's [RID]. [code]shape[/code]: The shape index of the colliding shape. The number of intersections can be limited with the second parameter, to reduce the processing time.
*/
func (o *Physics2DDirectSpaceState) IntersectShape(shape *Physics2DShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling Physics2DDirectSpaceState.IntersectShape()")

	returnValue := godotCallArrayObjectInt(o, "intersect_shape", &shape.Object, maxResults)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Physics2DDirectSpaceStateImplementer is an interface for Physics2DDirectSpaceState objects.
*/
type Physics2DDirectSpaceStateImplementer interface {
	Class
}

func newSingletonPhysics2DServer() *physics2DServer {
	obj := &physics2DServer{}
	name := C.CString("Physics2DServer")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Physics 2D Server is the server responsible for all 2D physics. It can create many kinds of physics objects, but does not insert them on the node tree.
*/
var Physics2DServer = newSingletonPhysics2DServer()

/*
   Physics 2D Server is the server responsible for all 2D physics. It can create many kinds of physics objects, but does not insert them on the node tree.
*/
type physics2DServer struct {
	Object
}

func (o *physics2DServer) baseClass() string {
	return "Physics2DServer"
}

/*
   Adds a shape to the area, along with a transform matrix. Shapes are usually referenced by their index, so you should track which shape has a given index.
*/
func (o *physics2DServer) AreaAddShape(area *RID, shape *RID, transform *Transform2D) {
	log.Println("Calling Physics2DServer.AreaAddShape()")

	godotCallVoidRidRidTransform2D(o, "area_add_shape", area, shape, transform)
	log.Println("  Function successfully completed.")

}

/*
   Assigns the area to a descendant of [Object], so it can exist in the node tree.
*/
func (o *physics2DServer) AreaAttachObjectInstanceId(area *RID, id int64) {
	log.Println("Calling Physics2DServer.AreaAttachObjectInstanceId()")

	godotCallVoidRidInt(o, "area_attach_object_instance_id", area, id)
	log.Println("  Function successfully completed.")

}

/*
   Removes all shapes from an area. It does not delete the shapes, so they can be reassigned later.
*/
func (o *physics2DServer) AreaClearShapes(area *RID) {
	log.Println("Calling Physics2DServer.AreaClearShapes()")

	godotCallVoidRid(o, "area_clear_shapes", area)
	log.Println("  Function successfully completed.")

}

/*
   Creates an [Area2D].
*/
func (o *physics2DServer) AreaCreate() *RID {
	log.Println("Calling Physics2DServer.AreaCreate()")

	returnValue := godotCallRid(o, "area_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Gets the instance ID of the object the area is assigned to.
*/
func (o *physics2DServer) AreaGetObjectInstanceId(area *RID) int64 {
	log.Println("Calling Physics2DServer.AreaGetObjectInstanceId()")

	returnValue := godotCallIntRid(o, "area_get_object_instance_id", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an area parameter value. A list of available parameters is on the AREA_PARAM_* constants.
*/
func (o *physics2DServer) AreaGetParam(area *RID, param int64) *Variant {
	log.Println("Calling Physics2DServer.AreaGetParam()")

	returnValue := godotCallVariantRidInt(o, "area_get_param", area, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [RID] of the nth shape of an area.
*/
func (o *physics2DServer) AreaGetShape(area *RID, shapeIdx int64) *RID {
	log.Println("Calling Physics2DServer.AreaGetShape()")

	returnValue := godotCallRidRidInt(o, "area_get_shape", area, shapeIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of shapes assigned to an area.
*/
func (o *physics2DServer) AreaGetShapeCount(area *RID) int64 {
	log.Println("Calling Physics2DServer.AreaGetShapeCount()")

	returnValue := godotCallIntRid(o, "area_get_shape_count", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the transform matrix of a shape within an area.
*/
func (o *physics2DServer) AreaGetShapeTransform(area *RID, shapeIdx int64) *Transform2D {
	log.Println("Calling Physics2DServer.AreaGetShapeTransform()")

	returnValue := godotCallTransform2DRidInt(o, "area_get_shape_transform", area, shapeIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the space assigned to the area.
*/
func (o *physics2DServer) AreaGetSpace(area *RID) *RID {
	log.Println("Calling Physics2DServer.AreaGetSpace()")

	returnValue := godotCallRidRid(o, "area_get_space", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the space override mode for the area.
*/
func (o *physics2DServer) AreaGetSpaceOverrideMode(area *RID) int64 {
	log.Println("Calling Physics2DServer.AreaGetSpaceOverrideMode()")

	returnValue := godotCallIntRid(o, "area_get_space_override_mode", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the transform matrix for an area.
*/
func (o *physics2DServer) AreaGetTransform(area *RID) *Transform2D {
	log.Println("Calling Physics2DServer.AreaGetTransform()")

	returnValue := godotCallTransform2DRid(o, "area_get_transform", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a shape from an area. It does not delete the shape, so it can be reassigned later.
*/
func (o *physics2DServer) AreaRemoveShape(area *RID, shapeIdx int64) {
	log.Println("Calling Physics2DServer.AreaRemoveShape()")

	godotCallVoidRidInt(o, "area_remove_shape", area, shapeIdx)
	log.Println("  Function successfully completed.")

}

/*
   Assigns the area to one or many physics layers.
*/
func (o *physics2DServer) AreaSetCollisionLayer(area *RID, layer int64) {
	log.Println("Calling Physics2DServer.AreaSetCollisionLayer()")

	godotCallVoidRidInt(o, "area_set_collision_layer", area, layer)
	log.Println("  Function successfully completed.")

}

/*
   Sets which physics layers the area will monitor.
*/
func (o *physics2DServer) AreaSetCollisionMask(area *RID, mask int64) {
	log.Println("Calling Physics2DServer.AreaSetCollisionMask()")

	godotCallVoidRidInt(o, "area_set_collision_mask", area, mask)
	log.Println("  Function successfully completed.")

}

/*
   Sets the function to call when any body/area enters or exits the area. This callback will be called for any object interacting with the area, and takes five parameters: 1: AREA_BODY_ADDED or AREA_BODY_REMOVED, depending on whether the object entered or exited the area. 2: [RID] of the object that entered/exited the area. 3: Instance ID of the object that entered/exited the area. 4: The shape index of the object that entered/exited the area. 5: The shape index of the area where the object entered/exited.
*/
func (o *physics2DServer) AreaSetMonitorCallback(area *RID, receiver *Object, method string) {
	log.Println("Calling Physics2DServer.AreaSetMonitorCallback()")

	godotCallVoidRidObjectString(o, "area_set_monitor_callback", area, receiver, method)
	log.Println("  Function successfully completed.")

}

/*
   Sets the value for an area parameter. A list of available parameters is on the AREA_PARAM_* constants.
*/
func (o *physics2DServer) AreaSetParam(area *RID, param int64, value *Variant) {
	log.Println("Calling Physics2DServer.AreaSetParam()")

	godotCallVoidRidIntVariant(o, "area_set_param", area, param, value)
	log.Println("  Function successfully completed.")

}

/*
   Substitutes a given area shape by another. The old shape is selected by its index, the new one by its [RID].
*/
func (o *physics2DServer) AreaSetShape(area *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling Physics2DServer.AreaSetShape()")

	godotCallVoidRidIntRid(o, "area_set_shape", area, shapeIdx, shape)
	log.Println("  Function successfully completed.")

}

/*
   Disables a given shape in an area.
*/
func (o *physics2DServer) AreaSetShapeDisabled(area *RID, shapeIdx int64, disable bool) {
	log.Println("Calling Physics2DServer.AreaSetShapeDisabled()")

	godotCallVoidRidIntBool(o, "area_set_shape_disabled", area, shapeIdx, disable)
	log.Println("  Function successfully completed.")

}

/*
   Sets the transform matrix for an area shape.
*/
func (o *physics2DServer) AreaSetShapeTransform(area *RID, shapeIdx int64, transform *Transform2D) {
	log.Println("Calling Physics2DServer.AreaSetShapeTransform()")

	godotCallVoidRidIntTransform2D(o, "area_set_shape_transform", area, shapeIdx, transform)
	log.Println("  Function successfully completed.")

}

/*
   Assigns a space to the area.
*/
func (o *physics2DServer) AreaSetSpace(area *RID, space *RID) {
	log.Println("Calling Physics2DServer.AreaSetSpace()")

	godotCallVoidRidRid(o, "area_set_space", area, space)
	log.Println("  Function successfully completed.")

}

/*
   Sets the space override mode for the area. The modes are described in the constants AREA_SPACE_OVERRIDE_*.
*/
func (o *physics2DServer) AreaSetSpaceOverrideMode(area *RID, mode int64) {
	log.Println("Calling Physics2DServer.AreaSetSpaceOverrideMode()")

	godotCallVoidRidInt(o, "area_set_space_override_mode", area, mode)
	log.Println("  Function successfully completed.")

}

/*
   Sets the transform matrix for an area.
*/
func (o *physics2DServer) AreaSetTransform(area *RID, transform *Transform2D) {
	log.Println("Calling Physics2DServer.AreaSetTransform()")

	godotCallVoidRidTransform2D(o, "area_set_transform", area, transform)
	log.Println("  Function successfully completed.")

}

/*
   Adds a body to the list of bodies exempt from collisions.
*/
func (o *physics2DServer) BodyAddCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling Physics2DServer.BodyAddCollisionException()")

	godotCallVoidRidRid(o, "body_add_collision_exception", body, exceptedBody)
	log.Println("  Function successfully completed.")

}

/*
   Adds a positioned force to the applied force and torque. As with [method body_apply_impulse], both the force and the offset from the body origin are in global coordinates. A force differs from an impulse in that, while the two are forces, the impulse clears itself after being applied.
*/
func (o *physics2DServer) BodyAddForce(body *RID, offset *Vector2, force *Vector2) {
	log.Println("Calling Physics2DServer.BodyAddForce()")

	godotCallVoidRidVector2Vector2(o, "body_add_force", body, offset, force)
	log.Println("  Function successfully completed.")

}

/*
   Adds a shape to the body, along with a transform matrix. Shapes are usually referenced by their index, so you should track which shape has a given index.
*/
func (o *physics2DServer) BodyAddShape(body *RID, shape *RID, transform *Transform2D) {
	log.Println("Calling Physics2DServer.BodyAddShape()")

	godotCallVoidRidRidTransform2D(o, "body_add_shape", body, shape, transform)
	log.Println("  Function successfully completed.")

}

/*
   Adds a positioned impulse to the applied force and torque. Both the force and the offset from the body origin are in global coordinates.
*/
func (o *physics2DServer) BodyApplyImpulse(body *RID, position *Vector2, impulse *Vector2) {
	log.Println("Calling Physics2DServer.BodyApplyImpulse()")

	godotCallVoidRidVector2Vector2(o, "body_apply_impulse", body, position, impulse)
	log.Println("  Function successfully completed.")

}

/*
   Assigns the area to a descendant of [Object], so it can exist in the node tree.
*/
func (o *physics2DServer) BodyAttachObjectInstanceId(body *RID, id int64) {
	log.Println("Calling Physics2DServer.BodyAttachObjectInstanceId()")

	godotCallVoidRidInt(o, "body_attach_object_instance_id", body, id)
	log.Println("  Function successfully completed.")

}

/*
   Removes all shapes from a body.
*/
func (o *physics2DServer) BodyClearShapes(body *RID) {
	log.Println("Calling Physics2DServer.BodyClearShapes()")

	godotCallVoidRid(o, "body_clear_shapes", body)
	log.Println("  Function successfully completed.")

}

/*
   Creates a physics body. The first parameter can be any value from constants BODY_MODE*, for the type of body created. Additionally, the body can be created in sleeping state to save processing time.
*/
func (o *physics2DServer) BodyCreate() *RID {
	log.Println("Calling Physics2DServer.BodyCreate()")

	returnValue := godotCallRid(o, "body_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the physics layer or layers a body belongs to.
*/
func (o *physics2DServer) BodyGetCollisionLayer(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetCollisionLayer()")

	returnValue := godotCallIntRid(o, "body_get_collision_layer", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the physics layer or layers a body can collide with.
*/
func (o *physics2DServer) BodyGetCollisionMask(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetCollisionMask()")

	returnValue := godotCallIntRid(o, "body_get_collision_mask", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the continuous collision detection mode.
*/
func (o *physics2DServer) BodyGetContinuousCollisionDetectionMode(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetContinuousCollisionDetectionMode()")

	returnValue := godotCallIntRid(o, "body_get_continuous_collision_detection_mode", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [Physics2DDirectBodyState] of the body.
*/
func (o *physics2DServer) BodyGetDirectState(body *RID) *Physics2DDirectBodyState {
	log.Println("Calling Physics2DServer.BodyGetDirectState()")

	returnValue := godotCallObjectRid(o, "body_get_direct_state", body)
	log.Println("  Got return value: ", returnValue)

	var ret Physics2DDirectBodyState
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the maximum contacts that can be reported. See [method body_set_max_contacts_reported].
*/
func (o *physics2DServer) BodyGetMaxContactsReported(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetMaxContactsReported()")

	returnValue := godotCallIntRid(o, "body_get_max_contacts_reported", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the body mode.
*/
func (o *physics2DServer) BodyGetMode(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetMode()")

	returnValue := godotCallIntRid(o, "body_get_mode", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Gets the instance ID of the object the area is assigned to.
*/
func (o *physics2DServer) BodyGetObjectInstanceId(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetObjectInstanceId()")

	returnValue := godotCallIntRid(o, "body_get_object_instance_id", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the value of a body parameter. A list of available parameters is on the BODY_PARAM_* constants.
*/
func (o *physics2DServer) BodyGetParam(body *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.BodyGetParam()")

	returnValue := godotCallFloatRidInt(o, "body_get_param", body, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [RID] of the nth shape of a body.
*/
func (o *physics2DServer) BodyGetShape(body *RID, shapeIdx int64) *RID {
	log.Println("Calling Physics2DServer.BodyGetShape()")

	returnValue := godotCallRidRidInt(o, "body_get_shape", body, shapeIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of shapes assigned to a body.
*/
func (o *physics2DServer) BodyGetShapeCount(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetShapeCount()")

	returnValue := godotCallIntRid(o, "body_get_shape_count", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the metadata of a shape of a body.
*/
func (o *physics2DServer) BodyGetShapeMetadata(body *RID, shapeIdx int64) *Variant {
	log.Println("Calling Physics2DServer.BodyGetShapeMetadata()")

	returnValue := godotCallVariantRidInt(o, "body_get_shape_metadata", body, shapeIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the transform matrix of a body shape.
*/
func (o *physics2DServer) BodyGetShapeTransform(body *RID, shapeIdx int64) *Transform2D {
	log.Println("Calling Physics2DServer.BodyGetShapeTransform()")

	returnValue := godotCallTransform2DRidInt(o, "body_get_shape_transform", body, shapeIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [RID] of the space assigned to a body.
*/
func (o *physics2DServer) BodyGetSpace(body *RID) *RID {
	log.Println("Calling Physics2DServer.BodyGetSpace()")

	returnValue := godotCallRidRid(o, "body_get_space", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a body state.
*/
func (o *physics2DServer) BodyGetState(body *RID, state int64) *Variant {
	log.Println("Calling Physics2DServer.BodyGetState()")

	returnValue := godotCallVariantRidInt(o, "body_get_state", body, state)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether a body uses a callback function to calculate its own physics (see [method body_set_force_integration_callback]).
*/
func (o *physics2DServer) BodyIsOmittingForceIntegration(body *RID) bool {
	log.Println("Calling Physics2DServer.BodyIsOmittingForceIntegration()")

	returnValue := godotCallBoolRid(o, "body_is_omitting_force_integration", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a body from the list of bodies exempt from collisions.
*/
func (o *physics2DServer) BodyRemoveCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling Physics2DServer.BodyRemoveCollisionException()")

	godotCallVoidRidRid(o, "body_remove_collision_exception", body, exceptedBody)
	log.Println("  Function successfully completed.")

}

/*
   Removes a shape from a body. The shape is not deleted, so it can be reused afterwards.
*/
func (o *physics2DServer) BodyRemoveShape(body *RID, shapeIdx int64) {
	log.Println("Calling Physics2DServer.BodyRemoveShape()")

	godotCallVoidRidInt(o, "body_remove_shape", body, shapeIdx)
	log.Println("  Function successfully completed.")

}

/*
   Sets an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *physics2DServer) BodySetAxisVelocity(body *RID, axisVelocity *Vector2) {
	log.Println("Calling Physics2DServer.BodySetAxisVelocity()")

	godotCallVoidRidVector2(o, "body_set_axis_velocity", body, axisVelocity)
	log.Println("  Function successfully completed.")

}

/*
   Sets the physics layer or layers a body belongs to.
*/
func (o *physics2DServer) BodySetCollisionLayer(body *RID, layer int64) {
	log.Println("Calling Physics2DServer.BodySetCollisionLayer()")

	godotCallVoidRidInt(o, "body_set_collision_layer", body, layer)
	log.Println("  Function successfully completed.")

}

/*
   Sets the physics layer or layers a body can collide with.
*/
func (o *physics2DServer) BodySetCollisionMask(body *RID, mask int64) {
	log.Println("Calling Physics2DServer.BodySetCollisionMask()")

	godotCallVoidRidInt(o, "body_set_collision_mask", body, mask)
	log.Println("  Function successfully completed.")

}

/*
   Sets the continuous collision detection mode from any of the CCD_MODE_* constants. Continuous collision detection tries to predict where a moving body will collide, instead of moving it and correcting its movement if it collided.
*/
func (o *physics2DServer) BodySetContinuousCollisionDetectionMode(body *RID, mode int64) {
	log.Println("Calling Physics2DServer.BodySetContinuousCollisionDetectionMode()")

	godotCallVoidRidInt(o, "body_set_continuous_collision_detection_mode", body, mode)
	log.Println("  Function successfully completed.")

}

/*
   Sets the function used to calculate physics for an object, if that object allows it (see [method body_set_omit_force integration]).
*/
func (o *physics2DServer) BodySetForceIntegrationCallback(body *RID, receiver *Object, method string, userdata *Variant) {
	log.Println("Calling Physics2DServer.BodySetForceIntegrationCallback()")

	godotCallVoidRidObjectStringVariant(o, "body_set_force_integration_callback", body, receiver, method, userdata)
	log.Println("  Function successfully completed.")

}

/*
   Sets the maximum contacts to report. Bodies can keep a log of the contacts with other bodies, this is enabled by setting the maximum amount of contacts reported to a number greater than 0.
*/
func (o *physics2DServer) BodySetMaxContactsReported(body *RID, amount int64) {
	log.Println("Calling Physics2DServer.BodySetMaxContactsReported()")

	godotCallVoidRidInt(o, "body_set_max_contacts_reported", body, amount)
	log.Println("  Function successfully completed.")

}

/*
   Sets the body mode, from one of the constants BODY_MODE*.
*/
func (o *physics2DServer) BodySetMode(body *RID, mode int64) {
	log.Println("Calling Physics2DServer.BodySetMode()")

	godotCallVoidRidInt(o, "body_set_mode", body, mode)
	log.Println("  Function successfully completed.")

}

/*
   Sets whether a body uses a callback function to calculate its own physics (see [method body_set_force_integration_callback]).
*/
func (o *physics2DServer) BodySetOmitForceIntegration(body *RID, enable bool) {
	log.Println("Calling Physics2DServer.BodySetOmitForceIntegration()")

	godotCallVoidRidBool(o, "body_set_omit_force_integration", body, enable)
	log.Println("  Function successfully completed.")

}

/*
   Sets a body parameter. A list of available parameters is on the BODY_PARAM_* constants.
*/
func (o *physics2DServer) BodySetParam(body *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.BodySetParam()")

	godotCallVoidRidIntFloat(o, "body_set_param", body, param, value)
	log.Println("  Function successfully completed.")

}

/*
   Substitutes a given body shape by another. The old shape is selected by its index, the new one by its [RID].
*/
func (o *physics2DServer) BodySetShape(body *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling Physics2DServer.BodySetShape()")

	godotCallVoidRidIntRid(o, "body_set_shape", body, shapeIdx, shape)
	log.Println("  Function successfully completed.")

}

/*
   Enables one way collision on body if [code]enable[/code] is [code]true[/code].
*/
func (o *physics2DServer) BodySetShapeAsOneWayCollision(body *RID, shapeIdx int64, enable bool) {
	log.Println("Calling Physics2DServer.BodySetShapeAsOneWayCollision()")

	godotCallVoidRidIntBool(o, "body_set_shape_as_one_way_collision", body, shapeIdx, enable)
	log.Println("  Function successfully completed.")

}

/*
   Disables shape in body if [code]disable[/code] is [code]true[/code].
*/
func (o *physics2DServer) BodySetShapeDisabled(body *RID, shapeIdx int64, disable bool) {
	log.Println("Calling Physics2DServer.BodySetShapeDisabled()")

	godotCallVoidRidIntBool(o, "body_set_shape_disabled", body, shapeIdx, disable)
	log.Println("  Function successfully completed.")

}

/*
   Sets metadata of a shape within a body. This metadata is different from [method Object.set_meta], and can be retrieved on shape queries.
*/
func (o *physics2DServer) BodySetShapeMetadata(body *RID, shapeIdx int64, metadata *Variant) {
	log.Println("Calling Physics2DServer.BodySetShapeMetadata()")

	godotCallVoidRidIntVariant(o, "body_set_shape_metadata", body, shapeIdx, metadata)
	log.Println("  Function successfully completed.")

}

/*
   Sets the transform matrix for a body shape.
*/
func (o *physics2DServer) BodySetShapeTransform(body *RID, shapeIdx int64, transform *Transform2D) {
	log.Println("Calling Physics2DServer.BodySetShapeTransform()")

	godotCallVoidRidIntTransform2D(o, "body_set_shape_transform", body, shapeIdx, transform)
	log.Println("  Function successfully completed.")

}

/*
   Assigns a space to the body (see [method create_space]).
*/
func (o *physics2DServer) BodySetSpace(body *RID, space *RID) {
	log.Println("Calling Physics2DServer.BodySetSpace()")

	godotCallVoidRidRid(o, "body_set_space", body, space)
	log.Println("  Function successfully completed.")

}

/*
   Sets a body state (see BODY_STATE* constants).
*/
func (o *physics2DServer) BodySetState(body *RID, state int64, value *Variant) {
	log.Println("Calling Physics2DServer.BodySetState()")

	godotCallVoidRidIntVariant(o, "body_set_state", body, state, value)
	log.Println("  Function successfully completed.")

}

/*
   Returns whether a body can move from a given point in a given direction. Apart from the boolean return value, a [Physics2DTestMotionResult] can be passed to return additional information in.
*/
func (o *physics2DServer) BodyTestMotion(body *RID, from *Transform2D, motion *Vector2, margin float64, result *Physics2DTestMotionResult) bool {
	log.Println("Calling Physics2DServer.BodyTestMotion()")

	returnValue := godotCallBoolRidTransform2DVector2FloatObject(o, "body_test_motion", body, from, motion, margin, &result.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *physics2DServer) CapsuleShapeCreate() *RID {
	log.Println("Calling Physics2DServer.CapsuleShapeCreate()")

	returnValue := godotCallRid(o, "capsule_shape_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *physics2DServer) CircleShapeCreate() *RID {
	log.Println("Calling Physics2DServer.CircleShapeCreate()")

	returnValue := godotCallRid(o, "circle_shape_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *physics2DServer) ConcavePolygonShapeCreate() *RID {
	log.Println("Calling Physics2DServer.ConcavePolygonShapeCreate()")

	returnValue := godotCallRid(o, "concave_polygon_shape_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *physics2DServer) ConvexPolygonShapeCreate() *RID {
	log.Println("Calling Physics2DServer.ConvexPolygonShapeCreate()")

	returnValue := godotCallRid(o, "convex_polygon_shape_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Creates a damped spring joint between two bodies. If not specified, the second body is assumed to be the joint itself.
*/
func (o *physics2DServer) DampedSpringJointCreate(anchorA *Vector2, anchorB *Vector2, bodyA *RID, bodyB *RID) *RID {
	log.Println("Calling Physics2DServer.DampedSpringJointCreate()")

	returnValue := godotCallRidVector2Vector2RidRid(o, "damped_spring_joint_create", anchorA, anchorB, bodyA, bodyB)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the value of a damped spring joint parameter.
*/
func (o *physics2DServer) DampedStringJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.DampedStringJointGetParam()")

	returnValue := godotCallFloatRidInt(o, "damped_string_joint_get_param", joint, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets a damped spring joint parameter. Parameters are explained in the DAMPED_STRING* constants.
*/
func (o *physics2DServer) DampedStringJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.DampedStringJointSetParam()")

	godotCallVoidRidIntFloat(o, "damped_string_joint_set_param", joint, param, value)
	log.Println("  Function successfully completed.")

}

/*
   Destroys any of the objects created by Physics2DServer. If the [RID] passed is not one of the objects that can be created by Physics2DServer, an error will be sent to the console.
*/
func (o *physics2DServer) FreeRid(rid *RID) {
	log.Println("Calling Physics2DServer.FreeRid()")

	godotCallVoidRid(o, "free_rid", rid)
	log.Println("  Function successfully completed.")

}

/*
   Returns information about the current state of the 2D physics engine. The states are listed under the INFO_* constants.
*/
func (o *physics2DServer) GetProcessInfo(processInfo int64) int64 {
	log.Println("Calling Physics2DServer.GetProcessInfo()")

	returnValue := godotCallIntInt(o, "get_process_info", processInfo)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Creates a groove joint between two bodies. If not specified, the bodyies are assumed to be the joint itself.
*/
func (o *physics2DServer) GrooveJointCreate(groove1A *Vector2, groove2A *Vector2, anchorB *Vector2, bodyA *RID, bodyB *RID) *RID {
	log.Println("Calling Physics2DServer.GrooveJointCreate()")

	returnValue := godotCallRidVector2Vector2Vector2RidRid(o, "groove_joint_create", groove1A, groove2A, anchorB, bodyA, bodyB)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the value of a joint parameter.
*/
func (o *physics2DServer) JointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.JointGetParam()")

	returnValue := godotCallFloatRidInt(o, "joint_get_param", joint, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the type of a joint (see JOINT_* constants).
*/
func (o *physics2DServer) JointGetType(joint *RID) int64 {
	log.Println("Calling Physics2DServer.JointGetType()")

	returnValue := godotCallIntRid(o, "joint_get_type", joint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets a joint parameter. Parameters are explained in the JOINT_PARAM* constants.
*/
func (o *physics2DServer) JointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.JointSetParam()")

	godotCallVoidRidIntFloat(o, "joint_set_param", joint, param, value)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *physics2DServer) LineShapeCreate() *RID {
	log.Println("Calling Physics2DServer.LineShapeCreate()")

	returnValue := godotCallRid(o, "line_shape_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Creates a pin joint between two bodies. If not specified, the second body is assumed to be the joint itself.
*/
func (o *physics2DServer) PinJointCreate(anchor *Vector2, bodyA *RID, bodyB *RID) *RID {
	log.Println("Calling Physics2DServer.PinJointCreate()")

	returnValue := godotCallRidVector2RidRid(o, "pin_joint_create", anchor, bodyA, bodyB)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *physics2DServer) RayShapeCreate() *RID {
	log.Println("Calling Physics2DServer.RayShapeCreate()")

	returnValue := godotCallRid(o, "ray_shape_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *physics2DServer) RectangleShapeCreate() *RID {
	log.Println("Calling Physics2DServer.RectangleShapeCreate()")

	returnValue := godotCallRid(o, "rectangle_shape_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *physics2DServer) SegmentShapeCreate() *RID {
	log.Println("Calling Physics2DServer.SegmentShapeCreate()")

	returnValue := godotCallRid(o, "segment_shape_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Activates or deactivates the 2D physics engine.
*/
func (o *physics2DServer) SetActive(active bool) {
	log.Println("Calling Physics2DServer.SetActive()")

	godotCallVoidBool(o, "set_active", active)
	log.Println("  Function successfully completed.")

}

/*
   Returns the shape data.
*/
func (o *physics2DServer) ShapeGetData(shape *RID) *Variant {
	log.Println("Calling Physics2DServer.ShapeGetData()")

	returnValue := godotCallVariantRid(o, "shape_get_data", shape)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the type of shape (see SHAPE_* constants).
*/
func (o *physics2DServer) ShapeGetType(shape *RID) int64 {
	log.Println("Calling Physics2DServer.ShapeGetType()")

	returnValue := godotCallIntRid(o, "shape_get_type", shape)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the shape data that defines its shape and size. The data to be passed depends on the kind of shape created [method shape_get_type].
*/
func (o *physics2DServer) ShapeSetData(shape *RID, data *Variant) {
	log.Println("Calling Physics2DServer.ShapeSetData()")

	godotCallVoidRidVariant(o, "shape_set_data", shape, data)
	log.Println("  Function successfully completed.")

}

/*
   Creates a space. A space is a collection of parameters for the physics engine that can be assigned to an area or a body. It can be assigned to an area with [method area_set_space], or to a body with [method body_set_space].
*/
func (o *physics2DServer) SpaceCreate() *RID {
	log.Println("Calling Physics2DServer.SpaceCreate()")

	returnValue := godotCallRid(o, "space_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the state of a space, a [Physics2DDirectSpaceState]. This object can be used to make collision/intersection queries.
*/
func (o *physics2DServer) SpaceGetDirectState(space *RID) *Physics2DDirectSpaceState {
	log.Println("Calling Physics2DServer.SpaceGetDirectState()")

	returnValue := godotCallObjectRid(o, "space_get_direct_state", space)
	log.Println("  Got return value: ", returnValue)

	var ret Physics2DDirectSpaceState
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the value of a space parameter.
*/
func (o *physics2DServer) SpaceGetParam(space *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.SpaceGetParam()")

	returnValue := godotCallFloatRidInt(o, "space_get_param", space, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether the space is active.
*/
func (o *physics2DServer) SpaceIsActive(space *RID) bool {
	log.Println("Calling Physics2DServer.SpaceIsActive()")

	returnValue := godotCallBoolRid(o, "space_is_active", space)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Marks a space as active. It will not have an effect, unless it is assigned to an area or body.
*/
func (o *physics2DServer) SpaceSetActive(space *RID, active bool) {
	log.Println("Calling Physics2DServer.SpaceSetActive()")

	godotCallVoidRidBool(o, "space_set_active", space, active)
	log.Println("  Function successfully completed.")

}

/*
   Sets the value for a space parameter. A list of available parameters is on the SPACE_PARAM_* constants.
*/
func (o *physics2DServer) SpaceSetParam(space *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.SpaceSetParam()")

	godotCallVoidRidIntFloat(o, "space_set_param", space, param, value)
	log.Println("  Function successfully completed.")

}

/*
   This class exposes no new methods or properties and should not be used, as [Physics2DServer] automatically selects the best implementation available.
*/
type Physics2DServerSW struct {
	physics2DServer
}

func (o *Physics2DServerSW) baseClass() string {
	return "Physics2DServerSW"
}

/*
   Physics2DServerSWImplementer is an interface for Physics2DServerSW objects.
*/
type Physics2DServerSWImplementer interface {
	Class
}

/*
   This class contains the shape and other parameters for intersection/collision queries.
*/
type Physics2DShapeQueryParameters struct {
	Reference
}

func (o *Physics2DShapeQueryParameters) baseClass() string {
	return "Physics2DShapeQueryParameters"
}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) GetCollisionLayer() int64 {
	log.Println("Calling Physics2DShapeQueryParameters.GetCollisionLayer()")

	returnValue := godotCallInt(o, "get_collision_layer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) GetExclude() *Array {
	log.Println("Calling Physics2DShapeQueryParameters.GetExclude()")

	returnValue := godotCallArray(o, "get_exclude")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) GetMargin() float64 {
	log.Println("Calling Physics2DShapeQueryParameters.GetMargin()")

	returnValue := godotCallFloat(o, "get_margin")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) GetMotion() *Vector2 {
	log.Println("Calling Physics2DShapeQueryParameters.GetMotion()")

	returnValue := godotCallVector2(o, "get_motion")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) GetShapeRid() *RID {
	log.Println("Calling Physics2DShapeQueryParameters.GetShapeRid()")

	returnValue := godotCallRid(o, "get_shape_rid")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) GetTransform() *Transform2D {
	log.Println("Calling Physics2DShapeQueryParameters.GetTransform()")

	returnValue := godotCallTransform2D(o, "get_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling Physics2DShapeQueryParameters.SetCollisionLayer()")

	godotCallVoidInt(o, "set_collision_layer", collisionLayer)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) SetExclude(exclude *Array) {
	log.Println("Calling Physics2DShapeQueryParameters.SetExclude()")

	godotCallVoidArray(o, "set_exclude", exclude)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) SetMargin(margin float64) {
	log.Println("Calling Physics2DShapeQueryParameters.SetMargin()")

	godotCallVoidFloat(o, "set_margin", margin)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) SetMotion(motion *Vector2) {
	log.Println("Calling Physics2DShapeQueryParameters.SetMotion()")

	godotCallVoidVector2(o, "set_motion", motion)
	log.Println("  Function successfully completed.")

}

/*
   Set the [Shape2D] that will be used for collision/intersection queries.
*/
func (o *Physics2DShapeQueryParameters) SetShape(shape *Resource) {
	log.Println("Calling Physics2DShapeQueryParameters.SetShape()")

	godotCallVoidObject(o, "set_shape", &shape.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) SetShapeRid(shape *RID) {
	log.Println("Calling Physics2DShapeQueryParameters.SetShapeRid()")

	godotCallVoidRid(o, "set_shape_rid", shape)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Physics2DShapeQueryParameters) SetTransform(transform *Transform2D) {
	log.Println("Calling Physics2DShapeQueryParameters.SetTransform()")

	godotCallVoidTransform2D(o, "set_transform", transform)
	log.Println("  Function successfully completed.")

}

/*
   Physics2DShapeQueryParametersImplementer is an interface for Physics2DShapeQueryParameters objects.
*/
type Physics2DShapeQueryParametersImplementer interface {
	Class
}

/*

 */
type Physics2DShapeQueryResult struct {
	Reference
}

func (o *Physics2DShapeQueryResult) baseClass() string {
	return "Physics2DShapeQueryResult"
}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultCount() int64 {
	log.Println("Calling Physics2DShapeQueryResult.GetResultCount()")

	returnValue := godotCallInt(o, "get_result_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultObject(idx int64) *Object {
	log.Println("Calling Physics2DShapeQueryResult.GetResultObject()")

	returnValue := godotCallObjectInt(o, "get_result_object", idx)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultObjectId(idx int64) int64 {
	log.Println("Calling Physics2DShapeQueryResult.GetResultObjectId()")

	returnValue := godotCallIntInt(o, "get_result_object_id", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultObjectShape(idx int64) int64 {
	log.Println("Calling Physics2DShapeQueryResult.GetResultObjectShape()")

	returnValue := godotCallIntInt(o, "get_result_object_shape", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultRid(idx int64) *RID {
	log.Println("Calling Physics2DShapeQueryResult.GetResultRid()")

	returnValue := godotCallRidInt(o, "get_result_rid", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Physics2DShapeQueryResultImplementer is an interface for Physics2DShapeQueryResult objects.
*/
type Physics2DShapeQueryResultImplementer interface {
	Class
}

/*

 */
type Physics2DTestMotionResult struct {
	Reference
}

func (o *Physics2DTestMotionResult) baseClass() string {
	return "Physics2DTestMotionResult"
}

/*
   Undocumented
*/
func (o *Physics2DTestMotionResult) GetCollider() *Object {
	log.Println("Calling Physics2DTestMotionResult.GetCollider()")

	returnValue := godotCallObject(o, "get_collider")
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Physics2DTestMotionResult) GetColliderId() int64 {
	log.Println("Calling Physics2DTestMotionResult.GetColliderId()")

	returnValue := godotCallInt(o, "get_collider_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DTestMotionResult) GetColliderRid() *RID {
	log.Println("Calling Physics2DTestMotionResult.GetColliderRid()")

	returnValue := godotCallRid(o, "get_collider_rid")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DTestMotionResult) GetColliderShape() int64 {
	log.Println("Calling Physics2DTestMotionResult.GetColliderShape()")

	returnValue := godotCallInt(o, "get_collider_shape")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DTestMotionResult) GetColliderVelocity() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetColliderVelocity()")

	returnValue := godotCallVector2(o, "get_collider_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DTestMotionResult) GetCollisionNormal() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetCollisionNormal()")

	returnValue := godotCallVector2(o, "get_collision_normal")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DTestMotionResult) GetCollisionPoint() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetCollisionPoint()")

	returnValue := godotCallVector2(o, "get_collision_point")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DTestMotionResult) GetMotion() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetMotion()")

	returnValue := godotCallVector2(o, "get_motion")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Physics2DTestMotionResult) GetMotionRemainder() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetMotionRemainder()")

	returnValue := godotCallVector2(o, "get_motion_remainder")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Physics2DTestMotionResultImplementer is an interface for Physics2DTestMotionResult objects.
*/
type Physics2DTestMotionResultImplementer interface {
	Class
}

/*
   PhysicsBody is an abstract base class for implementing a physics body. All *Body types inherit from it.
*/
type PhysicsBody struct {
	CollisionObject
}

func (o *PhysicsBody) baseClass() string {
	return "PhysicsBody"
}

/*
   Undocumented
*/
func (o *PhysicsBody) X_GetLayers() int64 {
	log.Println("Calling PhysicsBody.X_GetLayers()")

	returnValue := godotCallInt(o, "_get_layers")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsBody) X_SetLayers(mask int64) {
	log.Println("Calling PhysicsBody.X_SetLayers()")

	godotCallVoidInt(o, "_set_layers", mask)
	log.Println("  Function successfully completed.")

}

/*
   Adds a body to the list of bodies that this body can't collide with.
*/
func (o *PhysicsBody) AddCollisionExceptionWith(body *Object) {
	log.Println("Calling PhysicsBody.AddCollisionExceptionWith()")

	godotCallVoidObject(o, "add_collision_exception_with", body)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsBody) GetCollisionLayer() int64 {
	log.Println("Calling PhysicsBody.GetCollisionLayer()")

	returnValue := godotCallInt(o, "get_collision_layer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsBody) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling PhysicsBody.GetCollisionLayerBit()")

	returnValue := godotCallBoolInt(o, "get_collision_layer_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsBody) GetCollisionMask() int64 {
	log.Println("Calling PhysicsBody.GetCollisionMask()")

	returnValue := godotCallInt(o, "get_collision_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsBody) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling PhysicsBody.GetCollisionMaskBit()")

	returnValue := godotCallBoolInt(o, "get_collision_mask_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a body from the list of bodies that this body can't collide with.
*/
func (o *PhysicsBody) RemoveCollisionExceptionWith(body *Object) {
	log.Println("Calling PhysicsBody.RemoveCollisionExceptionWith()")

	godotCallVoidObject(o, "remove_collision_exception_with", body)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsBody) SetCollisionLayer(layer int64) {
	log.Println("Calling PhysicsBody.SetCollisionLayer()")

	godotCallVoidInt(o, "set_collision_layer", layer)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PhysicsBody) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling PhysicsBody.SetCollisionLayerBit()")

	godotCallVoidIntBool(o, "set_collision_layer_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsBody) SetCollisionMask(mask int64) {
	log.Println("Calling PhysicsBody.SetCollisionMask()")

	godotCallVoidInt(o, "set_collision_mask", mask)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PhysicsBody) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling PhysicsBody.SetCollisionMaskBit()")

	godotCallVoidIntBool(o, "set_collision_mask_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   PhysicsBodyImplementer is an interface for PhysicsBody objects.
*/
type PhysicsBodyImplementer interface {
	Class
}

/*
   PhysicsBody2D is an abstract base class for implementing a physics body. All *Body2D types inherit from it.
*/
type PhysicsBody2D struct {
	CollisionObject2D
}

func (o *PhysicsBody2D) baseClass() string {
	return "PhysicsBody2D"
}

/*
   Undocumented
*/
func (o *PhysicsBody2D) X_GetLayers() int64 {
	log.Println("Calling PhysicsBody2D.X_GetLayers()")

	returnValue := godotCallInt(o, "_get_layers")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsBody2D) X_SetLayers(mask int64) {
	log.Println("Calling PhysicsBody2D.X_SetLayers()")

	godotCallVoidInt(o, "_set_layers", mask)
	log.Println("  Function successfully completed.")

}

/*
   Adds a body to the list of bodies that this body can't collide with.
*/
func (o *PhysicsBody2D) AddCollisionExceptionWith(body *Object) {
	log.Println("Calling PhysicsBody2D.AddCollisionExceptionWith()")

	godotCallVoidObject(o, "add_collision_exception_with", body)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsBody2D) GetCollisionLayer() int64 {
	log.Println("Calling PhysicsBody2D.GetCollisionLayer()")

	returnValue := godotCallInt(o, "get_collision_layer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return an individual bit on the collision mask.
*/
func (o *PhysicsBody2D) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling PhysicsBody2D.GetCollisionLayerBit()")

	returnValue := godotCallBoolInt(o, "get_collision_layer_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsBody2D) GetCollisionMask() int64 {
	log.Println("Calling PhysicsBody2D.GetCollisionMask()")

	returnValue := godotCallInt(o, "get_collision_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return an individual bit on the collision mask.
*/
func (o *PhysicsBody2D) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling PhysicsBody2D.GetCollisionMaskBit()")

	returnValue := godotCallBoolInt(o, "get_collision_mask_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a body from the list of bodies that this body can't collide with.
*/
func (o *PhysicsBody2D) RemoveCollisionExceptionWith(body *Object) {
	log.Println("Calling PhysicsBody2D.RemoveCollisionExceptionWith()")

	godotCallVoidObject(o, "remove_collision_exception_with", body)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsBody2D) SetCollisionLayer(layer int64) {
	log.Println("Calling PhysicsBody2D.SetCollisionLayer()")

	godotCallVoidInt(o, "set_collision_layer", layer)
	log.Println("  Function successfully completed.")

}

/*
   Set/clear individual bits on the layer mask. This makes getting a body in/out of only one layer easier.
*/
func (o *PhysicsBody2D) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling PhysicsBody2D.SetCollisionLayerBit()")

	godotCallVoidIntBool(o, "set_collision_layer_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsBody2D) SetCollisionMask(mask int64) {
	log.Println("Calling PhysicsBody2D.SetCollisionMask()")

	godotCallVoidInt(o, "set_collision_mask", mask)
	log.Println("  Function successfully completed.")

}

/*
   Set/clear individual bits on the collision mask. This makes selecting the areas scanned easier.
*/
func (o *PhysicsBody2D) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling PhysicsBody2D.SetCollisionMaskBit()")

	godotCallVoidIntBool(o, "set_collision_mask_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   PhysicsBody2DImplementer is an interface for PhysicsBody2D objects.
*/
type PhysicsBody2DImplementer interface {
	Class
}

/*

 */
type PhysicsDirectBodyState struct {
	Object
}

func (o *PhysicsDirectBodyState) baseClass() string {
	return "PhysicsDirectBodyState"
}

/*

 */
func (o *PhysicsDirectBodyState) AddForce(force *Vector3, position *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.AddForce()")

	godotCallVoidVector3Vector3(o, "add_force", force, position)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PhysicsDirectBodyState) ApplyImpulse(position *Vector3, j *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.ApplyImpulse()")

	godotCallVoidVector3Vector3(o, "apply_impulse", position, j)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PhysicsDirectBodyState) ApplyTorqeImpulse(j *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.ApplyTorqeImpulse()")

	godotCallVoidVector3(o, "apply_torqe_impulse", j)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) GetAngularVelocity() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetAngularVelocity()")

	returnValue := godotCallVector3(o, "get_angular_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) GetCenterOfMass() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetCenterOfMass()")

	returnValue := godotCallVector3(o, "get_center_of_mass")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactCollider(contactIdx int64) *RID {
	log.Println("Calling PhysicsDirectBodyState.GetContactCollider()")

	returnValue := godotCallRidInt(o, "get_contact_collider", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderId(contactIdx int64) int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderId()")

	returnValue := godotCallIntInt(o, "get_contact_collider_id", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderObject(contactIdx int64) *Object {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderObject()")

	returnValue := godotCallObjectInt(o, "get_contact_collider_object", contactIdx)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderPosition(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderPosition()")

	returnValue := godotCallVector3Int(o, "get_contact_collider_position", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderShape(contactIdx int64) int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderShape()")

	returnValue := godotCallIntInt(o, "get_contact_collider_shape", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderVelocityAtPosition(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderVelocityAtPosition()")

	returnValue := godotCallVector3Int(o, "get_contact_collider_velocity_at_position", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactCount() int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactCount()")

	returnValue := godotCallInt(o, "get_contact_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactLocalNormal(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactLocalNormal()")

	returnValue := godotCallVector3Int(o, "get_contact_local_normal", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactLocalPosition(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactLocalPosition()")

	returnValue := godotCallVector3Int(o, "get_contact_local_position", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactLocalShape(contactIdx int64) int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactLocalShape()")

	returnValue := godotCallIntInt(o, "get_contact_local_shape", contactIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) GetInverseInertia() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetInverseInertia()")

	returnValue := godotCallVector3(o, "get_inverse_inertia")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) GetInverseMass() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetInverseMass()")

	returnValue := godotCallFloat(o, "get_inverse_mass")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) GetLinearVelocity() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetLinearVelocity()")

	returnValue := godotCallVector3(o, "get_linear_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) GetPrincipalInertiaAxes() *Basis {
	log.Println("Calling PhysicsDirectBodyState.GetPrincipalInertiaAxes()")

	returnValue := godotCallBasis(o, "get_principal_inertia_axes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetSpaceState() *PhysicsDirectSpaceState {
	log.Println("Calling PhysicsDirectBodyState.GetSpaceState()")

	returnValue := godotCallObject(o, "get_space_state")
	log.Println("  Got return value: ", returnValue)

	var ret PhysicsDirectSpaceState
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) GetStep() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetStep()")

	returnValue := godotCallFloat(o, "get_step")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) GetTotalAngularDamp() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetTotalAngularDamp()")

	returnValue := godotCallFloat(o, "get_total_angular_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) GetTotalGravity() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetTotalGravity()")

	returnValue := godotCallVector3(o, "get_total_gravity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) GetTotalLinearDamp() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetTotalLinearDamp()")

	returnValue := godotCallFloat(o, "get_total_linear_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) GetTransform() *Transform {
	log.Println("Calling PhysicsDirectBodyState.GetTransform()")

	returnValue := godotCallTransform(o, "get_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) IntegrateForces() {
	log.Println("Calling PhysicsDirectBodyState.IntegrateForces()")

	godotCallVoid(o, "integrate_forces")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) IsSleeping() bool {
	log.Println("Calling PhysicsDirectBodyState.IsSleeping()")

	returnValue := godotCallBool(o, "is_sleeping")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) SetAngularVelocity(velocity *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.SetAngularVelocity()")

	godotCallVoidVector3(o, "set_angular_velocity", velocity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) SetLinearVelocity(velocity *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.SetLinearVelocity()")

	godotCallVoidVector3(o, "set_linear_velocity", velocity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) SetSleepState(enabled bool) {
	log.Println("Calling PhysicsDirectBodyState.SetSleepState()")

	godotCallVoidBool(o, "set_sleep_state", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsDirectBodyState) SetTransform(transform *Transform) {
	log.Println("Calling PhysicsDirectBodyState.SetTransform()")

	godotCallVoidTransform(o, "set_transform", transform)
	log.Println("  Function successfully completed.")

}

/*
   PhysicsDirectBodyStateImplementer is an interface for PhysicsDirectBodyState objects.
*/
type PhysicsDirectBodyStateImplementer interface {
	Class
}

/*
   Direct access object to a space in the [PhysicsServer]. It's used mainly to do queries against objects and areas residing in a given space.
*/
type PhysicsDirectSpaceState struct {
	Object
}

func (o *PhysicsDirectSpaceState) baseClass() string {
	return "PhysicsDirectSpaceState"
}

/*
   Checks whether the shape can travel to a point. The method will return an array with two floats between 0 and 1, both representing a fraction of [code]motion[/code]. The first is how far the shape can move without triggering a collision, and the second is the point at which a collision will occur. If no collision is detected, the returned array will be [1, 1]. If the shape can not move, the array will be empty ([code]dir.empty()==true[/code]).
*/
func (o *PhysicsDirectSpaceState) CastMotion(shape *PhysicsShapeQueryParameters, motion *Vector3) *Array {
	log.Println("Calling PhysicsDirectSpaceState.CastMotion()")

	returnValue := godotCallArrayObjectVector3(o, "cast_motion", &shape.Object, motion)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Checks the intersections of a shape, given through a [PhysicsShapeQueryParameters] object, against the space. The resulting array contains a list of points where the shape intersects another. Like with [method intersect_shape], the number of returned results can be limited to save processing time.
*/
func (o *PhysicsDirectSpaceState) CollideShape(shape *PhysicsShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling PhysicsDirectSpaceState.CollideShape()")

	returnValue := godotCallArrayObjectInt(o, "collide_shape", &shape.Object, maxResults)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Checks the intersections of a shape, given through a [PhysicsShapeQueryParameters] object, against the space. If it collides with more than a shape, the nearest one is selected. The returned object is a dictionary containing the following fields: [code]collider_id[/code]: The colliding object's ID. [code]linear_velocity[/code]: The colliding object's velocity [Vector3]. If the object is an [Area], the result is [code](0, 0, 0)[/code]. [code]normal[/code]: The object's surface normal at the intersection point. [code]point[/code]: The intersection point. [code]rid[/code]: The intersecting object's [RID]. [code]shape[/code]: The shape index of the colliding shape. If the shape did not intersect anything, then an empty dictionary ([code]dir.empty()==true[/code]) is returned instead.
*/
func (o *PhysicsDirectSpaceState) GetRestInfo(shape *PhysicsShapeQueryParameters) *Dictionary {
	log.Println("Calling PhysicsDirectSpaceState.GetRestInfo()")

	returnValue := godotCallDictionaryObject(o, "get_rest_info", &shape.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Intersects a ray in a given space. The returned object is a dictionary with the following fields: [code]collider[/code]: The colliding object. [code]collider_id[/code]: The colliding object's ID. [code]normal[/code]: The object's surface normal at the intersection point. [code]position[/code]: The intersection point. [code]rid[/code]: The intersecting object's [RID]. [code]shape[/code]: The shape index of the colliding shape. If the ray did not intersect anything, then an empty dictionary ([code]dir.empty()==true[/code]) is returned instead. Additionally, the method can take an array of objects or [RID]s that are to be excluded from collisions, or a bitmask representing the physics layers to check in.
*/
func (o *PhysicsDirectSpaceState) IntersectRay(from *Vector3, to *Vector3, exclude *Array, collisionLayer int64) *Dictionary {
	log.Println("Calling PhysicsDirectSpaceState.IntersectRay()")

	returnValue := godotCallDictionaryVector3Vector3ArrayInt(o, "intersect_ray", from, to, exclude, collisionLayer)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Checks the intersections of a shape, given through a [PhysicsShapeQueryParameters] object, against the space. The intersected shapes are returned in an array containing dictionaries with the following fields: [code]collider[/code]: The colliding object. [code]collider_id[/code]: The colliding object's ID. [code]rid[/code]: The intersecting object's [RID]. [code]shape[/code]: The shape index of the colliding shape. The number of intersections can be limited with the second parameter, to reduce the processing time.
*/
func (o *PhysicsDirectSpaceState) IntersectShape(shape *PhysicsShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling PhysicsDirectSpaceState.IntersectShape()")

	returnValue := godotCallArrayObjectInt(o, "intersect_shape", &shape.Object, maxResults)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   PhysicsDirectSpaceStateImplementer is an interface for PhysicsDirectSpaceState objects.
*/
type PhysicsDirectSpaceStateImplementer interface {
	Class
}

func newSingletonPhysicsServer() *physicsServer {
	obj := &physicsServer{}
	name := C.CString("PhysicsServer")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Everything related to physics in 3D.
*/
var PhysicsServer = newSingletonPhysicsServer()

/*
   Everything related to physics in 3D.
*/
type physicsServer struct {
	Object
}

func (o *physicsServer) baseClass() string {
	return "PhysicsServer"
}

/*
   Adds a shape to the area, along with a transform matrix. Shapes are usually referenced by their index, so you should track which shape has a given index.
*/
func (o *physicsServer) AreaAddShape(area *RID, shape *RID, transform *Transform) {
	log.Println("Calling PhysicsServer.AreaAddShape()")

	godotCallVoidRidRidTransform(o, "area_add_shape", area, shape, transform)
	log.Println("  Function successfully completed.")

}

/*
   Assigns the area to a descendant of [Object], so it can exist in the node tree.
*/
func (o *physicsServer) AreaAttachObjectInstanceId(area *RID, id int64) {
	log.Println("Calling PhysicsServer.AreaAttachObjectInstanceId()")

	godotCallVoidRidInt(o, "area_attach_object_instance_id", area, id)
	log.Println("  Function successfully completed.")

}

/*
   Removes all shapes from an area. It does not delete the shapes, so they can be reassigned later.
*/
func (o *physicsServer) AreaClearShapes(area *RID) {
	log.Println("Calling PhysicsServer.AreaClearShapes()")

	godotCallVoidRid(o, "area_clear_shapes", area)
	log.Println("  Function successfully completed.")

}

/*
   Creates an [Area].
*/
func (o *physicsServer) AreaCreate() *RID {
	log.Println("Calling PhysicsServer.AreaCreate()")

	returnValue := godotCallRid(o, "area_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Gets the instance ID of the object the area is assigned to.
*/
func (o *physicsServer) AreaGetObjectInstanceId(area *RID) int64 {
	log.Println("Calling PhysicsServer.AreaGetObjectInstanceId()")

	returnValue := godotCallIntRid(o, "area_get_object_instance_id", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an area parameter value. A list of available parameters is on the AREA_PARAM_* constants.
*/
func (o *physicsServer) AreaGetParam(area *RID, param int64) *Variant {
	log.Println("Calling PhysicsServer.AreaGetParam()")

	returnValue := godotCallVariantRidInt(o, "area_get_param", area, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [RID] of the nth shape of an area.
*/
func (o *physicsServer) AreaGetShape(area *RID, shapeIdx int64) *RID {
	log.Println("Calling PhysicsServer.AreaGetShape()")

	returnValue := godotCallRidRidInt(o, "area_get_shape", area, shapeIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of shapes assigned to an area.
*/
func (o *physicsServer) AreaGetShapeCount(area *RID) int64 {
	log.Println("Calling PhysicsServer.AreaGetShapeCount()")

	returnValue := godotCallIntRid(o, "area_get_shape_count", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the transform matrix of a shape within an area.
*/
func (o *physicsServer) AreaGetShapeTransform(area *RID, shapeIdx int64) *Transform {
	log.Println("Calling PhysicsServer.AreaGetShapeTransform()")

	returnValue := godotCallTransformRidInt(o, "area_get_shape_transform", area, shapeIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the space assigned to the area.
*/
func (o *physicsServer) AreaGetSpace(area *RID) *RID {
	log.Println("Calling PhysicsServer.AreaGetSpace()")

	returnValue := godotCallRidRid(o, "area_get_space", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the space override mode for the area.
*/
func (o *physicsServer) AreaGetSpaceOverrideMode(area *RID) int64 {
	log.Println("Calling PhysicsServer.AreaGetSpaceOverrideMode()")

	returnValue := godotCallIntRid(o, "area_get_space_override_mode", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the transform matrix for an area.
*/
func (o *physicsServer) AreaGetTransform(area *RID) *Transform {
	log.Println("Calling PhysicsServer.AreaGetTransform()")

	returnValue := godotCallTransformRid(o, "area_get_transform", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] area collides with rays.
*/
func (o *physicsServer) AreaIsRayPickable(area *RID) bool {
	log.Println("Calling PhysicsServer.AreaIsRayPickable()")

	returnValue := godotCallBoolRid(o, "area_is_ray_pickable", area)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a shape from an area. It does not delete the shape, so it can be reassigned later.
*/
func (o *physicsServer) AreaRemoveShape(area *RID, shapeIdx int64) {
	log.Println("Calling PhysicsServer.AreaRemoveShape()")

	godotCallVoidRidInt(o, "area_remove_shape", area, shapeIdx)
	log.Println("  Function successfully completed.")

}

/*
   Assigns the area to one or many physics layers.
*/
func (o *physicsServer) AreaSetCollisionLayer(area *RID, layer int64) {
	log.Println("Calling PhysicsServer.AreaSetCollisionLayer()")

	godotCallVoidRidInt(o, "area_set_collision_layer", area, layer)
	log.Println("  Function successfully completed.")

}

/*
   Sets which physics layers the area will monitor.
*/
func (o *physicsServer) AreaSetCollisionMask(area *RID, mask int64) {
	log.Println("Calling PhysicsServer.AreaSetCollisionMask()")

	godotCallVoidRidInt(o, "area_set_collision_mask", area, mask)
	log.Println("  Function successfully completed.")

}

/*
   Sets the function to call when any body/area enters or exits the area. This callback will be called for any object interacting with the area, and takes five parameters: 1: AREA_BODY_ADDED or AREA_BODY_REMOVED, depending on whether the object entered or exited the area. 2: [RID] of the object that entered/exited the area. 3: Instance ID of the object that entered/exited the area. 4: The shape index of the object that entered/exited the area. 5: The shape index of the area where the object entered/exited.
*/
func (o *physicsServer) AreaSetMonitorCallback(area *RID, receiver *Object, method string) {
	log.Println("Calling PhysicsServer.AreaSetMonitorCallback()")

	godotCallVoidRidObjectString(o, "area_set_monitor_callback", area, receiver, method)
	log.Println("  Function successfully completed.")

}

/*
   Sets the value for an area parameter. A list of available parameters is on the AREA_PARAM_* constants.
*/
func (o *physicsServer) AreaSetParam(area *RID, param int64, value *Variant) {
	log.Println("Calling PhysicsServer.AreaSetParam()")

	godotCallVoidRidIntVariant(o, "area_set_param", area, param, value)
	log.Println("  Function successfully completed.")

}

/*
   Sets object pickable with rays.
*/
func (o *physicsServer) AreaSetRayPickable(area *RID, enable bool) {
	log.Println("Calling PhysicsServer.AreaSetRayPickable()")

	godotCallVoidRidBool(o, "area_set_ray_pickable", area, enable)
	log.Println("  Function successfully completed.")

}

/*
   Substitutes a given area shape by another. The old shape is selected by its index, the new one by its [RID].
*/
func (o *physicsServer) AreaSetShape(area *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling PhysicsServer.AreaSetShape()")

	godotCallVoidRidIntRid(o, "area_set_shape", area, shapeIdx, shape)
	log.Println("  Function successfully completed.")

}

/*
   Sets the transform matrix for an area shape.
*/
func (o *physicsServer) AreaSetShapeTransform(area *RID, shapeIdx int64, transform *Transform) {
	log.Println("Calling PhysicsServer.AreaSetShapeTransform()")

	godotCallVoidRidIntTransform(o, "area_set_shape_transform", area, shapeIdx, transform)
	log.Println("  Function successfully completed.")

}

/*
   Assigns a space to the area.
*/
func (o *physicsServer) AreaSetSpace(area *RID, space *RID) {
	log.Println("Calling PhysicsServer.AreaSetSpace()")

	godotCallVoidRidRid(o, "area_set_space", area, space)
	log.Println("  Function successfully completed.")

}

/*
   Sets the space override mode for the area. The modes are described in the constants AREA_SPACE_OVERRIDE_*.
*/
func (o *physicsServer) AreaSetSpaceOverrideMode(area *RID, mode int64) {
	log.Println("Calling PhysicsServer.AreaSetSpaceOverrideMode()")

	godotCallVoidRidInt(o, "area_set_space_override_mode", area, mode)
	log.Println("  Function successfully completed.")

}

/*
   Sets the transform matrix for an area.
*/
func (o *physicsServer) AreaSetTransform(area *RID, transform *Transform) {
	log.Println("Calling PhysicsServer.AreaSetTransform()")

	godotCallVoidRidTransform(o, "area_set_transform", area, transform)
	log.Println("  Function successfully completed.")

}

/*
   Adds a body to the list of bodies exempt from collisions.
*/
func (o *physicsServer) BodyAddCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling PhysicsServer.BodyAddCollisionException()")

	godotCallVoidRidRid(o, "body_add_collision_exception", body, exceptedBody)
	log.Println("  Function successfully completed.")

}

/*
   Adds a shape to the body, along with a transform matrix. Shapes are usually referenced by their index, so you should track which shape has a given index.
*/
func (o *physicsServer) BodyAddShape(body *RID, shape *RID, transform *Transform) {
	log.Println("Calling PhysicsServer.BodyAddShape()")

	godotCallVoidRidRidTransform(o, "body_add_shape", body, shape, transform)
	log.Println("  Function successfully completed.")

}

/*
   Gives the body a push at a [code]position[/code] in the direction of the [code]impulse[/code].
*/
func (o *physicsServer) BodyApplyImpulse(body *RID, position *Vector3, impulse *Vector3) {
	log.Println("Calling PhysicsServer.BodyApplyImpulse()")

	godotCallVoidRidVector3Vector3(o, "body_apply_impulse", body, position, impulse)
	log.Println("  Function successfully completed.")

}

/*
   Gives the body a push to rotate it.
*/
func (o *physicsServer) BodyApplyTorqueImpulse(body *RID, impulse *Vector3) {
	log.Println("Calling PhysicsServer.BodyApplyTorqueImpulse()")

	godotCallVoidRidVector3(o, "body_apply_torque_impulse", body, impulse)
	log.Println("  Function successfully completed.")

}

/*
   Assigns the area to a descendant of [Object], so it can exist in the node tree.
*/
func (o *physicsServer) BodyAttachObjectInstanceId(body *RID, id int64) {
	log.Println("Calling PhysicsServer.BodyAttachObjectInstanceId()")

	godotCallVoidRidInt(o, "body_attach_object_instance_id", body, id)
	log.Println("  Function successfully completed.")

}

/*
   Removes all shapes from a body.
*/
func (o *physicsServer) BodyClearShapes(body *RID) {
	log.Println("Calling PhysicsServer.BodyClearShapes()")

	godotCallVoidRid(o, "body_clear_shapes", body)
	log.Println("  Function successfully completed.")

}

/*
   Creates a physics body. The first parameter can be any value from constants BODY_MODE*, for the type of body created. Additionally, the body can be created in sleeping state to save processing time.
*/
func (o *physicsServer) BodyCreate(mode int64, initSleeping bool) *RID {
	log.Println("Calling PhysicsServer.BodyCreate()")

	returnValue := godotCallRidIntBool(o, "body_create", mode, initSleeping)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the physics layer or layers a body belongs to.
*/
func (o *physicsServer) BodyGetCollisionLayer(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetCollisionLayer()")

	returnValue := godotCallIntRid(o, "body_get_collision_layer", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
                Returns the physics layer or layers a body can collide with.
-
*/
func (o *physicsServer) BodyGetCollisionMask(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetCollisionMask()")

	returnValue := godotCallIntRid(o, "body_get_collision_mask", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [PhysicsDirectBodyState] of the body.
*/
func (o *physicsServer) BodyGetDirectState(body *RID) *PhysicsDirectBodyState {
	log.Println("Calling PhysicsServer.BodyGetDirectState()")

	returnValue := godotCallObjectRid(o, "body_get_direct_state", body)
	log.Println("  Got return value: ", returnValue)

	var ret PhysicsDirectBodyState
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *physicsServer) BodyGetKinematicSafeMargin(body *RID) float64 {
	log.Println("Calling PhysicsServer.BodyGetKinematicSafeMargin()")

	returnValue := godotCallFloatRid(o, "body_get_kinematic_safe_margin", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the maximum contacts that can be reported. See [method body_set_max_contacts_reported].
*/
func (o *physicsServer) BodyGetMaxContactsReported(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetMaxContactsReported()")

	returnValue := godotCallIntRid(o, "body_get_max_contacts_reported", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the body mode.
*/
func (o *physicsServer) BodyGetMode(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetMode()")

	returnValue := godotCallIntRid(o, "body_get_mode", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Gets the instance ID of the object the area is assigned to.
*/
func (o *physicsServer) BodyGetObjectInstanceId(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetObjectInstanceId()")

	returnValue := godotCallIntRid(o, "body_get_object_instance_id", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the value of a body parameter. A list of available parameters is on the BODY_PARAM_* constants.
*/
func (o *physicsServer) BodyGetParam(body *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.BodyGetParam()")

	returnValue := godotCallFloatRidInt(o, "body_get_param", body, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [RID] of the nth shape of a body.
*/
func (o *physicsServer) BodyGetShape(body *RID, shapeIdx int64) *RID {
	log.Println("Calling PhysicsServer.BodyGetShape()")

	returnValue := godotCallRidRidInt(o, "body_get_shape", body, shapeIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of shapes assigned to a body.
*/
func (o *physicsServer) BodyGetShapeCount(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetShapeCount()")

	returnValue := godotCallIntRid(o, "body_get_shape_count", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the transform matrix of a body shape.
*/
func (o *physicsServer) BodyGetShapeTransform(body *RID, shapeIdx int64) *Transform {
	log.Println("Calling PhysicsServer.BodyGetShapeTransform()")

	returnValue := godotCallTransformRidInt(o, "body_get_shape_transform", body, shapeIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [RID] of the space assigned to a body.
*/
func (o *physicsServer) BodyGetSpace(body *RID) *RID {
	log.Println("Calling PhysicsServer.BodyGetSpace()")

	returnValue := godotCallRidRid(o, "body_get_space", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a body state.
*/
func (o *physicsServer) BodyGetState(body *RID, state int64) *Variant {
	log.Println("Calling PhysicsServer.BodyGetState()")

	returnValue := godotCallVariantRidInt(o, "body_get_state", body, state)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *physicsServer) BodyIsAxisLocked(body *RID, axis int64) bool {
	log.Println("Calling PhysicsServer.BodyIsAxisLocked()")

	returnValue := godotCallBoolRidInt(o, "body_is_axis_locked", body, axis)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the continuous collision detection mode is enabled.
*/
func (o *physicsServer) BodyIsContinuousCollisionDetectionEnabled(body *RID) bool {
	log.Println("Calling PhysicsServer.BodyIsContinuousCollisionDetectionEnabled()")

	returnValue := godotCallBoolRid(o, "body_is_continuous_collision_detection_enabled", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether a body uses a callback function to calculate its own physics (see [method body_set_force_integration_callback]).
*/
func (o *physicsServer) BodyIsOmittingForceIntegration(body *RID) bool {
	log.Println("Calling PhysicsServer.BodyIsOmittingForceIntegration()")

	returnValue := godotCallBoolRid(o, "body_is_omitting_force_integration", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the body can be detected by rays
*/
func (o *physicsServer) BodyIsRayPickable(body *RID) bool {
	log.Println("Calling PhysicsServer.BodyIsRayPickable()")

	returnValue := godotCallBoolRid(o, "body_is_ray_pickable", body)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a body from the list of bodies exempt from collisions. Continuous collision detection tries to predict where a moving body will collide, instead of moving it and correcting its movement if it collided.
*/
func (o *physicsServer) BodyRemoveCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling PhysicsServer.BodyRemoveCollisionException()")

	godotCallVoidRidRid(o, "body_remove_collision_exception", body, exceptedBody)
	log.Println("  Function successfully completed.")

}

/*
   Removes a shape from a body. The shape is not deleted, so it can be reused afterwards.
*/
func (o *physicsServer) BodyRemoveShape(body *RID, shapeIdx int64) {
	log.Println("Calling PhysicsServer.BodyRemoveShape()")

	godotCallVoidRidInt(o, "body_remove_shape", body, shapeIdx)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *physicsServer) BodySetAxisLock(body *RID, axis int64, lock bool) {
	log.Println("Calling PhysicsServer.BodySetAxisLock()")

	godotCallVoidRidIntBool(o, "body_set_axis_lock", body, axis, lock)
	log.Println("  Function successfully completed.")

}

/*
   Sets an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *physicsServer) BodySetAxisVelocity(body *RID, axisVelocity *Vector3) {
	log.Println("Calling PhysicsServer.BodySetAxisVelocity()")

	godotCallVoidRidVector3(o, "body_set_axis_velocity", body, axisVelocity)
	log.Println("  Function successfully completed.")

}

/*
   Sets the physics layer or layers a body belongs to.
*/
func (o *physicsServer) BodySetCollisionLayer(body *RID, layer int64) {
	log.Println("Calling PhysicsServer.BodySetCollisionLayer()")

	godotCallVoidRidInt(o, "body_set_collision_layer", body, layer)
	log.Println("  Function successfully completed.")

}

/*
   Sets the physics layer or layers a body can collide with.
*/
func (o *physicsServer) BodySetCollisionMask(body *RID, mask int64) {
	log.Println("Calling PhysicsServer.BodySetCollisionMask()")

	godotCallVoidRidInt(o, "body_set_collision_mask", body, mask)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the continuous collision detection mode is enabled. Continuous collision detection tries to predict where a moving body will collide, instead of moving it and correcting its movement if it collided.
*/
func (o *physicsServer) BodySetEnableContinuousCollisionDetection(body *RID, enable bool) {
	log.Println("Calling PhysicsServer.BodySetEnableContinuousCollisionDetection()")

	godotCallVoidRidBool(o, "body_set_enable_continuous_collision_detection", body, enable)
	log.Println("  Function successfully completed.")

}

/*
   Sets the function used to calculate physics for an object, if that object allows it (see [method body_set_omit_force integration]).
*/
func (o *physicsServer) BodySetForceIntegrationCallback(body *RID, receiver *Object, method string, userdata *Variant) {
	log.Println("Calling PhysicsServer.BodySetForceIntegrationCallback()")

	godotCallVoidRidObjectStringVariant(o, "body_set_force_integration_callback", body, receiver, method, userdata)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *physicsServer) BodySetKinematicSafeMargin(body *RID, margin float64) {
	log.Println("Calling PhysicsServer.BodySetKinematicSafeMargin()")

	godotCallVoidRidFloat(o, "body_set_kinematic_safe_margin", body, margin)
	log.Println("  Function successfully completed.")

}

/*
   Sets the maximum contacts to report. Bodies can keep a log of the contacts with other bodies, this is enabled by setting the maximum amount of contacts reported to a number greater than 0.
*/
func (o *physicsServer) BodySetMaxContactsReported(body *RID, amount int64) {
	log.Println("Calling PhysicsServer.BodySetMaxContactsReported()")

	godotCallVoidRidInt(o, "body_set_max_contacts_reported", body, amount)
	log.Println("  Function successfully completed.")

}

/*
   Sets the body mode, from one of the constants BODY_MODE*.
*/
func (o *physicsServer) BodySetMode(body *RID, mode int64) {
	log.Println("Calling PhysicsServer.BodySetMode()")

	godotCallVoidRidInt(o, "body_set_mode", body, mode)
	log.Println("  Function successfully completed.")

}

/*
   Sets whether a body uses a callback function to calculate its own physics (see [method body_set_force_integration_callback]).
*/
func (o *physicsServer) BodySetOmitForceIntegration(body *RID, enable bool) {
	log.Println("Calling PhysicsServer.BodySetOmitForceIntegration()")

	godotCallVoidRidBool(o, "body_set_omit_force_integration", body, enable)
	log.Println("  Function successfully completed.")

}

/*
   Sets a body parameter. A list of available parameters is on the BODY_PARAM_* constants.
*/
func (o *physicsServer) BodySetParam(body *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.BodySetParam()")

	godotCallVoidRidIntFloat(o, "body_set_param", body, param, value)
	log.Println("  Function successfully completed.")

}

/*
   Sets the body pickable with rays if [code]enabled[/code] is set.
*/
func (o *physicsServer) BodySetRayPickable(body *RID, enable bool) {
	log.Println("Calling PhysicsServer.BodySetRayPickable()")

	godotCallVoidRidBool(o, "body_set_ray_pickable", body, enable)
	log.Println("  Function successfully completed.")

}

/*
   Substitutes a given body shape by another. The old shape is selected by its index, the new one by its [RID].
*/
func (o *physicsServer) BodySetShape(body *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling PhysicsServer.BodySetShape()")

	godotCallVoidRidIntRid(o, "body_set_shape", body, shapeIdx, shape)
	log.Println("  Function successfully completed.")

}

/*
   Sets the transform matrix for a body shape.
*/
func (o *physicsServer) BodySetShapeTransform(body *RID, shapeIdx int64, transform *Transform) {
	log.Println("Calling PhysicsServer.BodySetShapeTransform()")

	godotCallVoidRidIntTransform(o, "body_set_shape_transform", body, shapeIdx, transform)
	log.Println("  Function successfully completed.")

}

/*
   Assigns a space to the body (see [method create_space]).
*/
func (o *physicsServer) BodySetSpace(body *RID, space *RID) {
	log.Println("Calling PhysicsServer.BodySetSpace()")

	godotCallVoidRidRid(o, "body_set_space", body, space)
	log.Println("  Function successfully completed.")

}

/*
   Sets a body state (see BODY_STATE* constants).
*/
func (o *physicsServer) BodySetState(body *RID, state int64, value *Variant) {
	log.Println("Calling PhysicsServer.BodySetState()")

	godotCallVoidRidIntVariant(o, "body_set_state", body, state, value)
	log.Println("  Function successfully completed.")

}

/*
   Gets a cone_twist_joint parameter (see CONE_TWIST_JOINT* constants).
*/
func (o *physicsServer) ConeTwistJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.ConeTwistJointGetParam()")

	returnValue := godotCallFloatRidInt(o, "cone_twist_joint_get_param", joint, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets a cone_twist_joint parameter (see CONE_TWIST_JOINT* constants).
*/
func (o *physicsServer) ConeTwistJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.ConeTwistJointSetParam()")

	godotCallVoidRidIntFloat(o, "cone_twist_joint_set_param", joint, param, value)
	log.Println("  Function successfully completed.")

}

/*
   Destroys any of the objects created by PhysicsServer. If the [RID] passed is not one of the objects that can be created by PhysicsServer, an error will be sent to the console.
*/
func (o *physicsServer) FreeRid(rid *RID) {
	log.Println("Calling PhysicsServer.FreeRid()")

	godotCallVoidRid(o, "free_rid", rid)
	log.Println("  Function successfully completed.")

}

/*
   Gets a generic_6_DOF_joint flag (see G6DOF_JOINT_FLAG* constants).
*/
func (o *physicsServer) Generic6DofJointGetFlag(joint *RID, axis int64, flag int64) bool {
	log.Println("Calling PhysicsServer.Generic6DofJointGetFlag()")

	returnValue := godotCallBoolRidIntInt(o, "generic_6dof_joint_get_flag", joint, axis, flag)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Gets a generic_6_DOF_joint parameter (see G6DOF_JOINT* constants without the G6DOF_JOINT_FLAG*).
*/
func (o *physicsServer) Generic6DofJointGetParam(joint *RID, axis int64, param int64) float64 {
	log.Println("Calling PhysicsServer.Generic6DofJointGetParam()")

	returnValue := godotCallFloatRidIntInt(o, "generic_6dof_joint_get_param", joint, axis, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets a generic_6_DOF_joint flag (see G6DOF_JOINT_FLAG* constants).
*/
func (o *physicsServer) Generic6DofJointSetFlag(joint *RID, axis int64, flag int64, enable bool) {
	log.Println("Calling PhysicsServer.Generic6DofJointSetFlag()")

	godotCallVoidRidIntIntBool(o, "generic_6dof_joint_set_flag", joint, axis, flag, enable)
	log.Println("  Function successfully completed.")

}

/*
   Sets a generic_6_DOF_joint parameter (see G6DOF_JOINT* constants without the G6DOF_JOINT_FLAG*).
*/
func (o *physicsServer) Generic6DofJointSetParam(joint *RID, axis int64, param int64, value float64) {
	log.Println("Calling PhysicsServer.Generic6DofJointSetParam()")

	godotCallVoidRidIntIntFloat(o, "generic_6dof_joint_set_param", joint, axis, param, value)
	log.Println("  Function successfully completed.")

}

/*
   Returns an Info defined by the [ProcessInfo] input given.
*/
func (o *physicsServer) GetProcessInfo(processInfo int64) int64 {
	log.Println("Calling PhysicsServer.GetProcessInfo()")

	returnValue := godotCallIntInt(o, "get_process_info", processInfo)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Gets a hinge_joint flag (see HINGE_JOINT_FLAG* constants).
*/
func (o *physicsServer) HingeJointGetFlag(joint *RID, flag int64) bool {
	log.Println("Calling PhysicsServer.HingeJointGetFlag()")

	returnValue := godotCallBoolRidInt(o, "hinge_joint_get_flag", joint, flag)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Gets a hinge_joint parameter (see HINGE_JOINT* constants without the HINGE_JOINT_FLAG*).
*/
func (o *physicsServer) HingeJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.HingeJointGetParam()")

	returnValue := godotCallFloatRidInt(o, "hinge_joint_get_param", joint, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets a hinge_joint flag (see HINGE_JOINT_FLAG* constants).
*/
func (o *physicsServer) HingeJointSetFlag(joint *RID, flag int64, enabled bool) {
	log.Println("Calling PhysicsServer.HingeJointSetFlag()")

	godotCallVoidRidIntBool(o, "hinge_joint_set_flag", joint, flag, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets a hinge_joint parameter (see HINGE_JOINT* constants without the HINGE_JOINT_FLAG*).
*/
func (o *physicsServer) HingeJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.HingeJointSetParam()")

	godotCallVoidRidIntFloat(o, "hinge_joint_set_param", joint, param, value)
	log.Println("  Function successfully completed.")

}

/*
   Creates a [ConeTwistJoint].
*/
func (o *physicsServer) JointCreateConeTwist(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateConeTwist()")

	returnValue := godotCallRidRidTransformRidTransform(o, "joint_create_cone_twist", bodyA, localRefA, bodyB, localRefB)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Creates a [Generic6DOFJoint].
*/
func (o *physicsServer) JointCreateGeneric6Dof(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateGeneric6Dof()")

	returnValue := godotCallRidRidTransformRidTransform(o, "joint_create_generic_6dof", bodyA, localRefA, bodyB, localRefB)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Creates a [HingeJoint].
*/
func (o *physicsServer) JointCreateHinge(bodyA *RID, hingeA *Transform, bodyB *RID, hingeB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateHinge()")

	returnValue := godotCallRidRidTransformRidTransform(o, "joint_create_hinge", bodyA, hingeA, bodyB, hingeB)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Creates a [PinJoint].
*/
func (o *physicsServer) JointCreatePin(bodyA *RID, localA *Vector3, bodyB *RID, localB *Vector3) *RID {
	log.Println("Calling PhysicsServer.JointCreatePin()")

	returnValue := godotCallRidRidVector3RidVector3(o, "joint_create_pin", bodyA, localA, bodyB, localB)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Creates a [SliderJoint].
*/
func (o *physicsServer) JointCreateSlider(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateSlider()")

	returnValue := godotCallRidRidTransformRidTransform(o, "joint_create_slider", bodyA, localRefA, bodyB, localRefB)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Gets the priority value of the Joint.
*/
func (o *physicsServer) JointGetSolverPriority(joint *RID) int64 {
	log.Println("Calling PhysicsServer.JointGetSolverPriority()")

	returnValue := godotCallIntRid(o, "joint_get_solver_priority", joint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the type of the Joint.
*/
func (o *physicsServer) JointGetType(joint *RID) int64 {
	log.Println("Calling PhysicsServer.JointGetType()")

	returnValue := godotCallIntRid(o, "joint_get_type", joint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the priority value of the Joint.
*/
func (o *physicsServer) JointSetSolverPriority(joint *RID, priority int64) {
	log.Println("Calling PhysicsServer.JointSetSolverPriority()")

	godotCallVoidRidInt(o, "joint_set_solver_priority", joint, priority)
	log.Println("  Function successfully completed.")

}

/*
   Returns position of the joint in the local space of body a of the joint.
*/
func (o *physicsServer) PinJointGetLocalA(joint *RID) *Vector3 {
	log.Println("Calling PhysicsServer.PinJointGetLocalA()")

	returnValue := godotCallVector3Rid(o, "pin_joint_get_local_a", joint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns position of the joint in the local space of body b of the joint.
*/
func (o *physicsServer) PinJointGetLocalB(joint *RID) *Vector3 {
	log.Println("Calling PhysicsServer.PinJointGetLocalB()")

	returnValue := godotCallVector3Rid(o, "pin_joint_get_local_b", joint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Gets a pin_joint parameter (see PIN_JOINT* constants).
*/
func (o *physicsServer) PinJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.PinJointGetParam()")

	returnValue := godotCallFloatRidInt(o, "pin_joint_get_param", joint, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets position of the joint in the local space of body a of the joint.
*/
func (o *physicsServer) PinJointSetLocalA(joint *RID, localA *Vector3) {
	log.Println("Calling PhysicsServer.PinJointSetLocalA()")

	godotCallVoidRidVector3(o, "pin_joint_set_local_a", joint, localA)
	log.Println("  Function successfully completed.")

}

/*
   Sets position of the joint in the local space of body b of the joint.
*/
func (o *physicsServer) PinJointSetLocalB(joint *RID, localB *Vector3) {
	log.Println("Calling PhysicsServer.PinJointSetLocalB()")

	godotCallVoidRidVector3(o, "pin_joint_set_local_b", joint, localB)
	log.Println("  Function successfully completed.")

}

/*
   Sets a pin_joint parameter (see PIN_JOINT* constants).
*/
func (o *physicsServer) PinJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.PinJointSetParam()")

	godotCallVoidRidIntFloat(o, "pin_joint_set_param", joint, param, value)
	log.Println("  Function successfully completed.")

}

/*
   Activates or deactivates the 3D physics engine.
*/
func (o *physicsServer) SetActive(active bool) {
	log.Println("Calling PhysicsServer.SetActive()")

	godotCallVoidBool(o, "set_active", active)
	log.Println("  Function successfully completed.")

}

/*
   Creates a shape of type SHAPE_*. Does not assign it to a body or an area. To do so, you must use [method area_set_shape] or [method body_set_shape].
*/
func (o *physicsServer) ShapeCreate(aType int64) *RID {
	log.Println("Calling PhysicsServer.ShapeCreate()")

	returnValue := godotCallRidInt(o, "shape_create", aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the shape data.
*/
func (o *physicsServer) ShapeGetData(shape *RID) *Variant {
	log.Println("Calling PhysicsServer.ShapeGetData()")

	returnValue := godotCallVariantRid(o, "shape_get_data", shape)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the type of shape (see SHAPE_* constants).
*/
func (o *physicsServer) ShapeGetType(shape *RID) int64 {
	log.Println("Calling PhysicsServer.ShapeGetType()")

	returnValue := godotCallIntRid(o, "shape_get_type", shape)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the shape data that defines its shape and size. The data to be passed depends on the kind of shape created [method shape_get_type].
*/
func (o *physicsServer) ShapeSetData(shape *RID, data *Variant) {
	log.Println("Calling PhysicsServer.ShapeSetData()")

	godotCallVoidRidVariant(o, "shape_set_data", shape, data)
	log.Println("  Function successfully completed.")

}

/*
   Gets a slider_joint parameter (see SLIDER_JOINT* constants).
*/
func (o *physicsServer) SliderJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.SliderJointGetParam()")

	returnValue := godotCallFloatRidInt(o, "slider_joint_get_param", joint, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Gets a slider_joint parameter (see SLIDER_JOINT* constants).
*/
func (o *physicsServer) SliderJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.SliderJointSetParam()")

	godotCallVoidRidIntFloat(o, "slider_joint_set_param", joint, param, value)
	log.Println("  Function successfully completed.")

}

/*
   Creates a space. A space is a collection of parameters for the physics engine that can be assigned to an area or a body. It can be assigned to an area with [method area_set_space], or to a body with [method body_set_space].
*/
func (o *physicsServer) SpaceCreate() *RID {
	log.Println("Calling PhysicsServer.SpaceCreate()")

	returnValue := godotCallRid(o, "space_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the state of a space, a [PhysicsDirectSpaceState]. This object can be used to make collision/intersection queries.
*/
func (o *physicsServer) SpaceGetDirectState(space *RID) *PhysicsDirectSpaceState {
	log.Println("Calling PhysicsServer.SpaceGetDirectState()")

	returnValue := godotCallObjectRid(o, "space_get_direct_state", space)
	log.Println("  Got return value: ", returnValue)

	var ret PhysicsDirectSpaceState
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the value of a space parameter.
*/
func (o *physicsServer) SpaceGetParam(space *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.SpaceGetParam()")

	returnValue := godotCallFloatRidInt(o, "space_get_param", space, param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether the space is active.
*/
func (o *physicsServer) SpaceIsActive(space *RID) bool {
	log.Println("Calling PhysicsServer.SpaceIsActive()")

	returnValue := godotCallBoolRid(o, "space_is_active", space)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Marks a space as active. It will not have an effect, unless it is assigned to an area or body.
*/
func (o *physicsServer) SpaceSetActive(space *RID, active bool) {
	log.Println("Calling PhysicsServer.SpaceSetActive()")

	godotCallVoidRidBool(o, "space_set_active", space, active)
	log.Println("  Function successfully completed.")

}

/*
   Sets the value for a space parameter. A list of available parameters is on the SPACE_PARAM_* constants.
*/
func (o *physicsServer) SpaceSetParam(space *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.SpaceSetParam()")

	godotCallVoidRidIntFloat(o, "space_set_param", space, param, value)
	log.Println("  Function successfully completed.")

}

/*

 */
type PhysicsShapeQueryParameters struct {
	Reference
}

func (o *PhysicsShapeQueryParameters) baseClass() string {
	return "PhysicsShapeQueryParameters"
}

/*
   Undocumented
*/
func (o *PhysicsShapeQueryParameters) GetCollisionMask() int64 {
	log.Println("Calling PhysicsShapeQueryParameters.GetCollisionMask()")

	returnValue := godotCallInt(o, "get_collision_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsShapeQueryParameters) GetExclude() *Array {
	log.Println("Calling PhysicsShapeQueryParameters.GetExclude()")

	returnValue := godotCallArray(o, "get_exclude")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsShapeQueryParameters) GetMargin() float64 {
	log.Println("Calling PhysicsShapeQueryParameters.GetMargin()")

	returnValue := godotCallFloat(o, "get_margin")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsShapeQueryParameters) GetShapeRid() *RID {
	log.Println("Calling PhysicsShapeQueryParameters.GetShapeRid()")

	returnValue := godotCallRid(o, "get_shape_rid")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsShapeQueryParameters) GetTransform() *Transform {
	log.Println("Calling PhysicsShapeQueryParameters.GetTransform()")

	returnValue := godotCallTransform(o, "get_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PhysicsShapeQueryParameters) SetCollisionMask(collisionMask int64) {
	log.Println("Calling PhysicsShapeQueryParameters.SetCollisionMask()")

	godotCallVoidInt(o, "set_collision_mask", collisionMask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsShapeQueryParameters) SetExclude(exclude *Array) {
	log.Println("Calling PhysicsShapeQueryParameters.SetExclude()")

	godotCallVoidArray(o, "set_exclude", exclude)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsShapeQueryParameters) SetMargin(margin float64) {
	log.Println("Calling PhysicsShapeQueryParameters.SetMargin()")

	godotCallVoidFloat(o, "set_margin", margin)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetShape(shape *Resource) {
	log.Println("Calling PhysicsShapeQueryParameters.SetShape()")

	godotCallVoidObject(o, "set_shape", &shape.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsShapeQueryParameters) SetShapeRid(shape *RID) {
	log.Println("Calling PhysicsShapeQueryParameters.SetShapeRid()")

	godotCallVoidRid(o, "set_shape_rid", shape)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PhysicsShapeQueryParameters) SetTransform(transform *Transform) {
	log.Println("Calling PhysicsShapeQueryParameters.SetTransform()")

	godotCallVoidTransform(o, "set_transform", transform)
	log.Println("  Function successfully completed.")

}

/*
   PhysicsShapeQueryParametersImplementer is an interface for PhysicsShapeQueryParameters objects.
*/
type PhysicsShapeQueryParametersImplementer interface {
	Class
}

/*

 */
type PhysicsShapeQueryResult struct {
	Reference
}

func (o *PhysicsShapeQueryResult) baseClass() string {
	return "PhysicsShapeQueryResult"
}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultCount() int64 {
	log.Println("Calling PhysicsShapeQueryResult.GetResultCount()")

	returnValue := godotCallInt(o, "get_result_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultObject(idx int64) *Object {
	log.Println("Calling PhysicsShapeQueryResult.GetResultObject()")

	returnValue := godotCallObjectInt(o, "get_result_object", idx)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultObjectId(idx int64) int64 {
	log.Println("Calling PhysicsShapeQueryResult.GetResultObjectId()")

	returnValue := godotCallIntInt(o, "get_result_object_id", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultObjectShape(idx int64) int64 {
	log.Println("Calling PhysicsShapeQueryResult.GetResultObjectShape()")

	returnValue := godotCallIntInt(o, "get_result_object_shape", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultRid(idx int64) *RID {
	log.Println("Calling PhysicsShapeQueryResult.GetResultRid()")

	returnValue := godotCallRidInt(o, "get_result_rid", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   PhysicsShapeQueryResultImplementer is an interface for PhysicsShapeQueryResult objects.
*/
type PhysicsShapeQueryResultImplementer interface {
	Class
}

/*
   Pin Joint for 3D Rigid Bodies. It pins 2 bodies (rigid or static) together.
*/
type PinJoint struct {
	Joint
}

func (o *PinJoint) baseClass() string {
	return "PinJoint"
}

/*
   Undocumented
*/
func (o *PinJoint) GetParam(param int64) float64 {
	log.Println("Calling PinJoint.GetParam()")

	returnValue := godotCallFloatInt(o, "get_param", param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PinJoint) SetParam(param int64, value float64) {
	log.Println("Calling PinJoint.SetParam()")

	godotCallVoidIntFloat(o, "set_param", param, value)
	log.Println("  Function successfully completed.")

}

/*
   PinJointImplementer is an interface for PinJoint objects.
*/
type PinJointImplementer interface {
	Class
}

/*
   Pin Joint for 2D Rigid Bodies. It pins 2 bodies (rigid or static) together, or a single body to a fixed position in space.
*/
type PinJoint2D struct {
	Joint2D
}

func (o *PinJoint2D) baseClass() string {
	return "PinJoint2D"
}

/*
   Undocumented
*/
func (o *PinJoint2D) GetSoftness() float64 {
	log.Println("Calling PinJoint2D.GetSoftness()")

	returnValue := godotCallFloat(o, "get_softness")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PinJoint2D) SetSoftness(softness float64) {
	log.Println("Calling PinJoint2D.SetSoftness()")

	godotCallVoidFloat(o, "set_softness", softness)
	log.Println("  Function successfully completed.")

}

/*
   PinJoint2DImplementer is an interface for PinJoint2D objects.
*/
type PinJoint2DImplementer interface {
	Class
}

/*
   Class representing a planar [PrimitiveMesh]. This flat mesh does not have a thickness.
*/
type PlaneMesh struct {
	PrimitiveMesh
}

func (o *PlaneMesh) baseClass() string {
	return "PlaneMesh"
}

/*
   Undocumented
*/
func (o *PlaneMesh) GetSize() *Vector2 {
	log.Println("Calling PlaneMesh.GetSize()")

	returnValue := godotCallVector2(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PlaneMesh) GetSubdivideDepth() int64 {
	log.Println("Calling PlaneMesh.GetSubdivideDepth()")

	returnValue := godotCallInt(o, "get_subdivide_depth")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PlaneMesh) GetSubdivideWidth() int64 {
	log.Println("Calling PlaneMesh.GetSubdivideWidth()")

	returnValue := godotCallInt(o, "get_subdivide_width")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PlaneMesh) SetSize(size *Vector2) {
	log.Println("Calling PlaneMesh.SetSize()")

	godotCallVoidVector2(o, "set_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PlaneMesh) SetSubdivideDepth(subdivide int64) {
	log.Println("Calling PlaneMesh.SetSubdivideDepth()")

	godotCallVoidInt(o, "set_subdivide_depth", subdivide)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PlaneMesh) SetSubdivideWidth(subdivide int64) {
	log.Println("Calling PlaneMesh.SetSubdivideWidth()")

	godotCallVoidInt(o, "set_subdivide_width", subdivide)
	log.Println("  Function successfully completed.")

}

/*
   PlaneMeshImplementer is an interface for PlaneMesh objects.
*/
type PlaneMeshImplementer interface {
	Class
}

/*

 */
type PlaneShape struct {
	Shape
}

func (o *PlaneShape) baseClass() string {
	return "PlaneShape"
}

/*
   Undocumented
*/
func (o *PlaneShape) GetPlane() *Plane {
	log.Println("Calling PlaneShape.GetPlane()")

	returnValue := godotCallPlane(o, "get_plane")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PlaneShape) SetPlane(plane *Plane) {
	log.Println("Calling PlaneShape.SetPlane()")

	godotCallVoidPlane(o, "set_plane", plane)
	log.Println("  Function successfully completed.")

}

/*
   PlaneShapeImplementer is an interface for PlaneShape objects.
*/
type PlaneShapeImplementer interface {
	Class
}

/*
   Undocumented
*/
type PluginScript struct {
	Script
}

func (o *PluginScript) baseClass() string {
	return "PluginScript"
}

/*
   PluginScriptImplementer is an interface for PluginScript objects.
*/
type PluginScriptImplementer interface {
	Class
}

/*
   A Polygon2D is defined by a set of points. Each point is connected to the next, with the final point being connected to the first, resulting in a closed polygon. Polygon2Ds can be filled with color (solid or gradient) or filled with a given texture.
*/
type Polygon2D struct {
	Node2D
}

func (o *Polygon2D) baseClass() string {
	return "Polygon2D"
}

/*
   Undocumented
*/
func (o *Polygon2D) GetAntialiased() bool {
	log.Println("Calling Polygon2D.GetAntialiased()")

	returnValue := godotCallBool(o, "get_antialiased")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) GetColor() *Color {
	log.Println("Calling Polygon2D.GetColor()")

	returnValue := godotCallColor(o, "get_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) GetInvert() bool {
	log.Println("Calling Polygon2D.GetInvert()")

	returnValue := godotCallBool(o, "get_invert")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) GetInvertBorder() float64 {
	log.Println("Calling Polygon2D.GetInvertBorder()")

	returnValue := godotCallFloat(o, "get_invert_border")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) GetOffset() *Vector2 {
	log.Println("Calling Polygon2D.GetOffset()")

	returnValue := godotCallVector2(o, "get_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) GetPolygon() *PoolVector2Array {
	log.Println("Calling Polygon2D.GetPolygon()")

	returnValue := godotCallPoolVector2Array(o, "get_polygon")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) GetTexture() *Texture {
	log.Println("Calling Polygon2D.GetTexture()")

	returnValue := godotCallObject(o, "get_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Polygon2D) GetTextureOffset() *Vector2 {
	log.Println("Calling Polygon2D.GetTextureOffset()")

	returnValue := godotCallVector2(o, "get_texture_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) GetTextureRotation() float64 {
	log.Println("Calling Polygon2D.GetTextureRotation()")

	returnValue := godotCallFloat(o, "get_texture_rotation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) GetTextureRotationDegrees() float64 {
	log.Println("Calling Polygon2D.GetTextureRotationDegrees()")

	returnValue := godotCallFloat(o, "get_texture_rotation_degrees")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) GetTextureScale() *Vector2 {
	log.Println("Calling Polygon2D.GetTextureScale()")

	returnValue := godotCallVector2(o, "get_texture_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) GetUv() *PoolVector2Array {
	log.Println("Calling Polygon2D.GetUv()")

	returnValue := godotCallPoolVector2Array(o, "get_uv")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) GetVertexColors() *PoolColorArray {
	log.Println("Calling Polygon2D.GetVertexColors()")

	returnValue := godotCallPoolColorArray(o, "get_vertex_colors")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Polygon2D) SetAntialiased(antialiased bool) {
	log.Println("Calling Polygon2D.SetAntialiased()")

	godotCallVoidBool(o, "set_antialiased", antialiased)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetColor(color *Color) {
	log.Println("Calling Polygon2D.SetColor()")

	godotCallVoidColor(o, "set_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetInvert(invert bool) {
	log.Println("Calling Polygon2D.SetInvert()")

	godotCallVoidBool(o, "set_invert", invert)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetInvertBorder(invertBorder float64) {
	log.Println("Calling Polygon2D.SetInvertBorder()")

	godotCallVoidFloat(o, "set_invert_border", invertBorder)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetOffset(offset *Vector2) {
	log.Println("Calling Polygon2D.SetOffset()")

	godotCallVoidVector2(o, "set_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling Polygon2D.SetPolygon()")

	godotCallVoidPoolVector2Array(o, "set_polygon", polygon)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetTexture(texture *Texture) {
	log.Println("Calling Polygon2D.SetTexture()")

	godotCallVoidObject(o, "set_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetTextureOffset(textureOffset *Vector2) {
	log.Println("Calling Polygon2D.SetTextureOffset()")

	godotCallVoidVector2(o, "set_texture_offset", textureOffset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetTextureRotation(textureRotation float64) {
	log.Println("Calling Polygon2D.SetTextureRotation()")

	godotCallVoidFloat(o, "set_texture_rotation", textureRotation)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetTextureRotationDegrees(textureRotation float64) {
	log.Println("Calling Polygon2D.SetTextureRotationDegrees()")

	godotCallVoidFloat(o, "set_texture_rotation_degrees", textureRotation)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetTextureScale(textureScale *Vector2) {
	log.Println("Calling Polygon2D.SetTextureScale()")

	godotCallVoidVector2(o, "set_texture_scale", textureScale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetUv(uv *PoolVector2Array) {
	log.Println("Calling Polygon2D.SetUv()")

	godotCallVoidPoolVector2Array(o, "set_uv", uv)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Polygon2D) SetVertexColors(vertexColors *PoolColorArray) {
	log.Println("Calling Polygon2D.SetVertexColors()")

	godotCallVoidPoolColorArray(o, "set_vertex_colors", vertexColors)
	log.Println("  Function successfully completed.")

}

/*
   Polygon2DImplementer is an interface for Polygon2D objects.
*/
type Polygon2DImplementer interface {
	Class
}

/*

 */
type PolygonPathFinder struct {
	Resource
}

func (o *PolygonPathFinder) baseClass() string {
	return "PolygonPathFinder"
}

/*
   Undocumented
*/
func (o *PolygonPathFinder) X_GetData() *Dictionary {
	log.Println("Calling PolygonPathFinder.X_GetData()")

	returnValue := godotCallDictionary(o, "_get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PolygonPathFinder) X_SetData(arg0 *Dictionary) {
	log.Println("Calling PolygonPathFinder.X_SetData()")

	godotCallVoidDictionary(o, "_set_data", arg0)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PolygonPathFinder) FindPath(from *Vector2, to *Vector2) *PoolVector2Array {
	log.Println("Calling PolygonPathFinder.FindPath()")

	returnValue := godotCallPoolVector2ArrayVector2Vector2(o, "find_path", from, to)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) GetBounds() *Rect2 {
	log.Println("Calling PolygonPathFinder.GetBounds()")

	returnValue := godotCallRect2(o, "get_bounds")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) GetClosestPoint(point *Vector2) *Vector2 {
	log.Println("Calling PolygonPathFinder.GetClosestPoint()")

	returnValue := godotCallVector2Vector2(o, "get_closest_point", point)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) GetIntersections(from *Vector2, to *Vector2) *PoolVector2Array {
	log.Println("Calling PolygonPathFinder.GetIntersections()")

	returnValue := godotCallPoolVector2ArrayVector2Vector2(o, "get_intersections", from, to)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) GetPointPenalty(idx int64) float64 {
	log.Println("Calling PolygonPathFinder.GetPointPenalty()")

	returnValue := godotCallFloatInt(o, "get_point_penalty", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) IsPointInside(point *Vector2) bool {
	log.Println("Calling PolygonPathFinder.IsPointInside()")

	returnValue := godotCallBoolVector2(o, "is_point_inside", point)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) SetPointPenalty(idx int64, penalty float64) {
	log.Println("Calling PolygonPathFinder.SetPointPenalty()")

	godotCallVoidIntFloat(o, "set_point_penalty", idx, penalty)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PolygonPathFinder) Setup(points *PoolVector2Array, connections *PoolIntArray) {
	log.Println("Calling PolygonPathFinder.Setup()")

	godotCallVoidPoolVector2ArrayPoolIntArray(o, "setup", points, connections)
	log.Println("  Function successfully completed.")

}

/*
   PolygonPathFinderImplementer is an interface for PolygonPathFinder objects.
*/
type PolygonPathFinderImplementer interface {
	Class
}

/*
   Popup is a base [Control] used to show dialogs and popups. It's a subwindow and modal by default (see [Control]) and has helpers for custom popup behavior.
*/
type Popup struct {
	Control
}

func (o *Popup) baseClass() string {
	return "Popup"
}

/*
   Undocumented
*/
func (o *Popup) IsExclusive() bool {
	log.Println("Calling Popup.IsExclusive()")

	returnValue := godotCallBool(o, "is_exclusive")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Popup (show the control in modal form).
*/
func (o *Popup) Popup(bounds *Rect2) {
	log.Println("Calling Popup.Popup()")

	godotCallVoidRect2(o, "popup", bounds)
	log.Println("  Function successfully completed.")

}

/*
   Popup (show the control in modal form) in the center of the screen, at the current size, or at a size determined by "size".
*/
func (o *Popup) PopupCentered(size *Vector2) {
	log.Println("Calling Popup.PopupCentered()")

	godotCallVoidVector2(o, "popup_centered", size)
	log.Println("  Function successfully completed.")

}

/*
   Popup (show the control in modal form) in the center of the screen, ensuring the size is never smaller than [code]minsize[/code].
*/
func (o *Popup) PopupCenteredMinsize(minsize *Vector2) {
	log.Println("Calling Popup.PopupCenteredMinsize()")

	godotCallVoidVector2(o, "popup_centered_minsize", minsize)
	log.Println("  Function successfully completed.")

}

/*
   Popup (show the control in modal form) in the center of the screen, scaled at a ratio of size of the screen.
*/
func (o *Popup) PopupCenteredRatio(ratio float64) {
	log.Println("Calling Popup.PopupCenteredRatio()")

	godotCallVoidFloat(o, "popup_centered_ratio", ratio)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Popup) SetExclusive(enable bool) {
	log.Println("Calling Popup.SetExclusive()")

	godotCallVoidBool(o, "set_exclusive", enable)
	log.Println("  Function successfully completed.")

}

/*
   PopupImplementer is an interface for Popup objects.
*/
type PopupImplementer interface {
	Class
}

/*
   PopupDialog is a base class for popup dialogs, along with [WindowDialog].
*/
type PopupDialog struct {
	Popup
}

func (o *PopupDialog) baseClass() string {
	return "PopupDialog"
}

/*
   PopupDialogImplementer is an interface for PopupDialog objects.
*/
type PopupDialogImplementer interface {
	Class
}

/*
   PopupMenu is the typical Control that displays a list of options. They are popular in toolbars or context menus.
*/
type PopupMenu struct {
	Popup
}

func (o *PopupMenu) baseClass() string {
	return "PopupMenu"
}

/*
   Undocumented
*/
func (o *PopupMenu) X_GetItems() *Array {
	log.Println("Calling PopupMenu.X_GetItems()")

	returnValue := godotCallArray(o, "_get_items")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PopupMenu) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling PopupMenu.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PopupMenu) X_SetItems(arg0 *Array) {
	log.Println("Calling PopupMenu.X_SetItems()")

	godotCallVoidArray(o, "_set_items", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PopupMenu) X_SubmenuTimeout() {
	log.Println("Calling PopupMenu.X_SubmenuTimeout()")

	godotCallVoid(o, "_submenu_timeout")
	log.Println("  Function successfully completed.")

}

/*
   Add a new checkable item with text "label". An id can optionally be provided, as well as an accelerator. If no id is provided, one will be created from the index. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) AddCheckItem(label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddCheckItem()")

	godotCallVoidStringIntInt(o, "add_check_item", label, id, accel)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PopupMenu) AddCheckShortcut(shortcut *ShortCut, id int64, global bool) {
	log.Println("Calling PopupMenu.AddCheckShortcut()")

	godotCallVoidObjectIntBool(o, "add_check_shortcut", &shortcut.Object, id, global)
	log.Println("  Function successfully completed.")

}

/*
   Add a new checkable item with text "label" and icon "texture". An id can optionally be provided, as well as an accelerator. If no id is provided, one will be created from the index. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) AddIconCheckItem(texture *Texture, label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddIconCheckItem()")

	godotCallVoidObjectStringIntInt(o, "add_icon_check_item", &texture.Object, label, id, accel)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PopupMenu) AddIconCheckShortcut(texture *Texture, shortcut *ShortCut, id int64, global bool) {
	log.Println("Calling PopupMenu.AddIconCheckShortcut()")

	godotCallVoidObjectObjectIntBool(o, "add_icon_check_shortcut", &texture.Object, &shortcut.Object, id, global)
	log.Println("  Function successfully completed.")

}

/*
   Add a new item with text "label" and icon "texture". An id can optionally be provided, as well as an accelerator keybinding. If no id is provided, one will be created from the index.
*/
func (o *PopupMenu) AddIconItem(texture *Texture, label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddIconItem()")

	godotCallVoidObjectStringIntInt(o, "add_icon_item", &texture.Object, label, id, accel)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PopupMenu) AddIconShortcut(texture *Texture, shortcut *ShortCut, id int64, global bool) {
	log.Println("Calling PopupMenu.AddIconShortcut()")

	godotCallVoidObjectObjectIntBool(o, "add_icon_shortcut", &texture.Object, &shortcut.Object, id, global)
	log.Println("  Function successfully completed.")

}

/*
   Add a new item with text "label". An id can optionally be provided, as well as an accelerator keybinding. If no id is provided, one will be created from the index.
*/
func (o *PopupMenu) AddItem(label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddItem()")

	godotCallVoidStringIntInt(o, "add_item", label, id, accel)
	log.Println("  Function successfully completed.")

}

/*
   Add a separator between items. Separators also occupy an index.
*/
func (o *PopupMenu) AddSeparator() {
	log.Println("Calling PopupMenu.AddSeparator()")

	godotCallVoid(o, "add_separator")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PopupMenu) AddShortcut(shortcut *ShortCut, id int64, global bool) {
	log.Println("Calling PopupMenu.AddShortcut()")

	godotCallVoidObjectIntBool(o, "add_shortcut", &shortcut.Object, id, global)
	log.Println("  Function successfully completed.")

}

/*
   Adds an item with a submenu. The submenu is the name of a child PopupMenu node that would be shown when the item is clicked. An id can optionally be provided, but if is isn't provided, one will be created from the index.
*/
func (o *PopupMenu) AddSubmenuItem(label string, submenu string, id int64) {
	log.Println("Calling PopupMenu.AddSubmenuItem()")

	godotCallVoidStringStringInt(o, "add_submenu_item", label, submenu, id)
	log.Println("  Function successfully completed.")

}

/*
   Clear the popup menu, in effect removing all items.
*/
func (o *PopupMenu) Clear() {
	log.Println("Calling PopupMenu.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Return the accelerator of the item at index "idx". Accelerators are special combinations of keys that activate the item, no matter which control is focused.
*/
func (o *PopupMenu) GetItemAccelerator(idx int64) int64 {
	log.Println("Calling PopupMenu.GetItemAccelerator()")

	returnValue := godotCallIntInt(o, "get_item_accelerator", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the amount of items.
*/
func (o *PopupMenu) GetItemCount() int64 {
	log.Println("Calling PopupMenu.GetItemCount()")

	returnValue := godotCallInt(o, "get_item_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the icon of the item at index "idx".
*/
func (o *PopupMenu) GetItemIcon(idx int64) *Texture {
	log.Println("Calling PopupMenu.GetItemIcon()")

	returnValue := godotCallObjectInt(o, "get_item_icon", idx)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the id of the item at index "idx".
*/
func (o *PopupMenu) GetItemId(idx int64) int64 {
	log.Println("Calling PopupMenu.GetItemId()")

	returnValue := godotCallIntInt(o, "get_item_id", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Find and return the index of the item containing a given id.
*/
func (o *PopupMenu) GetItemIndex(id int64) int64 {
	log.Println("Calling PopupMenu.GetItemIndex()")

	returnValue := godotCallIntInt(o, "get_item_index", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the metadata of an item, which might be of any type. You can set it with [method set_item_metadata], which provides a simple way of assigning context data to items.
*/
func (o *PopupMenu) GetItemMetadata(idx int64) *Variant {
	log.Println("Calling PopupMenu.GetItemMetadata()")

	returnValue := godotCallVariantInt(o, "get_item_metadata", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PopupMenu) GetItemShortcut(idx int64) *ShortCut {
	log.Println("Calling PopupMenu.GetItemShortcut()")

	returnValue := godotCallObjectInt(o, "get_item_shortcut", idx)
	log.Println("  Got return value: ", returnValue)

	var ret ShortCut
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the submenu name of the item at index "idx".
*/
func (o *PopupMenu) GetItemSubmenu(idx int64) string {
	log.Println("Calling PopupMenu.GetItemSubmenu()")

	returnValue := godotCallStringInt(o, "get_item_submenu", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the text of the item at index "idx".
*/
func (o *PopupMenu) GetItemText(idx int64) string {
	log.Println("Calling PopupMenu.GetItemText()")

	returnValue := godotCallStringInt(o, "get_item_text", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *PopupMenu) GetItemTooltip(idx int64) string {
	log.Println("Calling PopupMenu.GetItemTooltip()")

	returnValue := godotCallStringInt(o, "get_item_tooltip", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PopupMenu) IsHideOnCheckableItemSelection() bool {
	log.Println("Calling PopupMenu.IsHideOnCheckableItemSelection()")

	returnValue := godotCallBool(o, "is_hide_on_checkable_item_selection")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PopupMenu) IsHideOnItemSelection() bool {
	log.Println("Calling PopupMenu.IsHideOnItemSelection()")

	returnValue := godotCallBool(o, "is_hide_on_item_selection")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PopupMenu) IsHideOnStateItemSelection() bool {
	log.Println("Calling PopupMenu.IsHideOnStateItemSelection()")

	returnValue := godotCallBool(o, "is_hide_on_state_item_selection")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return whether the item at index "idx" has a checkbox. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) IsItemCheckable(idx int64) bool {
	log.Println("Calling PopupMenu.IsItemCheckable()")

	returnValue := godotCallBoolInt(o, "is_item_checkable", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the checkstate status of the item at index "idx".
*/
func (o *PopupMenu) IsItemChecked(idx int64) bool {
	log.Println("Calling PopupMenu.IsItemChecked()")

	returnValue := godotCallBoolInt(o, "is_item_checked", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return whether the item at index "idx" is disabled. When it is disabled it can't be selected, or its action invoked.
*/
func (o *PopupMenu) IsItemDisabled(idx int64) bool {
	log.Println("Calling PopupMenu.IsItemDisabled()")

	returnValue := godotCallBoolInt(o, "is_item_disabled", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return whether the item is a separator. If it is, it would be displayed as a line.
*/
func (o *PopupMenu) IsItemSeparator(idx int64) bool {
	log.Println("Calling PopupMenu.IsItemSeparator()")

	returnValue := godotCallBoolInt(o, "is_item_separator", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes the item at index "idx" from the menu. Note that the indexes of items after the removed item are going to be shifted by one.
*/
func (o *PopupMenu) RemoveItem(idx int64) {
	log.Println("Calling PopupMenu.RemoveItem()")

	godotCallVoidInt(o, "remove_item", idx)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PopupMenu) SetHideOnCheckableItemSelection(enable bool) {
	log.Println("Calling PopupMenu.SetHideOnCheckableItemSelection()")

	godotCallVoidBool(o, "set_hide_on_checkable_item_selection", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PopupMenu) SetHideOnItemSelection(enable bool) {
	log.Println("Calling PopupMenu.SetHideOnItemSelection()")

	godotCallVoidBool(o, "set_hide_on_item_selection", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PopupMenu) SetHideOnStateItemSelection(enable bool) {
	log.Println("Calling PopupMenu.SetHideOnStateItemSelection()")

	godotCallVoidBool(o, "set_hide_on_state_item_selection", enable)
	log.Println("  Function successfully completed.")

}

/*
   Set the accelerator of the item at index "idx". Accelerators are special combinations of keys that activate the item, no matter which control is focused.
*/
func (o *PopupMenu) SetItemAccelerator(idx int64, accel int64) {
	log.Println("Calling PopupMenu.SetItemAccelerator()")

	godotCallVoidIntInt(o, "set_item_accelerator", idx, accel)
	log.Println("  Function successfully completed.")

}

/*
   Set whether the item at index "idx" has a checkbox. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) SetItemAsCheckable(idx int64, enable bool) {
	log.Println("Calling PopupMenu.SetItemAsCheckable()")

	godotCallVoidIntBool(o, "set_item_as_checkable", idx, enable)
	log.Println("  Function successfully completed.")

}

/*
   Mark the item at index "idx" as a separator, which means that it would be displayed as a mere line.
*/
func (o *PopupMenu) SetItemAsSeparator(idx int64, enable bool) {
	log.Println("Calling PopupMenu.SetItemAsSeparator()")

	godotCallVoidIntBool(o, "set_item_as_separator", idx, enable)
	log.Println("  Function successfully completed.")

}

/*
   Set the checkstate status of the item at index "idx".
*/
func (o *PopupMenu) SetItemChecked(idx int64, checked bool) {
	log.Println("Calling PopupMenu.SetItemChecked()")

	godotCallVoidIntBool(o, "set_item_checked", idx, checked)
	log.Println("  Function successfully completed.")

}

/*
   Sets whether the item at index "idx" is disabled or not. When it is disabled it can't be selected, or its action invoked.
*/
func (o *PopupMenu) SetItemDisabled(idx int64, disabled bool) {
	log.Println("Calling PopupMenu.SetItemDisabled()")

	godotCallVoidIntBool(o, "set_item_disabled", idx, disabled)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PopupMenu) SetItemIcon(idx int64, icon *Texture) {
	log.Println("Calling PopupMenu.SetItemIcon()")

	godotCallVoidIntObject(o, "set_item_icon", idx, &icon.Object)
	log.Println("  Function successfully completed.")

}

/*
   Set the id of the item at index "idx".
*/
func (o *PopupMenu) SetItemId(idx int64, id int64) {
	log.Println("Calling PopupMenu.SetItemId()")

	godotCallVoidIntInt(o, "set_item_id", idx, id)
	log.Println("  Function successfully completed.")

}

/*
   Sets the metadata of an item, which might be of any type. You can later get it with [method get_item_metadata], which provides a simple way of assigning context data to items.
*/
func (o *PopupMenu) SetItemMetadata(idx int64, metadata *Variant) {
	log.Println("Calling PopupMenu.SetItemMetadata()")

	godotCallVoidIntVariant(o, "set_item_metadata", idx, metadata)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PopupMenu) SetItemMultistate(idx int64, state int64) {
	log.Println("Calling PopupMenu.SetItemMultistate()")

	godotCallVoidIntInt(o, "set_item_multistate", idx, state)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PopupMenu) SetItemShortcut(idx int64, shortcut *ShortCut, global bool) {
	log.Println("Calling PopupMenu.SetItemShortcut()")

	godotCallVoidIntObjectBool(o, "set_item_shortcut", idx, &shortcut.Object, global)
	log.Println("  Function successfully completed.")

}

/*
   Sets the submenu of the item at index "idx". The submenu is the name of a child PopupMenu node that would be shown when the item is clicked.
*/
func (o *PopupMenu) SetItemSubmenu(idx int64, submenu string) {
	log.Println("Calling PopupMenu.SetItemSubmenu()")

	godotCallVoidIntString(o, "set_item_submenu", idx, submenu)
	log.Println("  Function successfully completed.")

}

/*
   Set the text of the item at index "idx".
*/
func (o *PopupMenu) SetItemText(idx int64, text string) {
	log.Println("Calling PopupMenu.SetItemText()")

	godotCallVoidIntString(o, "set_item_text", idx, text)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PopupMenu) SetItemTooltip(idx int64, tooltip string) {
	log.Println("Calling PopupMenu.SetItemTooltip()")

	godotCallVoidIntString(o, "set_item_tooltip", idx, tooltip)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PopupMenu) ToggleItemChecked(idx int64) {
	log.Println("Calling PopupMenu.ToggleItemChecked()")

	godotCallVoidInt(o, "toggle_item_checked", idx)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *PopupMenu) ToggleItemMultistate(idx int64) {
	log.Println("Calling PopupMenu.ToggleItemMultistate()")

	godotCallVoidInt(o, "toggle_item_multistate", idx)
	log.Println("  Function successfully completed.")

}

/*
   PopupMenuImplementer is an interface for PopupMenu objects.
*/
type PopupMenuImplementer interface {
	Class
}

/*
   Class for displaying popups with a panel background. In some cases it might be simpler to use than [Popup], since it provides a configurable background. If you are making windows, better check [WindowDialog].
*/
type PopupPanel struct {
	Popup
}

func (o *PopupPanel) baseClass() string {
	return "PopupPanel"
}

/*
   PopupPanelImplementer is an interface for PopupPanel objects.
*/
type PopupPanelImplementer interface {
	Class
}

/*
   Generic 2D Position hint for editing. It's just like a plain [Node2D] but displays as a cross in the 2D-Editor at all times.
*/
type Position2D struct {
	Node2D
}

func (o *Position2D) baseClass() string {
	return "Position2D"
}

/*
   Position2DImplementer is an interface for Position2D objects.
*/
type Position2DImplementer interface {
	Class
}

/*
   Generic 3D Position hint for editing. It's just like a plain [Spatial] but displays as a cross in the 3D-Editor at all times.
*/
type Position3D struct {
	Spatial
}

func (o *Position3D) baseClass() string {
	return "Position3D"
}

/*
   Position3DImplementer is an interface for Position3D objects.
*/
type Position3DImplementer interface {
	Class
}

/*
   Base class for all primitive meshes. Handles applying a [Material] to a primitive mesh.
*/
type PrimitiveMesh struct {
	Mesh
}

func (o *PrimitiveMesh) baseClass() string {
	return "PrimitiveMesh"
}

/*
   Undocumented
*/
func (o *PrimitiveMesh) X_Update() {
	log.Println("Calling PrimitiveMesh.X_Update()")

	godotCallVoid(o, "_update")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PrimitiveMesh) GetMaterial() *Material {
	log.Println("Calling PrimitiveMesh.GetMaterial()")

	returnValue := godotCallObject(o, "get_material")
	log.Println("  Got return value: ", returnValue)

	var ret Material
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *PrimitiveMesh) GetMeshArrays() *Array {
	log.Println("Calling PrimitiveMesh.GetMeshArrays()")

	returnValue := godotCallArray(o, "get_mesh_arrays")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PrimitiveMesh) SetMaterial(material *Material) {
	log.Println("Calling PrimitiveMesh.SetMaterial()")

	godotCallVoidObject(o, "set_material", &material.Object)
	log.Println("  Function successfully completed.")

}

/*
   PrimitiveMeshImplementer is an interface for PrimitiveMesh objects.
*/
type PrimitiveMeshImplementer interface {
	Class
}

/*
   Class representing a prism-shaped [PrimitiveMesh].
*/
type PrismMesh struct {
	PrimitiveMesh
}

func (o *PrismMesh) baseClass() string {
	return "PrismMesh"
}

/*
   Undocumented
*/
func (o *PrismMesh) GetLeftToRight() float64 {
	log.Println("Calling PrismMesh.GetLeftToRight()")

	returnValue := godotCallFloat(o, "get_left_to_right")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PrismMesh) GetSize() *Vector3 {
	log.Println("Calling PrismMesh.GetSize()")

	returnValue := godotCallVector3(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PrismMesh) GetSubdivideDepth() int64 {
	log.Println("Calling PrismMesh.GetSubdivideDepth()")

	returnValue := godotCallInt(o, "get_subdivide_depth")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PrismMesh) GetSubdivideHeight() int64 {
	log.Println("Calling PrismMesh.GetSubdivideHeight()")

	returnValue := godotCallInt(o, "get_subdivide_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PrismMesh) GetSubdivideWidth() int64 {
	log.Println("Calling PrismMesh.GetSubdivideWidth()")

	returnValue := godotCallInt(o, "get_subdivide_width")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *PrismMesh) SetLeftToRight(leftToRight float64) {
	log.Println("Calling PrismMesh.SetLeftToRight()")

	godotCallVoidFloat(o, "set_left_to_right", leftToRight)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PrismMesh) SetSize(size *Vector3) {
	log.Println("Calling PrismMesh.SetSize()")

	godotCallVoidVector3(o, "set_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PrismMesh) SetSubdivideDepth(segments int64) {
	log.Println("Calling PrismMesh.SetSubdivideDepth()")

	godotCallVoidInt(o, "set_subdivide_depth", segments)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PrismMesh) SetSubdivideHeight(segments int64) {
	log.Println("Calling PrismMesh.SetSubdivideHeight()")

	godotCallVoidInt(o, "set_subdivide_height", segments)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *PrismMesh) SetSubdivideWidth(segments int64) {
	log.Println("Calling PrismMesh.SetSubdivideWidth()")

	godotCallVoidInt(o, "set_subdivide_width", segments)
	log.Println("  Function successfully completed.")

}

/*
   PrismMeshImplementer is an interface for PrismMesh objects.
*/
type PrismMeshImplementer interface {
	Class
}

/*

 */
type ProceduralSky struct {
	Sky
}

func (o *ProceduralSky) baseClass() string {
	return "ProceduralSky"
}

/*
   Undocumented
*/
func (o *ProceduralSky) X_ThreadDone(image *Image) {
	log.Println("Calling ProceduralSky.X_ThreadDone()")

	godotCallVoidObject(o, "_thread_done", &image.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) X_UpdateSky() {
	log.Println("Calling ProceduralSky.X_UpdateSky()")

	godotCallVoid(o, "_update_sky")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetGroundBottomColor() *Color {
	log.Println("Calling ProceduralSky.GetGroundBottomColor()")

	returnValue := godotCallColor(o, "get_ground_bottom_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetGroundCurve() float64 {
	log.Println("Calling ProceduralSky.GetGroundCurve()")

	returnValue := godotCallFloat(o, "get_ground_curve")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetGroundEnergy() float64 {
	log.Println("Calling ProceduralSky.GetGroundEnergy()")

	returnValue := godotCallFloat(o, "get_ground_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetGroundHorizonColor() *Color {
	log.Println("Calling ProceduralSky.GetGroundHorizonColor()")

	returnValue := godotCallColor(o, "get_ground_horizon_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetSkyCurve() float64 {
	log.Println("Calling ProceduralSky.GetSkyCurve()")

	returnValue := godotCallFloat(o, "get_sky_curve")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetSkyEnergy() float64 {
	log.Println("Calling ProceduralSky.GetSkyEnergy()")

	returnValue := godotCallFloat(o, "get_sky_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetSkyHorizonColor() *Color {
	log.Println("Calling ProceduralSky.GetSkyHorizonColor()")

	returnValue := godotCallColor(o, "get_sky_horizon_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetSkyTopColor() *Color {
	log.Println("Calling ProceduralSky.GetSkyTopColor()")

	returnValue := godotCallColor(o, "get_sky_top_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetSunAngleMax() float64 {
	log.Println("Calling ProceduralSky.GetSunAngleMax()")

	returnValue := godotCallFloat(o, "get_sun_angle_max")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetSunAngleMin() float64 {
	log.Println("Calling ProceduralSky.GetSunAngleMin()")

	returnValue := godotCallFloat(o, "get_sun_angle_min")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetSunColor() *Color {
	log.Println("Calling ProceduralSky.GetSunColor()")

	returnValue := godotCallColor(o, "get_sun_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetSunCurve() float64 {
	log.Println("Calling ProceduralSky.GetSunCurve()")

	returnValue := godotCallFloat(o, "get_sun_curve")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetSunEnergy() float64 {
	log.Println("Calling ProceduralSky.GetSunEnergy()")

	returnValue := godotCallFloat(o, "get_sun_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetSunLatitude() float64 {
	log.Println("Calling ProceduralSky.GetSunLatitude()")

	returnValue := godotCallFloat(o, "get_sun_latitude")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetSunLongitude() float64 {
	log.Println("Calling ProceduralSky.GetSunLongitude()")

	returnValue := godotCallFloat(o, "get_sun_longitude")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) GetTextureSize() int64 {
	log.Println("Calling ProceduralSky.GetTextureSize()")

	returnValue := godotCallInt(o, "get_texture_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetGroundBottomColor(color *Color) {
	log.Println("Calling ProceduralSky.SetGroundBottomColor()")

	godotCallVoidColor(o, "set_ground_bottom_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetGroundCurve(curve float64) {
	log.Println("Calling ProceduralSky.SetGroundCurve()")

	godotCallVoidFloat(o, "set_ground_curve", curve)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetGroundEnergy(energy float64) {
	log.Println("Calling ProceduralSky.SetGroundEnergy()")

	godotCallVoidFloat(o, "set_ground_energy", energy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetGroundHorizonColor(color *Color) {
	log.Println("Calling ProceduralSky.SetGroundHorizonColor()")

	godotCallVoidColor(o, "set_ground_horizon_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetSkyCurve(curve float64) {
	log.Println("Calling ProceduralSky.SetSkyCurve()")

	godotCallVoidFloat(o, "set_sky_curve", curve)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetSkyEnergy(energy float64) {
	log.Println("Calling ProceduralSky.SetSkyEnergy()")

	godotCallVoidFloat(o, "set_sky_energy", energy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetSkyHorizonColor(color *Color) {
	log.Println("Calling ProceduralSky.SetSkyHorizonColor()")

	godotCallVoidColor(o, "set_sky_horizon_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetSkyTopColor(color *Color) {
	log.Println("Calling ProceduralSky.SetSkyTopColor()")

	godotCallVoidColor(o, "set_sky_top_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetSunAngleMax(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunAngleMax()")

	godotCallVoidFloat(o, "set_sun_angle_max", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetSunAngleMin(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunAngleMin()")

	godotCallVoidFloat(o, "set_sun_angle_min", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetSunColor(color *Color) {
	log.Println("Calling ProceduralSky.SetSunColor()")

	godotCallVoidColor(o, "set_sun_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetSunCurve(curve float64) {
	log.Println("Calling ProceduralSky.SetSunCurve()")

	godotCallVoidFloat(o, "set_sun_curve", curve)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetSunEnergy(energy float64) {
	log.Println("Calling ProceduralSky.SetSunEnergy()")

	godotCallVoidFloat(o, "set_sun_energy", energy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetSunLatitude(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunLatitude()")

	godotCallVoidFloat(o, "set_sun_latitude", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetSunLongitude(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunLongitude()")

	godotCallVoidFloat(o, "set_sun_longitude", degrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProceduralSky) SetTextureSize(size int64) {
	log.Println("Calling ProceduralSky.SetTextureSize()")

	godotCallVoidInt(o, "set_texture_size", size)
	log.Println("  Function successfully completed.")

}

/*
   ProceduralSkyImplementer is an interface for ProceduralSky objects.
*/
type ProceduralSkyImplementer interface {
	Class
}

/*
   General purpose progress bar. Shows fill percentage from right to left.
*/
type ProgressBar struct {
	Range
}

func (o *ProgressBar) baseClass() string {
	return "ProgressBar"
}

/*
   Undocumented
*/
func (o *ProgressBar) IsPercentVisible() bool {
	log.Println("Calling ProgressBar.IsPercentVisible()")

	returnValue := godotCallBool(o, "is_percent_visible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProgressBar) SetPercentVisible(visible bool) {
	log.Println("Calling ProgressBar.SetPercentVisible()")

	godotCallVoidBool(o, "set_percent_visible", visible)
	log.Println("  Function successfully completed.")

}

/*
   ProgressBarImplementer is an interface for ProgressBar objects.
*/
type ProgressBarImplementer interface {
	Class
}

func newSingletonProjectSettings() *projectSettings {
	obj := &projectSettings{}
	name := C.CString("ProjectSettings")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Contains global variables accessible from everywhere. Use "ProjectSettings.get_setting(variable)", "ProjectSettings.set_setting(variable,value)" or "ProjectSettings.has_setting(variable)" to access them. Variables stored in project.godot are also loaded into ProjectSettings, making this object very useful for reading custom game configuration options.
*/
var ProjectSettings = newSingletonProjectSettings()

/*
   Contains global variables accessible from everywhere. Use "ProjectSettings.get_setting(variable)", "ProjectSettings.set_setting(variable,value)" or "ProjectSettings.has_setting(variable)" to access them. Variables stored in project.godot are also loaded into ProjectSettings, making this object very useful for reading custom game configuration options.
*/
type projectSettings struct {
	Object
}

func (o *projectSettings) baseClass() string {
	return "ProjectSettings"
}

/*
   Add a custom property info to a property. The dictionary must contain: name:[String](the name of the property) and type:[int](see TYPE_* in [@GlobalScope]), and optionally hint:[int](see PROPERTY_HINT_* in [@GlobalScope]), hint_string:[String]. Example: [codeblock] ProjectSettings.set("category/property_name", 0) var property_info = { "name": "category/property_name", "type": TYPE_INT, "hint": PROPERTY_HINT_ENUM, "hint_string": "one,two,three" } ProjectSettings.add_property_info(property_info) [/codeblock]
*/
func (o *projectSettings) AddPropertyInfo(hint *Dictionary) {
	log.Println("Calling ProjectSettings.AddPropertyInfo()")

	godotCallVoidDictionary(o, "add_property_info", hint)
	log.Println("  Function successfully completed.")

}

/*
   Clear the whole configuration (not recommended, may break things).
*/
func (o *projectSettings) Clear(name string) {
	log.Println("Calling ProjectSettings.Clear()")

	godotCallVoidString(o, "clear", name)
	log.Println("  Function successfully completed.")

}

/*
   Return the order of a configuration value (influences when saved to the config file).
*/
func (o *projectSettings) GetOrder(name string) int64 {
	log.Println("Calling ProjectSettings.GetOrder()")

	returnValue := godotCallIntString(o, "get_order", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *projectSettings) GetSetting(name string) *Variant {
	log.Println("Calling ProjectSettings.GetSetting()")

	returnValue := godotCallVariantString(o, "get_setting", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Convert a localized path (res://) to a full native OS path.
*/
func (o *projectSettings) GlobalizePath(path string) string {
	log.Println("Calling ProjectSettings.GlobalizePath()")

	returnValue := godotCallStringString(o, "globalize_path", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return true if a configuration value is present.
*/
func (o *projectSettings) HasSetting(name string) bool {
	log.Println("Calling ProjectSettings.HasSetting()")

	returnValue := godotCallBoolString(o, "has_setting", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *projectSettings) LoadResourcePack(pack string) bool {
	log.Println("Calling ProjectSettings.LoadResourcePack()")

	returnValue := godotCallBoolString(o, "load_resource_pack", pack)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Convert a path to a localized path (res:// path).
*/
func (o *projectSettings) LocalizePath(path string) string {
	log.Println("Calling ProjectSettings.LocalizePath()")

	returnValue := godotCallStringString(o, "localize_path", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *projectSettings) PropertyCanRevert(name string) bool {
	log.Println("Calling ProjectSettings.PropertyCanRevert()")

	returnValue := godotCallBoolString(o, "property_can_revert", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *projectSettings) PropertyGetRevert(name string) *Variant {
	log.Println("Calling ProjectSettings.PropertyGetRevert()")

	returnValue := godotCallVariantString(o, "property_get_revert", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *projectSettings) Save() int64 {
	log.Println("Calling ProjectSettings.Save()")

	returnValue := godotCallInt(o, "save")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *projectSettings) SaveCustom(file string) int64 {
	log.Println("Calling ProjectSettings.SaveCustom()")

	returnValue := godotCallIntString(o, "save_custom", file)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *projectSettings) SetInitialValue(name string, value *Variant) {
	log.Println("Calling ProjectSettings.SetInitialValue()")

	godotCallVoidStringVariant(o, "set_initial_value", name, value)
	log.Println("  Function successfully completed.")

}

/*
   Set the order of a configuration value (influences when saved to the config file).
*/
func (o *projectSettings) SetOrder(name string, position int64) {
	log.Println("Calling ProjectSettings.SetOrder()")

	godotCallVoidStringInt(o, "set_order", name, position)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *projectSettings) SetSetting(name string, value *Variant) {
	log.Println("Calling ProjectSettings.SetSetting()")

	godotCallVoidStringVariant(o, "set_setting", name, value)
	log.Println("  Function successfully completed.")

}

/*
   General purpose proximity-detection node.
*/
type ProximityGroup struct {
	Spatial
}

func (o *ProximityGroup) baseClass() string {
	return "ProximityGroup"
}

/*
   Undocumented
*/
func (o *ProximityGroup) X_ProximityGroupBroadcast(name string, params *Variant) {
	log.Println("Calling ProximityGroup.X_ProximityGroupBroadcast()")

	godotCallVoidStringVariant(o, "_proximity_group_broadcast", name, params)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ProximityGroup) Broadcast(name string, parameters *Variant) {
	log.Println("Calling ProximityGroup.Broadcast()")

	godotCallVoidStringVariant(o, "broadcast", name, parameters)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProximityGroup) GetDispatchMode() int64 {
	log.Println("Calling ProximityGroup.GetDispatchMode()")

	returnValue := godotCallInt(o, "get_dispatch_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProximityGroup) GetGridRadius() *Vector3 {
	log.Println("Calling ProximityGroup.GetGridRadius()")

	returnValue := godotCallVector3(o, "get_grid_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProximityGroup) GetGroupName() string {
	log.Println("Calling ProximityGroup.GetGroupName()")

	returnValue := godotCallString(o, "get_group_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ProximityGroup) SetDispatchMode(mode int64) {
	log.Println("Calling ProximityGroup.SetDispatchMode()")

	godotCallVoidInt(o, "set_dispatch_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProximityGroup) SetGridRadius(radius *Vector3) {
	log.Println("Calling ProximityGroup.SetGridRadius()")

	godotCallVoidVector3(o, "set_grid_radius", radius)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ProximityGroup) SetGroupName(name string) {
	log.Println("Calling ProximityGroup.SetGroupName()")

	godotCallVoidString(o, "set_group_name", name)
	log.Println("  Function successfully completed.")

}

/*
   ProximityGroupImplementer is an interface for ProximityGroup objects.
*/
type ProximityGroupImplementer interface {
	Class
}

/*

 */
type ProxyTexture struct {
	Texture
}

func (o *ProxyTexture) baseClass() string {
	return "ProxyTexture"
}

/*
   Undocumented
*/
func (o *ProxyTexture) GetBase() *Texture {
	log.Println("Calling ProxyTexture.GetBase()")

	returnValue := godotCallObject(o, "get_base")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *ProxyTexture) SetBase(base *Texture) {
	log.Println("Calling ProxyTexture.SetBase()")

	godotCallVoidObject(o, "set_base", &base.Object)
	log.Println("  Function successfully completed.")

}

/*
   ProxyTextureImplementer is an interface for ProxyTexture objects.
*/
type ProxyTextureImplementer interface {
	Class
}

/*
   Class representing a square mesh with size (2,2,0). Consider using a [PlaneMesh] if you require a differently sized plane.
*/
type QuadMesh struct {
	PrimitiveMesh
}

func (o *QuadMesh) baseClass() string {
	return "QuadMesh"
}

/*
   Undocumented
*/
func (o *QuadMesh) GetSize() *Vector2 {
	log.Println("Calling QuadMesh.GetSize()")

	returnValue := godotCallVector2(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *QuadMesh) SetSize(size *Vector2) {
	log.Println("Calling QuadMesh.SetSize()")

	godotCallVoidVector2(o, "set_size", size)
	log.Println("  Function successfully completed.")

}

/*
   QuadMeshImplementer is an interface for QuadMesh objects.
*/
type QuadMeshImplementer interface {
	Class
}

/*
   Range is a base class for [Control] nodes that change a floating point [i]value[/i] between a [i]minimum[/i] and a [i]maximum[/i], using [i]step[/i] and [i]page[/i], for example a [ScrollBar].
*/
type Range struct {
	Control
}

func (o *Range) baseClass() string {
	return "Range"
}

/*
   Undocumented
*/
func (o *Range) GetAsRatio() float64 {
	log.Println("Calling Range.GetAsRatio()")

	returnValue := godotCallFloat(o, "get_as_ratio")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Range) GetMax() float64 {
	log.Println("Calling Range.GetMax()")

	returnValue := godotCallFloat(o, "get_max")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Range) GetMin() float64 {
	log.Println("Calling Range.GetMin()")

	returnValue := godotCallFloat(o, "get_min")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Range) GetPage() float64 {
	log.Println("Calling Range.GetPage()")

	returnValue := godotCallFloat(o, "get_page")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Range) GetStep() float64 {
	log.Println("Calling Range.GetStep()")

	returnValue := godotCallFloat(o, "get_step")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Range) GetValue() float64 {
	log.Println("Calling Range.GetValue()")

	returnValue := godotCallFloat(o, "get_value")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Range) IsRatioExp() bool {
	log.Println("Calling Range.IsRatioExp()")

	returnValue := godotCallBool(o, "is_ratio_exp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Range) IsUsingRoundedValues() bool {
	log.Println("Calling Range.IsUsingRoundedValues()")

	returnValue := godotCallBool(o, "is_using_rounded_values")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Range) SetAsRatio(value float64) {
	log.Println("Calling Range.SetAsRatio()")

	godotCallVoidFloat(o, "set_as_ratio", value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Range) SetExpRatio(enabled bool) {
	log.Println("Calling Range.SetExpRatio()")

	godotCallVoidBool(o, "set_exp_ratio", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Range) SetMax(maximum float64) {
	log.Println("Calling Range.SetMax()")

	godotCallVoidFloat(o, "set_max", maximum)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Range) SetMin(minimum float64) {
	log.Println("Calling Range.SetMin()")

	godotCallVoidFloat(o, "set_min", minimum)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Range) SetPage(pagesize float64) {
	log.Println("Calling Range.SetPage()")

	godotCallVoidFloat(o, "set_page", pagesize)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Range) SetStep(step float64) {
	log.Println("Calling Range.SetStep()")

	godotCallVoidFloat(o, "set_step", step)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Range) SetUseRoundedValues(enabled bool) {
	log.Println("Calling Range.SetUseRoundedValues()")

	godotCallVoidBool(o, "set_use_rounded_values", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Range) SetValue(value float64) {
	log.Println("Calling Range.SetValue()")

	godotCallVoidFloat(o, "set_value", value)
	log.Println("  Function successfully completed.")

}

/*
   Binds two Ranges together along with any Ranges previously grouped with either of them. When any of Range's member variables change, it will share the new value with all other Ranges in its group.
*/
func (o *Range) Share(with *Object) {
	log.Println("Calling Range.Share()")

	godotCallVoidObject(o, "share", with)
	log.Println("  Function successfully completed.")

}

/*
   Stop Range from sharing its member variables with any other Range.
*/
func (o *Range) Unshare() {
	log.Println("Calling Range.Unshare()")

	godotCallVoid(o, "unshare")
	log.Println("  Function successfully completed.")

}

/*
   RangeImplementer is an interface for Range objects.
*/
type RangeImplementer interface {
	Class
}

/*
   A RayCast represents a line from its origin to its destination position, [code]cast_to[/code]. It is used to query the 3D space in order to find the closest object along the path of the ray. RayCast can ignore some objects by adding them to the exception list via [code]add_exception[/code], by setting proper filtering with collision layers, or by filtering object types with type masks. Only enabled raycasts will be able to query the space and report collisions. RayCast calculates intersection every physics frame (see [Node]), and the result is cached so it can be used later until the next frame. If multiple queries are required between physics frames (or during the same frame) use [method force_raycast_update] after adjusting the raycast.
*/
type RayCast struct {
	Spatial
}

func (o *RayCast) baseClass() string {
	return "RayCast"
}

/*
   Adds a collision exception so the ray does not report collisions with the specified node.
*/
func (o *RayCast) AddException(node *Object) {
	log.Println("Calling RayCast.AddException()")

	godotCallVoidObject(o, "add_exception", node)
	log.Println("  Function successfully completed.")

}

/*
   Adds a collision exception so the ray does not report collisions with the specified [RID].
*/
func (o *RayCast) AddExceptionRid(rid *RID) {
	log.Println("Calling RayCast.AddExceptionRid()")

	godotCallVoidRid(o, "add_exception_rid", rid)
	log.Println("  Function successfully completed.")

}

/*
   Removes all collision exceptions for this ray.
*/
func (o *RayCast) ClearExceptions() {
	log.Println("Calling RayCast.ClearExceptions()")

	godotCallVoid(o, "clear_exceptions")
	log.Println("  Function successfully completed.")

}

/*
   Updates the collision information for the ray. Use this method to update the collision information immediately instead of waiting for the next [code]_physics_process[/code] call, for example if the ray or its parent has changed state. Note: [code]enabled == true[/code] is not required for this to work.
*/
func (o *RayCast) ForceRaycastUpdate() {
	log.Println("Calling RayCast.ForceRaycastUpdate()")

	godotCallVoid(o, "force_raycast_update")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RayCast) GetCastTo() *Vector3 {
	log.Println("Calling RayCast.GetCastTo()")

	returnValue := godotCallVector3(o, "get_cast_to")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the closest object the ray is pointing to. Note that this does not consider the length of the ray, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray. Example: [codeblock] if RayCast.is_colliding(): var collider = RayCast.get_collider() [/codeblock]
*/
func (o *RayCast) GetCollider() *Object {
	log.Println("Calling RayCast.GetCollider()")

	returnValue := godotCallObject(o, "get_collider")
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the collision shape of the closest object the ray is pointing to. Note that this does not consider the length of the ray, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray. Example: [codeblock] if RayCast.is_colliding(): var shape = RayCast.get_collider_shape() [/codeblock]
*/
func (o *RayCast) GetColliderShape() int64 {
	log.Println("Calling RayCast.GetColliderShape()")

	returnValue := godotCallInt(o, "get_collider_shape")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RayCast) GetCollisionMask() int64 {
	log.Println("Calling RayCast.GetCollisionMask()")

	returnValue := godotCallInt(o, "get_collision_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the bit index passed is turned on. Note that bit indexes range from 0-19.
*/
func (o *RayCast) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling RayCast.GetCollisionMaskBit()")

	returnValue := godotCallBoolInt(o, "get_collision_mask_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the normal of the intersecting object's shape at the collision point.
*/
func (o *RayCast) GetCollisionNormal() *Vector3 {
	log.Println("Calling RayCast.GetCollisionNormal()")

	returnValue := godotCallVector3(o, "get_collision_normal")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the collision point at which the ray intersects the closest object. Note: this point is in the [b]global[/b] coordinate system.
*/
func (o *RayCast) GetCollisionPoint() *Vector3 {
	log.Println("Calling RayCast.GetCollisionPoint()")

	returnValue := godotCallVector3(o, "get_collision_point")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RayCast) GetExcludeParentBody() bool {
	log.Println("Calling RayCast.GetExcludeParentBody()")

	returnValue := godotCallBool(o, "get_exclude_parent_body")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return whether the closest object the ray is pointing to is colliding with the vector (considering the vector length).
*/
func (o *RayCast) IsColliding() bool {
	log.Println("Calling RayCast.IsColliding()")

	returnValue := godotCallBool(o, "is_colliding")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RayCast) IsEnabled() bool {
	log.Println("Calling RayCast.IsEnabled()")

	returnValue := godotCallBool(o, "is_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a collision exception so the ray does report collisions with the specified node.
*/
func (o *RayCast) RemoveException(node *Object) {
	log.Println("Calling RayCast.RemoveException()")

	godotCallVoidObject(o, "remove_exception", node)
	log.Println("  Function successfully completed.")

}

/*
   Removes a collision exception so the ray does report collisions with the specified [RID].
*/
func (o *RayCast) RemoveExceptionRid(rid *RID) {
	log.Println("Calling RayCast.RemoveExceptionRid()")

	godotCallVoidRid(o, "remove_exception_rid", rid)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RayCast) SetCastTo(localPoint *Vector3) {
	log.Println("Calling RayCast.SetCastTo()")

	godotCallVoidVector3(o, "set_cast_to", localPoint)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RayCast) SetCollisionMask(mask int64) {
	log.Println("Calling RayCast.SetCollisionMask()")

	godotCallVoidInt(o, "set_collision_mask", mask)
	log.Println("  Function successfully completed.")

}

/*
   Sets the bit index passed to the [code]value[/code] passed. Note that bit indexes range from 0-19.
*/
func (o *RayCast) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling RayCast.SetCollisionMaskBit()")

	godotCallVoidIntBool(o, "set_collision_mask_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RayCast) SetEnabled(enabled bool) {
	log.Println("Calling RayCast.SetEnabled()")

	godotCallVoidBool(o, "set_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RayCast) SetExcludeParentBody(mask bool) {
	log.Println("Calling RayCast.SetExcludeParentBody()")

	godotCallVoidBool(o, "set_exclude_parent_body", mask)
	log.Println("  Function successfully completed.")

}

/*
   RayCastImplementer is an interface for RayCast objects.
*/
type RayCastImplementer interface {
	Class
}

/*
   A RayCast represents a line from its origin to its destination position, [code]cast_to[/code]. It is used to query the 2D space in order to find the closest object along the path of the ray. RayCast2D can ignore some objects by adding them to the exception list via [code]add_exception[/code], by setting proper filtering with collision layers, or by filtering object types with type masks. Only enabled raycasts will be able to query the space and report collisions. RayCast2D calculates intersection every physics frame (see [Node]), and the result is cached so it can be used later until the next frame. If multiple queries are required between physics frames (or during the same frame) use [method force_raycast_update] after adjusting the raycast.
*/
type RayCast2D struct {
	Node2D
}

func (o *RayCast2D) baseClass() string {
	return "RayCast2D"
}

/*
   Adds a collision exception so the ray does not report collisions with the specified node.
*/
func (o *RayCast2D) AddException(node *Object) {
	log.Println("Calling RayCast2D.AddException()")

	godotCallVoidObject(o, "add_exception", node)
	log.Println("  Function successfully completed.")

}

/*
   Adds a collision exception so the ray does not report collisions with the specified [RID].
*/
func (o *RayCast2D) AddExceptionRid(rid *RID) {
	log.Println("Calling RayCast2D.AddExceptionRid()")

	godotCallVoidRid(o, "add_exception_rid", rid)
	log.Println("  Function successfully completed.")

}

/*
   Removes all collision exceptions for this ray.
*/
func (o *RayCast2D) ClearExceptions() {
	log.Println("Calling RayCast2D.ClearExceptions()")

	godotCallVoid(o, "clear_exceptions")
	log.Println("  Function successfully completed.")

}

/*
   Updates the collision information for the ray. Use this method to update the collision information immediately instead of waiting for the next [code]_physics_process[/code] call, for example if the ray or its parent has changed state. Note: [code]enabled == true[/code] is not required for this to work.
*/
func (o *RayCast2D) ForceRaycastUpdate() {
	log.Println("Calling RayCast2D.ForceRaycastUpdate()")

	godotCallVoid(o, "force_raycast_update")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RayCast2D) GetCastTo() *Vector2 {
	log.Println("Calling RayCast2D.GetCastTo()")

	returnValue := godotCallVector2(o, "get_cast_to")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the closest object the ray is pointing to. Note that this does not consider the length of the ray, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray. Example: [codeblock] if RayCast2D.is_colliding(): var collider = RayCast2D.get_collider() [/codeblock]
*/
func (o *RayCast2D) GetCollider() *Object {
	log.Println("Calling RayCast2D.GetCollider()")

	returnValue := godotCallObject(o, "get_collider")
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the collision shape of the closest object the ray is pointing to. Note that this does not consider the length of the ray, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray. Example: [codeblock] if RayCast2D.is_colliding(): var shape = RayCast2D.get_collider_shape() [/codeblock]
*/
func (o *RayCast2D) GetColliderShape() int64 {
	log.Println("Calling RayCast2D.GetColliderShape()")

	returnValue := godotCallInt(o, "get_collider_shape")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RayCast2D) GetCollisionMask() int64 {
	log.Println("Calling RayCast2D.GetCollisionMask()")

	returnValue := godotCallInt(o, "get_collision_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return an individual bit on the collision mask.
*/
func (o *RayCast2D) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling RayCast2D.GetCollisionMaskBit()")

	returnValue := godotCallBoolInt(o, "get_collision_mask_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the normal of the intersecting object's shape at the collision point.
*/
func (o *RayCast2D) GetCollisionNormal() *Vector2 {
	log.Println("Calling RayCast2D.GetCollisionNormal()")

	returnValue := godotCallVector2(o, "get_collision_normal")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the collision point at which the ray intersects the closest object. Note: this point is in the [b]global[/b] coordinate system.
*/
func (o *RayCast2D) GetCollisionPoint() *Vector2 {
	log.Println("Calling RayCast2D.GetCollisionPoint()")

	returnValue := godotCallVector2(o, "get_collision_point")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RayCast2D) GetExcludeParentBody() bool {
	log.Println("Calling RayCast2D.GetExcludeParentBody()")

	returnValue := godotCallBool(o, "get_exclude_parent_body")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return whether the closest object the ray is pointing to is colliding with the vector (considering the vector length).
*/
func (o *RayCast2D) IsColliding() bool {
	log.Println("Calling RayCast2D.IsColliding()")

	returnValue := godotCallBool(o, "is_colliding")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RayCast2D) IsEnabled() bool {
	log.Println("Calling RayCast2D.IsEnabled()")

	returnValue := godotCallBool(o, "is_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a collision exception so the ray does report collisions with the specified node.
*/
func (o *RayCast2D) RemoveException(node *Object) {
	log.Println("Calling RayCast2D.RemoveException()")

	godotCallVoidObject(o, "remove_exception", node)
	log.Println("  Function successfully completed.")

}

/*
   Removes a collision exception so the ray does report collisions with the specified [RID].
*/
func (o *RayCast2D) RemoveExceptionRid(rid *RID) {
	log.Println("Calling RayCast2D.RemoveExceptionRid()")

	godotCallVoidRid(o, "remove_exception_rid", rid)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RayCast2D) SetCastTo(localPoint *Vector2) {
	log.Println("Calling RayCast2D.SetCastTo()")

	godotCallVoidVector2(o, "set_cast_to", localPoint)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RayCast2D) SetCollisionMask(mask int64) {
	log.Println("Calling RayCast2D.SetCollisionMask()")

	godotCallVoidInt(o, "set_collision_mask", mask)
	log.Println("  Function successfully completed.")

}

/*
   Set/clear individual bits on the collision mask. This makes selecting the areas scanned easier.
*/
func (o *RayCast2D) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling RayCast2D.SetCollisionMaskBit()")

	godotCallVoidIntBool(o, "set_collision_mask_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RayCast2D) SetEnabled(enabled bool) {
	log.Println("Calling RayCast2D.SetEnabled()")

	godotCallVoidBool(o, "set_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RayCast2D) SetExcludeParentBody(mask bool) {
	log.Println("Calling RayCast2D.SetExcludeParentBody()")

	godotCallVoidBool(o, "set_exclude_parent_body", mask)
	log.Println("  Function successfully completed.")

}

/*
   RayCast2DImplementer is an interface for RayCast2D objects.
*/
type RayCast2DImplementer interface {
	Class
}

/*
   Ray shape for 3D collisions, which can be set into a [PhysicsBody] or [Area]. A ray is not really a collision body, instead it tries to separate itself from whatever is touching its far endpoint. It's often useful for characters.
*/
type RayShape struct {
	Shape
}

func (o *RayShape) baseClass() string {
	return "RayShape"
}

/*
   Undocumented
*/
func (o *RayShape) GetLength() float64 {
	log.Println("Calling RayShape.GetLength()")

	returnValue := godotCallFloat(o, "get_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RayShape) SetLength(length float64) {
	log.Println("Calling RayShape.SetLength()")

	godotCallVoidFloat(o, "set_length", length)
	log.Println("  Function successfully completed.")

}

/*
   RayShapeImplementer is an interface for RayShape objects.
*/
type RayShapeImplementer interface {
	Class
}

/*
   Ray shape for 2D collisions. A ray is not really a collision body, instead it tries to separate itself from whatever is touching its far endpoint. It's often useful for characters.
*/
type RayShape2D struct {
	Shape2D
}

func (o *RayShape2D) baseClass() string {
	return "RayShape2D"
}

/*
   Undocumented
*/
func (o *RayShape2D) GetLength() float64 {
	log.Println("Calling RayShape2D.GetLength()")

	returnValue := godotCallFloat(o, "get_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RayShape2D) SetLength(length float64) {
	log.Println("Calling RayShape2D.SetLength()")

	godotCallVoidFloat(o, "set_length", length)
	log.Println("  Function successfully completed.")

}

/*
   RayShape2DImplementer is an interface for RayShape2D objects.
*/
type RayShape2DImplementer interface {
	Class
}

/*
   Rectangle shape for 2D collisions. This shape is useful for modeling box-like 2D objects.
*/
type RectangleShape2D struct {
	Shape2D
}

func (o *RectangleShape2D) baseClass() string {
	return "RectangleShape2D"
}

/*
   Undocumented
*/
func (o *RectangleShape2D) GetExtents() *Vector2 {
	log.Println("Calling RectangleShape2D.GetExtents()")

	returnValue := godotCallVector2(o, "get_extents")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RectangleShape2D) SetExtents(extents *Vector2) {
	log.Println("Calling RectangleShape2D.SetExtents()")

	godotCallVoidVector2(o, "set_extents", extents)
	log.Println("  Function successfully completed.")

}

/*
   RectangleShape2DImplementer is an interface for RectangleShape2D objects.
*/
type RectangleShape2DImplementer interface {
	Class
}

/*
   Base class for anything that keeps a reference count. Resource and many other helper objects inherit this. References keep an internal reference counter so they are only released when no longer in use.
*/
type Reference struct {
	Object
}

func (o *Reference) baseClass() string {
	return "Reference"
}

/*

 */
func (o *Reference) InitRef() bool {
	log.Println("Calling Reference.InitRef()")

	returnValue := godotCallBool(o, "init_ref")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Increase the internal reference counter. Use this only if you really know what you are doing.
*/
func (o *Reference) Reference() bool {
	log.Println("Calling Reference.Reference()")

	returnValue := godotCallBool(o, "reference")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Decrease the internal reference counter. Use this only if you really know what you are doing.
*/
func (o *Reference) Unreference() bool {
	log.Println("Calling Reference.Unreference()")

	returnValue := godotCallBool(o, "unreference")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   ReferenceImplementer is an interface for Reference objects.
*/
type ReferenceImplementer interface {
	Class
}

/*
   Reference frame for GUI. It's just like an empty control, except a red box is displayed while editing around its size at all times.
*/
type ReferenceRect struct {
	Control
}

func (o *ReferenceRect) baseClass() string {
	return "ReferenceRect"
}

/*
   ReferenceRectImplementer is an interface for ReferenceRect objects.
*/
type ReferenceRectImplementer interface {
	Class
}

/*

 */
type ReflectionProbe struct {
	VisualInstance
}

func (o *ReflectionProbe) baseClass() string {
	return "ReflectionProbe"
}

/*
   Undocumented
*/
func (o *ReflectionProbe) AreShadowsEnabled() bool {
	log.Println("Calling ReflectionProbe.AreShadowsEnabled()")

	returnValue := godotCallBool(o, "are_shadows_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) GetCullMask() int64 {
	log.Println("Calling ReflectionProbe.GetCullMask()")

	returnValue := godotCallInt(o, "get_cull_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) GetExtents() *Vector3 {
	log.Println("Calling ReflectionProbe.GetExtents()")

	returnValue := godotCallVector3(o, "get_extents")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) GetIntensity() float64 {
	log.Println("Calling ReflectionProbe.GetIntensity()")

	returnValue := godotCallFloat(o, "get_intensity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) GetInteriorAmbient() *Color {
	log.Println("Calling ReflectionProbe.GetInteriorAmbient()")

	returnValue := godotCallColor(o, "get_interior_ambient")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) GetInteriorAmbientEnergy() float64 {
	log.Println("Calling ReflectionProbe.GetInteriorAmbientEnergy()")

	returnValue := godotCallFloat(o, "get_interior_ambient_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) GetInteriorAmbientProbeContribution() float64 {
	log.Println("Calling ReflectionProbe.GetInteriorAmbientProbeContribution()")

	returnValue := godotCallFloat(o, "get_interior_ambient_probe_contribution")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) GetMaxDistance() float64 {
	log.Println("Calling ReflectionProbe.GetMaxDistance()")

	returnValue := godotCallFloat(o, "get_max_distance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) GetOriginOffset() *Vector3 {
	log.Println("Calling ReflectionProbe.GetOriginOffset()")

	returnValue := godotCallVector3(o, "get_origin_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) GetUpdateMode() int64 {
	log.Println("Calling ReflectionProbe.GetUpdateMode()")

	returnValue := godotCallInt(o, "get_update_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) IsBoxProjectionEnabled() bool {
	log.Println("Calling ReflectionProbe.IsBoxProjectionEnabled()")

	returnValue := godotCallBool(o, "is_box_projection_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) IsSetAsInterior() bool {
	log.Println("Calling ReflectionProbe.IsSetAsInterior()")

	returnValue := godotCallBool(o, "is_set_as_interior")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetAsInterior(enable bool) {
	log.Println("Calling ReflectionProbe.SetAsInterior()")

	godotCallVoidBool(o, "set_as_interior", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetCullMask(layers int64) {
	log.Println("Calling ReflectionProbe.SetCullMask()")

	godotCallVoidInt(o, "set_cull_mask", layers)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetEnableBoxProjection(enable bool) {
	log.Println("Calling ReflectionProbe.SetEnableBoxProjection()")

	godotCallVoidBool(o, "set_enable_box_projection", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetEnableShadows(enable bool) {
	log.Println("Calling ReflectionProbe.SetEnableShadows()")

	godotCallVoidBool(o, "set_enable_shadows", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetExtents(extents *Vector3) {
	log.Println("Calling ReflectionProbe.SetExtents()")

	godotCallVoidVector3(o, "set_extents", extents)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetIntensity(intensity float64) {
	log.Println("Calling ReflectionProbe.SetIntensity()")

	godotCallVoidFloat(o, "set_intensity", intensity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetInteriorAmbient(ambient *Color) {
	log.Println("Calling ReflectionProbe.SetInteriorAmbient()")

	godotCallVoidColor(o, "set_interior_ambient", ambient)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetInteriorAmbientEnergy(ambientEnergy float64) {
	log.Println("Calling ReflectionProbe.SetInteriorAmbientEnergy()")

	godotCallVoidFloat(o, "set_interior_ambient_energy", ambientEnergy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetInteriorAmbientProbeContribution(ambientProbeContribution float64) {
	log.Println("Calling ReflectionProbe.SetInteriorAmbientProbeContribution()")

	godotCallVoidFloat(o, "set_interior_ambient_probe_contribution", ambientProbeContribution)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetMaxDistance(maxDistance float64) {
	log.Println("Calling ReflectionProbe.SetMaxDistance()")

	godotCallVoidFloat(o, "set_max_distance", maxDistance)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetOriginOffset(originOffset *Vector3) {
	log.Println("Calling ReflectionProbe.SetOriginOffset()")

	godotCallVoidVector3(o, "set_origin_offset", originOffset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ReflectionProbe) SetUpdateMode(mode int64) {
	log.Println("Calling ReflectionProbe.SetUpdateMode()")

	godotCallVoidInt(o, "set_update_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   ReflectionProbeImplementer is an interface for ReflectionProbe objects.
*/
type ReflectionProbeImplementer interface {
	Class
}

/*
   Undocumented
*/
type RegEx struct {
	Reference
}

func (o *RegEx) baseClass() string {
	return "RegEx"
}

/*
   Undocumented
*/
func (o *RegEx) Clear() {
	log.Println("Calling RegEx.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RegEx) Compile(pattern string) int64 {
	log.Println("Calling RegEx.Compile()")

	returnValue := godotCallIntString(o, "compile", pattern)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegEx) GetGroupCount() int64 {
	log.Println("Calling RegEx.GetGroupCount()")

	returnValue := godotCallInt(o, "get_group_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegEx) GetNames() *Array {
	log.Println("Calling RegEx.GetNames()")

	returnValue := godotCallArray(o, "get_names")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegEx) GetPattern() string {
	log.Println("Calling RegEx.GetPattern()")

	returnValue := godotCallString(o, "get_pattern")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegEx) IsValid() bool {
	log.Println("Calling RegEx.IsValid()")

	returnValue := godotCallBool(o, "is_valid")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegEx) Search(subject string, offset int64, end int64) *RegExMatch {
	log.Println("Calling RegEx.Search()")

	returnValue := godotCallObjectStringIntInt(o, "search", subject, offset, end)
	log.Println("  Got return value: ", returnValue)

	var ret RegExMatch
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *RegEx) SearchAll(subject string, offset int64, end int64) *Array {
	log.Println("Calling RegEx.SearchAll()")

	returnValue := godotCallArrayStringIntInt(o, "search_all", subject, offset, end)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegEx) Sub(subject string, replacement string, all bool, offset int64, end int64) string {
	log.Println("Calling RegEx.Sub()")

	returnValue := godotCallStringStringStringBoolIntInt(o, "sub", subject, replacement, all, offset, end)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   RegExImplementer is an interface for RegEx objects.
*/
type RegExImplementer interface {
	Class
}

/*
   Undocumented
*/
type RegExMatch struct {
	Reference
}

func (o *RegExMatch) baseClass() string {
	return "RegExMatch"
}

/*
   Undocumented
*/
func (o *RegExMatch) GetEnd(name *Variant) int64 {
	log.Println("Calling RegExMatch.GetEnd()")

	returnValue := godotCallIntVariant(o, "get_end", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegExMatch) GetGroupCount() int64 {
	log.Println("Calling RegExMatch.GetGroupCount()")

	returnValue := godotCallInt(o, "get_group_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegExMatch) GetNames() *Dictionary {
	log.Println("Calling RegExMatch.GetNames()")

	returnValue := godotCallDictionary(o, "get_names")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegExMatch) GetStart(name *Variant) int64 {
	log.Println("Calling RegExMatch.GetStart()")

	returnValue := godotCallIntVariant(o, "get_start", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegExMatch) GetString(name *Variant) string {
	log.Println("Calling RegExMatch.GetString()")

	returnValue := godotCallStringVariant(o, "get_string", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegExMatch) GetStrings() *Array {
	log.Println("Calling RegExMatch.GetStrings()")

	returnValue := godotCallArray(o, "get_strings")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RegExMatch) GetSubject() string {
	log.Println("Calling RegExMatch.GetSubject()")

	returnValue := godotCallString(o, "get_subject")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   RegExMatchImplementer is an interface for RegExMatch objects.
*/
type RegExMatchImplementer interface {
	Class
}

/*
   RemoteTransform leads the [Transform] of another [Spatial] derived Node (called the remote node) in the scene. It can be set to track another Node's position, rotation and/or scale. It can update using either global or local coordinates.
*/
type RemoteTransform struct {
	Spatial
}

func (o *RemoteTransform) baseClass() string {
	return "RemoteTransform"
}

/*
   Undocumented
*/
func (o *RemoteTransform) GetRemoteNode() *NodePath {
	log.Println("Calling RemoteTransform.GetRemoteNode()")

	returnValue := godotCallNodePath(o, "get_remote_node")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RemoteTransform) GetUpdatePosition() bool {
	log.Println("Calling RemoteTransform.GetUpdatePosition()")

	returnValue := godotCallBool(o, "get_update_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RemoteTransform) GetUpdateRotation() bool {
	log.Println("Calling RemoteTransform.GetUpdateRotation()")

	returnValue := godotCallBool(o, "get_update_rotation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RemoteTransform) GetUpdateScale() bool {
	log.Println("Calling RemoteTransform.GetUpdateScale()")

	returnValue := godotCallBool(o, "get_update_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RemoteTransform) GetUseGlobalCoordinates() bool {
	log.Println("Calling RemoteTransform.GetUseGlobalCoordinates()")

	returnValue := godotCallBool(o, "get_use_global_coordinates")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RemoteTransform) SetRemoteNode(path *NodePath) {
	log.Println("Calling RemoteTransform.SetRemoteNode()")

	godotCallVoidNodePath(o, "set_remote_node", path)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RemoteTransform) SetUpdatePosition(updateRemotePosition bool) {
	log.Println("Calling RemoteTransform.SetUpdatePosition()")

	godotCallVoidBool(o, "set_update_position", updateRemotePosition)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RemoteTransform) SetUpdateRotation(updateRemoteRotation bool) {
	log.Println("Calling RemoteTransform.SetUpdateRotation()")

	godotCallVoidBool(o, "set_update_rotation", updateRemoteRotation)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RemoteTransform) SetUpdateScale(updateRemoteScale bool) {
	log.Println("Calling RemoteTransform.SetUpdateScale()")

	godotCallVoidBool(o, "set_update_scale", updateRemoteScale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RemoteTransform) SetUseGlobalCoordinates(useGlobalCoordinates bool) {
	log.Println("Calling RemoteTransform.SetUseGlobalCoordinates()")

	godotCallVoidBool(o, "set_use_global_coordinates", useGlobalCoordinates)
	log.Println("  Function successfully completed.")

}

/*
   RemoteTransformImplementer is an interface for RemoteTransform objects.
*/
type RemoteTransformImplementer interface {
	Class
}

/*
   RemoteTransform2D leads the [Transform2D] of another [CanvasItem] derived Node (called the remote node) in the scene. It can be set to track another Node's position, rotation and/or scale. It can update using either global or local coordinates.
*/
type RemoteTransform2D struct {
	Node2D
}

func (o *RemoteTransform2D) baseClass() string {
	return "RemoteTransform2D"
}

/*
   Undocumented
*/
func (o *RemoteTransform2D) GetRemoteNode() *NodePath {
	log.Println("Calling RemoteTransform2D.GetRemoteNode()")

	returnValue := godotCallNodePath(o, "get_remote_node")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RemoteTransform2D) GetUpdatePosition() bool {
	log.Println("Calling RemoteTransform2D.GetUpdatePosition()")

	returnValue := godotCallBool(o, "get_update_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RemoteTransform2D) GetUpdateRotation() bool {
	log.Println("Calling RemoteTransform2D.GetUpdateRotation()")

	returnValue := godotCallBool(o, "get_update_rotation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RemoteTransform2D) GetUpdateScale() bool {
	log.Println("Calling RemoteTransform2D.GetUpdateScale()")

	returnValue := godotCallBool(o, "get_update_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RemoteTransform2D) GetUseGlobalCoordinates() bool {
	log.Println("Calling RemoteTransform2D.GetUseGlobalCoordinates()")

	returnValue := godotCallBool(o, "get_use_global_coordinates")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RemoteTransform2D) SetRemoteNode(path *NodePath) {
	log.Println("Calling RemoteTransform2D.SetRemoteNode()")

	godotCallVoidNodePath(o, "set_remote_node", path)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RemoteTransform2D) SetUpdatePosition(updateRemotePosition bool) {
	log.Println("Calling RemoteTransform2D.SetUpdatePosition()")

	godotCallVoidBool(o, "set_update_position", updateRemotePosition)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RemoteTransform2D) SetUpdateRotation(updateRemoteRotation bool) {
	log.Println("Calling RemoteTransform2D.SetUpdateRotation()")

	godotCallVoidBool(o, "set_update_rotation", updateRemoteRotation)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RemoteTransform2D) SetUpdateScale(updateRemoteScale bool) {
	log.Println("Calling RemoteTransform2D.SetUpdateScale()")

	godotCallVoidBool(o, "set_update_scale", updateRemoteScale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RemoteTransform2D) SetUseGlobalCoordinates(useGlobalCoordinates bool) {
	log.Println("Calling RemoteTransform2D.SetUseGlobalCoordinates()")

	godotCallVoidBool(o, "set_use_global_coordinates", useGlobalCoordinates)
	log.Println("  Function successfully completed.")

}

/*
   RemoteTransform2DImplementer is an interface for RemoteTransform2D objects.
*/
type RemoteTransform2DImplementer interface {
	Class
}

/*
   Resource is the base class for all resource types. Resources are primarily data containers. They are reference counted and freed when no longer in use. They are also loaded only once from disk, and further attempts to load the resource will return the same reference (all this in contrast to a [Node], which is not reference counted and can be instanced from disk as many times as desired). Resources can be saved externally on disk or bundled into another object, such as a [Node] or another resource.
*/
type Resource struct {
	Reference
}

func (o *Resource) baseClass() string {
	return "Resource"
}

/*

 */
func (o *Resource) X_SetupLocalToScene() {
	log.Println("Calling Resource.X_SetupLocalToScene()")

	godotCallVoid(o, "_setup_local_to_scene")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Resource) Duplicate(subresources bool) *Resource {
	log.Println("Calling Resource.Duplicate()")

	returnValue := godotCallObjectBool(o, "duplicate", subresources)
	log.Println("  Got return value: ", returnValue)

	var ret Resource
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *Resource) GetLocalScene() *Node {
	log.Println("Calling Resource.GetLocalScene()")

	returnValue := godotCallObject(o, "get_local_scene")
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Resource) GetName() string {
	log.Println("Calling Resource.GetName()")

	returnValue := godotCallString(o, "get_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Resource) GetPath() string {
	log.Println("Calling Resource.GetPath()")

	returnValue := godotCallString(o, "get_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the RID of the resource (or an empty RID). Many resources (such as [Texture], [Mesh], etc) are high level abstractions of resources stored in a server, so this function will return the original RID.
*/
func (o *Resource) GetRid() *RID {
	log.Println("Calling Resource.GetRid()")

	returnValue := godotCallRid(o, "get_rid")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Resource) IsLocalToScene() bool {
	log.Println("Calling Resource.IsLocalToScene()")

	returnValue := godotCallBool(o, "is_local_to_scene")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Resource) SetLocalToScene(enable bool) {
	log.Println("Calling Resource.SetLocalToScene()")

	godotCallVoidBool(o, "set_local_to_scene", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Resource) SetName(name string) {
	log.Println("Calling Resource.SetName()")

	godotCallVoidString(o, "set_name", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Resource) SetPath(path string) {
	log.Println("Calling Resource.SetPath()")

	godotCallVoidString(o, "set_path", path)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Resource) SetupLocalToScene() {
	log.Println("Calling Resource.SetupLocalToScene()")

	godotCallVoid(o, "setup_local_to_scene")
	log.Println("  Function successfully completed.")

}

/*
   Set the path of the resource. Differs from set_path(), if another [code]Resource[/code] exists with "path" it over-takes it, instead of failing.
*/
func (o *Resource) TakeOverPath(path string) {
	log.Println("Calling Resource.TakeOverPath()")

	godotCallVoidString(o, "take_over_path", path)
	log.Println("  Function successfully completed.")

}

/*
   ResourceImplementer is an interface for Resource objects.
*/
type ResourceImplementer interface {
	Class
}

/*

 */
type ResourceImporter struct {
	Reference
}

func (o *ResourceImporter) baseClass() string {
	return "ResourceImporter"
}

/*
   ResourceImporterImplementer is an interface for ResourceImporter objects.
*/
type ResourceImporterImplementer interface {
	Class
}

/*
   Undocumented
*/
type ResourceImporterOGGVorbis struct {
	ResourceImporter
}

func (o *ResourceImporterOGGVorbis) baseClass() string {
	return "ResourceImporterOGGVorbis"
}

/*
   ResourceImporterOGGVorbisImplementer is an interface for ResourceImporterOGGVorbis objects.
*/
type ResourceImporterOGGVorbisImplementer interface {
	Class
}

/*
   Undocumented
*/
type ResourceImporterTheora struct {
	ResourceImporter
}

func (o *ResourceImporterTheora) baseClass() string {
	return "ResourceImporterTheora"
}

/*
   ResourceImporterTheoraImplementer is an interface for ResourceImporterTheora objects.
*/
type ResourceImporterTheoraImplementer interface {
	Class
}

/*
   Undocumented
*/
type ResourceImporterWebm struct {
	ResourceImporter
}

func (o *ResourceImporterWebm) baseClass() string {
	return "ResourceImporterWebm"
}

/*
   ResourceImporterWebmImplementer is an interface for ResourceImporterWebm objects.
*/
type ResourceImporterWebmImplementer interface {
	Class
}

/*
   Interactive Resource Loader. This object is returned by ResourceLoader when performing an interactive load. It allows to load with high granularity, so this is mainly useful for displaying load bars/percentages.
*/
type ResourceInteractiveLoader struct {
	Reference
}

func (o *ResourceInteractiveLoader) baseClass() string {
	return "ResourceInteractiveLoader"
}

/*
   Return the loaded resource (only if loaded). Otherwise, returns null.
*/
func (o *ResourceInteractiveLoader) GetResource() *Resource {
	log.Println("Calling ResourceInteractiveLoader.GetResource()")

	returnValue := godotCallObject(o, "get_resource")
	log.Println("  Got return value: ", returnValue)

	var ret Resource
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the load stage. The total amount of stages can be queried with [method get_stage_count]
*/
func (o *ResourceInteractiveLoader) GetStage() int64 {
	log.Println("Calling ResourceInteractiveLoader.GetStage()")

	returnValue := godotCallInt(o, "get_stage")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the total amount of stages (calls to [method poll]) needed to completely load this resource.
*/
func (o *ResourceInteractiveLoader) GetStageCount() int64 {
	log.Println("Calling ResourceInteractiveLoader.GetStageCount()")

	returnValue := godotCallInt(o, "get_stage_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Poll the load. If OK is returned, this means poll will have to be called again. If ERR_FILE_EOF is returned, them the load has finished and the resource can be obtained by calling [method get_resource].
*/
func (o *ResourceInteractiveLoader) Poll() int64 {
	log.Println("Calling ResourceInteractiveLoader.Poll()")

	returnValue := godotCallInt(o, "poll")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *ResourceInteractiveLoader) Wait() int64 {
	log.Println("Calling ResourceInteractiveLoader.Wait()")

	returnValue := godotCallInt(o, "wait")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   ResourceInteractiveLoaderImplementer is an interface for ResourceInteractiveLoader objects.
*/
type ResourceInteractiveLoaderImplementer interface {
	Class
}

/*
   Resource Preloader Node. This node is used to preload sub-resources inside a scene, so when the scene is loaded all the resources are ready to use and be retrieved from here.
*/
type ResourcePreloader struct {
	Node
}

func (o *ResourcePreloader) baseClass() string {
	return "ResourcePreloader"
}

/*
   Undocumented
*/
func (o *ResourcePreloader) X_GetResources() *Array {
	log.Println("Calling ResourcePreloader.X_GetResources()")

	returnValue := godotCallArray(o, "_get_resources")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ResourcePreloader) X_SetResources(arg0 *Array) {
	log.Println("Calling ResourcePreloader.X_SetResources()")

	godotCallVoidArray(o, "_set_resources", arg0)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ResourcePreloader) AddResource(name string, resource *Resource) {
	log.Println("Calling ResourcePreloader.AddResource()")

	godotCallVoidStringObject(o, "add_resource", name, &resource.Object)
	log.Println("  Function successfully completed.")

}

/*
   Return the resource given a text-id.
*/
func (o *ResourcePreloader) GetResource(name string) *Resource {
	log.Println("Calling ResourcePreloader.GetResource()")

	returnValue := godotCallObjectString(o, "get_resource", name)
	log.Println("  Got return value: ", returnValue)

	var ret Resource
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the list of resources inside the preloader.
*/
func (o *ResourcePreloader) GetResourceList() *PoolStringArray {
	log.Println("Calling ResourcePreloader.GetResourceList()")

	returnValue := godotCallPoolStringArray(o, "get_resource_list")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return true if the preloader has a given resource.
*/
func (o *ResourcePreloader) HasResource(name string) bool {
	log.Println("Calling ResourcePreloader.HasResource()")

	returnValue := godotCallBoolString(o, "has_resource", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Remove a resource from the preloader by text id.
*/
func (o *ResourcePreloader) RemoveResource(name string) {
	log.Println("Calling ResourcePreloader.RemoveResource()")

	godotCallVoidString(o, "remove_resource", name)
	log.Println("  Function successfully completed.")

}

/*
   Rename a resource inside the preloader, from a text-id to a new text-id.
*/
func (o *ResourcePreloader) RenameResource(name string, newname string) {
	log.Println("Calling ResourcePreloader.RenameResource()")

	godotCallVoidStringString(o, "rename_resource", name, newname)
	log.Println("  Function successfully completed.")

}

/*
   ResourcePreloaderImplementer is an interface for ResourcePreloader objects.
*/
type ResourcePreloaderImplementer interface {
	Class
}

/*
   Rich text can contain custom text, fonts, images and some basic formatting. The label manages these as an internal tag stack. It also adapts itself to given width/heights. Note that assignments to [member bbcode_text] clear the tag stack and reconstruct it from the property's contents. Any edits made to [member bbcode_text] will erase previous edits made from other manual sources such as [method append_bbcode] and the [code]push_*[/code] / [method pop] methods.
*/
type RichTextLabel struct {
	Control
}

func (o *RichTextLabel) baseClass() string {
	return "RichTextLabel"
}

/*
   Undocumented
*/
func (o *RichTextLabel) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling RichTextLabel.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) X_ScrollChanged(arg0 float64) {
	log.Println("Calling RichTextLabel.X_ScrollChanged()")

	godotCallVoidFloat(o, "_scroll_changed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Adds an image's opening and closing tags to the tag stack.
*/
func (o *RichTextLabel) AddImage(image *Texture) {
	log.Println("Calling RichTextLabel.AddImage()")

	godotCallVoidObject(o, "add_image", &image.Object)
	log.Println("  Function successfully completed.")

}

/*
   Adds raw non-bbcode-parsed text to the tag stack.
*/
func (o *RichTextLabel) AddText(text string) {
	log.Println("Calling RichTextLabel.AddText()")

	godotCallVoidString(o, "add_text", text)
	log.Println("  Function successfully completed.")

}

/*
   Parses [code]bbcode[/code] and adds tags to the tag stack as needed. Returns the result of the parsing, [code]OK[/code] if successful.
*/
func (o *RichTextLabel) AppendBbcode(bbcode string) int64 {
	log.Println("Calling RichTextLabel.AppendBbcode()")

	returnValue := godotCallIntString(o, "append_bbcode", bbcode)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Clears the tag stack and sets [member bbcode_text] to an empty string.
*/
func (o *RichTextLabel) Clear() {
	log.Println("Calling RichTextLabel.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) GetBbcode() string {
	log.Println("Calling RichTextLabel.GetBbcode()")

	returnValue := godotCallString(o, "get_bbcode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the total number of newlines in the tag stack's text tags. Considers wrapped text as one line.
*/
func (o *RichTextLabel) GetLineCount() int64 {
	log.Println("Calling RichTextLabel.GetLineCount()")

	returnValue := godotCallInt(o, "get_line_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RichTextLabel) GetPercentVisible() float64 {
	log.Println("Calling RichTextLabel.GetPercentVisible()")

	returnValue := godotCallFloat(o, "get_percent_visible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RichTextLabel) GetTabSize() int64 {
	log.Println("Calling RichTextLabel.GetTabSize()")

	returnValue := godotCallInt(o, "get_tab_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RichTextLabel) GetText() string {
	log.Println("Calling RichTextLabel.GetText()")

	returnValue := godotCallString(o, "get_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the total number of characters from text tags. Does not include bbcodes.
*/
func (o *RichTextLabel) GetTotalCharacterCount() int64 {
	log.Println("Calling RichTextLabel.GetTotalCharacterCount()")

	returnValue := godotCallInt(o, "get_total_character_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the vertical scrollbar.
*/
func (o *RichTextLabel) GetVScroll() *VScrollBar {
	log.Println("Calling RichTextLabel.GetVScroll()")

	returnValue := godotCallObject(o, "get_v_scroll")
	log.Println("  Got return value: ", returnValue)

	var ret VScrollBar
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *RichTextLabel) GetVisibleCharacters() int64 {
	log.Println("Calling RichTextLabel.GetVisibleCharacters()")

	returnValue := godotCallInt(o, "get_visible_characters")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of visible lines.
*/
func (o *RichTextLabel) GetVisibleLineCount() int64 {
	log.Println("Calling RichTextLabel.GetVisibleLineCount()")

	returnValue := godotCallInt(o, "get_visible_line_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RichTextLabel) IsMetaUnderlined() bool {
	log.Println("Calling RichTextLabel.IsMetaUnderlined()")

	returnValue := godotCallBool(o, "is_meta_underlined")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RichTextLabel) IsOverridingSelectedFontColor() bool {
	log.Println("Calling RichTextLabel.IsOverridingSelectedFontColor()")

	returnValue := godotCallBool(o, "is_overriding_selected_font_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RichTextLabel) IsScrollActive() bool {
	log.Println("Calling RichTextLabel.IsScrollActive()")

	returnValue := godotCallBool(o, "is_scroll_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RichTextLabel) IsScrollFollowing() bool {
	log.Println("Calling RichTextLabel.IsScrollFollowing()")

	returnValue := godotCallBool(o, "is_scroll_following")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RichTextLabel) IsSelectionEnabled() bool {
	log.Println("Calling RichTextLabel.IsSelectionEnabled()")

	returnValue := godotCallBool(o, "is_selection_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RichTextLabel) IsUsingBbcode() bool {
	log.Println("Calling RichTextLabel.IsUsingBbcode()")

	returnValue := godotCallBool(o, "is_using_bbcode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Adds a newline tag to the tag stack.
*/
func (o *RichTextLabel) Newline() {
	log.Println("Calling RichTextLabel.Newline()")

	godotCallVoid(o, "newline")
	log.Println("  Function successfully completed.")

}

/*
   The assignment version of [method append_bbcode]. Clears the tag stack and inserts the new content. Returns [code]OK[/code] if parses [code]bbcode[/code] successfully.
*/
func (o *RichTextLabel) ParseBbcode(bbcode string) int64 {
	log.Println("Calling RichTextLabel.ParseBbcode()")

	returnValue := godotCallIntString(o, "parse_bbcode", bbcode)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Terminates the current tag. Use after [code]push_*[/code] methods to close bbcodes manually. Does not need to follow [code]add_*[/code] methods.
*/
func (o *RichTextLabel) Pop() {
	log.Println("Calling RichTextLabel.Pop()")

	godotCallVoid(o, "pop")
	log.Println("  Function successfully completed.")

}

/*
   Adds a [code][right][/code] tag to the tag stack.
*/
func (o *RichTextLabel) PushAlign(align int64) {
	log.Println("Calling RichTextLabel.PushAlign()")

	godotCallVoidInt(o, "push_align", align)
	log.Println("  Function successfully completed.")

}

/*
   Adds a [code][cell][/code] tag to the tag stack. Must be inside a [table] tag. See [method push_table] for details.
*/
func (o *RichTextLabel) PushCell() {
	log.Println("Calling RichTextLabel.PushCell()")

	godotCallVoid(o, "push_cell")
	log.Println("  Function successfully completed.")

}

/*
   Adds a [code][color][/code] tag to the tag stack.
*/
func (o *RichTextLabel) PushColor(color *Color) {
	log.Println("Calling RichTextLabel.PushColor()")

	godotCallVoidColor(o, "push_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Adds a [code][font][/code] tag to the tag stack. Overrides default fonts for its duration.
*/
func (o *RichTextLabel) PushFont(font *Font) {
	log.Println("Calling RichTextLabel.PushFont()")

	godotCallVoidObject(o, "push_font", &font.Object)
	log.Println("  Function successfully completed.")

}

/*
   Adds an [code][indent][/code] tag to the tag stack. Multiplies "level" by current tab_size to determine new margin length.
*/
func (o *RichTextLabel) PushIndent(level int64) {
	log.Println("Calling RichTextLabel.PushIndent()")

	godotCallVoidInt(o, "push_indent", level)
	log.Println("  Function successfully completed.")

}

/*
   Adds a list tag to the tag stack. Similar to the bbcodes [code][ol][/code] or [code][ul][/code], but supports more list types. Not fully implemented!
*/
func (o *RichTextLabel) PushList(aType int64) {
	log.Println("Calling RichTextLabel.PushList()")

	godotCallVoidInt(o, "push_list", aType)
	log.Println("  Function successfully completed.")

}

/*
   Adds a meta tag to the tag stack. Similar to the bbcode [code][url=something]{text}[/url][/code], but supports non-[String] metadata types.
*/
func (o *RichTextLabel) PushMeta(data *Variant) {
	log.Println("Calling RichTextLabel.PushMeta()")

	godotCallVoidVariant(o, "push_meta", data)
	log.Println("  Function successfully completed.")

}

/*
   Adds a [code][table=columns][/code] tag to the tag stack.
*/
func (o *RichTextLabel) PushTable(columns int64) {
	log.Println("Calling RichTextLabel.PushTable()")

	godotCallVoidInt(o, "push_table", columns)
	log.Println("  Function successfully completed.")

}

/*
   Adds a [code][u][/code] tag to the tag stack.
*/
func (o *RichTextLabel) PushUnderline() {
	log.Println("Calling RichTextLabel.PushUnderline()")

	godotCallVoid(o, "push_underline")
	log.Println("  Function successfully completed.")

}

/*
   Removes a line of content from the label. Returns [code]true[/code] if the line exists.
*/
func (o *RichTextLabel) RemoveLine(line int64) bool {
	log.Println("Calling RichTextLabel.RemoveLine()")

	returnValue := godotCallBoolInt(o, "remove_line", line)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Scrolls the window's top line to match [code]line[/code].
*/
func (o *RichTextLabel) ScrollToLine(line int64) {
	log.Println("Calling RichTextLabel.ScrollToLine()")

	godotCallVoidInt(o, "scroll_to_line", line)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) SetBbcode(text string) {
	log.Println("Calling RichTextLabel.SetBbcode()")

	godotCallVoidString(o, "set_bbcode", text)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) SetMetaUnderline(enable bool) {
	log.Println("Calling RichTextLabel.SetMetaUnderline()")

	godotCallVoidBool(o, "set_meta_underline", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) SetOverrideSelectedFontColor(override bool) {
	log.Println("Calling RichTextLabel.SetOverrideSelectedFontColor()")

	godotCallVoidBool(o, "set_override_selected_font_color", override)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) SetPercentVisible(percentVisible float64) {
	log.Println("Calling RichTextLabel.SetPercentVisible()")

	godotCallVoidFloat(o, "set_percent_visible", percentVisible)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) SetScrollActive(active bool) {
	log.Println("Calling RichTextLabel.SetScrollActive()")

	godotCallVoidBool(o, "set_scroll_active", active)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) SetScrollFollow(follow bool) {
	log.Println("Calling RichTextLabel.SetScrollFollow()")

	godotCallVoidBool(o, "set_scroll_follow", follow)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) SetSelectionEnabled(enabled bool) {
	log.Println("Calling RichTextLabel.SetSelectionEnabled()")

	godotCallVoidBool(o, "set_selection_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) SetTabSize(spaces int64) {
	log.Println("Calling RichTextLabel.SetTabSize()")

	godotCallVoidInt(o, "set_tab_size", spaces)
	log.Println("  Function successfully completed.")

}

/*
   Edits the selected columns expansion options. If [code]expand[/code] is [code]true[/code], the column expands in proportion to its expansion ratio versus the other columns' ratios. For example, 2 columns with ratios 3 and 4 plus 70 pixels in available width would expand 30 and 40 pixels, respectively. Columns with a [code]false[/code] expand will not contribute to the total ratio.
*/
func (o *RichTextLabel) SetTableColumnExpand(column int64, expand bool, ratio int64) {
	log.Println("Calling RichTextLabel.SetTableColumnExpand()")

	godotCallVoidIntBoolInt(o, "set_table_column_expand", column, expand, ratio)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) SetText(text string) {
	log.Println("Calling RichTextLabel.SetText()")

	godotCallVoidString(o, "set_text", text)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) SetUseBbcode(enable bool) {
	log.Println("Calling RichTextLabel.SetUseBbcode()")

	godotCallVoidBool(o, "set_use_bbcode", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RichTextLabel) SetVisibleCharacters(amount int64) {
	log.Println("Calling RichTextLabel.SetVisibleCharacters()")

	godotCallVoidInt(o, "set_visible_characters", amount)
	log.Println("  Function successfully completed.")

}

/*
   RichTextLabelImplementer is an interface for RichTextLabel objects.
*/
type RichTextLabelImplementer interface {
	Class
}

/*
   This is the node that implements full 3D physics. This means that you do not control a RigidBody directly. Instead you can apply forces to it (gravity, impulses, etc.), and the physics simulation will calculate the resulting movement, collision, bouncing, rotating, etc. A RigidBody has 4 behavior [member mode]s: Rigid, Static, Character, and Kinematic. [b]Note:[/b] Don't change a RigidBody's position every frame or very often. Sporadic changes work fine, but physics runs at a different granularity (fixed hz) than usual rendering (process callback) and maybe even in a separate thread, so changing this from a process loop will yield strange behavior. If you need to directly affect the body's state, use [method _integrate_forces], which allows you to directly access the physics state. If you need to override the default physics behavior, you can write a custom force integration. See [member custom_integrator].
*/
type RigidBody struct {
	PhysicsBody
}

func (o *RigidBody) baseClass() string {
	return "RigidBody"
}

/*
   Undocumented
*/
func (o *RigidBody) X_BodyEnterTree(arg0 int64) {
	log.Println("Calling RigidBody.X_BodyEnterTree()")

	godotCallVoidInt(o, "_body_enter_tree", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) X_BodyExitTree(arg0 int64) {
	log.Println("Calling RigidBody.X_BodyExitTree()")

	godotCallVoidInt(o, "_body_exit_tree", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) X_DirectStateChanged(arg0 *Object) {
	log.Println("Calling RigidBody.X_DirectStateChanged()")

	godotCallVoidObject(o, "_direct_state_changed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default it works in addition to the usual physics behavior, but [method set_use_custom_integrator] allows you to disable the default behavior and do fully custom force integration for a body.
*/
func (o *RigidBody) X_IntegrateForces(state *PhysicsDirectBodyState) {
	log.Println("Calling RigidBody.X_IntegrateForces()")

	godotCallVoidObject(o, "_integrate_forces", &state.Object)
	log.Println("  Function successfully completed.")

}

/*
   Apply a positioned impulse (which will be affected by the body mass and shape). This is the equivalent of hitting a billiard ball with a cue: a force that is applied once, and only once. Both the impulse and the position are in global coordinates, and the position is relative to the object's origin.
*/
func (o *RigidBody) ApplyImpulse(position *Vector3, impulse *Vector3) {
	log.Println("Calling RigidBody.ApplyImpulse()")

	godotCallVoidVector3Vector3(o, "apply_impulse", position, impulse)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) GetAngularDamp() float64 {
	log.Println("Calling RigidBody.GetAngularDamp()")

	returnValue := godotCallFloat(o, "get_angular_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) GetAngularVelocity() *Vector3 {
	log.Println("Calling RigidBody.GetAngularVelocity()")

	returnValue := godotCallVector3(o, "get_angular_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) GetAxisLock(axis int64) bool {
	log.Println("Calling RigidBody.GetAxisLock()")

	returnValue := godotCallBoolInt(o, "get_axis_lock", axis)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) GetBounce() float64 {
	log.Println("Calling RigidBody.GetBounce()")

	returnValue := godotCallFloat(o, "get_bounce")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return a list of the bodies colliding with this one. By default, number of max contacts reported is at 0 , see [method set_max_contacts_reported] to increase it. Note that the result of this test is not immediate after moving objects. For performance, list of collisions is updated once per frame and before the physics step. Consider using signals instead.
*/
func (o *RigidBody) GetCollidingBodies() *Array {
	log.Println("Calling RigidBody.GetCollidingBodies()")

	returnValue := godotCallArray(o, "get_colliding_bodies")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) GetFriction() float64 {
	log.Println("Calling RigidBody.GetFriction()")

	returnValue := godotCallFloat(o, "get_friction")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) GetGravityScale() float64 {
	log.Println("Calling RigidBody.GetGravityScale()")

	returnValue := godotCallFloat(o, "get_gravity_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) GetLinearDamp() float64 {
	log.Println("Calling RigidBody.GetLinearDamp()")

	returnValue := godotCallFloat(o, "get_linear_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) GetLinearVelocity() *Vector3 {
	log.Println("Calling RigidBody.GetLinearVelocity()")

	returnValue := godotCallVector3(o, "get_linear_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) GetMass() float64 {
	log.Println("Calling RigidBody.GetMass()")

	returnValue := godotCallFloat(o, "get_mass")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) GetMaxContactsReported() int64 {
	log.Println("Calling RigidBody.GetMaxContactsReported()")

	returnValue := godotCallInt(o, "get_max_contacts_reported")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) GetMode() int64 {
	log.Println("Calling RigidBody.GetMode()")

	returnValue := godotCallInt(o, "get_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) GetWeight() float64 {
	log.Println("Calling RigidBody.GetWeight()")

	returnValue := godotCallFloat(o, "get_weight")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) IsAbleToSleep() bool {
	log.Println("Calling RigidBody.IsAbleToSleep()")

	returnValue := godotCallBool(o, "is_able_to_sleep")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) IsContactMonitorEnabled() bool {
	log.Println("Calling RigidBody.IsContactMonitorEnabled()")

	returnValue := godotCallBool(o, "is_contact_monitor_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) IsSleeping() bool {
	log.Println("Calling RigidBody.IsSleeping()")

	returnValue := godotCallBool(o, "is_sleeping")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) IsUsingContinuousCollisionDetection() bool {
	log.Println("Calling RigidBody.IsUsingContinuousCollisionDetection()")

	returnValue := godotCallBool(o, "is_using_continuous_collision_detection")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) IsUsingCustomIntegrator() bool {
	log.Println("Calling RigidBody.IsUsingCustomIntegrator()")

	returnValue := godotCallBool(o, "is_using_custom_integrator")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody) SetAngularDamp(angularDamp float64) {
	log.Println("Calling RigidBody.SetAngularDamp()")

	godotCallVoidFloat(o, "set_angular_damp", angularDamp)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetAngularVelocity(angularVelocity *Vector3) {
	log.Println("Calling RigidBody.SetAngularVelocity()")

	godotCallVoidVector3(o, "set_angular_velocity", angularVelocity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetAxisLock(axis int64, lock bool) {
	log.Println("Calling RigidBody.SetAxisLock()")

	godotCallVoidIntBool(o, "set_axis_lock", axis, lock)
	log.Println("  Function successfully completed.")

}

/*
   Set an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *RigidBody) SetAxisVelocity(axisVelocity *Vector3) {
	log.Println("Calling RigidBody.SetAxisVelocity()")

	godotCallVoidVector3(o, "set_axis_velocity", axisVelocity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetBounce(bounce float64) {
	log.Println("Calling RigidBody.SetBounce()")

	godotCallVoidFloat(o, "set_bounce", bounce)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetCanSleep(ableToSleep bool) {
	log.Println("Calling RigidBody.SetCanSleep()")

	godotCallVoidBool(o, "set_can_sleep", ableToSleep)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetContactMonitor(enabled bool) {
	log.Println("Calling RigidBody.SetContactMonitor()")

	godotCallVoidBool(o, "set_contact_monitor", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetFriction(friction float64) {
	log.Println("Calling RigidBody.SetFriction()")

	godotCallVoidFloat(o, "set_friction", friction)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetGravityScale(gravityScale float64) {
	log.Println("Calling RigidBody.SetGravityScale()")

	godotCallVoidFloat(o, "set_gravity_scale", gravityScale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetLinearDamp(linearDamp float64) {
	log.Println("Calling RigidBody.SetLinearDamp()")

	godotCallVoidFloat(o, "set_linear_damp", linearDamp)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetLinearVelocity(linearVelocity *Vector3) {
	log.Println("Calling RigidBody.SetLinearVelocity()")

	godotCallVoidVector3(o, "set_linear_velocity", linearVelocity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetMass(mass float64) {
	log.Println("Calling RigidBody.SetMass()")

	godotCallVoidFloat(o, "set_mass", mass)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetMaxContactsReported(amount int64) {
	log.Println("Calling RigidBody.SetMaxContactsReported()")

	godotCallVoidInt(o, "set_max_contacts_reported", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetMode(mode int64) {
	log.Println("Calling RigidBody.SetMode()")

	godotCallVoidInt(o, "set_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetSleeping(sleeping bool) {
	log.Println("Calling RigidBody.SetSleeping()")

	godotCallVoidBool(o, "set_sleeping", sleeping)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetUseContinuousCollisionDetection(enable bool) {
	log.Println("Calling RigidBody.SetUseContinuousCollisionDetection()")

	godotCallVoidBool(o, "set_use_continuous_collision_detection", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetUseCustomIntegrator(enable bool) {
	log.Println("Calling RigidBody.SetUseCustomIntegrator()")

	godotCallVoidBool(o, "set_use_custom_integrator", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody) SetWeight(weight float64) {
	log.Println("Calling RigidBody.SetWeight()")

	godotCallVoidFloat(o, "set_weight", weight)
	log.Println("  Function successfully completed.")

}

/*
   RigidBodyImplementer is an interface for RigidBody objects.
*/
type RigidBodyImplementer interface {
	Class
}

/*
   This node implements simulated 2D physics. You do not control a RigidBody2D directly. Instead you apply forces to it (gravity, impulses, etc.) and the physics simulation calculates the resulting movement based on its mass, friction, and other physical properties. A RigidBody2D has 4 behavior [member mode]s: Rigid, Static, Character, and Kinematic. [b]Note:[/b] You should not change a RigidBody2D's [code]position[/code] or [code]linear_velocity[/code] every frame or even very often. If you need to directly affect the body's state, use [method _integrate_forces], which allows you to directly access the physics state. If you need to override the default physics behavior, you can write a custom force integration. See [member custom_integrator].
*/
type RigidBody2D struct {
	PhysicsBody2D
}

func (o *RigidBody2D) baseClass() string {
	return "RigidBody2D"
}

/*
   Undocumented
*/
func (o *RigidBody2D) X_BodyEnterTree(arg0 int64) {
	log.Println("Calling RigidBody2D.X_BodyEnterTree()")

	godotCallVoidInt(o, "_body_enter_tree", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) X_BodyExitTree(arg0 int64) {
	log.Println("Calling RigidBody2D.X_BodyExitTree()")

	godotCallVoidInt(o, "_body_exit_tree", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) X_DirectStateChanged(arg0 *Object) {
	log.Println("Calling RigidBody2D.X_DirectStateChanged()")

	godotCallVoidObject(o, "_direct_state_changed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Allows you to read and safely modify the simulation state for the object. Use this instead of [Node._physics_process] if you need to directly change the body's [code]position[/code] or other physics properties. By default it works in addition to the usual physics behavior, but [member custom_integrator] allows you to disable the default behavior and write custom force integration for a body.
*/
func (o *RigidBody2D) X_IntegrateForces(state *Physics2DDirectBodyState) {
	log.Println("Calling RigidBody2D.X_IntegrateForces()")

	godotCallVoidObject(o, "_integrate_forces", &state.Object)
	log.Println("  Function successfully completed.")

}

/*
   Adds a positioned force to the body. Both the force and the offset from the body origin are in global coordinates.
*/
func (o *RigidBody2D) AddForce(offset *Vector2, force *Vector2) {
	log.Println("Calling RigidBody2D.AddForce()")

	godotCallVoidVector2Vector2(o, "add_force", offset, force)
	log.Println("  Function successfully completed.")

}

/*
   Applies a positioned impulse to the body (which will be affected by the body mass and shape). This is the equivalent of hitting a billiard ball with a cue: a force that is applied instantaneously. Both the impulse and the offset from the body origin are in global coordinates.
*/
func (o *RigidBody2D) ApplyImpulse(offset *Vector2, impulse *Vector2) {
	log.Println("Calling RigidBody2D.ApplyImpulse()")

	godotCallVoidVector2Vector2(o, "apply_impulse", offset, impulse)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetAngularDamp() float64 {
	log.Println("Calling RigidBody2D.GetAngularDamp()")

	returnValue := godotCallFloat(o, "get_angular_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetAngularVelocity() float64 {
	log.Println("Calling RigidBody2D.GetAngularVelocity()")

	returnValue := godotCallFloat(o, "get_angular_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetAppliedForce() *Vector2 {
	log.Println("Calling RigidBody2D.GetAppliedForce()")

	returnValue := godotCallVector2(o, "get_applied_force")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetAppliedTorque() float64 {
	log.Println("Calling RigidBody2D.GetAppliedTorque()")

	returnValue := godotCallFloat(o, "get_applied_torque")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetBounce() float64 {
	log.Println("Calling RigidBody2D.GetBounce()")

	returnValue := godotCallFloat(o, "get_bounce")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a list of the bodies colliding with this one. Use [member contacts_reported] to set the maximum number reported. You must also set [member contact_monitor] to [code]true[/code]. Note that the result of this test is not immediate after moving objects. For performance, list of collisions is updated once per frame and before the physics step. Consider using signals instead.
*/
func (o *RigidBody2D) GetCollidingBodies() *Array {
	log.Println("Calling RigidBody2D.GetCollidingBodies()")

	returnValue := godotCallArray(o, "get_colliding_bodies")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetContinuousCollisionDetectionMode() int64 {
	log.Println("Calling RigidBody2D.GetContinuousCollisionDetectionMode()")

	returnValue := godotCallInt(o, "get_continuous_collision_detection_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetFriction() float64 {
	log.Println("Calling RigidBody2D.GetFriction()")

	returnValue := godotCallFloat(o, "get_friction")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetGravityScale() float64 {
	log.Println("Calling RigidBody2D.GetGravityScale()")

	returnValue := godotCallFloat(o, "get_gravity_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetInertia() float64 {
	log.Println("Calling RigidBody2D.GetInertia()")

	returnValue := godotCallFloat(o, "get_inertia")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetLinearDamp() float64 {
	log.Println("Calling RigidBody2D.GetLinearDamp()")

	returnValue := godotCallFloat(o, "get_linear_damp")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetLinearVelocity() *Vector2 {
	log.Println("Calling RigidBody2D.GetLinearVelocity()")

	returnValue := godotCallVector2(o, "get_linear_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetMass() float64 {
	log.Println("Calling RigidBody2D.GetMass()")

	returnValue := godotCallFloat(o, "get_mass")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetMaxContactsReported() int64 {
	log.Println("Calling RigidBody2D.GetMaxContactsReported()")

	returnValue := godotCallInt(o, "get_max_contacts_reported")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetMode() int64 {
	log.Println("Calling RigidBody2D.GetMode()")

	returnValue := godotCallInt(o, "get_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) GetWeight() float64 {
	log.Println("Calling RigidBody2D.GetWeight()")

	returnValue := godotCallFloat(o, "get_weight")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) IsAbleToSleep() bool {
	log.Println("Calling RigidBody2D.IsAbleToSleep()")

	returnValue := godotCallBool(o, "is_able_to_sleep")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) IsContactMonitorEnabled() bool {
	log.Println("Calling RigidBody2D.IsContactMonitorEnabled()")

	returnValue := godotCallBool(o, "is_contact_monitor_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) IsSleeping() bool {
	log.Println("Calling RigidBody2D.IsSleeping()")

	returnValue := godotCallBool(o, "is_sleeping")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) IsUsingCustomIntegrator() bool {
	log.Println("Calling RigidBody2D.IsUsingCustomIntegrator()")

	returnValue := godotCallBool(o, "is_using_custom_integrator")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetAngularDamp(angularDamp float64) {
	log.Println("Calling RigidBody2D.SetAngularDamp()")

	godotCallVoidFloat(o, "set_angular_damp", angularDamp)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetAngularVelocity(angularVelocity float64) {
	log.Println("Calling RigidBody2D.SetAngularVelocity()")

	godotCallVoidFloat(o, "set_angular_velocity", angularVelocity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetAppliedForce(force *Vector2) {
	log.Println("Calling RigidBody2D.SetAppliedForce()")

	godotCallVoidVector2(o, "set_applied_force", force)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetAppliedTorque(torque float64) {
	log.Println("Calling RigidBody2D.SetAppliedTorque()")

	godotCallVoidFloat(o, "set_applied_torque", torque)
	log.Println("  Function successfully completed.")

}

/*
   Sets the body's velocity on the given axis. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *RigidBody2D) SetAxisVelocity(axisVelocity *Vector2) {
	log.Println("Calling RigidBody2D.SetAxisVelocity()")

	godotCallVoidVector2(o, "set_axis_velocity", axisVelocity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetBounce(bounce float64) {
	log.Println("Calling RigidBody2D.SetBounce()")

	godotCallVoidFloat(o, "set_bounce", bounce)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetCanSleep(ableToSleep bool) {
	log.Println("Calling RigidBody2D.SetCanSleep()")

	godotCallVoidBool(o, "set_can_sleep", ableToSleep)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetContactMonitor(enabled bool) {
	log.Println("Calling RigidBody2D.SetContactMonitor()")

	godotCallVoidBool(o, "set_contact_monitor", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetContinuousCollisionDetectionMode(mode int64) {
	log.Println("Calling RigidBody2D.SetContinuousCollisionDetectionMode()")

	godotCallVoidInt(o, "set_continuous_collision_detection_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetFriction(friction float64) {
	log.Println("Calling RigidBody2D.SetFriction()")

	godotCallVoidFloat(o, "set_friction", friction)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetGravityScale(gravityScale float64) {
	log.Println("Calling RigidBody2D.SetGravityScale()")

	godotCallVoidFloat(o, "set_gravity_scale", gravityScale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetInertia(inertia float64) {
	log.Println("Calling RigidBody2D.SetInertia()")

	godotCallVoidFloat(o, "set_inertia", inertia)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetLinearDamp(linearDamp float64) {
	log.Println("Calling RigidBody2D.SetLinearDamp()")

	godotCallVoidFloat(o, "set_linear_damp", linearDamp)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetLinearVelocity(linearVelocity *Vector2) {
	log.Println("Calling RigidBody2D.SetLinearVelocity()")

	godotCallVoidVector2(o, "set_linear_velocity", linearVelocity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetMass(mass float64) {
	log.Println("Calling RigidBody2D.SetMass()")

	godotCallVoidFloat(o, "set_mass", mass)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetMaxContactsReported(amount int64) {
	log.Println("Calling RigidBody2D.SetMaxContactsReported()")

	godotCallVoidInt(o, "set_max_contacts_reported", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetMode(mode int64) {
	log.Println("Calling RigidBody2D.SetMode()")

	godotCallVoidInt(o, "set_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetSleeping(sleeping bool) {
	log.Println("Calling RigidBody2D.SetSleeping()")

	godotCallVoidBool(o, "set_sleeping", sleeping)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetUseCustomIntegrator(enable bool) {
	log.Println("Calling RigidBody2D.SetUseCustomIntegrator()")

	godotCallVoidBool(o, "set_use_custom_integrator", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *RigidBody2D) SetWeight(weight float64) {
	log.Println("Calling RigidBody2D.SetWeight()")

	godotCallVoidFloat(o, "set_weight", weight)
	log.Println("  Function successfully completed.")

}

/*
   Returns [code]true[/code] if a collision would result from moving in the given vector. [code]margin[/code] increases the size of the shapes involved in the collision detection, and [code]result[/code] is an object of type [Physics2DTestMotionResult], which contains additional information about the collision (should there be one).
*/
func (o *RigidBody2D) TestMotion(motion *Vector2, margin float64, result *Physics2DTestMotionResult) bool {
	log.Println("Calling RigidBody2D.TestMotion()")

	returnValue := godotCallBoolVector2FloatObject(o, "test_motion", motion, margin, &result.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   RigidBody2DImplementer is an interface for RigidBody2D objects.
*/
type RigidBody2DImplementer interface {
	Class
}

/*
   Maintains a list of resources, nodes, exported and overridden properties, and built-in scripts associated with a scene.
*/
type SceneState struct {
	Reference
}

func (o *SceneState) baseClass() string {
	return "SceneState"
}

/*
   Returns the list of bound parameters for the signal at [code]idx[/code].
*/
func (o *SceneState) GetConnectionBinds(idx int64) *Array {
	log.Println("Calling SceneState.GetConnectionBinds()")

	returnValue := godotCallArrayInt(o, "get_connection_binds", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of signal connections in the scene.
*/
func (o *SceneState) GetConnectionCount() int64 {
	log.Println("Calling SceneState.GetConnectionCount()")

	returnValue := godotCallInt(o, "get_connection_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the flags for the signal at [code]idx[/code]. See [Object]'s [code]CONNECT_*[/code] flags.
*/
func (o *SceneState) GetConnectionFlags(idx int64) int64 {
	log.Println("Calling SceneState.GetConnectionFlags()")

	returnValue := godotCallIntInt(o, "get_connection_flags", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the method connected to the signal at [code]idx[/code].
*/
func (o *SceneState) GetConnectionMethod(idx int64) string {
	log.Println("Calling SceneState.GetConnectionMethod()")

	returnValue := godotCallStringInt(o, "get_connection_method", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the name of the signal at [code]idx[/code].
*/
func (o *SceneState) GetConnectionSignal(idx int64) string {
	log.Println("Calling SceneState.GetConnectionSignal()")

	returnValue := godotCallStringInt(o, "get_connection_signal", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the path to the node that owns the signal at [code]idx[/code], relative to the root node.
*/
func (o *SceneState) GetConnectionSource(idx int64) *NodePath {
	log.Println("Calling SceneState.GetConnectionSource()")

	returnValue := godotCallNodePathInt(o, "get_connection_source", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the path to the node that owns the method connected to the signal at [code]idx[/code], relative to the root node.
*/
func (o *SceneState) GetConnectionTarget(idx int64) *NodePath {
	log.Println("Calling SceneState.GetConnectionTarget()")

	returnValue := godotCallNodePathInt(o, "get_connection_target", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of nodes in the scene.
*/
func (o *SceneState) GetNodeCount() int64 {
	log.Println("Calling SceneState.GetNodeCount()")

	returnValue := godotCallInt(o, "get_node_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the list of group names associated with the node at [code]idx[/code].
*/
func (o *SceneState) GetNodeGroups(idx int64) *PoolStringArray {
	log.Println("Calling SceneState.GetNodeGroups()")

	returnValue := godotCallPoolStringArrayInt(o, "get_node_groups", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeIndex(idx int64) int64 {
	log.Println("Calling SceneState.GetNodeIndex()")

	returnValue := godotCallIntInt(o, "get_node_index", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the scene for the node at [code]idx[/code] or [code]null[/code] if the node is not an instance.
*/
func (o *SceneState) GetNodeInstance(idx int64) *PackedScene {
	log.Println("Calling SceneState.GetNodeInstance()")

	returnValue := godotCallObjectInt(o, "get_node_instance", idx)
	log.Println("  Got return value: ", returnValue)

	var ret PackedScene
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the path to the represented scene file if the node at [code]idx[/code] is an [InstancePlaceholder].
*/
func (o *SceneState) GetNodeInstancePlaceholder(idx int64) string {
	log.Println("Calling SceneState.GetNodeInstancePlaceholder()")

	returnValue := godotCallStringInt(o, "get_node_instance_placeholder", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the name of the node at [code]idx[/code].
*/
func (o *SceneState) GetNodeName(idx int64) string {
	log.Println("Calling SceneState.GetNodeName()")

	returnValue := godotCallStringInt(o, "get_node_name", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the path to the owner of the node at [code]idx[/code], relative to the root node.
*/
func (o *SceneState) GetNodeOwnerPath(idx int64) *NodePath {
	log.Println("Calling SceneState.GetNodeOwnerPath()")

	returnValue := godotCallNodePathInt(o, "get_node_owner_path", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the path to the node at [code]idx[/code].
*/
func (o *SceneState) GetNodePath(idx int64, forParent bool) *NodePath {
	log.Println("Calling SceneState.GetNodePath()")

	returnValue := godotCallNodePathIntBool(o, "get_node_path", idx, forParent)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the number of exported or overridden properties for the node at [code]idx[/code].
*/
func (o *SceneState) GetNodePropertyCount(idx int64) int64 {
	log.Println("Calling SceneState.GetNodePropertyCount()")

	returnValue := godotCallIntInt(o, "get_node_property_count", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the name of the property at [code]prop_idx[/code] for the node at [code]idx[/code].
*/
func (o *SceneState) GetNodePropertyName(idx int64, propIdx int64) string {
	log.Println("Calling SceneState.GetNodePropertyName()")

	returnValue := godotCallStringIntInt(o, "get_node_property_name", idx, propIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the value of the property at [code]prop_idx[/code] for the node at [code]idx[/code].
*/
func (o *SceneState) GetNodePropertyValue(idx int64, propIdx int64) *Variant {
	log.Println("Calling SceneState.GetNodePropertyValue()")

	returnValue := godotCallVariantIntInt(o, "get_node_property_value", idx, propIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the type of the node at [code]idx[/code].
*/
func (o *SceneState) GetNodeType(idx int64) string {
	log.Println("Calling SceneState.GetNodeType()")

	returnValue := godotCallStringInt(o, "get_node_type", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the node at [code]idx[/code] is an [InstancePlaceholder].
*/
func (o *SceneState) IsNodeInstancePlaceholder(idx int64) bool {
	log.Println("Calling SceneState.IsNodeInstancePlaceholder()")

	returnValue := godotCallBoolInt(o, "is_node_instance_placeholder", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   SceneStateImplementer is an interface for SceneState objects.
*/
type SceneStateImplementer interface {
	Class
}

/*

 */
type SceneTree struct {
	MainLoop
}

func (o *SceneTree) baseClass() string {
	return "SceneTree"
}

/*
   Undocumented
*/
func (o *SceneTree) X_ChangeScene(arg0 *Object) {
	log.Println("Calling SceneTree.X_ChangeScene()")

	godotCallVoidObject(o, "_change_scene", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) X_ConnectedToServer() {
	log.Println("Calling SceneTree.X_ConnectedToServer()")

	godotCallVoid(o, "_connected_to_server")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) X_ConnectionFailed() {
	log.Println("Calling SceneTree.X_ConnectionFailed()")

	godotCallVoid(o, "_connection_failed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) X_NetworkPeerConnected(arg0 int64) {
	log.Println("Calling SceneTree.X_NetworkPeerConnected()")

	godotCallVoidInt(o, "_network_peer_connected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) X_NetworkPeerDisconnected(arg0 int64) {
	log.Println("Calling SceneTree.X_NetworkPeerDisconnected()")

	godotCallVoidInt(o, "_network_peer_disconnected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) X_ServerDisconnected() {
	log.Println("Calling SceneTree.X_ServerDisconnected()")

	godotCallVoid(o, "_server_disconnected")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SceneTree) CallGroup(group string, method string, varArgs ...interface{}) *Variant {
	log.Println("Calling SceneTree.CallGroup()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantStringStringVarargs(o, "call_group", group, method, varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneTree) CallGroupFlags(flags int64, group string, method string, varArgs ...interface{}) *Variant {
	log.Println("Calling SceneTree.CallGroupFlags()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantIntStringStringVarargs(o, "call_group_flags", flags, group, method, varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneTree) ChangeScene(path string) int64 {
	log.Println("Calling SceneTree.ChangeScene()")

	returnValue := godotCallIntString(o, "change_scene", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneTree) ChangeSceneTo(packedScene *PackedScene) int64 {
	log.Println("Calling SceneTree.ChangeSceneTo()")

	returnValue := godotCallIntObject(o, "change_scene_to", &packedScene.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneTree) CreateTimer(timeSec float64, pauseModeProcess bool) *SceneTreeTimer {
	log.Println("Calling SceneTree.CreateTimer()")

	returnValue := godotCallObjectFloatBool(o, "create_timer", timeSec, pauseModeProcess)
	log.Println("  Got return value: ", returnValue)

	var ret SceneTreeTimer
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *SceneTree) GetCurrentScene() *Node {
	log.Println("Calling SceneTree.GetCurrentScene()")

	returnValue := godotCallObject(o, "get_current_scene")
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *SceneTree) GetEditedSceneRoot() *Node {
	log.Println("Calling SceneTree.GetEditedSceneRoot()")

	returnValue := godotCallObject(o, "get_edited_scene_root")
	log.Println("  Got return value: ", returnValue)

	var ret Node
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *SceneTree) GetFrame() int64 {
	log.Println("Calling SceneTree.GetFrame()")

	returnValue := godotCallInt(o, "get_frame")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneTree) GetNetworkConnectedPeers() *PoolIntArray {
	log.Println("Calling SceneTree.GetNetworkConnectedPeers()")

	returnValue := godotCallPoolIntArray(o, "get_network_connected_peers")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SceneTree) GetNetworkPeer() *NetworkedMultiplayerPeer {
	log.Println("Calling SceneTree.GetNetworkPeer()")

	returnValue := godotCallObject(o, "get_network_peer")
	log.Println("  Got return value: ", returnValue)

	var ret NetworkedMultiplayerPeer
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *SceneTree) GetNetworkUniqueId() int64 {
	log.Println("Calling SceneTree.GetNetworkUniqueId()")

	returnValue := godotCallInt(o, "get_network_unique_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneTree) GetNodeCount() int64 {
	log.Println("Calling SceneTree.GetNodeCount()")

	returnValue := godotCallInt(o, "get_node_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneTree) GetNodesInGroup(group string) *Array {
	log.Println("Calling SceneTree.GetNodesInGroup()")

	returnValue := godotCallArrayString(o, "get_nodes_in_group", group)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SceneTree) GetRoot() *Viewport {
	log.Println("Calling SceneTree.GetRoot()")

	returnValue := godotCallObject(o, "get_root")
	log.Println("  Got return value: ", returnValue)

	var ret Viewport
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *SceneTree) GetRpcSenderId() int64 {
	log.Println("Calling SceneTree.GetRpcSenderId()")

	returnValue := godotCallInt(o, "get_rpc_sender_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneTree) HasGroup(name string) bool {
	log.Println("Calling SceneTree.HasGroup()")

	returnValue := godotCallBoolString(o, "has_group", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns true if there is a [NetworkedMultiplayerPeer] set (with [method SceneTree.set_network_peer]).
*/
func (o *SceneTree) HasNetworkPeer() bool {
	log.Println("Calling SceneTree.HasNetworkPeer()")

	returnValue := godotCallBool(o, "has_network_peer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SceneTree) IsDebuggingCollisionsHint() bool {
	log.Println("Calling SceneTree.IsDebuggingCollisionsHint()")

	returnValue := godotCallBool(o, "is_debugging_collisions_hint")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SceneTree) IsDebuggingNavigationHint() bool {
	log.Println("Calling SceneTree.IsDebuggingNavigationHint()")

	returnValue := godotCallBool(o, "is_debugging_navigation_hint")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneTree) IsInputHandled() bool {
	log.Println("Calling SceneTree.IsInputHandled()")

	returnValue := godotCallBool(o, "is_input_handled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns true if this SceneTree's [NetworkedMultiplayerPeer] is in server mode (listening for connections).
*/
func (o *SceneTree) IsNetworkServer() bool {
	log.Println("Calling SceneTree.IsNetworkServer()")

	returnValue := godotCallBool(o, "is_network_server")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SceneTree) IsPaused() bool {
	log.Println("Calling SceneTree.IsPaused()")

	returnValue := godotCallBool(o, "is_paused")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SceneTree) IsRefusingNewNetworkConnections() bool {
	log.Println("Calling SceneTree.IsRefusingNewNetworkConnections()")

	returnValue := godotCallBool(o, "is_refusing_new_network_connections")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SceneTree) IsUsingFontOversampling() bool {
	log.Println("Calling SceneTree.IsUsingFontOversampling()")

	returnValue := godotCallBool(o, "is_using_font_oversampling")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneTree) NotifyGroup(group string, notification int64) {
	log.Println("Calling SceneTree.NotifyGroup()")

	godotCallVoidStringInt(o, "notify_group", group, notification)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SceneTree) NotifyGroupFlags(callFlags int64, group string, notification int64) {
	log.Println("Calling SceneTree.NotifyGroupFlags()")

	godotCallVoidIntStringInt(o, "notify_group_flags", callFlags, group, notification)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SceneTree) QueueDelete(obj *Object) {
	log.Println("Calling SceneTree.QueueDelete()")

	godotCallVoidObject(o, "queue_delete", obj)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SceneTree) Quit() {
	log.Println("Calling SceneTree.Quit()")

	godotCallVoid(o, "quit")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SceneTree) ReloadCurrentScene() int64 {
	log.Println("Calling SceneTree.ReloadCurrentScene()")

	returnValue := godotCallInt(o, "reload_current_scene")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SceneTree) SetAutoAcceptQuit(enabled bool) {
	log.Println("Calling SceneTree.SetAutoAcceptQuit()")

	godotCallVoidBool(o, "set_auto_accept_quit", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) SetCurrentScene(childNode *Object) {
	log.Println("Calling SceneTree.SetCurrentScene()")

	godotCallVoidObject(o, "set_current_scene", childNode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) SetDebugCollisionsHint(enable bool) {
	log.Println("Calling SceneTree.SetDebugCollisionsHint()")

	godotCallVoidBool(o, "set_debug_collisions_hint", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) SetDebugNavigationHint(enable bool) {
	log.Println("Calling SceneTree.SetDebugNavigationHint()")

	godotCallVoidBool(o, "set_debug_navigation_hint", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) SetEditedSceneRoot(scene *Object) {
	log.Println("Calling SceneTree.SetEditedSceneRoot()")

	godotCallVoidObject(o, "set_edited_scene_root", scene)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SceneTree) SetGroup(group string, property string, value *Variant) {
	log.Println("Calling SceneTree.SetGroup()")

	godotCallVoidStringStringVariant(o, "set_group", group, property, value)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SceneTree) SetGroupFlags(callFlags int64, group string, property string, value *Variant) {
	log.Println("Calling SceneTree.SetGroupFlags()")

	godotCallVoidIntStringStringVariant(o, "set_group_flags", callFlags, group, property, value)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SceneTree) SetInputAsHandled() {
	log.Println("Calling SceneTree.SetInputAsHandled()")

	godotCallVoid(o, "set_input_as_handled")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) SetNetworkPeer(peer *NetworkedMultiplayerPeer) {
	log.Println("Calling SceneTree.SetNetworkPeer()")

	godotCallVoidObject(o, "set_network_peer", &peer.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) SetPause(enable bool) {
	log.Println("Calling SceneTree.SetPause()")

	godotCallVoidBool(o, "set_pause", enable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SceneTree) SetQuitOnGoBack(enabled bool) {
	log.Println("Calling SceneTree.SetQuitOnGoBack()")

	godotCallVoidBool(o, "set_quit_on_go_back", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) SetRefuseNewNetworkConnections(refuse bool) {
	log.Println("Calling SceneTree.SetRefuseNewNetworkConnections()")

	godotCallVoidBool(o, "set_refuse_new_network_connections", refuse)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SceneTree) SetScreenStretch(mode int64, aspect int64, minsize *Vector2, shrink float64) {
	log.Println("Calling SceneTree.SetScreenStretch()")

	godotCallVoidIntIntVector2Float(o, "set_screen_stretch", mode, aspect, minsize, shrink)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SceneTree) SetUseFontOversampling(enable bool) {
	log.Println("Calling SceneTree.SetUseFontOversampling()")

	godotCallVoidBool(o, "set_use_font_oversampling", enable)
	log.Println("  Function successfully completed.")

}

/*
   SceneTreeImplementer is an interface for SceneTree objects.
*/
type SceneTreeImplementer interface {
	Class
}

/*

 */
type SceneTreeTimer struct {
	Reference
}

func (o *SceneTreeTimer) baseClass() string {
	return "SceneTreeTimer"
}

/*
   Undocumented
*/
func (o *SceneTreeTimer) GetTimeLeft() float64 {
	log.Println("Calling SceneTreeTimer.GetTimeLeft()")

	returnValue := godotCallFloat(o, "get_time_left")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SceneTreeTimer) SetTimeLeft(time float64) {
	log.Println("Calling SceneTreeTimer.SetTimeLeft()")

	godotCallVoidFloat(o, "set_time_left", time)
	log.Println("  Function successfully completed.")

}

/*
   SceneTreeTimerImplementer is an interface for SceneTreeTimer objects.
*/
type SceneTreeTimerImplementer interface {
	Class
}

/*
   A class stored as a resource. The script exends the functionality of all objects that instance it. The 'new' method of a script subclass creates a new instance. [method Object.set_script] extends an existing object, if that object's class matches one of the script's base classes.
*/
type Script struct {
	Resource
}

func (o *Script) baseClass() string {
	return "Script"
}

/*
   Returns true if the script can be instanced.
*/
func (o *Script) CanInstance() bool {
	log.Println("Calling Script.CanInstance()")

	returnValue := godotCallBool(o, "can_instance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Script) GetBaseScript() *Script {
	log.Println("Calling Script.GetBaseScript()")

	returnValue := godotCallObject(o, "get_base_script")
	log.Println("  Got return value: ", returnValue)

	var ret Script
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *Script) GetInstanceBaseType() string {
	log.Println("Calling Script.GetInstanceBaseType()")

	returnValue := godotCallString(o, "get_instance_base_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Script) GetSourceCode() string {
	log.Println("Calling Script.GetSourceCode()")

	returnValue := godotCallString(o, "get_source_code")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns true if the script, or a base class, defines a signal with the given name.
*/
func (o *Script) HasScriptSignal(signalName string) bool {
	log.Println("Calling Script.HasScriptSignal()")

	returnValue := godotCallBoolString(o, "has_script_signal", signalName)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns true if the script contains non-empty source code.
*/
func (o *Script) HasSourceCode() bool {
	log.Println("Calling Script.HasSourceCode()")

	returnValue := godotCallBool(o, "has_source_code")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns true if 'base_object' is an instance of this script.
*/
func (o *Script) InstanceHas(baseObject *Object) bool {
	log.Println("Calling Script.InstanceHas()")

	returnValue := godotCallBoolObject(o, "instance_has", baseObject)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns true if the script is a tool script. A tool script can run in the editor.
*/
func (o *Script) IsTool() bool {
	log.Println("Calling Script.IsTool()")

	returnValue := godotCallBool(o, "is_tool")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Reloads the script's class implementation. Returns an error code.
*/
func (o *Script) Reload(keepState bool) int64 {
	log.Println("Calling Script.Reload()")

	returnValue := godotCallIntBool(o, "reload", keepState)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Script) SetSourceCode(source string) {
	log.Println("Calling Script.SetSourceCode()")

	godotCallVoidString(o, "set_source_code", source)
	log.Println("  Function successfully completed.")

}

/*
   ScriptImplementer is an interface for Script objects.
*/
type ScriptImplementer interface {
	Class
}

/*

 */
type ScriptEditor struct {
	PanelContainer
}

func (o *ScriptEditor) baseClass() string {
	return "ScriptEditor"
}

/*
   Undocumented
*/
func (o *ScriptEditor) X_AddCallback(arg0 *Object, arg1 string, arg2 *PoolStringArray) {
	log.Println("Calling ScriptEditor.X_AddCallback()")

	godotCallVoidObjectStringPoolStringArray(o, "_add_callback", arg0, arg1, arg2)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_AutosaveScripts() {
	log.Println("Calling ScriptEditor.X_AutosaveScripts()")

	godotCallVoid(o, "_autosave_scripts")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_Breaked(arg0 bool, arg1 bool) {
	log.Println("Calling ScriptEditor.X_Breaked()")

	godotCallVoidBoolBool(o, "_breaked", arg0, arg1)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_CloseAllTabs() {
	log.Println("Calling ScriptEditor.X_CloseAllTabs()")

	godotCallVoid(o, "_close_all_tabs")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_CloseCurrentTab() {
	log.Println("Calling ScriptEditor.X_CloseCurrentTab()")

	godotCallVoid(o, "_close_current_tab")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_CloseDiscardCurrentTab(arg0 string) {
	log.Println("Calling ScriptEditor.X_CloseDiscardCurrentTab()")

	godotCallVoidString(o, "_close_discard_current_tab", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_CloseDocsTab() {
	log.Println("Calling ScriptEditor.X_CloseDocsTab()")

	godotCallVoid(o, "_close_docs_tab")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_CloseOtherTabs() {
	log.Println("Calling ScriptEditor.X_CloseOtherTabs()")

	godotCallVoid(o, "_close_other_tabs")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_CopyScriptPath() {
	log.Println("Calling ScriptEditor.X_CopyScriptPath()")

	godotCallVoid(o, "_copy_script_path")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_EditorPause() {
	log.Println("Calling ScriptEditor.X_EditorPause()")

	godotCallVoid(o, "_editor_pause")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_EditorPlay() {
	log.Println("Calling ScriptEditor.X_EditorPlay()")

	godotCallVoid(o, "_editor_play")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_EditorSettingsChanged() {
	log.Println("Calling ScriptEditor.X_EditorSettingsChanged()")

	godotCallVoid(o, "_editor_settings_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_EditorStop() {
	log.Println("Calling ScriptEditor.X_EditorStop()")

	godotCallVoid(o, "_editor_stop")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_FileDialogAction(arg0 string) {
	log.Println("Calling ScriptEditor.X_FileDialogAction()")

	godotCallVoidString(o, "_file_dialog_action", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_GetDebugTooltip(arg0 string, arg1 *Object) string {
	log.Println("Calling ScriptEditor.X_GetDebugTooltip()")

	returnValue := godotCallStringStringObject(o, "_get_debug_tooltip", arg0, arg1)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_GotoScriptLine(arg0 *Reference, arg1 int64) {
	log.Println("Calling ScriptEditor.X_GotoScriptLine()")

	godotCallVoidObjectInt(o, "_goto_script_line", &arg0.Object, arg1)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_GotoScriptLine2(arg0 int64) {
	log.Println("Calling ScriptEditor.X_GotoScriptLine2()")

	godotCallVoidInt(o, "_goto_script_line2", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HelpClassGoto(arg0 string) {
	log.Println("Calling ScriptEditor.X_HelpClassGoto()")

	godotCallVoidString(o, "_help_class_goto", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HelpClassOpen(arg0 string) {
	log.Println("Calling ScriptEditor.X_HelpClassOpen()")

	godotCallVoidString(o, "_help_class_open", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HelpIndex(arg0 string) {
	log.Println("Calling ScriptEditor.X_HelpIndex()")

	godotCallVoidString(o, "_help_index", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HelpOverviewSelected(arg0 int64) {
	log.Println("Calling ScriptEditor.X_HelpOverviewSelected()")

	godotCallVoidInt(o, "_help_overview_selected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HelpSearch(arg0 string) {
	log.Println("Calling ScriptEditor.X_HelpSearch()")

	godotCallVoidString(o, "_help_search", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HistoryBack() {
	log.Println("Calling ScriptEditor.X_HistoryBack()")

	godotCallVoid(o, "_history_back")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_HistoryForward() {
	log.Println("Calling ScriptEditor.X_HistoryForward()")

	godotCallVoid(o, "_history_forward")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_LiveAutoReloadRunningScripts() {
	log.Println("Calling ScriptEditor.X_LiveAutoReloadRunningScripts()")

	godotCallVoid(o, "_live_auto_reload_running_scripts")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_MembersOverviewSelected(arg0 int64) {
	log.Println("Calling ScriptEditor.X_MembersOverviewSelected()")

	godotCallVoidInt(o, "_members_overview_selected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_MenuOption(arg0 int64) {
	log.Println("Calling ScriptEditor.X_MenuOption()")

	godotCallVoidInt(o, "_menu_option", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_OpenRecentScript(arg0 int64) {
	log.Println("Calling ScriptEditor.X_OpenRecentScript()")

	godotCallVoidInt(o, "_open_recent_script", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ReloadScripts() {
	log.Println("Calling ScriptEditor.X_ReloadScripts()")

	godotCallVoid(o, "_reload_scripts")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_RequestHelp(arg0 string) {
	log.Println("Calling ScriptEditor.X_RequestHelp()")

	godotCallVoidString(o, "_request_help", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ResSavedCallback(arg0 *Resource) {
	log.Println("Calling ScriptEditor.X_ResSavedCallback()")

	godotCallVoidObject(o, "_res_saved_callback", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ResaveScripts(arg0 string) {
	log.Println("Calling ScriptEditor.X_ResaveScripts()")

	godotCallVoidString(o, "_resave_scripts", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_SaveHistory() {
	log.Println("Calling ScriptEditor.X_SaveHistory()")

	godotCallVoid(o, "_save_history")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ScriptChanged() {
	log.Println("Calling ScriptEditor.X_ScriptChanged()")

	godotCallVoid(o, "_script_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ScriptCreated(arg0 *Script) {
	log.Println("Calling ScriptEditor.X_ScriptCreated()")

	godotCallVoidObject(o, "_script_created", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ScriptListGuiInput(arg0 *InputEvent) {
	log.Println("Calling ScriptEditor.X_ScriptListGuiInput()")

	godotCallVoidObject(o, "_script_list_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ScriptSelected(arg0 int64) {
	log.Println("Calling ScriptEditor.X_ScriptSelected()")

	godotCallVoidInt(o, "_script_selected", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ScriptSplitDragged(arg0 float64) {
	log.Println("Calling ScriptEditor.X_ScriptSplitDragged()")

	godotCallVoidFloat(o, "_script_split_dragged", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_ShowDebugger(arg0 bool) {
	log.Println("Calling ScriptEditor.X_ShowDebugger()")

	godotCallVoidBool(o, "_show_debugger", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_TabChanged(arg0 int64) {
	log.Println("Calling ScriptEditor.X_TabChanged()")

	godotCallVoidInt(o, "_tab_changed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_TreeChanged() {
	log.Println("Calling ScriptEditor.X_TreeChanged()")

	godotCallVoid(o, "_tree_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_UnhandledInput(arg0 *InputEvent) {
	log.Println("Calling ScriptEditor.X_UnhandledInput()")

	godotCallVoidObject(o, "_unhandled_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_UpdateRecentScripts() {
	log.Println("Calling ScriptEditor.X_UpdateRecentScripts()")

	godotCallVoid(o, "_update_recent_scripts")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScriptEditor) X_UpdateScriptNames() {
	log.Println("Calling ScriptEditor.X_UpdateScriptNames()")

	godotCallVoid(o, "_update_script_names")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ScriptEditor) CanDropDataFw(point *Vector2, data *Variant, from *Object) bool {
	log.Println("Calling ScriptEditor.CanDropDataFw()")

	returnValue := godotCallBoolVector2VariantObject(o, "can_drop_data_fw", point, data, from)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *ScriptEditor) DropDataFw(point *Vector2, data *Variant, from *Object) {
	log.Println("Calling ScriptEditor.DropDataFw()")

	godotCallVoidVector2VariantObject(o, "drop_data_fw", point, data, from)
	log.Println("  Function successfully completed.")

}

/*
   Returns a [Script] that is currently active in editor.
*/
func (o *ScriptEditor) GetCurrentScript() *Script {
	log.Println("Calling ScriptEditor.GetCurrentScript()")

	returnValue := godotCallObject(o, "get_current_script")
	log.Println("  Got return value: ", returnValue)

	var ret Script
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *ScriptEditor) GetDragDataFw(point *Vector2, from *Object) *Variant {
	log.Println("Calling ScriptEditor.GetDragDataFw()")

	returnValue := godotCallVariantVector2Object(o, "get_drag_data_fw", point, from)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an array with all [Script] objects which are currently open in editor.
*/
func (o *ScriptEditor) GetOpenScripts() *Array {
	log.Println("Calling ScriptEditor.GetOpenScripts()")

	returnValue := godotCallArray(o, "get_open_scripts")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *ScriptEditor) OpenScriptCreateDialog(baseName string, basePath string) {
	log.Println("Calling ScriptEditor.OpenScriptCreateDialog()")

	godotCallVoidStringString(o, "open_script_create_dialog", baseName, basePath)
	log.Println("  Function successfully completed.")

}

/*
   ScriptEditorImplementer is an interface for ScriptEditor objects.
*/
type ScriptEditorImplementer interface {
	Class
}

/*
   Scrollbars are a [Range] based [Control], that display a draggable area (the size of the page). Horizontal ([HScrollBar]) and Vertical ([VScrollBar]) versions are available.
*/
type ScrollBar struct {
	Range
}

func (o *ScrollBar) baseClass() string {
	return "ScrollBar"
}

/*
   Undocumented
*/
func (o *ScrollBar) X_DragSlaveExit() {
	log.Println("Calling ScrollBar.X_DragSlaveExit()")

	godotCallVoid(o, "_drag_slave_exit")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScrollBar) X_DragSlaveInput(arg0 *InputEvent) {
	log.Println("Calling ScrollBar.X_DragSlaveInput()")

	godotCallVoidObject(o, "_drag_slave_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScrollBar) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling ScrollBar.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScrollBar) GetCustomStep() float64 {
	log.Println("Calling ScrollBar.GetCustomStep()")

	returnValue := godotCallFloat(o, "get_custom_step")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ScrollBar) SetCustomStep(step float64) {
	log.Println("Calling ScrollBar.SetCustomStep()")

	godotCallVoidFloat(o, "set_custom_step", step)
	log.Println("  Function successfully completed.")

}

/*
   ScrollBarImplementer is an interface for ScrollBar objects.
*/
type ScrollBarImplementer interface {
	Class
}

/*
   A ScrollContainer node with a [Control] child and scrollbar child ([HScrollbar], [VScrollBar], or both) will only draw the Control within the ScrollContainer area. Scrollbars will automatically be drawn at the right (for vertical) or bottom (for horizontal) and will enable dragging to move the viewable Control (and its children) within the ScrollContainer. Scrollbars will also automatically resize the grabber based on the minimum_size of the Control relative to the ScrollContainer. Works great with a [Panel] control. You can set EXPAND on children size flags, so they will upscale to ScrollContainer size if ScrollContainer size is bigger (scroll is invisible for chosen dimension).
*/
type ScrollContainer struct {
	Container
}

func (o *ScrollContainer) baseClass() string {
	return "ScrollContainer"
}

/*
   Undocumented
*/
func (o *ScrollContainer) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling ScrollContainer.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScrollContainer) X_ScrollMoved(arg0 float64) {
	log.Println("Calling ScrollContainer.X_ScrollMoved()")

	godotCallVoidFloat(o, "_scroll_moved", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScrollContainer) X_UpdateScrollbarPosition() {
	log.Println("Calling ScrollContainer.X_UpdateScrollbarPosition()")

	godotCallVoid(o, "_update_scrollbar_position")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScrollContainer) GetHScroll() int64 {
	log.Println("Calling ScrollContainer.GetHScroll()")

	returnValue := godotCallInt(o, "get_h_scroll")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ScrollContainer) GetVScroll() int64 {
	log.Println("Calling ScrollContainer.GetVScroll()")

	returnValue := godotCallInt(o, "get_v_scroll")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ScrollContainer) IsHScrollEnabled() bool {
	log.Println("Calling ScrollContainer.IsHScrollEnabled()")

	returnValue := godotCallBool(o, "is_h_scroll_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ScrollContainer) IsVScrollEnabled() bool {
	log.Println("Calling ScrollContainer.IsVScrollEnabled()")

	returnValue := godotCallBool(o, "is_v_scroll_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ScrollContainer) SetEnableHScroll(enable bool) {
	log.Println("Calling ScrollContainer.SetEnableHScroll()")

	godotCallVoidBool(o, "set_enable_h_scroll", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScrollContainer) SetEnableVScroll(enable bool) {
	log.Println("Calling ScrollContainer.SetEnableVScroll()")

	godotCallVoidBool(o, "set_enable_v_scroll", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScrollContainer) SetHScroll(value int64) {
	log.Println("Calling ScrollContainer.SetHScroll()")

	godotCallVoidInt(o, "set_h_scroll", value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ScrollContainer) SetVScroll(value int64) {
	log.Println("Calling ScrollContainer.SetVScroll()")

	godotCallVoidInt(o, "set_v_scroll", value)
	log.Println("  Function successfully completed.")

}

/*
   ScrollContainerImplementer is an interface for ScrollContainer objects.
*/
type ScrollContainerImplementer interface {
	Class
}

/*
   Segment shape for 2D collisions. Consists of two points, [code]a[/code] and [code]b[/code].
*/
type SegmentShape2D struct {
	Shape2D
}

func (o *SegmentShape2D) baseClass() string {
	return "SegmentShape2D"
}

/*
   Undocumented
*/
func (o *SegmentShape2D) GetA() *Vector2 {
	log.Println("Calling SegmentShape2D.GetA()")

	returnValue := godotCallVector2(o, "get_a")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SegmentShape2D) GetB() *Vector2 {
	log.Println("Calling SegmentShape2D.GetB()")

	returnValue := godotCallVector2(o, "get_b")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SegmentShape2D) SetA(a *Vector2) {
	log.Println("Calling SegmentShape2D.SetA()")

	godotCallVoidVector2(o, "set_a", a)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SegmentShape2D) SetB(b *Vector2) {
	log.Println("Calling SegmentShape2D.SetB()")

	godotCallVoidVector2(o, "set_b", b)
	log.Println("  Function successfully completed.")

}

/*
   SegmentShape2DImplementer is an interface for SegmentShape2D objects.
*/
type SegmentShape2DImplementer interface {
	Class
}

/*
   Separator is a [Control] used for separating other controls. It's purely a visual decoration. Horizontal ([HSeparator]) and Vertical ([VSeparator]) versions are available.
*/
type Separator struct {
	Control
}

func (o *Separator) baseClass() string {
	return "Separator"
}

/*
   SeparatorImplementer is an interface for Separator objects.
*/
type SeparatorImplementer interface {
	Class
}

/*
   To be changed, ignore.
*/
type Shader struct {
	Resource
}

func (o *Shader) baseClass() string {
	return "Shader"
}

/*
   Undocumented
*/
func (o *Shader) GetCode() string {
	log.Println("Calling Shader.GetCode()")

	returnValue := godotCallString(o, "get_code")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Shader) GetDefaultTextureParam(param string) *Texture {
	log.Println("Calling Shader.GetDefaultTextureParam()")

	returnValue := godotCallObjectString(o, "get_default_texture_param", param)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *Shader) GetMode() int64 {
	log.Println("Calling Shader.GetMode()")

	returnValue := godotCallInt(o, "get_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Shader) HasParam(name string) bool {
	log.Println("Calling Shader.HasParam()")

	returnValue := godotCallBoolString(o, "has_param", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Shader) SetCode(code string) {
	log.Println("Calling Shader.SetCode()")

	godotCallVoidString(o, "set_code", code)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Shader) SetDefaultTextureParam(param string, texture *Texture) {
	log.Println("Calling Shader.SetDefaultTextureParam()")

	godotCallVoidStringObject(o, "set_default_texture_param", param, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   ShaderImplementer is an interface for Shader objects.
*/
type ShaderImplementer interface {
	Class
}

/*

 */
type ShaderMaterial struct {
	Material
}

func (o *ShaderMaterial) baseClass() string {
	return "ShaderMaterial"
}

/*
   Undocumented
*/
func (o *ShaderMaterial) GetShader() *Shader {
	log.Println("Calling ShaderMaterial.GetShader()")

	returnValue := godotCallObject(o, "get_shader")
	log.Println("  Got return value: ", returnValue)

	var ret Shader
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *ShaderMaterial) GetShaderParam(param string) *Variant {
	log.Println("Calling ShaderMaterial.GetShaderParam()")

	returnValue := godotCallVariantString(o, "get_shader_param", param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ShaderMaterial) SetShader(shader *Shader) {
	log.Println("Calling ShaderMaterial.SetShader()")

	godotCallVoidObject(o, "set_shader", &shader.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *ShaderMaterial) SetShaderParam(param string, value *Variant) {
	log.Println("Calling ShaderMaterial.SetShaderParam()")

	godotCallVoidStringVariant(o, "set_shader_param", param, value)
	log.Println("  Function successfully completed.")

}

/*
   ShaderMaterialImplementer is an interface for ShaderMaterial objects.
*/
type ShaderMaterialImplementer interface {
	Class
}

/*
   Base class for all 3D shape resources. All 3D shapes that inherit from this can be set into a [PhysicsBody] or [Area].
*/
type Shape struct {
	Resource
}

func (o *Shape) baseClass() string {
	return "Shape"
}

/*
   ShapeImplementer is an interface for Shape objects.
*/
type ShapeImplementer interface {
	Class
}

/*
   Base class for all 2D Shapes. All 2D shape types inherit from this.
*/
type Shape2D struct {
	Resource
}

func (o *Shape2D) baseClass() string {
	return "Shape2D"
}

/*
   Return whether this shape is colliding with another. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the shape to check collisions with ([code]with_shape[/code]), and the transformation matrix of that shape ([code]shape_xform[/code]).
*/
func (o *Shape2D) Collide(localXform *Transform2D, withShape *Shape2D, shapeXform *Transform2D) bool {
	log.Println("Calling Shape2D.Collide()")

	returnValue := godotCallBoolTransform2DObjectTransform2D(o, "collide", localXform, &withShape.Object, shapeXform)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return a list of the points where this shape touches another. If there are no collisions, the list is empty. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the shape to check collisions with ([code]with_shape[/code]), and the transformation matrix of that shape ([code]shape_xform[/code]).
*/
func (o *Shape2D) CollideAndGetContacts(localXform *Transform2D, withShape *Shape2D, shapeXform *Transform2D) *Variant {
	log.Println("Calling Shape2D.CollideAndGetContacts()")

	returnValue := godotCallVariantTransform2DObjectTransform2D(o, "collide_and_get_contacts", localXform, &withShape.Object, shapeXform)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return whether this shape would collide with another, if a given movement was applied. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the movement to test on this shape ([code]local_motion[/code]), the shape to check collisions with ([code]with_shape[/code]), the transformation matrix of that shape ([code]shape_xform[/code]), and the movement to test onto the other object ([code]shape_motion[/code]).
*/
func (o *Shape2D) CollideWithMotion(localXform *Transform2D, localMotion *Vector2, withShape *Shape2D, shapeXform *Transform2D, shapeMotion *Vector2) bool {
	log.Println("Calling Shape2D.CollideWithMotion()")

	returnValue := godotCallBoolTransform2DVector2ObjectTransform2DVector2(o, "collide_with_motion", localXform, localMotion, &withShape.Object, shapeXform, shapeMotion)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return a list of the points where this shape would touch another, if a given movement was applied. If there are no collisions, the list is empty. This method needs the transformation matrix for this shape ([code]local_xform[/code]), the movement to test on this shape ([code]local_motion[/code]), the shape to check collisions with ([code]with_shape[/code]), the transformation matrix of that shape ([code]shape_xform[/code]), and the movement to test onto the other object ([code]shape_motion[/code]).
*/
func (o *Shape2D) CollideWithMotionAndGetContacts(localXform *Transform2D, localMotion *Vector2, withShape *Shape2D, shapeXform *Transform2D, shapeMotion *Vector2) *Variant {
	log.Println("Calling Shape2D.CollideWithMotionAndGetContacts()")

	returnValue := godotCallVariantTransform2DVector2ObjectTransform2DVector2(o, "collide_with_motion_and_get_contacts", localXform, localMotion, &withShape.Object, shapeXform, shapeMotion)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Shape2D) GetCustomSolverBias() float64 {
	log.Println("Calling Shape2D.GetCustomSolverBias()")

	returnValue := godotCallFloat(o, "get_custom_solver_bias")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Shape2D) SetCustomSolverBias(bias float64) {
	log.Println("Calling Shape2D.SetCustomSolverBias()")

	godotCallVoidFloat(o, "set_custom_solver_bias", bias)
	log.Println("  Function successfully completed.")

}

/*
   Shape2DImplementer is an interface for Shape2D objects.
*/
type Shape2DImplementer interface {
	Class
}

/*
   A shortcut for binding input. Shortcuts are commonly used for interacting with a [Control] element from a [InputEvent].
*/
type ShortCut struct {
	Resource
}

func (o *ShortCut) baseClass() string {
	return "ShortCut"
}

/*
   Returns the Shortcut's [InputEvent] as a [String].
*/
func (o *ShortCut) GetAsText() string {
	log.Println("Calling ShortCut.GetAsText()")

	returnValue := godotCallString(o, "get_as_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ShortCut) GetShortcut() *InputEvent {
	log.Println("Calling ShortCut.GetShortcut()")

	returnValue := godotCallObject(o, "get_shortcut")
	log.Println("  Got return value: ", returnValue)

	var ret InputEvent
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns [code]true[/code] if the Shortcut's [InputEvent] equals [code]event[/code].
*/
func (o *ShortCut) IsShortcut(event *InputEvent) bool {
	log.Println("Calling ShortCut.IsShortcut()")

	returnValue := godotCallBoolObject(o, "is_shortcut", &event.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] this Shortcut is valid.
*/
func (o *ShortCut) IsValid() bool {
	log.Println("Calling ShortCut.IsValid()")

	returnValue := godotCallBool(o, "is_valid")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ShortCut) SetShortcut(event *InputEvent) {
	log.Println("Calling ShortCut.SetShortcut()")

	godotCallVoidObject(o, "set_shortcut", &event.Object)
	log.Println("  Function successfully completed.")

}

/*
   ShortCutImplementer is an interface for ShortCut objects.
*/
type ShortCutImplementer interface {
	Class
}

/*
   Skeleton provides a hierarchical interface for managing bones, including pose, rest and animation (see [Animation]). Skeleton will support rag doll dynamics in the future.
*/
type Skeleton struct {
	Spatial
}

func (o *Skeleton) baseClass() string {
	return "Skeleton"
}

/*
   Add a bone, with name "name". [method get_bone_count] will become the bone index.
*/
func (o *Skeleton) AddBone(name string) {
	log.Println("Calling Skeleton.AddBone()")

	godotCallVoidString(o, "add_bone", name)
	log.Println("  Function successfully completed.")

}

/*
   Deprecated soon.
*/
func (o *Skeleton) BindChildNodeToBone(boneIdx int64, node *Object) {
	log.Println("Calling Skeleton.BindChildNodeToBone()")

	godotCallVoidIntObject(o, "bind_child_node_to_bone", boneIdx, node)
	log.Println("  Function successfully completed.")

}

/*
   Clear all the bones in this skeleton.
*/
func (o *Skeleton) ClearBones() {
	log.Println("Calling Skeleton.ClearBones()")

	godotCallVoid(o, "clear_bones")
	log.Println("  Function successfully completed.")

}

/*
   Return the bone index that matches "name" as its name.
*/
func (o *Skeleton) FindBone(name string) int64 {
	log.Println("Calling Skeleton.FindBone()")

	returnValue := godotCallIntString(o, "find_bone", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the amount of bones in the skeleton.
*/
func (o *Skeleton) GetBoneCount() int64 {
	log.Println("Calling Skeleton.GetBoneCount()")

	returnValue := godotCallInt(o, "get_bone_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Skeleton) GetBoneCustomPose(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneCustomPose()")

	returnValue := godotCallTransformInt(o, "get_bone_custom_pose", boneIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Skeleton) GetBoneGlobalPose(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneGlobalPose()")

	returnValue := godotCallTransformInt(o, "get_bone_global_pose", boneIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the name of the bone at index "index"
*/
func (o *Skeleton) GetBoneName(boneIdx int64) string {
	log.Println("Calling Skeleton.GetBoneName()")

	returnValue := godotCallStringInt(o, "get_bone_name", boneIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the bone index which is the parent of the bone at "bone_idx". If -1, then bone has no parent. Note that the parent bone returned will always be less than "bone_idx".
*/
func (o *Skeleton) GetBoneParent(boneIdx int64) int64 {
	log.Println("Calling Skeleton.GetBoneParent()")

	returnValue := godotCallIntInt(o, "get_bone_parent", boneIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the pose transform for bone "bone_idx".
*/
func (o *Skeleton) GetBonePose(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBonePose()")

	returnValue := godotCallTransformInt(o, "get_bone_pose", boneIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the rest transform for a bone "bone_idx".
*/
func (o *Skeleton) GetBoneRest(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneRest()")

	returnValue := godotCallTransformInt(o, "get_bone_rest", boneIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Skeleton) GetBoneTransform(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneTransform()")

	returnValue := godotCallTransformInt(o, "get_bone_transform", boneIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Deprecated soon.
*/
func (o *Skeleton) GetBoundChildNodesToBone(boneIdx int64) *Array {
	log.Println("Calling Skeleton.GetBoundChildNodesToBone()")

	returnValue := godotCallArrayInt(o, "get_bound_child_nodes_to_bone", boneIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Skeleton) IsBoneRestDisabled(boneIdx int64) bool {
	log.Println("Calling Skeleton.IsBoneRestDisabled()")

	returnValue := godotCallBoolInt(o, "is_bone_rest_disabled", boneIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Skeleton) SetBoneCustomPose(boneIdx int64, customPose *Transform) {
	log.Println("Calling Skeleton.SetBoneCustomPose()")

	godotCallVoidIntTransform(o, "set_bone_custom_pose", boneIdx, customPose)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Skeleton) SetBoneDisableRest(boneIdx int64, disable bool) {
	log.Println("Calling Skeleton.SetBoneDisableRest()")

	godotCallVoidIntBool(o, "set_bone_disable_rest", boneIdx, disable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Skeleton) SetBoneGlobalPose(boneIdx int64, pose *Transform) {
	log.Println("Calling Skeleton.SetBoneGlobalPose()")

	godotCallVoidIntTransform(o, "set_bone_global_pose", boneIdx, pose)
	log.Println("  Function successfully completed.")

}

/*
   Set the bone index "parent_idx" as the parent of the bone at "bone_idx". If -1, then bone has no parent. Note: "parent_idx" must be less than "bone_idx".
*/
func (o *Skeleton) SetBoneParent(boneIdx int64, parentIdx int64) {
	log.Println("Calling Skeleton.SetBoneParent()")

	godotCallVoidIntInt(o, "set_bone_parent", boneIdx, parentIdx)
	log.Println("  Function successfully completed.")

}

/*
   Return the pose transform for bone "bone_idx".
*/
func (o *Skeleton) SetBonePose(boneIdx int64, pose *Transform) {
	log.Println("Calling Skeleton.SetBonePose()")

	godotCallVoidIntTransform(o, "set_bone_pose", boneIdx, pose)
	log.Println("  Function successfully completed.")

}

/*
   Set the rest transform for bone "bone_idx"
*/
func (o *Skeleton) SetBoneRest(boneIdx int64, rest *Transform) {
	log.Println("Calling Skeleton.SetBoneRest()")

	godotCallVoidIntTransform(o, "set_bone_rest", boneIdx, rest)
	log.Println("  Function successfully completed.")

}

/*
   Deprecated soon.
*/
func (o *Skeleton) UnbindChildNodeFromBone(boneIdx int64, node *Object) {
	log.Println("Calling Skeleton.UnbindChildNodeFromBone()")

	godotCallVoidIntObject(o, "unbind_child_node_from_bone", boneIdx, node)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Skeleton) UnparentBoneAndRest(boneIdx int64) {
	log.Println("Calling Skeleton.UnparentBoneAndRest()")

	godotCallVoidInt(o, "unparent_bone_and_rest", boneIdx)
	log.Println("  Function successfully completed.")

}

/*
   SkeletonImplementer is an interface for Skeleton objects.
*/
type SkeletonImplementer interface {
	Class
}

/*
   The base class for [PanoramaSky] and [ProceduralSky].
*/
type Sky struct {
	Resource
}

func (o *Sky) baseClass() string {
	return "Sky"
}

/*
   Undocumented
*/
func (o *Sky) GetRadianceSize() int64 {
	log.Println("Calling Sky.GetRadianceSize()")

	returnValue := godotCallInt(o, "get_radiance_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sky) SetRadianceSize(size int64) {
	log.Println("Calling Sky.SetRadianceSize()")

	godotCallVoidInt(o, "set_radiance_size", size)
	log.Println("  Function successfully completed.")

}

/*
   SkyImplementer is an interface for Sky objects.
*/
type SkyImplementer interface {
	Class
}

/*
   Base class for GUI Sliders.
*/
type Slider struct {
	Range
}

func (o *Slider) baseClass() string {
	return "Slider"
}

/*
   Undocumented
*/
func (o *Slider) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling Slider.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Slider) GetTicks() int64 {
	log.Println("Calling Slider.GetTicks()")

	returnValue := godotCallInt(o, "get_ticks")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Slider) GetTicksOnBorders() bool {
	log.Println("Calling Slider.GetTicksOnBorders()")

	returnValue := godotCallBool(o, "get_ticks_on_borders")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Slider) IsEditable() bool {
	log.Println("Calling Slider.IsEditable()")

	returnValue := godotCallBool(o, "is_editable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Slider) SetEditable(editable bool) {
	log.Println("Calling Slider.SetEditable()")

	godotCallVoidBool(o, "set_editable", editable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Slider) SetTicks(count int64) {
	log.Println("Calling Slider.SetTicks()")

	godotCallVoidInt(o, "set_ticks", count)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Slider) SetTicksOnBorders(ticksOnBorder bool) {
	log.Println("Calling Slider.SetTicksOnBorders()")

	godotCallVoidBool(o, "set_ticks_on_borders", ticksOnBorder)
	log.Println("  Function successfully completed.")

}

/*
   SliderImplementer is an interface for Slider objects.
*/
type SliderImplementer interface {
	Class
}

/*
   Slides across the x-axis of the [Pivot] object.
*/
type SliderJoint struct {
	Joint
}

func (o *SliderJoint) baseClass() string {
	return "SliderJoint"
}

/*
   Undocumented
*/
func (o *SliderJoint) X_GetLowerLimitAngular() float64 {
	log.Println("Calling SliderJoint.X_GetLowerLimitAngular()")

	returnValue := godotCallFloat(o, "_get_lower_limit_angular")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SliderJoint) X_GetUpperLimitAngular() float64 {
	log.Println("Calling SliderJoint.X_GetUpperLimitAngular()")

	returnValue := godotCallFloat(o, "_get_upper_limit_angular")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SliderJoint) X_SetLowerLimitAngular(lowerLimitAngular float64) {
	log.Println("Calling SliderJoint.X_SetLowerLimitAngular()")

	godotCallVoidFloat(o, "_set_lower_limit_angular", lowerLimitAngular)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SliderJoint) X_SetUpperLimitAngular(upperLimitAngular float64) {
	log.Println("Calling SliderJoint.X_SetUpperLimitAngular()")

	godotCallVoidFloat(o, "_set_upper_limit_angular", upperLimitAngular)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SliderJoint) GetParam(param int64) float64 {
	log.Println("Calling SliderJoint.GetParam()")

	returnValue := godotCallFloatInt(o, "get_param", param)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SliderJoint) SetParam(param int64, value float64) {
	log.Println("Calling SliderJoint.SetParam()")

	godotCallVoidIntFloat(o, "set_param", param, value)
	log.Println("  Function successfully completed.")

}

/*
   SliderJointImplementer is an interface for SliderJoint objects.
*/
type SliderJointImplementer interface {
	Class
}

/*
   Most basic 3D game object, with a 3D [Transform] and visibility settings. All other 3D game objects inherit from Spatial. Use Spatial as a parent node to move, scale, rotate and show/hide children in a 3D project. Affine operations (rotate, scale, translate) happen in parent's local coordinate system, unless the Spatial object is set as top level. Affine operations in this coordinate system correspond to direct affine operations on the Spatial's transform. The word local below refers to this coordinate system. The coordinate system that is attached to the Spatial object itself is referred to as object-local coordinate system.
*/
type Spatial struct {
	Node
}

func (o *Spatial) baseClass() string {
	return "Spatial"
}

/*
   Undocumented
*/
func (o *Spatial) X_UpdateGizmo() {
	log.Println("Calling Spatial.X_UpdateGizmo()")

	godotCallVoid(o, "_update_gizmo")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Spatial) GetGizmo() *SpatialGizmo {
	log.Println("Calling Spatial.GetGizmo()")

	returnValue := godotCallObject(o, "get_gizmo")
	log.Println("  Got return value: ", returnValue)

	var ret SpatialGizmo
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Spatial) GetGlobalTransform() *Transform {
	log.Println("Calling Spatial.GetGlobalTransform()")

	returnValue := godotCallTransform(o, "get_global_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the parent [code]Spatial[/code], or an empty [Object] if no parent exists or parent is not of type [code]Spatial[/code].
*/
func (o *Spatial) GetParentSpatial() *Spatial {
	log.Println("Calling Spatial.GetParentSpatial()")

	returnValue := godotCallObject(o, "get_parent_spatial")
	log.Println("  Got return value: ", returnValue)

	var ret Spatial
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Spatial) GetRotation() *Vector3 {
	log.Println("Calling Spatial.GetRotation()")

	returnValue := godotCallVector3(o, "get_rotation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Spatial) GetRotationDegrees() *Vector3 {
	log.Println("Calling Spatial.GetRotationDegrees()")

	returnValue := godotCallVector3(o, "get_rotation_degrees")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Spatial) GetScale() *Vector3 {
	log.Println("Calling Spatial.GetScale()")

	returnValue := godotCallVector3(o, "get_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Spatial) GetTransform() *Transform {
	log.Println("Calling Spatial.GetTransform()")

	returnValue := godotCallTransform(o, "get_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Spatial) GetTranslation() *Vector3 {
	log.Println("Calling Spatial.GetTranslation()")

	returnValue := godotCallVector3(o, "get_translation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the current [World] resource this Spatial node is registered to.
*/
func (o *Spatial) GetWorld() *World {
	log.Println("Calling Spatial.GetWorld()")

	returnValue := godotCallObject(o, "get_world")
	log.Println("  Got return value: ", returnValue)

	var ret World
	ret.owner = returnValue.owner
	return &ret

}

/*
   Rotates the global (world) transformation around axis, a unit [Vector3], by specified angle in radians. The rotation axis is in global coordinate system.
*/
func (o *Spatial) GlobalRotate(axis *Vector3, angle float64) {
	log.Println("Calling Spatial.GlobalRotate()")

	godotCallVoidVector3Float(o, "global_rotate", axis, angle)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Spatial) GlobalScale(scale *Vector3) {
	log.Println("Calling Spatial.GlobalScale()")

	godotCallVoidVector3(o, "global_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Moves the global (world) transformation by [Vector3] offset. The offset is in global coordinate system.
*/
func (o *Spatial) GlobalTranslate(offset *Vector3) {
	log.Println("Calling Spatial.GlobalTranslate()")

	godotCallVoidVector3(o, "global_translate", offset)
	log.Println("  Function successfully completed.")

}

/*
   Disables rendering of this node. Change Spatial Visible property to false.
*/
func (o *Spatial) Hide() {
	log.Println("Calling Spatial.Hide()")

	godotCallVoid(o, "hide")
	log.Println("  Function successfully completed.")

}

/*
   Returns whether node notifies about its local transformation changes. Spatial will not propagate this by default.
*/
func (o *Spatial) IsLocalTransformNotificationEnabled() bool {
	log.Println("Calling Spatial.IsLocalTransformNotificationEnabled()")

	returnValue := godotCallBool(o, "is_local_transform_notification_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether this node is set as Toplevel, that is whether it ignores its parent nodes transformations.
*/
func (o *Spatial) IsSetAsToplevel() bool {
	log.Println("Calling Spatial.IsSetAsToplevel()")

	returnValue := godotCallBool(o, "is_set_as_toplevel")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether the node notifies about its global and local transformation changes. Spatial will not propagate this by default.
*/
func (o *Spatial) IsTransformNotificationEnabled() bool {
	log.Println("Calling Spatial.IsTransformNotificationEnabled()")

	returnValue := godotCallBool(o, "is_transform_notification_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Spatial) IsVisible() bool {
	log.Println("Calling Spatial.IsVisible()")

	returnValue := godotCallBool(o, "is_visible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether the node is visible, taking into consideration that its parents visibility.
*/
func (o *Spatial) IsVisibleInTree() bool {
	log.Println("Calling Spatial.IsVisibleInTree()")

	returnValue := godotCallBool(o, "is_visible_in_tree")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Rotates itself to point into direction of target position. Operations take place in global space.
*/
func (o *Spatial) LookAt(target *Vector3, up *Vector3) {
	log.Println("Calling Spatial.LookAt()")

	godotCallVoidVector3Vector3(o, "look_at", target, up)
	log.Println("  Function successfully completed.")

}

/*
   Moves the node to specified position and then rotates itself to point into direction of target position. Operations take place in global space.
*/
func (o *Spatial) LookAtFromPosition(position *Vector3, target *Vector3, up *Vector3) {
	log.Println("Calling Spatial.LookAtFromPosition()")

	godotCallVoidVector3Vector3Vector3(o, "look_at_from_position", position, target, up)
	log.Println("  Function successfully completed.")

}

/*
   Resets this node's transformations (like scale, skew and taper) preserving its rotation and translation by performing Gram-Schmidt orthonormalization on this node's [Transform3D].
*/
func (o *Spatial) Orthonormalize() {
	log.Println("Calling Spatial.Orthonormalize()")

	godotCallVoid(o, "orthonormalize")
	log.Println("  Function successfully completed.")

}

/*
   Rotates the local transformation around axis, a unit [Vector3], by specified angle in radians.
*/
func (o *Spatial) Rotate(axis *Vector3, angle float64) {
	log.Println("Calling Spatial.Rotate()")

	godotCallVoidVector3Float(o, "rotate", axis, angle)
	log.Println("  Function successfully completed.")

}

/*
   Rotates the local transformation around axis, a unit [Vector3], by specified angle in radians. The rotation axis is in object-local coordinate system.
*/
func (o *Spatial) RotateObjectLocal(axis *Vector3, angle float64) {
	log.Println("Calling Spatial.RotateObjectLocal()")

	godotCallVoidVector3Float(o, "rotate_object_local", axis, angle)
	log.Println("  Function successfully completed.")

}

/*
   Rotates the local transformation around the X axis by angle in radians
*/
func (o *Spatial) RotateX(angle float64) {
	log.Println("Calling Spatial.RotateX()")

	godotCallVoidFloat(o, "rotate_x", angle)
	log.Println("  Function successfully completed.")

}

/*
   Rotates the local transformation around the Y axis by angle in radians.
*/
func (o *Spatial) RotateY(angle float64) {
	log.Println("Calling Spatial.RotateY()")

	godotCallVoidFloat(o, "rotate_y", angle)
	log.Println("  Function successfully completed.")

}

/*
   Rotates the local transformation around the Z axis by angle in radians.
*/
func (o *Spatial) RotateZ(angle float64) {
	log.Println("Calling Spatial.RotateZ()")

	godotCallVoidFloat(o, "rotate_z", angle)
	log.Println("  Function successfully completed.")

}

/*
   Scales the local transformation by given 3D scale factors in object-local coordinate system.
*/
func (o *Spatial) ScaleObjectLocal(scale *Vector3) {
	log.Println("Calling Spatial.ScaleObjectLocal()")

	godotCallVoidVector3(o, "scale_object_local", scale)
	log.Println("  Function successfully completed.")

}

/*
   Makes the node ignore its parents transformations. Node transformations are only in global space.
*/
func (o *Spatial) SetAsToplevel(enable bool) {
	log.Println("Calling Spatial.SetAsToplevel()")

	godotCallVoidBool(o, "set_as_toplevel", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Spatial) SetGizmo(gizmo *SpatialGizmo) {
	log.Println("Calling Spatial.SetGizmo()")

	godotCallVoidObject(o, "set_gizmo", &gizmo.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Spatial) SetGlobalTransform(global *Transform) {
	log.Println("Calling Spatial.SetGlobalTransform()")

	godotCallVoidTransform(o, "set_global_transform", global)
	log.Println("  Function successfully completed.")

}

/*
   Reset all transformations for this node. Set its [Transform3D] to identity matrix.
*/
func (o *Spatial) SetIdentity() {
	log.Println("Calling Spatial.SetIdentity()")

	godotCallVoid(o, "set_identity")
	log.Println("  Function successfully completed.")

}

/*
   Set whether the node ignores notification that its transformation (global or local) changed.
*/
func (o *Spatial) SetIgnoreTransformNotification(enabled bool) {
	log.Println("Calling Spatial.SetIgnoreTransformNotification()")

	godotCallVoidBool(o, "set_ignore_transform_notification", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Set whether the node notifies about its local transformation changes. Spatial will not propagate this by default.
*/
func (o *Spatial) SetNotifyLocalTransform(enable bool) {
	log.Println("Calling Spatial.SetNotifyLocalTransform()")

	godotCallVoidBool(o, "set_notify_local_transform", enable)
	log.Println("  Function successfully completed.")

}

/*
   Set whether the node notifies about its global and local transformation changes. Spatial will not propagate this by default.
*/
func (o *Spatial) SetNotifyTransform(enable bool) {
	log.Println("Calling Spatial.SetNotifyTransform()")

	godotCallVoidBool(o, "set_notify_transform", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Spatial) SetRotation(euler *Vector3) {
	log.Println("Calling Spatial.SetRotation()")

	godotCallVoidVector3(o, "set_rotation", euler)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Spatial) SetRotationDegrees(eulerDegrees *Vector3) {
	log.Println("Calling Spatial.SetRotationDegrees()")

	godotCallVoidVector3(o, "set_rotation_degrees", eulerDegrees)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Spatial) SetScale(scale *Vector3) {
	log.Println("Calling Spatial.SetScale()")

	godotCallVoidVector3(o, "set_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Spatial) SetTransform(local *Transform) {
	log.Println("Calling Spatial.SetTransform()")

	godotCallVoidTransform(o, "set_transform", local)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Spatial) SetTranslation(translation *Vector3) {
	log.Println("Calling Spatial.SetTranslation()")

	godotCallVoidVector3(o, "set_translation", translation)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Spatial) SetVisible(visible bool) {
	log.Println("Calling Spatial.SetVisible()")

	godotCallVoidBool(o, "set_visible", visible)
	log.Println("  Function successfully completed.")

}

/*
   Enables rendering of this node. Change Spatial Visible property to "True".
*/
func (o *Spatial) Show() {
	log.Println("Calling Spatial.Show()")

	godotCallVoid(o, "show")
	log.Println("  Function successfully completed.")

}

/*
   Transforms [Vector3] "local_point" from this node's local space to world space.
*/
func (o *Spatial) ToGlobal(localPoint *Vector3) *Vector3 {
	log.Println("Calling Spatial.ToGlobal()")

	returnValue := godotCallVector3Vector3(o, "to_global", localPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Transforms [Vector3] "global_point" from world space to this node's local space.
*/
func (o *Spatial) ToLocal(globalPoint *Vector3) *Vector3 {
	log.Println("Calling Spatial.ToLocal()")

	returnValue := godotCallVector3Vector3(o, "to_local", globalPoint)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Changes the node's position by given offset [Vector3].
*/
func (o *Spatial) Translate(offset *Vector3) {
	log.Println("Calling Spatial.Translate()")

	godotCallVoidVector3(o, "translate", offset)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Spatial) TranslateObjectLocal(offset *Vector3) {
	log.Println("Calling Spatial.TranslateObjectLocal()")

	godotCallVoidVector3(o, "translate_object_local", offset)
	log.Println("  Function successfully completed.")

}

/*
   Updates the [SpatialGizmo] of this node.
*/
func (o *Spatial) UpdateGizmo() {
	log.Println("Calling Spatial.UpdateGizmo()")

	godotCallVoid(o, "update_gizmo")
	log.Println("  Function successfully completed.")

}

/*
   SpatialImplementer is an interface for Spatial objects.
*/
type SpatialImplementer interface {
	Class
}

/*

 */
type SpatialGizmo struct {
	Reference
}

func (o *SpatialGizmo) baseClass() string {
	return "SpatialGizmo"
}

/*
   SpatialGizmoImplementer is an interface for SpatialGizmo objects.
*/
type SpatialGizmoImplementer interface {
	Class
}

/*

 */
type SpatialMaterial struct {
	Material
}

func (o *SpatialMaterial) baseClass() string {
	return "SpatialMaterial"
}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetAlbedo() *Color {
	log.Println("Calling SpatialMaterial.GetAlbedo()")

	returnValue := godotCallColor(o, "get_albedo")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetAlphaScissorThreshold() float64 {
	log.Println("Calling SpatialMaterial.GetAlphaScissorThreshold()")

	returnValue := godotCallFloat(o, "get_alpha_scissor_threshold")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetAnisotropy() float64 {
	log.Println("Calling SpatialMaterial.GetAnisotropy()")

	returnValue := godotCallFloat(o, "get_anisotropy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetAoLightAffect() float64 {
	log.Println("Calling SpatialMaterial.GetAoLightAffect()")

	returnValue := godotCallFloat(o, "get_ao_light_affect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetAoTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetAoTextureChannel()")

	returnValue := godotCallInt(o, "get_ao_texture_channel")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetBillboardMode() int64 {
	log.Println("Calling SpatialMaterial.GetBillboardMode()")

	returnValue := godotCallInt(o, "get_billboard_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetBlendMode() int64 {
	log.Println("Calling SpatialMaterial.GetBlendMode()")

	returnValue := godotCallInt(o, "get_blend_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetClearcoat() float64 {
	log.Println("Calling SpatialMaterial.GetClearcoat()")

	returnValue := godotCallFloat(o, "get_clearcoat")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetClearcoatGloss() float64 {
	log.Println("Calling SpatialMaterial.GetClearcoatGloss()")

	returnValue := godotCallFloat(o, "get_clearcoat_gloss")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetCullMode() int64 {
	log.Println("Calling SpatialMaterial.GetCullMode()")

	returnValue := godotCallInt(o, "get_cull_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetDepthDeepParallaxMaxLayers() int64 {
	log.Println("Calling SpatialMaterial.GetDepthDeepParallaxMaxLayers()")

	returnValue := godotCallInt(o, "get_depth_deep_parallax_max_layers")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetDepthDeepParallaxMinLayers() int64 {
	log.Println("Calling SpatialMaterial.GetDepthDeepParallaxMinLayers()")

	returnValue := godotCallInt(o, "get_depth_deep_parallax_min_layers")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetDepthDrawMode() int64 {
	log.Println("Calling SpatialMaterial.GetDepthDrawMode()")

	returnValue := godotCallInt(o, "get_depth_draw_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetDepthScale() float64 {
	log.Println("Calling SpatialMaterial.GetDepthScale()")

	returnValue := godotCallFloat(o, "get_depth_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetDetailBlendMode() int64 {
	log.Println("Calling SpatialMaterial.GetDetailBlendMode()")

	returnValue := godotCallInt(o, "get_detail_blend_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetDetailUv() int64 {
	log.Println("Calling SpatialMaterial.GetDetailUv()")

	returnValue := godotCallInt(o, "get_detail_uv")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetDiffuseMode() int64 {
	log.Println("Calling SpatialMaterial.GetDiffuseMode()")

	returnValue := godotCallInt(o, "get_diffuse_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetDistanceFadeMaxDistance() float64 {
	log.Println("Calling SpatialMaterial.GetDistanceFadeMaxDistance()")

	returnValue := godotCallFloat(o, "get_distance_fade_max_distance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetDistanceFadeMinDistance() float64 {
	log.Println("Calling SpatialMaterial.GetDistanceFadeMinDistance()")

	returnValue := godotCallFloat(o, "get_distance_fade_min_distance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetEmission() *Color {
	log.Println("Calling SpatialMaterial.GetEmission()")

	returnValue := godotCallColor(o, "get_emission")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetEmissionEnergy() float64 {
	log.Println("Calling SpatialMaterial.GetEmissionEnergy()")

	returnValue := godotCallFloat(o, "get_emission_energy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetEmissionOperator() int64 {
	log.Println("Calling SpatialMaterial.GetEmissionOperator()")

	returnValue := godotCallInt(o, "get_emission_operator")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetFeature(feature int64) bool {
	log.Println("Calling SpatialMaterial.GetFeature()")

	returnValue := godotCallBoolInt(o, "get_feature", feature)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetFlag(flag int64) bool {
	log.Println("Calling SpatialMaterial.GetFlag()")

	returnValue := godotCallBoolInt(o, "get_flag", flag)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetGrow() float64 {
	log.Println("Calling SpatialMaterial.GetGrow()")

	returnValue := godotCallFloat(o, "get_grow")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetLineWidth() float64 {
	log.Println("Calling SpatialMaterial.GetLineWidth()")

	returnValue := godotCallFloat(o, "get_line_width")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetMetallic() float64 {
	log.Println("Calling SpatialMaterial.GetMetallic()")

	returnValue := godotCallFloat(o, "get_metallic")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetMetallicTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetMetallicTextureChannel()")

	returnValue := godotCallInt(o, "get_metallic_texture_channel")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetNormalScale() float64 {
	log.Println("Calling SpatialMaterial.GetNormalScale()")

	returnValue := godotCallFloat(o, "get_normal_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetParticlesAnimHFrames() int64 {
	log.Println("Calling SpatialMaterial.GetParticlesAnimHFrames()")

	returnValue := godotCallInt(o, "get_particles_anim_h_frames")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetParticlesAnimLoop() int64 {
	log.Println("Calling SpatialMaterial.GetParticlesAnimLoop()")

	returnValue := godotCallInt(o, "get_particles_anim_loop")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetParticlesAnimVFrames() int64 {
	log.Println("Calling SpatialMaterial.GetParticlesAnimVFrames()")

	returnValue := godotCallInt(o, "get_particles_anim_v_frames")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetPointSize() float64 {
	log.Println("Calling SpatialMaterial.GetPointSize()")

	returnValue := godotCallFloat(o, "get_point_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetProximityFadeDistance() float64 {
	log.Println("Calling SpatialMaterial.GetProximityFadeDistance()")

	returnValue := godotCallFloat(o, "get_proximity_fade_distance")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetRefraction() float64 {
	log.Println("Calling SpatialMaterial.GetRefraction()")

	returnValue := godotCallFloat(o, "get_refraction")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetRefractionTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetRefractionTextureChannel()")

	returnValue := godotCallInt(o, "get_refraction_texture_channel")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetRim() float64 {
	log.Println("Calling SpatialMaterial.GetRim()")

	returnValue := godotCallFloat(o, "get_rim")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetRimTint() float64 {
	log.Println("Calling SpatialMaterial.GetRimTint()")

	returnValue := godotCallFloat(o, "get_rim_tint")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetRoughness() float64 {
	log.Println("Calling SpatialMaterial.GetRoughness()")

	returnValue := godotCallFloat(o, "get_roughness")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetRoughnessTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetRoughnessTextureChannel()")

	returnValue := godotCallInt(o, "get_roughness_texture_channel")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetSpecular() float64 {
	log.Println("Calling SpatialMaterial.GetSpecular()")

	returnValue := godotCallFloat(o, "get_specular")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetSpecularMode() int64 {
	log.Println("Calling SpatialMaterial.GetSpecularMode()")

	returnValue := godotCallInt(o, "get_specular_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetSubsurfaceScatteringStrength() float64 {
	log.Println("Calling SpatialMaterial.GetSubsurfaceScatteringStrength()")

	returnValue := godotCallFloat(o, "get_subsurface_scattering_strength")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetTexture(param int64) *Texture {
	log.Println("Calling SpatialMaterial.GetTexture()")

	returnValue := godotCallObjectInt(o, "get_texture", param)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetTransmission() *Color {
	log.Println("Calling SpatialMaterial.GetTransmission()")

	returnValue := godotCallColor(o, "get_transmission")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetUv1Offset() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv1Offset()")

	returnValue := godotCallVector3(o, "get_uv1_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetUv1Scale() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv1Scale()")

	returnValue := godotCallVector3(o, "get_uv1_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetUv1TriplanarBlendSharpness() float64 {
	log.Println("Calling SpatialMaterial.GetUv1TriplanarBlendSharpness()")

	returnValue := godotCallFloat(o, "get_uv1_triplanar_blend_sharpness")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetUv2Offset() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv2Offset()")

	returnValue := godotCallVector3(o, "get_uv2_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetUv2Scale() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv2Scale()")

	returnValue := godotCallVector3(o, "get_uv2_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) GetUv2TriplanarBlendSharpness() float64 {
	log.Println("Calling SpatialMaterial.GetUv2TriplanarBlendSharpness()")

	returnValue := godotCallFloat(o, "get_uv2_triplanar_blend_sharpness")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) IsDepthDeepParallaxEnabled() bool {
	log.Println("Calling SpatialMaterial.IsDepthDeepParallaxEnabled()")

	returnValue := godotCallBool(o, "is_depth_deep_parallax_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) IsDistanceFadeEnabled() bool {
	log.Println("Calling SpatialMaterial.IsDistanceFadeEnabled()")

	returnValue := godotCallBool(o, "is_distance_fade_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) IsGrowEnabled() bool {
	log.Println("Calling SpatialMaterial.IsGrowEnabled()")

	returnValue := godotCallBool(o, "is_grow_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) IsProximityFadeEnabled() bool {
	log.Println("Calling SpatialMaterial.IsProximityFadeEnabled()")

	returnValue := godotCallBool(o, "is_proximity_fade_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetAlbedo(albedo *Color) {
	log.Println("Calling SpatialMaterial.SetAlbedo()")

	godotCallVoidColor(o, "set_albedo", albedo)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetAlphaScissorThreshold(threshold float64) {
	log.Println("Calling SpatialMaterial.SetAlphaScissorThreshold()")

	godotCallVoidFloat(o, "set_alpha_scissor_threshold", threshold)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetAnisotropy(anisotropy float64) {
	log.Println("Calling SpatialMaterial.SetAnisotropy()")

	godotCallVoidFloat(o, "set_anisotropy", anisotropy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetAoLightAffect(amount float64) {
	log.Println("Calling SpatialMaterial.SetAoLightAffect()")

	godotCallVoidFloat(o, "set_ao_light_affect", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetAoTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetAoTextureChannel()")

	godotCallVoidInt(o, "set_ao_texture_channel", channel)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetBillboardMode(mode int64) {
	log.Println("Calling SpatialMaterial.SetBillboardMode()")

	godotCallVoidInt(o, "set_billboard_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetBlendMode(blendMode int64) {
	log.Println("Calling SpatialMaterial.SetBlendMode()")

	godotCallVoidInt(o, "set_blend_mode", blendMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetClearcoat(clearcoat float64) {
	log.Println("Calling SpatialMaterial.SetClearcoat()")

	godotCallVoidFloat(o, "set_clearcoat", clearcoat)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetClearcoatGloss(clearcoatGloss float64) {
	log.Println("Calling SpatialMaterial.SetClearcoatGloss()")

	godotCallVoidFloat(o, "set_clearcoat_gloss", clearcoatGloss)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetCullMode(cullMode int64) {
	log.Println("Calling SpatialMaterial.SetCullMode()")

	godotCallVoidInt(o, "set_cull_mode", cullMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetDepthDeepParallax(enable bool) {
	log.Println("Calling SpatialMaterial.SetDepthDeepParallax()")

	godotCallVoidBool(o, "set_depth_deep_parallax", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetDepthDeepParallaxMaxLayers(layer int64) {
	log.Println("Calling SpatialMaterial.SetDepthDeepParallaxMaxLayers()")

	godotCallVoidInt(o, "set_depth_deep_parallax_max_layers", layer)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetDepthDeepParallaxMinLayers(layer int64) {
	log.Println("Calling SpatialMaterial.SetDepthDeepParallaxMinLayers()")

	godotCallVoidInt(o, "set_depth_deep_parallax_min_layers", layer)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetDepthDrawMode(depthDrawMode int64) {
	log.Println("Calling SpatialMaterial.SetDepthDrawMode()")

	godotCallVoidInt(o, "set_depth_draw_mode", depthDrawMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetDepthScale(depthScale float64) {
	log.Println("Calling SpatialMaterial.SetDepthScale()")

	godotCallVoidFloat(o, "set_depth_scale", depthScale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetDetailBlendMode(detailBlendMode int64) {
	log.Println("Calling SpatialMaterial.SetDetailBlendMode()")

	godotCallVoidInt(o, "set_detail_blend_mode", detailBlendMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetDetailUv(detailUv int64) {
	log.Println("Calling SpatialMaterial.SetDetailUv()")

	godotCallVoidInt(o, "set_detail_uv", detailUv)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetDiffuseMode(diffuseMode int64) {
	log.Println("Calling SpatialMaterial.SetDiffuseMode()")

	godotCallVoidInt(o, "set_diffuse_mode", diffuseMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetDistanceFade(enabled bool) {
	log.Println("Calling SpatialMaterial.SetDistanceFade()")

	godotCallVoidBool(o, "set_distance_fade", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetDistanceFadeMaxDistance(distance float64) {
	log.Println("Calling SpatialMaterial.SetDistanceFadeMaxDistance()")

	godotCallVoidFloat(o, "set_distance_fade_max_distance", distance)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetDistanceFadeMinDistance(distance float64) {
	log.Println("Calling SpatialMaterial.SetDistanceFadeMinDistance()")

	godotCallVoidFloat(o, "set_distance_fade_min_distance", distance)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetEmission(emission *Color) {
	log.Println("Calling SpatialMaterial.SetEmission()")

	godotCallVoidColor(o, "set_emission", emission)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetEmissionEnergy(emissionEnergy float64) {
	log.Println("Calling SpatialMaterial.SetEmissionEnergy()")

	godotCallVoidFloat(o, "set_emission_energy", emissionEnergy)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetEmissionOperator(operator int64) {
	log.Println("Calling SpatialMaterial.SetEmissionOperator()")

	godotCallVoidInt(o, "set_emission_operator", operator)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetFeature(feature int64, enable bool) {
	log.Println("Calling SpatialMaterial.SetFeature()")

	godotCallVoidIntBool(o, "set_feature", feature, enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetFlag(flag int64, enable bool) {
	log.Println("Calling SpatialMaterial.SetFlag()")

	godotCallVoidIntBool(o, "set_flag", flag, enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetGrow(amount float64) {
	log.Println("Calling SpatialMaterial.SetGrow()")

	godotCallVoidFloat(o, "set_grow", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetGrowEnabled(enable bool) {
	log.Println("Calling SpatialMaterial.SetGrowEnabled()")

	godotCallVoidBool(o, "set_grow_enabled", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetLineWidth(lineWidth float64) {
	log.Println("Calling SpatialMaterial.SetLineWidth()")

	godotCallVoidFloat(o, "set_line_width", lineWidth)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetMetallic(metallic float64) {
	log.Println("Calling SpatialMaterial.SetMetallic()")

	godotCallVoidFloat(o, "set_metallic", metallic)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetMetallicTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetMetallicTextureChannel()")

	godotCallVoidInt(o, "set_metallic_texture_channel", channel)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetNormalScale(normalScale float64) {
	log.Println("Calling SpatialMaterial.SetNormalScale()")

	godotCallVoidFloat(o, "set_normal_scale", normalScale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetParticlesAnimHFrames(frames int64) {
	log.Println("Calling SpatialMaterial.SetParticlesAnimHFrames()")

	godotCallVoidInt(o, "set_particles_anim_h_frames", frames)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetParticlesAnimLoop(frames int64) {
	log.Println("Calling SpatialMaterial.SetParticlesAnimLoop()")

	godotCallVoidInt(o, "set_particles_anim_loop", frames)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetParticlesAnimVFrames(frames int64) {
	log.Println("Calling SpatialMaterial.SetParticlesAnimVFrames()")

	godotCallVoidInt(o, "set_particles_anim_v_frames", frames)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetPointSize(pointSize float64) {
	log.Println("Calling SpatialMaterial.SetPointSize()")

	godotCallVoidFloat(o, "set_point_size", pointSize)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetProximityFade(enabled bool) {
	log.Println("Calling SpatialMaterial.SetProximityFade()")

	godotCallVoidBool(o, "set_proximity_fade", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetProximityFadeDistance(distance float64) {
	log.Println("Calling SpatialMaterial.SetProximityFadeDistance()")

	godotCallVoidFloat(o, "set_proximity_fade_distance", distance)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetRefraction(refraction float64) {
	log.Println("Calling SpatialMaterial.SetRefraction()")

	godotCallVoidFloat(o, "set_refraction", refraction)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetRefractionTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetRefractionTextureChannel()")

	godotCallVoidInt(o, "set_refraction_texture_channel", channel)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetRim(rim float64) {
	log.Println("Calling SpatialMaterial.SetRim()")

	godotCallVoidFloat(o, "set_rim", rim)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetRimTint(rimTint float64) {
	log.Println("Calling SpatialMaterial.SetRimTint()")

	godotCallVoidFloat(o, "set_rim_tint", rimTint)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetRoughness(roughness float64) {
	log.Println("Calling SpatialMaterial.SetRoughness()")

	godotCallVoidFloat(o, "set_roughness", roughness)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetRoughnessTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetRoughnessTextureChannel()")

	godotCallVoidInt(o, "set_roughness_texture_channel", channel)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetSpecular(specular float64) {
	log.Println("Calling SpatialMaterial.SetSpecular()")

	godotCallVoidFloat(o, "set_specular", specular)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetSpecularMode(specularMode int64) {
	log.Println("Calling SpatialMaterial.SetSpecularMode()")

	godotCallVoidInt(o, "set_specular_mode", specularMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetSubsurfaceScatteringStrength(strength float64) {
	log.Println("Calling SpatialMaterial.SetSubsurfaceScatteringStrength()")

	godotCallVoidFloat(o, "set_subsurface_scattering_strength", strength)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetTexture(param int64, texture *Texture) {
	log.Println("Calling SpatialMaterial.SetTexture()")

	godotCallVoidIntObject(o, "set_texture", param, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetTransmission(transmission *Color) {
	log.Println("Calling SpatialMaterial.SetTransmission()")

	godotCallVoidColor(o, "set_transmission", transmission)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetUv1Offset(offset *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv1Offset()")

	godotCallVoidVector3(o, "set_uv1_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetUv1Scale(scale *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv1Scale()")

	godotCallVoidVector3(o, "set_uv1_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetUv1TriplanarBlendSharpness(sharpness float64) {
	log.Println("Calling SpatialMaterial.SetUv1TriplanarBlendSharpness()")

	godotCallVoidFloat(o, "set_uv1_triplanar_blend_sharpness", sharpness)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetUv2Offset(offset *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv2Offset()")

	godotCallVoidVector3(o, "set_uv2_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetUv2Scale(scale *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv2Scale()")

	godotCallVoidVector3(o, "set_uv2_scale", scale)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialMaterial) SetUv2TriplanarBlendSharpness(sharpness float64) {
	log.Println("Calling SpatialMaterial.SetUv2TriplanarBlendSharpness()")

	godotCallVoidFloat(o, "set_uv2_triplanar_blend_sharpness", sharpness)
	log.Println("  Function successfully completed.")

}

/*
   SpatialMaterialImplementer is an interface for SpatialMaterial objects.
*/
type SpatialMaterialImplementer interface {
	Class
}

/*

 */
type SpatialVelocityTracker struct {
	Reference
}

func (o *SpatialVelocityTracker) baseClass() string {
	return "SpatialVelocityTracker"
}

/*

 */
func (o *SpatialVelocityTracker) GetTrackedLinearVelocity() *Vector3 {
	log.Println("Calling SpatialVelocityTracker.GetTrackedLinearVelocity()")

	returnValue := godotCallVector3(o, "get_tracked_linear_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpatialVelocityTracker) IsTrackingPhysicsStep() bool {
	log.Println("Calling SpatialVelocityTracker.IsTrackingPhysicsStep()")

	returnValue := godotCallBool(o, "is_tracking_physics_step")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SpatialVelocityTracker) Reset(position *Vector3) {
	log.Println("Calling SpatialVelocityTracker.Reset()")

	godotCallVoidVector3(o, "reset", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpatialVelocityTracker) SetTrackPhysicsStep(enable bool) {
	log.Println("Calling SpatialVelocityTracker.SetTrackPhysicsStep()")

	godotCallVoidBool(o, "set_track_physics_step", enable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SpatialVelocityTracker) UpdatePosition(position *Vector3) {
	log.Println("Calling SpatialVelocityTracker.UpdatePosition()")

	godotCallVoidVector3(o, "update_position", position)
	log.Println("  Function successfully completed.")

}

/*
   SpatialVelocityTrackerImplementer is an interface for SpatialVelocityTracker objects.
*/
type SpatialVelocityTrackerImplementer interface {
	Class
}

/*
   Class representing a spherical [PrimitiveMesh].
*/
type SphereMesh struct {
	PrimitiveMesh
}

func (o *SphereMesh) baseClass() string {
	return "SphereMesh"
}

/*
   Undocumented
*/
func (o *SphereMesh) GetHeight() float64 {
	log.Println("Calling SphereMesh.GetHeight()")

	returnValue := godotCallFloat(o, "get_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SphereMesh) GetIsHemisphere() bool {
	log.Println("Calling SphereMesh.GetIsHemisphere()")

	returnValue := godotCallBool(o, "get_is_hemisphere")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SphereMesh) GetRadialSegments() int64 {
	log.Println("Calling SphereMesh.GetRadialSegments()")

	returnValue := godotCallInt(o, "get_radial_segments")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SphereMesh) GetRadius() float64 {
	log.Println("Calling SphereMesh.GetRadius()")

	returnValue := godotCallFloat(o, "get_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SphereMesh) GetRings() int64 {
	log.Println("Calling SphereMesh.GetRings()")

	returnValue := godotCallInt(o, "get_rings")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SphereMesh) SetHeight(height float64) {
	log.Println("Calling SphereMesh.SetHeight()")

	godotCallVoidFloat(o, "set_height", height)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SphereMesh) SetIsHemisphere(isHemisphere bool) {
	log.Println("Calling SphereMesh.SetIsHemisphere()")

	godotCallVoidBool(o, "set_is_hemisphere", isHemisphere)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SphereMesh) SetRadialSegments(radialSegments int64) {
	log.Println("Calling SphereMesh.SetRadialSegments()")

	godotCallVoidInt(o, "set_radial_segments", radialSegments)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SphereMesh) SetRadius(radius float64) {
	log.Println("Calling SphereMesh.SetRadius()")

	godotCallVoidFloat(o, "set_radius", radius)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SphereMesh) SetRings(rings int64) {
	log.Println("Calling SphereMesh.SetRings()")

	godotCallVoidInt(o, "set_rings", rings)
	log.Println("  Function successfully completed.")

}

/*
   SphereMeshImplementer is an interface for SphereMesh objects.
*/
type SphereMeshImplementer interface {
	Class
}

/*
   Sphere shape for 3D collisions, which can be set into a [PhysicsBody] or [Area]. This shape is useful for modeling sphere-like 3D objects.
*/
type SphereShape struct {
	Shape
}

func (o *SphereShape) baseClass() string {
	return "SphereShape"
}

/*
   Undocumented
*/
func (o *SphereShape) GetRadius() float64 {
	log.Println("Calling SphereShape.GetRadius()")

	returnValue := godotCallFloat(o, "get_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SphereShape) SetRadius(radius float64) {
	log.Println("Calling SphereShape.SetRadius()")

	godotCallVoidFloat(o, "set_radius", radius)
	log.Println("  Function successfully completed.")

}

/*
   SphereShapeImplementer is an interface for SphereShape objects.
*/
type SphereShapeImplementer interface {
	Class
}

/*
   SpinBox is a numerical input text field. It allows entering integers and floats.
*/
type SpinBox struct {
	Range
}

func (o *SpinBox) baseClass() string {
	return "SpinBox"
}

/*
   Undocumented
*/
func (o *SpinBox) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling SpinBox.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpinBox) X_LineEditFocusExit() {
	log.Println("Calling SpinBox.X_LineEditFocusExit()")

	godotCallVoid(o, "_line_edit_focus_exit")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpinBox) X_LineEditInput(arg0 *InputEvent) {
	log.Println("Calling SpinBox.X_LineEditInput()")

	godotCallVoidObject(o, "_line_edit_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpinBox) X_RangeClickTimeout() {
	log.Println("Calling SpinBox.X_RangeClickTimeout()")

	godotCallVoid(o, "_range_click_timeout")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpinBox) X_TextEntered(arg0 string) {
	log.Println("Calling SpinBox.X_TextEntered()")

	godotCallVoidString(o, "_text_entered", arg0)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SpinBox) GetLineEdit() *LineEdit {
	log.Println("Calling SpinBox.GetLineEdit()")

	returnValue := godotCallObject(o, "get_line_edit")
	log.Println("  Got return value: ", returnValue)

	var ret LineEdit
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *SpinBox) GetPrefix() string {
	log.Println("Calling SpinBox.GetPrefix()")

	returnValue := godotCallString(o, "get_prefix")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpinBox) GetSuffix() string {
	log.Println("Calling SpinBox.GetSuffix()")

	returnValue := godotCallString(o, "get_suffix")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpinBox) IsEditable() bool {
	log.Println("Calling SpinBox.IsEditable()")

	returnValue := godotCallBool(o, "is_editable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpinBox) SetEditable(editable bool) {
	log.Println("Calling SpinBox.SetEditable()")

	godotCallVoidBool(o, "set_editable", editable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpinBox) SetPrefix(prefix string) {
	log.Println("Calling SpinBox.SetPrefix()")

	godotCallVoidString(o, "set_prefix", prefix)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpinBox) SetSuffix(suffix string) {
	log.Println("Calling SpinBox.SetSuffix()")

	godotCallVoidString(o, "set_suffix", suffix)
	log.Println("  Function successfully completed.")

}

/*
   SpinBoxImplementer is an interface for SpinBox objects.
*/
type SpinBoxImplementer interface {
	Class
}

/*
   Container for splitting two controls vertically or horizontally, with a grabber that allows adjusting the split offset or ratio.
*/
type SplitContainer struct {
	Container
}

func (o *SplitContainer) baseClass() string {
	return "SplitContainer"
}

/*
   Undocumented
*/
func (o *SplitContainer) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling SplitContainer.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SplitContainer) GetDraggerVisibility() int64 {
	log.Println("Calling SplitContainer.GetDraggerVisibility()")

	returnValue := godotCallInt(o, "get_dragger_visibility")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SplitContainer) GetSplitOffset() int64 {
	log.Println("Calling SplitContainer.GetSplitOffset()")

	returnValue := godotCallInt(o, "get_split_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SplitContainer) IsCollapsed() bool {
	log.Println("Calling SplitContainer.IsCollapsed()")

	returnValue := godotCallBool(o, "is_collapsed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SplitContainer) SetCollapsed(collapsed bool) {
	log.Println("Calling SplitContainer.SetCollapsed()")

	godotCallVoidBool(o, "set_collapsed", collapsed)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SplitContainer) SetDraggerVisibility(mode int64) {
	log.Println("Calling SplitContainer.SetDraggerVisibility()")

	godotCallVoidInt(o, "set_dragger_visibility", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SplitContainer) SetSplitOffset(offset int64) {
	log.Println("Calling SplitContainer.SetSplitOffset()")

	godotCallVoidInt(o, "set_split_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   SplitContainerImplementer is an interface for SplitContainer objects.
*/
type SplitContainerImplementer interface {
	Class
}

/*
   A SpotLight light is a type of [Light] node that emits lights in a specific direction, in the shape of a cone. The light is attenuated through the distance and this attenuation can be configured by changing the energy, radius and attenuation parameters of [Light]. TODO: Image of a spotlight.
*/
type SpotLight struct {
	Light
}

func (o *SpotLight) baseClass() string {
	return "SpotLight"
}

/*
   SpotLightImplementer is an interface for SpotLight objects.
*/
type SpotLightImplementer interface {
	Class
}

/*
   A node that displays a 2D texture. The texture displayed can be a region from a larger atlas texture, or a frame from a sprite sheet animation.
*/
type Sprite struct {
	Node2D
}

func (o *Sprite) baseClass() string {
	return "Sprite"
}

/*
   Undocumented
*/
func (o *Sprite) GetFrame() int64 {
	log.Println("Calling Sprite.GetFrame()")

	returnValue := godotCallInt(o, "get_frame")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite) GetHframes() int64 {
	log.Println("Calling Sprite.GetHframes()")

	returnValue := godotCallInt(o, "get_hframes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite) GetNormalMap() *Texture {
	log.Println("Calling Sprite.GetNormalMap()")

	returnValue := godotCallObject(o, "get_normal_map")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Sprite) GetOffset() *Vector2 {
	log.Println("Calling Sprite.GetOffset()")

	returnValue := godotCallVector2(o, "get_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite) GetRegionRect() *Rect2 {
	log.Println("Calling Sprite.GetRegionRect()")

	returnValue := godotCallRect2(o, "get_region_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite) GetTexture() *Texture {
	log.Println("Calling Sprite.GetTexture()")

	returnValue := godotCallObject(o, "get_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Sprite) GetVframes() int64 {
	log.Println("Calling Sprite.GetVframes()")

	returnValue := godotCallInt(o, "get_vframes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite) IsCentered() bool {
	log.Println("Calling Sprite.IsCentered()")

	returnValue := godotCallBool(o, "is_centered")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite) IsFlippedH() bool {
	log.Println("Calling Sprite.IsFlippedH()")

	returnValue := godotCallBool(o, "is_flipped_h")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite) IsFlippedV() bool {
	log.Println("Calling Sprite.IsFlippedV()")

	returnValue := godotCallBool(o, "is_flipped_v")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite) IsRegion() bool {
	log.Println("Calling Sprite.IsRegion()")

	returnValue := godotCallBool(o, "is_region")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite) IsRegionFilterClipEnabled() bool {
	log.Println("Calling Sprite.IsRegionFilterClipEnabled()")

	returnValue := godotCallBool(o, "is_region_filter_clip_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite) SetCentered(centered bool) {
	log.Println("Calling Sprite.SetCentered()")

	godotCallVoidBool(o, "set_centered", centered)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite) SetFlipH(flipH bool) {
	log.Println("Calling Sprite.SetFlipH()")

	godotCallVoidBool(o, "set_flip_h", flipH)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite) SetFlipV(flipV bool) {
	log.Println("Calling Sprite.SetFlipV()")

	godotCallVoidBool(o, "set_flip_v", flipV)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite) SetFrame(frame int64) {
	log.Println("Calling Sprite.SetFrame()")

	godotCallVoidInt(o, "set_frame", frame)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite) SetHframes(hframes int64) {
	log.Println("Calling Sprite.SetHframes()")

	godotCallVoidInt(o, "set_hframes", hframes)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite) SetNormalMap(normalMap *Texture) {
	log.Println("Calling Sprite.SetNormalMap()")

	godotCallVoidObject(o, "set_normal_map", &normalMap.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite) SetOffset(offset *Vector2) {
	log.Println("Calling Sprite.SetOffset()")

	godotCallVoidVector2(o, "set_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite) SetRegion(enabled bool) {
	log.Println("Calling Sprite.SetRegion()")

	godotCallVoidBool(o, "set_region", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite) SetRegionFilterClip(enabled bool) {
	log.Println("Calling Sprite.SetRegionFilterClip()")

	godotCallVoidBool(o, "set_region_filter_clip", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite) SetRegionRect(rect *Rect2) {
	log.Println("Calling Sprite.SetRegionRect()")

	godotCallVoidRect2(o, "set_region_rect", rect)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite) SetTexture(texture *Texture) {
	log.Println("Calling Sprite.SetTexture()")

	godotCallVoidObject(o, "set_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite) SetVframes(vframes int64) {
	log.Println("Calling Sprite.SetVframes()")

	godotCallVoidInt(o, "set_vframes", vframes)
	log.Println("  Function successfully completed.")

}

/*
   SpriteImplementer is an interface for Sprite objects.
*/
type SpriteImplementer interface {
	Class
}

/*
   A node that displays a 2D texture in a 3D environment. The texture displayed can be a region from a larger atlas texture, or a frame from a sprite sheet animation.
*/
type Sprite3D struct {
	SpriteBase3D
}

func (o *Sprite3D) baseClass() string {
	return "Sprite3D"
}

/*
   Undocumented
*/
func (o *Sprite3D) GetFrame() int64 {
	log.Println("Calling Sprite3D.GetFrame()")

	returnValue := godotCallInt(o, "get_frame")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite3D) GetHframes() int64 {
	log.Println("Calling Sprite3D.GetHframes()")

	returnValue := godotCallInt(o, "get_hframes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite3D) GetRegionRect() *Rect2 {
	log.Println("Calling Sprite3D.GetRegionRect()")

	returnValue := godotCallRect2(o, "get_region_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite3D) GetTexture() *Texture {
	log.Println("Calling Sprite3D.GetTexture()")

	returnValue := godotCallObject(o, "get_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Sprite3D) GetVframes() int64 {
	log.Println("Calling Sprite3D.GetVframes()")

	returnValue := godotCallInt(o, "get_vframes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite3D) IsRegion() bool {
	log.Println("Calling Sprite3D.IsRegion()")

	returnValue := godotCallBool(o, "is_region")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Sprite3D) SetFrame(frame int64) {
	log.Println("Calling Sprite3D.SetFrame()")

	godotCallVoidInt(o, "set_frame", frame)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite3D) SetHframes(hframes int64) {
	log.Println("Calling Sprite3D.SetHframes()")

	godotCallVoidInt(o, "set_hframes", hframes)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite3D) SetRegion(enabled bool) {
	log.Println("Calling Sprite3D.SetRegion()")

	godotCallVoidBool(o, "set_region", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite3D) SetRegionRect(rect *Rect2) {
	log.Println("Calling Sprite3D.SetRegionRect()")

	godotCallVoidRect2(o, "set_region_rect", rect)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite3D) SetTexture(texture *Texture) {
	log.Println("Calling Sprite3D.SetTexture()")

	godotCallVoidObject(o, "set_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Sprite3D) SetVframes(vframes int64) {
	log.Println("Calling Sprite3D.SetVframes()")

	godotCallVoidInt(o, "set_vframes", vframes)
	log.Println("  Function successfully completed.")

}

/*
   Sprite3DImplementer is an interface for Sprite3D objects.
*/
type Sprite3DImplementer interface {
	Class
}

/*
   A node that displays 2D texture information in a 3D environment.
*/
type SpriteBase3D struct {
	GeometryInstance
}

func (o *SpriteBase3D) baseClass() string {
	return "SpriteBase3D"
}

/*
   Undocumented
*/
func (o *SpriteBase3D) X_ImUpdate() {
	log.Println("Calling SpriteBase3D.X_ImUpdate()")

	godotCallVoid(o, "_im_update")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) X_QueueUpdate() {
	log.Println("Calling SpriteBase3D.X_QueueUpdate()")

	godotCallVoid(o, "_queue_update")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) GetAlphaCutMode() int64 {
	log.Println("Calling SpriteBase3D.GetAlphaCutMode()")

	returnValue := godotCallInt(o, "get_alpha_cut_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteBase3D) GetAxis() int64 {
	log.Println("Calling SpriteBase3D.GetAxis()")

	returnValue := godotCallInt(o, "get_axis")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteBase3D) GetDrawFlag(flag int64) bool {
	log.Println("Calling SpriteBase3D.GetDrawFlag()")

	returnValue := godotCallBoolInt(o, "get_draw_flag", flag)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) GetItemRect() *Rect2 {
	log.Println("Calling SpriteBase3D.GetItemRect()")

	returnValue := godotCallRect2(o, "get_item_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteBase3D) GetModulate() *Color {
	log.Println("Calling SpriteBase3D.GetModulate()")

	returnValue := godotCallColor(o, "get_modulate")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteBase3D) GetOffset() *Vector2 {
	log.Println("Calling SpriteBase3D.GetOffset()")

	returnValue := godotCallVector2(o, "get_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteBase3D) GetOpacity() float64 {
	log.Println("Calling SpriteBase3D.GetOpacity()")

	returnValue := godotCallFloat(o, "get_opacity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteBase3D) GetPixelSize() float64 {
	log.Println("Calling SpriteBase3D.GetPixelSize()")

	returnValue := godotCallFloat(o, "get_pixel_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteBase3D) IsCentered() bool {
	log.Println("Calling SpriteBase3D.IsCentered()")

	returnValue := godotCallBool(o, "is_centered")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteBase3D) IsFlippedH() bool {
	log.Println("Calling SpriteBase3D.IsFlippedH()")

	returnValue := godotCallBool(o, "is_flipped_h")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteBase3D) IsFlippedV() bool {
	log.Println("Calling SpriteBase3D.IsFlippedV()")

	returnValue := godotCallBool(o, "is_flipped_v")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteBase3D) SetAlphaCutMode(mode int64) {
	log.Println("Calling SpriteBase3D.SetAlphaCutMode()")

	godotCallVoidInt(o, "set_alpha_cut_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) SetAxis(axis int64) {
	log.Println("Calling SpriteBase3D.SetAxis()")

	godotCallVoidInt(o, "set_axis", axis)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) SetCentered(centered bool) {
	log.Println("Calling SpriteBase3D.SetCentered()")

	godotCallVoidBool(o, "set_centered", centered)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) SetDrawFlag(flag int64, enabled bool) {
	log.Println("Calling SpriteBase3D.SetDrawFlag()")

	godotCallVoidIntBool(o, "set_draw_flag", flag, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) SetFlipH(flipH bool) {
	log.Println("Calling SpriteBase3D.SetFlipH()")

	godotCallVoidBool(o, "set_flip_h", flipH)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) SetFlipV(flipV bool) {
	log.Println("Calling SpriteBase3D.SetFlipV()")

	godotCallVoidBool(o, "set_flip_v", flipV)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) SetModulate(modulate *Color) {
	log.Println("Calling SpriteBase3D.SetModulate()")

	godotCallVoidColor(o, "set_modulate", modulate)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) SetOffset(offset *Vector2) {
	log.Println("Calling SpriteBase3D.SetOffset()")

	godotCallVoidVector2(o, "set_offset", offset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) SetOpacity(opacity float64) {
	log.Println("Calling SpriteBase3D.SetOpacity()")

	godotCallVoidFloat(o, "set_opacity", opacity)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteBase3D) SetPixelSize(pixelSize float64) {
	log.Println("Calling SpriteBase3D.SetPixelSize()")

	godotCallVoidFloat(o, "set_pixel_size", pixelSize)
	log.Println("  Function successfully completed.")

}

/*
   SpriteBase3DImplementer is an interface for SpriteBase3D objects.
*/
type SpriteBase3DImplementer interface {
	Class
}

/*
   Sprite frame library for [AnimatedSprite]. Contains frames and animation data for playback.
*/
type SpriteFrames struct {
	Resource
}

func (o *SpriteFrames) baseClass() string {
	return "SpriteFrames"
}

/*
   Undocumented
*/
func (o *SpriteFrames) X_GetAnimations() *Array {
	log.Println("Calling SpriteFrames.X_GetAnimations()")

	returnValue := godotCallArray(o, "_get_animations")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteFrames) X_GetFrames() *Array {
	log.Println("Calling SpriteFrames.X_GetFrames()")

	returnValue := godotCallArray(o, "_get_frames")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *SpriteFrames) X_SetAnimations(arg0 *Array) {
	log.Println("Calling SpriteFrames.X_SetAnimations()")

	godotCallVoidArray(o, "_set_animations", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *SpriteFrames) X_SetFrames(arg0 *Array) {
	log.Println("Calling SpriteFrames.X_SetFrames()")

	godotCallVoidArray(o, "_set_frames", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Adds a new animation to the the library.
*/
func (o *SpriteFrames) AddAnimation(anim string) {
	log.Println("Calling SpriteFrames.AddAnimation()")

	godotCallVoidString(o, "add_animation", anim)
	log.Println("  Function successfully completed.")

}

/*
   Adds a frame to the given animation.
*/
func (o *SpriteFrames) AddFrame(anim string, frame *Texture, atPosition int64) {
	log.Println("Calling SpriteFrames.AddFrame()")

	godotCallVoidStringObjectInt(o, "add_frame", anim, &frame.Object, atPosition)
	log.Println("  Function successfully completed.")

}

/*
   Removes all frames from the given animation.
*/
func (o *SpriteFrames) Clear(anim string) {
	log.Println("Calling SpriteFrames.Clear()")

	godotCallVoidString(o, "clear", anim)
	log.Println("  Function successfully completed.")

}

/*
   Removes all animations. A "default" animation will be created.
*/
func (o *SpriteFrames) ClearAll() {
	log.Println("Calling SpriteFrames.ClearAll()")

	godotCallVoid(o, "clear_all")
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the given animation will loop.
*/
func (o *SpriteFrames) GetAnimationLoop(anim string) bool {
	log.Println("Calling SpriteFrames.GetAnimationLoop()")

	returnValue := godotCallBoolString(o, "get_animation_loop", anim)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   The animation's speed in frames per second.
*/
func (o *SpriteFrames) GetAnimationSpeed(anim string) float64 {
	log.Println("Calling SpriteFrames.GetAnimationSpeed()")

	returnValue := godotCallFloatString(o, "get_animation_speed", anim)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the animation's selected frame.
*/
func (o *SpriteFrames) GetFrame(anim string, idx int64) *Texture {
	log.Println("Calling SpriteFrames.GetFrame()")

	returnValue := godotCallObjectStringInt(o, "get_frame", anim, idx)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of frames in the animation.
*/
func (o *SpriteFrames) GetFrameCount(anim string) int64 {
	log.Println("Calling SpriteFrames.GetFrameCount()")

	returnValue := godotCallIntString(o, "get_frame_count", anim)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the named animation exists.
*/
func (o *SpriteFrames) HasAnimation(anim string) bool {
	log.Println("Calling SpriteFrames.HasAnimation()")

	returnValue := godotCallBoolString(o, "has_animation", anim)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes the given animation.
*/
func (o *SpriteFrames) RemoveAnimation(anim string) {
	log.Println("Calling SpriteFrames.RemoveAnimation()")

	godotCallVoidString(o, "remove_animation", anim)
	log.Println("  Function successfully completed.")

}

/*
   Removes the animation's selected frame.
*/
func (o *SpriteFrames) RemoveFrame(anim string, idx int64) {
	log.Println("Calling SpriteFrames.RemoveFrame()")

	godotCallVoidStringInt(o, "remove_frame", anim, idx)
	log.Println("  Function successfully completed.")

}

/*
   Changes the animation's name to [code]newname[/code].
*/
func (o *SpriteFrames) RenameAnimation(anim string, newname string) {
	log.Println("Calling SpriteFrames.RenameAnimation()")

	godotCallVoidStringString(o, "rename_animation", anim, newname)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the animation will loop.
*/
func (o *SpriteFrames) SetAnimationLoop(anim string, loop bool) {
	log.Println("Calling SpriteFrames.SetAnimationLoop()")

	godotCallVoidStringBool(o, "set_animation_loop", anim, loop)
	log.Println("  Function successfully completed.")

}

/*
   The animation's speed in frames per second.
*/
func (o *SpriteFrames) SetAnimationSpeed(anim string, speed float64) {
	log.Println("Calling SpriteFrames.SetAnimationSpeed()")

	godotCallVoidStringFloat(o, "set_animation_speed", anim, speed)
	log.Println("  Function successfully completed.")

}

/*
   Sets the texture of the given frame.
*/
func (o *SpriteFrames) SetFrame(anim string, idx int64, txt *Texture) {
	log.Println("Calling SpriteFrames.SetFrame()")

	godotCallVoidStringIntObject(o, "set_frame", anim, idx, &txt.Object)
	log.Println("  Function successfully completed.")

}

/*
   SpriteFramesImplementer is an interface for SpriteFrames objects.
*/
type SpriteFramesImplementer interface {
	Class
}

/*
   Static body for 3D Physics. A static body is a simple body that is not intended to move. They don't consume any CPU resources in contrast to a [RigidBody3D] so they are great for scenario collision. A static body can also be animated by using simulated motion mode. This is useful for implementing functionalities such as moving platforms. When this mode is active the body can be animated and automatically computes linear and angular velocity to apply in that frame and to influence other bodies. Alternatively, a constant linear or angular velocity can be set for the static body, so even if it doesn't move, it affects other bodies as if it was moving (this is useful for simulating conveyor belts or conveyor wheels).
*/
type StaticBody struct {
	PhysicsBody
}

func (o *StaticBody) baseClass() string {
	return "StaticBody"
}

/*
   Undocumented
*/
func (o *StaticBody) GetBounce() float64 {
	log.Println("Calling StaticBody.GetBounce()")

	returnValue := godotCallFloat(o, "get_bounce")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StaticBody) GetConstantAngularVelocity() *Vector3 {
	log.Println("Calling StaticBody.GetConstantAngularVelocity()")

	returnValue := godotCallVector3(o, "get_constant_angular_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StaticBody) GetConstantLinearVelocity() *Vector3 {
	log.Println("Calling StaticBody.GetConstantLinearVelocity()")

	returnValue := godotCallVector3(o, "get_constant_linear_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StaticBody) GetFriction() float64 {
	log.Println("Calling StaticBody.GetFriction()")

	returnValue := godotCallFloat(o, "get_friction")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StaticBody) SetBounce(bounce float64) {
	log.Println("Calling StaticBody.SetBounce()")

	godotCallVoidFloat(o, "set_bounce", bounce)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StaticBody) SetConstantAngularVelocity(vel *Vector3) {
	log.Println("Calling StaticBody.SetConstantAngularVelocity()")

	godotCallVoidVector3(o, "set_constant_angular_velocity", vel)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StaticBody) SetConstantLinearVelocity(vel *Vector3) {
	log.Println("Calling StaticBody.SetConstantLinearVelocity()")

	godotCallVoidVector3(o, "set_constant_linear_velocity", vel)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StaticBody) SetFriction(friction float64) {
	log.Println("Calling StaticBody.SetFriction()")

	godotCallVoidFloat(o, "set_friction", friction)
	log.Println("  Function successfully completed.")

}

/*
   StaticBodyImplementer is an interface for StaticBody objects.
*/
type StaticBodyImplementer interface {
	Class
}

/*
   Static body for 2D Physics. A StaticBody2D is a body that is not intended to move. It is ideal for implementing objects in the environment, such as walls or platforms. Additionally, a constant linear or angular velocity can be set for the static body, which will affect colliding bodies as if it were moving (for example, a conveyor belt).
*/
type StaticBody2D struct {
	PhysicsBody2D
}

func (o *StaticBody2D) baseClass() string {
	return "StaticBody2D"
}

/*
   Undocumented
*/
func (o *StaticBody2D) GetBounce() float64 {
	log.Println("Calling StaticBody2D.GetBounce()")

	returnValue := godotCallFloat(o, "get_bounce")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StaticBody2D) GetConstantAngularVelocity() float64 {
	log.Println("Calling StaticBody2D.GetConstantAngularVelocity()")

	returnValue := godotCallFloat(o, "get_constant_angular_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StaticBody2D) GetConstantLinearVelocity() *Vector2 {
	log.Println("Calling StaticBody2D.GetConstantLinearVelocity()")

	returnValue := godotCallVector2(o, "get_constant_linear_velocity")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StaticBody2D) GetFriction() float64 {
	log.Println("Calling StaticBody2D.GetFriction()")

	returnValue := godotCallFloat(o, "get_friction")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StaticBody2D) SetBounce(bounce float64) {
	log.Println("Calling StaticBody2D.SetBounce()")

	godotCallVoidFloat(o, "set_bounce", bounce)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StaticBody2D) SetConstantAngularVelocity(vel float64) {
	log.Println("Calling StaticBody2D.SetConstantAngularVelocity()")

	godotCallVoidFloat(o, "set_constant_angular_velocity", vel)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StaticBody2D) SetConstantLinearVelocity(vel *Vector2) {
	log.Println("Calling StaticBody2D.SetConstantLinearVelocity()")

	godotCallVoidVector2(o, "set_constant_linear_velocity", vel)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StaticBody2D) SetFriction(friction float64) {
	log.Println("Calling StaticBody2D.SetFriction()")

	godotCallVoidFloat(o, "set_friction", friction)
	log.Println("  Function successfully completed.")

}

/*
   StaticBody2DImplementer is an interface for StaticBody2D objects.
*/
type StaticBody2DImplementer interface {
	Class
}

/*
   StreamPeer is an abstraction and base class for stream-based protocols (such as TCP or Unix Sockets). It provides an API for sending and receiving data through streams as raw data or strings.
*/
type StreamPeer struct {
	Reference
}

func (o *StreamPeer) baseClass() string {
	return "StreamPeer"
}

/*
   Get a signed 16 bit value from the stream.
*/
func (o *StreamPeer) Get16() int64 {
	log.Println("Calling StreamPeer.Get16()")

	returnValue := godotCallInt(o, "get_16")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get a signed 32 bit value from the stream.
*/
func (o *StreamPeer) Get32() int64 {
	log.Println("Calling StreamPeer.Get32()")

	returnValue := godotCallInt(o, "get_32")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get a signed 64 bit value from the stream.
*/
func (o *StreamPeer) Get64() int64 {
	log.Println("Calling StreamPeer.Get64()")

	returnValue := godotCallInt(o, "get_64")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get a signed byte from the stream.
*/
func (o *StreamPeer) Get8() int64 {
	log.Println("Calling StreamPeer.Get8()")

	returnValue := godotCallInt(o, "get_8")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the amount of bytes this [code]StreamPeer[/code] has available.
*/
func (o *StreamPeer) GetAvailableBytes() int64 {
	log.Println("Calling StreamPeer.GetAvailableBytes()")

	returnValue := godotCallInt(o, "get_available_bytes")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return a chunk data with the received bytes. The amount of bytes to be received can be requested in the "bytes" argument. If not enough bytes are available, the function will block until the desired amount is received. This function returns two values, an Error code and a data array.
*/
func (o *StreamPeer) GetData(bytes int64) *Array {
	log.Println("Calling StreamPeer.GetData()")

	returnValue := godotCallArrayInt(o, "get_data", bytes)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get a double-precision float from the stream.
*/
func (o *StreamPeer) GetDouble() float64 {
	log.Println("Calling StreamPeer.GetDouble()")

	returnValue := godotCallFloat(o, "get_double")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get a single-precision float from the stream.
*/
func (o *StreamPeer) GetFloat() float64 {
	log.Println("Calling StreamPeer.GetFloat()")

	returnValue := godotCallFloat(o, "get_float")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return a chunk data with the received bytes. The amount of bytes to be received can be requested in the "bytes" argument. If not enough bytes are available, the function will return how many were actually received. This function returns two values, an Error code, and a data array.
*/
func (o *StreamPeer) GetPartialData(bytes int64) *Array {
	log.Println("Calling StreamPeer.GetPartialData()")

	returnValue := godotCallArrayInt(o, "get_partial_data", bytes)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get a string with byte-length "bytes" from the stream.
*/
func (o *StreamPeer) GetString(bytes int64) string {
	log.Println("Calling StreamPeer.GetString()")

	returnValue := godotCallStringInt(o, "get_string", bytes)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get an unsigned 16 bit value from the stream.
*/
func (o *StreamPeer) GetU16() int64 {
	log.Println("Calling StreamPeer.GetU16()")

	returnValue := godotCallInt(o, "get_u16")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get an unsigned 32 bit value from the stream.
*/
func (o *StreamPeer) GetU32() int64 {
	log.Println("Calling StreamPeer.GetU32()")

	returnValue := godotCallInt(o, "get_u32")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get an unsigned 64 bit value from the stream.
*/
func (o *StreamPeer) GetU64() int64 {
	log.Println("Calling StreamPeer.GetU64()")

	returnValue := godotCallInt(o, "get_u64")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get an unsigned byte from the stream.
*/
func (o *StreamPeer) GetU8() int64 {
	log.Println("Calling StreamPeer.GetU8()")

	returnValue := godotCallInt(o, "get_u8")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get a utf8 string with byte-length "bytes" from the stream (this decodes the string sent as utf8).
*/
func (o *StreamPeer) GetUtf8String(bytes int64) string {
	log.Println("Calling StreamPeer.GetUtf8String()")

	returnValue := godotCallStringInt(o, "get_utf8_string", bytes)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get a Variant from the stream.
*/
func (o *StreamPeer) GetVar() *Variant {
	log.Println("Calling StreamPeer.GetVar()")

	returnValue := godotCallVariant(o, "get_var")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StreamPeer) IsBigEndianEnabled() bool {
	log.Println("Calling StreamPeer.IsBigEndianEnabled()")

	returnValue := godotCallBool(o, "is_big_endian_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Put a signed 16 bit value into the stream.
*/
func (o *StreamPeer) Put16(value int64) {
	log.Println("Calling StreamPeer.Put16()")

	godotCallVoidInt(o, "put_16", value)
	log.Println("  Function successfully completed.")

}

/*
   Put a signed 32 bit value into the stream.
*/
func (o *StreamPeer) Put32(value int64) {
	log.Println("Calling StreamPeer.Put32()")

	godotCallVoidInt(o, "put_32", value)
	log.Println("  Function successfully completed.")

}

/*
   Put a signed 64 bit value into the stream.
*/
func (o *StreamPeer) Put64(value int64) {
	log.Println("Calling StreamPeer.Put64()")

	godotCallVoidInt(o, "put_64", value)
	log.Println("  Function successfully completed.")

}

/*
   Put a signed byte into the stream.
*/
func (o *StreamPeer) Put8(value int64) {
	log.Println("Calling StreamPeer.Put8()")

	godotCallVoidInt(o, "put_8", value)
	log.Println("  Function successfully completed.")

}

/*
   Send a chunk of data through the connection, blocking if necessary until the data is done sending. This function returns an Error code.
*/
func (o *StreamPeer) PutData(data *PoolByteArray) int64 {
	log.Println("Calling StreamPeer.PutData()")

	returnValue := godotCallIntPoolByteArray(o, "put_data", data)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Put a double-precision float into the stream.
*/
func (o *StreamPeer) PutDouble(value float64) {
	log.Println("Calling StreamPeer.PutDouble()")

	godotCallVoidFloat(o, "put_double", value)
	log.Println("  Function successfully completed.")

}

/*
   Put a single-precision float into the stream.
*/
func (o *StreamPeer) PutFloat(value float64) {
	log.Println("Calling StreamPeer.PutFloat()")

	godotCallVoidFloat(o, "put_float", value)
	log.Println("  Function successfully completed.")

}

/*
   Send a chunk of data through the connection, if all the data could not be sent at once, only part of it will. This function returns two values, an Error code and an integer, describing how much data was actually sent.
*/
func (o *StreamPeer) PutPartialData(data *PoolByteArray) *Array {
	log.Println("Calling StreamPeer.PutPartialData()")

	returnValue := godotCallArrayPoolByteArray(o, "put_partial_data", data)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Put an unsigned 16 bit value into the stream.
*/
func (o *StreamPeer) PutU16(value int64) {
	log.Println("Calling StreamPeer.PutU16()")

	godotCallVoidInt(o, "put_u16", value)
	log.Println("  Function successfully completed.")

}

/*
   Put an unsigned 32 bit value into the stream.
*/
func (o *StreamPeer) PutU32(value int64) {
	log.Println("Calling StreamPeer.PutU32()")

	godotCallVoidInt(o, "put_u32", value)
	log.Println("  Function successfully completed.")

}

/*
   Put an unsigned 64 bit value into the stream.
*/
func (o *StreamPeer) PutU64(value int64) {
	log.Println("Calling StreamPeer.PutU64()")

	godotCallVoidInt(o, "put_u64", value)
	log.Println("  Function successfully completed.")

}

/*
   Put an unsigned byte into the stream.
*/
func (o *StreamPeer) PutU8(value int64) {
	log.Println("Calling StreamPeer.PutU8()")

	godotCallVoidInt(o, "put_u8", value)
	log.Println("  Function successfully completed.")

}

/*
   Put a zero-terminated utf8 string into the stream.
*/
func (o *StreamPeer) PutUtf8String(value string) {
	log.Println("Calling StreamPeer.PutUtf8String()")

	godotCallVoidString(o, "put_utf8_string", value)
	log.Println("  Function successfully completed.")

}

/*
   Put a Variant into the stream.
*/
func (o *StreamPeer) PutVar(value *Variant) {
	log.Println("Calling StreamPeer.PutVar()")

	godotCallVoidVariant(o, "put_var", value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StreamPeer) SetBigEndian(enable bool) {
	log.Println("Calling StreamPeer.SetBigEndian()")

	godotCallVoidBool(o, "set_big_endian", enable)
	log.Println("  Function successfully completed.")

}

/*
   StreamPeerImplementer is an interface for StreamPeer objects.
*/
type StreamPeerImplementer interface {
	Class
}

/*

 */
type StreamPeerBuffer struct {
	StreamPeer
}

func (o *StreamPeerBuffer) baseClass() string {
	return "StreamPeerBuffer"
}

/*

 */
func (o *StreamPeerBuffer) Clear() {
	log.Println("Calling StreamPeerBuffer.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *StreamPeerBuffer) Duplicate() *StreamPeerBuffer {
	log.Println("Calling StreamPeerBuffer.Duplicate()")

	returnValue := godotCallObject(o, "duplicate")
	log.Println("  Got return value: ", returnValue)

	var ret StreamPeerBuffer
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *StreamPeerBuffer) GetDataArray() *PoolByteArray {
	log.Println("Calling StreamPeerBuffer.GetDataArray()")

	returnValue := godotCallPoolByteArray(o, "get_data_array")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *StreamPeerBuffer) GetPosition() int64 {
	log.Println("Calling StreamPeerBuffer.GetPosition()")

	returnValue := godotCallInt(o, "get_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *StreamPeerBuffer) GetSize() int64 {
	log.Println("Calling StreamPeerBuffer.GetSize()")

	returnValue := godotCallInt(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *StreamPeerBuffer) Resize(size int64) {
	log.Println("Calling StreamPeerBuffer.Resize()")

	godotCallVoidInt(o, "resize", size)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *StreamPeerBuffer) Seek(position int64) {
	log.Println("Calling StreamPeerBuffer.Seek()")

	godotCallVoidInt(o, "seek", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StreamPeerBuffer) SetDataArray(data *PoolByteArray) {
	log.Println("Calling StreamPeerBuffer.SetDataArray()")

	godotCallVoidPoolByteArray(o, "set_data_array", data)
	log.Println("  Function successfully completed.")

}

/*
   StreamPeerBufferImplementer is an interface for StreamPeerBuffer objects.
*/
type StreamPeerBufferImplementer interface {
	Class
}

/*
   SSL Stream peer. This object can be used to connect to SSL servers.
*/
type StreamPeerSSL struct {
	StreamPeer
}

func (o *StreamPeerSSL) baseClass() string {
	return "StreamPeerSSL"
}

/*

 */
func (o *StreamPeerSSL) AcceptStream(stream *StreamPeer) int64 {
	log.Println("Calling StreamPeerSSL.AcceptStream()")

	returnValue := godotCallIntObject(o, "accept_stream", &stream.Object)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Connect to a peer using an underlying [StreamPeer] "stream", when "validate_certs" is true, [code]StreamPeerSSL[/code] will validate that the certificate presented by the peer matches the "for_hostname".
*/
func (o *StreamPeerSSL) ConnectToStream(stream *StreamPeer, validateCerts bool, forHostname string) int64 {
	log.Println("Calling StreamPeerSSL.ConnectToStream()")

	returnValue := godotCallIntObjectBoolString(o, "connect_to_stream", &stream.Object, validateCerts, forHostname)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Disconnect from host.
*/
func (o *StreamPeerSSL) DisconnectFromStream() {
	log.Println("Calling StreamPeerSSL.DisconnectFromStream()")

	godotCallVoid(o, "disconnect_from_stream")
	log.Println("  Function successfully completed.")

}

/*
   Return the status of the connection, one of STATUS_* enum.
*/
func (o *StreamPeerSSL) GetStatus() int64 {
	log.Println("Calling StreamPeerSSL.GetStatus()")

	returnValue := godotCallInt(o, "get_status")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   StreamPeerSSLImplementer is an interface for StreamPeerSSL objects.
*/
type StreamPeerSSLImplementer interface {
	Class
}

/*
   TCP Stream peer. This object can be used to connect to TCP servers, or also is returned by a tcp server.
*/
type StreamPeerTCP struct {
	StreamPeer
}

func (o *StreamPeerTCP) baseClass() string {
	return "StreamPeerTCP"
}

/*
   Connect to the specified host:port pair. A hostname will be resolved if valid. Returns [OK] on success or [FAILED] on failure.
*/
func (o *StreamPeerTCP) ConnectToHost(host string, port int64) int64 {
	log.Println("Calling StreamPeerTCP.ConnectToHost()")

	returnValue := godotCallIntStringInt(o, "connect_to_host", host, port)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Disconnect from host.
*/
func (o *StreamPeerTCP) DisconnectFromHost() {
	log.Println("Calling StreamPeerTCP.DisconnectFromHost()")

	godotCallVoid(o, "disconnect_from_host")
	log.Println("  Function successfully completed.")

}

/*
   Return the IP of this peer.
*/
func (o *StreamPeerTCP) GetConnectedHost() string {
	log.Println("Calling StreamPeerTCP.GetConnectedHost()")

	returnValue := godotCallString(o, "get_connected_host")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the port of this peer.
*/
func (o *StreamPeerTCP) GetConnectedPort() int64 {
	log.Println("Calling StreamPeerTCP.GetConnectedPort()")

	returnValue := godotCallInt(o, "get_connected_port")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the status of the connection, one of STATUS_* enum.
*/
func (o *StreamPeerTCP) GetStatus() int64 {
	log.Println("Calling StreamPeerTCP.GetStatus()")

	returnValue := godotCallInt(o, "get_status")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *StreamPeerTCP) IsConnectedToHost() bool {
	log.Println("Calling StreamPeerTCP.IsConnectedToHost()")

	returnValue := godotCallBool(o, "is_connected_to_host")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   StreamPeerTCPImplementer is an interface for StreamPeerTCP objects.
*/
type StreamPeerTCPImplementer interface {
	Class
}

/*
   A texture that is loaded from a .stex file.
*/
type StreamTexture struct {
	Texture
}

func (o *StreamTexture) baseClass() string {
	return "StreamTexture"
}

/*
   Undocumented
*/
func (o *StreamTexture) GetLoadPath() string {
	log.Println("Calling StreamTexture.GetLoadPath()")

	returnValue := godotCallString(o, "get_load_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StreamTexture) Load(path string) int64 {
	log.Println("Calling StreamTexture.Load()")

	returnValue := godotCallIntString(o, "load", path)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   StreamTextureImplementer is an interface for StreamTexture objects.
*/
type StreamTextureImplementer interface {
	Class
}

/*
   StyleBox is [Resource] that provides an abstract base class for drawing stylized boxes for the UI. StyleBoxes are used for drawing the styles of buttons, line edit backgrounds, tree backgrounds, etc. and also for testing a transparency mask for pointer signals. If mask test fails on a StyleBox assigned as mask to a control, clicks and motion signals will go through it to the one below.
*/
type StyleBox struct {
	Resource
}

func (o *StyleBox) baseClass() string {
	return "StyleBox"
}

/*

 */
func (o *StyleBox) Draw(canvasItem *RID, rect *Rect2) {
	log.Println("Calling StyleBox.Draw()")

	godotCallVoidRidRect2(o, "draw", canvasItem, rect)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *StyleBox) GetCenterSize() *Vector2 {
	log.Println("Calling StyleBox.GetCenterSize()")

	returnValue := godotCallVector2(o, "get_center_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBox) GetDefaultMargin(margin int64) float64 {
	log.Println("Calling StyleBox.GetDefaultMargin()")

	returnValue := godotCallFloatInt(o, "get_default_margin", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the offset of margin "margin" (see MARGIN_* enum).
*/
func (o *StyleBox) GetMargin(margin int64) float64 {
	log.Println("Calling StyleBox.GetMargin()")

	returnValue := godotCallFloatInt(o, "get_margin", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the minimum size that this stylebox can be shrunk to.
*/
func (o *StyleBox) GetMinimumSize() *Vector2 {
	log.Println("Calling StyleBox.GetMinimumSize()")

	returnValue := godotCallVector2(o, "get_minimum_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the "offset" of a stylebox, this is a helper function, like writing [code]Vector2(style.get_margin(MARGIN_LEFT), style.get_margin(MARGIN_TOP))[/code].
*/
func (o *StyleBox) GetOffset() *Vector2 {
	log.Println("Calling StyleBox.GetOffset()")

	returnValue := godotCallVector2(o, "get_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBox) SetDefaultMargin(margin int64, offset float64) {
	log.Println("Calling StyleBox.SetDefaultMargin()")

	godotCallVoidIntFloat(o, "set_default_margin", margin, offset)
	log.Println("  Function successfully completed.")

}

/*
   Test a position in a rectangle, return whether it passes the mask test.
*/
func (o *StyleBox) TestMask(point *Vector2, rect *Rect2) bool {
	log.Println("Calling StyleBox.TestMask()")

	returnValue := godotCallBoolVector2Rect2(o, "test_mask", point, rect)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   StyleBoxImplementer is an interface for StyleBox objects.
*/
type StyleBoxImplementer interface {
	Class
}

/*
   Empty stylebox (really does not display anything).
*/
type StyleBoxEmpty struct {
	StyleBox
}

func (o *StyleBoxEmpty) baseClass() string {
	return "StyleBoxEmpty"
}

/*
   StyleBoxEmptyImplementer is an interface for StyleBoxEmpty objects.
*/
type StyleBoxEmptyImplementer interface {
	Class
}

/*
   This stylebox can be used to achieve all kinds of looks without the need of a texture. Those properties are customizable: - Color - Border width (individual width for each border) - Rounded corners (individual radius for each corner) - Shadow About corner radius: Setting corner radius to high values is allowed. As soon as corners would overlap the stylebox will switch to a relative system. Example: [codeblock] height = 30 corner_radius_top_left = 50 corner_radius_bottom_left = 100 [/codeblock] The relative system now would take the 1:2 ratio of the two left corners to calculate the actual corner width. Both corners added will [b]never[/b] be more than the height. Result: [codeblock] corner_radius_top_left: 10 corner_radius_bottom_left: 20 [/codeblock]
*/
type StyleBoxFlat struct {
	StyleBox
}

func (o *StyleBoxFlat) baseClass() string {
	return "StyleBoxFlat"
}

/*
   Undocumented
*/
func (o *StyleBoxFlat) GetAaSize() int64 {
	log.Println("Calling StyleBoxFlat.GetAaSize()")

	returnValue := godotCallInt(o, "get_aa_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) GetBgColor() *Color {
	log.Println("Calling StyleBoxFlat.GetBgColor()")

	returnValue := godotCallColor(o, "get_bg_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) GetBorderBlend() bool {
	log.Println("Calling StyleBoxFlat.GetBorderBlend()")

	returnValue := godotCallBool(o, "get_border_blend")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) GetBorderColor() *Color {
	log.Println("Calling StyleBoxFlat.GetBorderColor()")

	returnValue := godotCallColor(o, "get_border_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) GetBorderWidth(margin int64) int64 {
	log.Println("Calling StyleBoxFlat.GetBorderWidth()")

	returnValue := godotCallIntInt(o, "get_border_width", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) GetBorderWidthMin() int64 {
	log.Println("Calling StyleBoxFlat.GetBorderWidthMin()")

	returnValue := godotCallInt(o, "get_border_width_min")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) GetCornerDetail() int64 {
	log.Println("Calling StyleBoxFlat.GetCornerDetail()")

	returnValue := godotCallInt(o, "get_corner_detail")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) GetCornerRadius(corner int64) int64 {
	log.Println("Calling StyleBoxFlat.GetCornerRadius()")

	returnValue := godotCallIntInt(o, "get_corner_radius", corner)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) GetExpandMargin(margin int64) float64 {
	log.Println("Calling StyleBoxFlat.GetExpandMargin()")

	returnValue := godotCallFloatInt(o, "get_expand_margin", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) GetShadowColor() *Color {
	log.Println("Calling StyleBoxFlat.GetShadowColor()")

	returnValue := godotCallColor(o, "get_shadow_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) GetShadowSize() int64 {
	log.Println("Calling StyleBoxFlat.GetShadowSize()")

	returnValue := godotCallInt(o, "get_shadow_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) IsAntiAliased() bool {
	log.Println("Calling StyleBoxFlat.IsAntiAliased()")

	returnValue := godotCallBool(o, "is_anti_aliased")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) IsDrawCenterEnabled() bool {
	log.Println("Calling StyleBoxFlat.IsDrawCenterEnabled()")

	returnValue := godotCallBool(o, "is_draw_center_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetAaSize(size int64) {
	log.Println("Calling StyleBoxFlat.SetAaSize()")

	godotCallVoidInt(o, "set_aa_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetAntiAliased(antiAliased bool) {
	log.Println("Calling StyleBoxFlat.SetAntiAliased()")

	godotCallVoidBool(o, "set_anti_aliased", antiAliased)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetBgColor(color *Color) {
	log.Println("Calling StyleBoxFlat.SetBgColor()")

	godotCallVoidColor(o, "set_bg_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetBorderBlend(blend bool) {
	log.Println("Calling StyleBoxFlat.SetBorderBlend()")

	godotCallVoidBool(o, "set_border_blend", blend)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetBorderColor(color *Color) {
	log.Println("Calling StyleBoxFlat.SetBorderColor()")

	godotCallVoidColor(o, "set_border_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetBorderWidth(margin int64, width int64) {
	log.Println("Calling StyleBoxFlat.SetBorderWidth()")

	godotCallVoidIntInt(o, "set_border_width", margin, width)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *StyleBoxFlat) SetBorderWidthAll(width int64) {
	log.Println("Calling StyleBoxFlat.SetBorderWidthAll()")

	godotCallVoidInt(o, "set_border_width_all", width)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetCornerDetail(detail int64) {
	log.Println("Calling StyleBoxFlat.SetCornerDetail()")

	godotCallVoidInt(o, "set_corner_detail", detail)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetCornerRadius(corner int64, radius int64) {
	log.Println("Calling StyleBoxFlat.SetCornerRadius()")

	godotCallVoidIntInt(o, "set_corner_radius", corner, radius)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *StyleBoxFlat) SetCornerRadiusAll(radius int64) {
	log.Println("Calling StyleBoxFlat.SetCornerRadiusAll()")

	godotCallVoidInt(o, "set_corner_radius_all", radius)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *StyleBoxFlat) SetCornerRadiusIndividual(radiusTopLeft int64, radiusTopRight int64, radiusBottomRight int64, radiusBottomLeft int64) {
	log.Println("Calling StyleBoxFlat.SetCornerRadiusIndividual()")

	godotCallVoidIntIntIntInt(o, "set_corner_radius_individual", radiusTopLeft, radiusTopRight, radiusBottomRight, radiusBottomLeft)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetDrawCenter(drawCenter bool) {
	log.Println("Calling StyleBoxFlat.SetDrawCenter()")

	godotCallVoidBool(o, "set_draw_center", drawCenter)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetExpandMargin(margin int64, size float64) {
	log.Println("Calling StyleBoxFlat.SetExpandMargin()")

	godotCallVoidIntFloat(o, "set_expand_margin", margin, size)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *StyleBoxFlat) SetExpandMarginAll(size float64) {
	log.Println("Calling StyleBoxFlat.SetExpandMarginAll()")

	godotCallVoidFloat(o, "set_expand_margin_all", size)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *StyleBoxFlat) SetExpandMarginIndividual(sizeLeft float64, sizeTop float64, sizeRight float64, sizeBottom float64) {
	log.Println("Calling StyleBoxFlat.SetExpandMarginIndividual()")

	godotCallVoidFloatFloatFloatFloat(o, "set_expand_margin_individual", sizeLeft, sizeTop, sizeRight, sizeBottom)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetShadowColor(color *Color) {
	log.Println("Calling StyleBoxFlat.SetShadowColor()")

	godotCallVoidColor(o, "set_shadow_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxFlat) SetShadowSize(size int64) {
	log.Println("Calling StyleBoxFlat.SetShadowSize()")

	godotCallVoidInt(o, "set_shadow_size", size)
	log.Println("  Function successfully completed.")

}

/*
   StyleBoxFlatImplementer is an interface for StyleBoxFlat objects.
*/
type StyleBoxFlatImplementer interface {
	Class
}

/*

 */
type StyleBoxLine struct {
	StyleBox
}

func (o *StyleBoxLine) baseClass() string {
	return "StyleBoxLine"
}

/*
   Undocumented
*/
func (o *StyleBoxLine) GetColor() *Color {
	log.Println("Calling StyleBoxLine.GetColor()")

	returnValue := godotCallColor(o, "get_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxLine) GetGrow() float64 {
	log.Println("Calling StyleBoxLine.GetGrow()")

	returnValue := godotCallFloat(o, "get_grow")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxLine) GetThickness() int64 {
	log.Println("Calling StyleBoxLine.GetThickness()")

	returnValue := godotCallInt(o, "get_thickness")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxLine) IsVertical() bool {
	log.Println("Calling StyleBoxLine.IsVertical()")

	returnValue := godotCallBool(o, "is_vertical")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxLine) SetColor(color *Color) {
	log.Println("Calling StyleBoxLine.SetColor()")

	godotCallVoidColor(o, "set_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxLine) SetGrow(grow float64) {
	log.Println("Calling StyleBoxLine.SetGrow()")

	godotCallVoidFloat(o, "set_grow", grow)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxLine) SetThickness(thickness int64) {
	log.Println("Calling StyleBoxLine.SetThickness()")

	godotCallVoidInt(o, "set_thickness", thickness)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxLine) SetVertical(vertical bool) {
	log.Println("Calling StyleBoxLine.SetVertical()")

	godotCallVoidBool(o, "set_vertical", vertical)
	log.Println("  Function successfully completed.")

}

/*
   StyleBoxLineImplementer is an interface for StyleBoxLine objects.
*/
type StyleBoxLineImplementer interface {
	Class
}

/*
   Texture Based 3x3 scale style. This stylebox performs a 3x3 scaling of a texture, where only the center cell is fully stretched. This allows for the easy creation of bordered styles.
*/
type StyleBoxTexture struct {
	StyleBox
}

func (o *StyleBoxTexture) baseClass() string {
	return "StyleBoxTexture"
}

/*
   Undocumented
*/
func (o *StyleBoxTexture) GetExpandMarginSize(margin int64) float64 {
	log.Println("Calling StyleBoxTexture.GetExpandMarginSize()")

	returnValue := godotCallFloatInt(o, "get_expand_margin_size", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) GetHAxisStretchMode() int64 {
	log.Println("Calling StyleBoxTexture.GetHAxisStretchMode()")

	returnValue := godotCallInt(o, "get_h_axis_stretch_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) GetMarginSize(margin int64) float64 {
	log.Println("Calling StyleBoxTexture.GetMarginSize()")

	returnValue := godotCallFloatInt(o, "get_margin_size", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) GetModulate() *Color {
	log.Println("Calling StyleBoxTexture.GetModulate()")

	returnValue := godotCallColor(o, "get_modulate")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) GetNormalMap() *Resource {
	log.Println("Calling StyleBoxTexture.GetNormalMap()")

	returnValue := godotCallObject(o, "get_normal_map")
	log.Println("  Got return value: ", returnValue)

	var ret Resource
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) GetRegionRect() *Rect2 {
	log.Println("Calling StyleBoxTexture.GetRegionRect()")

	returnValue := godotCallRect2(o, "get_region_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) GetTexture() *Resource {
	log.Println("Calling StyleBoxTexture.GetTexture()")

	returnValue := godotCallObject(o, "get_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Resource
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) GetVAxisStretchMode() int64 {
	log.Println("Calling StyleBoxTexture.GetVAxisStretchMode()")

	returnValue := godotCallInt(o, "get_v_axis_stretch_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) IsDrawCenterEnabled() bool {
	log.Println("Calling StyleBoxTexture.IsDrawCenterEnabled()")

	returnValue := godotCallBool(o, "is_draw_center_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) SetDrawCenter(enable bool) {
	log.Println("Calling StyleBoxTexture.SetDrawCenter()")

	godotCallVoidBool(o, "set_draw_center", enable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *StyleBoxTexture) SetExpandMarginAll(size float64) {
	log.Println("Calling StyleBoxTexture.SetExpandMarginAll()")

	godotCallVoidFloat(o, "set_expand_margin_all", size)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *StyleBoxTexture) SetExpandMarginIndividual(sizeLeft float64, sizeTop float64, sizeRight float64, sizeBottom float64) {
	log.Println("Calling StyleBoxTexture.SetExpandMarginIndividual()")

	godotCallVoidFloatFloatFloatFloat(o, "set_expand_margin_individual", sizeLeft, sizeTop, sizeRight, sizeBottom)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) SetExpandMarginSize(margin int64, size float64) {
	log.Println("Calling StyleBoxTexture.SetExpandMarginSize()")

	godotCallVoidIntFloat(o, "set_expand_margin_size", margin, size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) SetHAxisStretchMode(mode int64) {
	log.Println("Calling StyleBoxTexture.SetHAxisStretchMode()")

	godotCallVoidInt(o, "set_h_axis_stretch_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) SetMarginSize(margin int64, size float64) {
	log.Println("Calling StyleBoxTexture.SetMarginSize()")

	godotCallVoidIntFloat(o, "set_margin_size", margin, size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) SetModulate(color *Color) {
	log.Println("Calling StyleBoxTexture.SetModulate()")

	godotCallVoidColor(o, "set_modulate", color)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) SetNormalMap(normalMap *Resource) {
	log.Println("Calling StyleBoxTexture.SetNormalMap()")

	godotCallVoidObject(o, "set_normal_map", &normalMap.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) SetRegionRect(region *Rect2) {
	log.Println("Calling StyleBoxTexture.SetRegionRect()")

	godotCallVoidRect2(o, "set_region_rect", region)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) SetTexture(texture *Resource) {
	log.Println("Calling StyleBoxTexture.SetTexture()")

	godotCallVoidObject(o, "set_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *StyleBoxTexture) SetVAxisStretchMode(mode int64) {
	log.Println("Calling StyleBoxTexture.SetVAxisStretchMode()")

	godotCallVoidInt(o, "set_v_axis_stretch_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   StyleBoxTextureImplementer is an interface for StyleBoxTexture objects.
*/
type StyleBoxTextureImplementer interface {
	Class
}

/*
   The [code]SurfaceTool[/code] is used to construct a [Mesh] by specifying vertex attributes individually. It can be used to construct a [Mesh] from script. All properties except index need to be added before a call to [method add_vertex]. For example adding vertex colors and UVs looks like [codeblock] var st = SurfaceTool.new() st.begin(Mesh.PRIMITIVE_TRIANGLES) st.add_color(Color(1, 0, 0)) st.add_uv(Vector2(0, 0)) st.add_vertex(Vector3(0, 0, 0)) [/codeblock] The [code]SurfaceTool[/code] now contains one vertex of a triangle which has a UV coordinate and a specified [Color]. If another vertex were added without calls to [method add_uv] or [method add_color] then the last values would be used. It is very important that vertex attributes are passed [b]before[/b] the call to [method add_vertex], failure to do this will result in an error when committing the vertex information to a mesh.
*/
type SurfaceTool struct {
	Reference
}

func (o *SurfaceTool) baseClass() string {
	return "SurfaceTool"
}

/*
   Add an array of bones for the next Vertex to use.
*/
func (o *SurfaceTool) AddBones(bones *PoolIntArray) {
	log.Println("Calling SurfaceTool.AddBones()")

	godotCallVoidPoolIntArray(o, "add_bones", bones)
	log.Println("  Function successfully completed.")

}

/*
   Specify a [Color] for the next Vertex to use.
*/
func (o *SurfaceTool) AddColor(color *Color) {
	log.Println("Calling SurfaceTool.AddColor()")

	godotCallVoidColor(o, "add_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Adds an index to index array if you are using indexed Vertices. Does not need to be called before adding Vertex.
*/
func (o *SurfaceTool) AddIndex(index int64) {
	log.Println("Calling SurfaceTool.AddIndex()")

	godotCallVoidInt(o, "add_index", index)
	log.Println("  Function successfully completed.")

}

/*
   Specify a normal for the next Vertex to use.
*/
func (o *SurfaceTool) AddNormal(normal *Vector3) {
	log.Println("Calling SurfaceTool.AddNormal()")

	godotCallVoidVector3(o, "add_normal", normal)
	log.Println("  Function successfully completed.")

}

/*
   Specify whether current Vertex (if using only Vertex arrays) or current index (if also using index arrays) should utilize smooth normals for normal calculation.
*/
func (o *SurfaceTool) AddSmoothGroup(smooth bool) {
	log.Println("Calling SurfaceTool.AddSmoothGroup()")

	godotCallVoidBool(o, "add_smooth_group", smooth)
	log.Println("  Function successfully completed.")

}

/*
   Specify a Tangent for the next Vertex to use.
*/
func (o *SurfaceTool) AddTangent(tangent *Plane) {
	log.Println("Calling SurfaceTool.AddTangent()")

	godotCallVoidPlane(o, "add_tangent", tangent)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SurfaceTool) AddToFormat(flags int64) {
	log.Println("Calling SurfaceTool.AddToFormat()")

	godotCallVoidInt(o, "add_to_format", flags)
	log.Println("  Function successfully completed.")

}

/*
   Insert a triangle fan made of array data into [Mesh] being constructed.
*/
func (o *SurfaceTool) AddTriangleFan(vertexes *PoolVector3Array, uvs *PoolVector2Array, colors *PoolColorArray, uv2S *PoolVector2Array, normals *PoolVector3Array, tangents *Array) {
	log.Println("Calling SurfaceTool.AddTriangleFan()")

	godotCallVoidPoolVector3ArrayPoolVector2ArrayPoolColorArrayPoolVector2ArrayPoolVector3ArrayArray(o, "add_triangle_fan", vertexes, uvs, colors, uv2S, normals, tangents)
	log.Println("  Function successfully completed.")

}

/*
   Specify UV Coordinate for next Vertex to use.
*/
func (o *SurfaceTool) AddUv(uv *Vector2) {
	log.Println("Calling SurfaceTool.AddUv()")

	godotCallVoidVector2(o, "add_uv", uv)
	log.Println("  Function successfully completed.")

}

/*
   Specify an optional second set of UV coordinates for next Vertex to use.
*/
func (o *SurfaceTool) AddUv2(uv2 *Vector2) {
	log.Println("Calling SurfaceTool.AddUv2()")

	godotCallVoidVector2(o, "add_uv2", uv2)
	log.Println("  Function successfully completed.")

}

/*
   Specify position of current Vertex. Should be called after specifying other vertex properties (e.g. Color, UV).
*/
func (o *SurfaceTool) AddVertex(vertex *Vector3) {
	log.Println("Calling SurfaceTool.AddVertex()")

	godotCallVoidVector3(o, "add_vertex", vertex)
	log.Println("  Function successfully completed.")

}

/*
   Specify weight value for next Vertex to use.
*/
func (o *SurfaceTool) AddWeights(weights *PoolRealArray) {
	log.Println("Calling SurfaceTool.AddWeights()")

	godotCallVoidPoolRealArray(o, "add_weights", weights)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SurfaceTool) AppendFrom(existing *Mesh, surface int64, transform *Transform) {
	log.Println("Calling SurfaceTool.AppendFrom()")

	godotCallVoidObjectIntTransform(o, "append_from", &existing.Object, surface, transform)
	log.Println("  Function successfully completed.")

}

/*
   Called before adding any Vertices. Takes the primitive type as an argument (e.g. Mesh.PRIMITIVE_TRIANGLES).
*/
func (o *SurfaceTool) Begin(primitive int64) {
	log.Println("Calling SurfaceTool.Begin()")

	godotCallVoidInt(o, "begin", primitive)
	log.Println("  Function successfully completed.")

}

/*
   Clear all information passed into the surface tool so far.
*/
func (o *SurfaceTool) Clear() {
	log.Println("Calling SurfaceTool.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Returns a constructed [ArrayMesh] from current information passed in. If an existing [ArrayMesh] is passed in as an argument, will add an extra surface to the existing [ArrayMesh].
*/
func (o *SurfaceTool) Commit(existing *ArrayMesh, flags int64) *ArrayMesh {
	log.Println("Calling SurfaceTool.Commit()")

	returnValue := godotCallObjectObjectInt(o, "commit", &existing.Object, flags)
	log.Println("  Got return value: ", returnValue)

	var ret ArrayMesh
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *SurfaceTool) CreateFrom(existing *Mesh, surface int64) {
	log.Println("Calling SurfaceTool.CreateFrom()")

	godotCallVoidObjectInt(o, "create_from", &existing.Object, surface)
	log.Println("  Function successfully completed.")

}

/*
   Removes index array by expanding Vertex array.
*/
func (o *SurfaceTool) Deindex() {
	log.Println("Calling SurfaceTool.Deindex()")

	godotCallVoid(o, "deindex")
	log.Println("  Function successfully completed.")

}

/*
   Generates normals from Vertices so you do not have to do it manually.
*/
func (o *SurfaceTool) GenerateNormals() {
	log.Println("Calling SurfaceTool.GenerateNormals()")

	godotCallVoid(o, "generate_normals")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *SurfaceTool) GenerateTangents() {
	log.Println("Calling SurfaceTool.GenerateTangents()")

	godotCallVoid(o, "generate_tangents")
	log.Println("  Function successfully completed.")

}

/*
   Shrinks Vertex array by creating an index array. Avoids reusing Vertices.
*/
func (o *SurfaceTool) Index() {
	log.Println("Calling SurfaceTool.Index()")

	godotCallVoid(o, "index")
	log.Println("  Function successfully completed.")

}

/*
   Sets [Material] to be used by the [Mesh] you are constructing.
*/
func (o *SurfaceTool) SetMaterial(material *Material) {
	log.Println("Calling SurfaceTool.SetMaterial()")

	godotCallVoidObject(o, "set_material", &material.Object)
	log.Println("  Function successfully completed.")

}

/*
   SurfaceToolImplementer is an interface for SurfaceTool objects.
*/
type SurfaceToolImplementer interface {
	Class
}

/*
   TCP Server class. Listens to connections on a port and returns a [StreamPeerTCP] when got a connection.
*/
type TCP_Server struct {
	Reference
}

func (o *TCP_Server) baseClass() string {
	return "TCP_Server"
}

/*
   Return true if a connection is available for taking.
*/
func (o *TCP_Server) IsConnectionAvailable() bool {
	log.Println("Calling TCP_Server.IsConnectionAvailable()")

	returnValue := godotCallBool(o, "is_connection_available")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Listen on the "port" binding to "bind_address". If "bind_address" is set as "*" (default), the server will listen on all available addresses (both IPv4 and IPv6). If "bind_address" is set as "0.0.0.0" (for IPv4) or "::" (for IPv6), the server will listen on all available addresses matching that IP type. If "bind_address" is set to any valid address (e.g. "192.168.1.101", "::1", etc), the server will only listen on the interface with that addresses (or fail if no interface with the given address exists).
*/
func (o *TCP_Server) Listen(port int64, bindAddress string) int64 {
	log.Println("Calling TCP_Server.Listen()")

	returnValue := godotCallIntIntString(o, "listen", port, bindAddress)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Stop listening.
*/
func (o *TCP_Server) Stop() {
	log.Println("Calling TCP_Server.Stop()")

	godotCallVoid(o, "stop")
	log.Println("  Function successfully completed.")

}

/*
   If a connection is available, return a StreamPeerTCP with the connection/
*/
func (o *TCP_Server) TakeConnection() *StreamPeerTCP {
	log.Println("Calling TCP_Server.TakeConnection()")

	returnValue := godotCallObject(o, "take_connection")
	log.Println("  Got return value: ", returnValue)

	var ret StreamPeerTCP
	ret.owner = returnValue.owner
	return &ret

}

/*
   TCP_ServerImplementer is an interface for TCP_Server objects.
*/
type TCP_ServerImplementer interface {
	Class
}

/*
   Sets the active tab's [code]visible[/code] property to the value [code]true[/code]. Sets all other children's to [code]false[/code]. Ignores non-[Control] children. Individual tabs are always visible unless you use [method set_tab_disabled] and [method set_tab_title] to hide it. To hide only a tab's content, nest the content inside a child [Control], so it receives the [code]TabContainer[/code]'s visibility setting instead.
*/
type TabContainer struct {
	Control
}

func (o *TabContainer) baseClass() string {
	return "TabContainer"
}

/*
   Undocumented
*/
func (o *TabContainer) X_ChildRenamedCallback() {
	log.Println("Calling TabContainer.X_ChildRenamedCallback()")

	godotCallVoid(o, "_child_renamed_callback")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TabContainer) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling TabContainer.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TabContainer) X_OnThemeChanged() {
	log.Println("Calling TabContainer.X_OnThemeChanged()")

	godotCallVoid(o, "_on_theme_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TabContainer) AreTabsVisible() bool {
	log.Println("Calling TabContainer.AreTabsVisible()")

	returnValue := godotCallBool(o, "are_tabs_visible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TabContainer) GetCurrentTab() int64 {
	log.Println("Calling TabContainer.GetCurrentTab()")

	returnValue := godotCallInt(o, "get_current_tab")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the child [Control] node located at the active tab index.
*/
func (o *TabContainer) GetCurrentTabControl() *Control {
	log.Println("Calling TabContainer.GetCurrentTabControl()")

	returnValue := godotCallObject(o, "get_current_tab_control")
	log.Println("  Got return value: ", returnValue)

	var ret Control
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the [Popup] node instance if one has been set already with [method set_popup].
*/
func (o *TabContainer) GetPopup() *Popup {
	log.Println("Calling TabContainer.GetPopup()")

	returnValue := godotCallObject(o, "get_popup")
	log.Println("  Got return value: ", returnValue)

	var ret Popup
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the previously active tab index.
*/
func (o *TabContainer) GetPreviousTab() int64 {
	log.Println("Calling TabContainer.GetPreviousTab()")

	returnValue := godotCallInt(o, "get_previous_tab")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TabContainer) GetTabAlign() int64 {
	log.Println("Calling TabContainer.GetTabAlign()")

	returnValue := godotCallInt(o, "get_tab_align")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the currently visible tab's [Control] node.
*/
func (o *TabContainer) GetTabControl(idx int64) *Control {
	log.Println("Calling TabContainer.GetTabControl()")

	returnValue := godotCallObjectInt(o, "get_tab_control", idx)
	log.Println("  Got return value: ", returnValue)

	var ret Control
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of tabs.
*/
func (o *TabContainer) GetTabCount() int64 {
	log.Println("Calling TabContainer.GetTabCount()")

	returnValue := godotCallInt(o, "get_tab_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the tab at index [code]tab_idx[/code] is disabled.
*/
func (o *TabContainer) GetTabDisabled(tabIdx int64) bool {
	log.Println("Calling TabContainer.GetTabDisabled()")

	returnValue := godotCallBoolInt(o, "get_tab_disabled", tabIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [Texture] for the tab at index [code]tab_idx[/code] or null if the tab has no [Texture].
*/
func (o *TabContainer) GetTabIcon(tabIdx int64) *Texture {
	log.Println("Calling TabContainer.GetTabIcon()")

	returnValue := godotCallObjectInt(o, "get_tab_icon", tabIdx)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the title of the tab at index [code]tab_idx[/code]. Tab titles default to the name of the indexed child node, but this can be overridden with [method set_tab_title].
*/
func (o *TabContainer) GetTabTitle(tabIdx int64) string {
	log.Println("Calling TabContainer.GetTabTitle()")

	returnValue := godotCallStringInt(o, "get_tab_title", tabIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TabContainer) SetCurrentTab(tabIdx int64) {
	log.Println("Calling TabContainer.SetCurrentTab()")

	godotCallVoidInt(o, "set_current_tab", tabIdx)
	log.Println("  Function successfully completed.")

}

/*
   If set on a [Popup] node instance, a popup menu icon appears in the top-right corner of the [code]TabContainer[/code]. Clicking it will expand the [Popup] node.
*/
func (o *TabContainer) SetPopup(popup *Object) {
	log.Println("Calling TabContainer.SetPopup()")

	godotCallVoidObject(o, "set_popup", popup)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TabContainer) SetTabAlign(align int64) {
	log.Println("Calling TabContainer.SetTabAlign()")

	godotCallVoidInt(o, "set_tab_align", align)
	log.Println("  Function successfully completed.")

}

/*
   If [code]disabled[/code] is false, hides the tab at index [code]tab_idx[/code]. Note that its title text will remain, unless also removed with [method set_tab_title].
*/
func (o *TabContainer) SetTabDisabled(tabIdx int64, disabled bool) {
	log.Println("Calling TabContainer.SetTabDisabled()")

	godotCallVoidIntBool(o, "set_tab_disabled", tabIdx, disabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets an icon for the tab at index [code]tab_idx[/code].
*/
func (o *TabContainer) SetTabIcon(tabIdx int64, icon *Texture) {
	log.Println("Calling TabContainer.SetTabIcon()")

	godotCallVoidIntObject(o, "set_tab_icon", tabIdx, &icon.Object)
	log.Println("  Function successfully completed.")

}

/*
   Sets a title for the tab at index [code]tab_idx[/code]. Tab titles default to the name of the indexed child node, but this can be overridden with [method set_tab_title].
*/
func (o *TabContainer) SetTabTitle(tabIdx int64, title string) {
	log.Println("Calling TabContainer.SetTabTitle()")

	godotCallVoidIntString(o, "set_tab_title", tabIdx, title)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TabContainer) SetTabsVisible(visible bool) {
	log.Println("Calling TabContainer.SetTabsVisible()")

	godotCallVoidBool(o, "set_tabs_visible", visible)
	log.Println("  Function successfully completed.")

}

/*
   TabContainerImplementer is an interface for TabContainer objects.
*/
type TabContainerImplementer interface {
	Class
}

/*
   Simple tabs control, similar to [TabContainer] but is only in charge of drawing tabs, not interact with children.
*/
type Tabs struct {
	Control
}

func (o *Tabs) baseClass() string {
	return "Tabs"
}

/*
   Undocumented
*/
func (o *Tabs) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling Tabs.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Tabs) AddTab(title string, icon *Texture) {
	log.Println("Calling Tabs.AddTab()")

	godotCallVoidStringObject(o, "add_tab", title, &icon.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Tabs) EnsureTabVisible(idx int64) {
	log.Println("Calling Tabs.EnsureTabVisible()")

	godotCallVoidInt(o, "ensure_tab_visible", idx)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tabs) GetCurrentTab() int64 {
	log.Println("Calling Tabs.GetCurrentTab()")

	returnValue := godotCallInt(o, "get_current_tab")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Tabs) GetOffsetButtonsVisible() bool {
	log.Println("Calling Tabs.GetOffsetButtonsVisible()")

	returnValue := godotCallBool(o, "get_offset_buttons_visible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tabs) GetScrollingEnabled() bool {
	log.Println("Calling Tabs.GetScrollingEnabled()")

	returnValue := godotCallBool(o, "get_scrolling_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tabs) GetTabAlign() int64 {
	log.Println("Calling Tabs.GetTabAlign()")

	returnValue := godotCallInt(o, "get_tab_align")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tabs) GetTabCloseDisplayPolicy() int64 {
	log.Println("Calling Tabs.GetTabCloseDisplayPolicy()")

	returnValue := godotCallInt(o, "get_tab_close_display_policy")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Tabs) GetTabCount() int64 {
	log.Println("Calling Tabs.GetTabCount()")

	returnValue := godotCallInt(o, "get_tab_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Tabs) GetTabDisabled(tabIdx int64) bool {
	log.Println("Calling Tabs.GetTabDisabled()")

	returnValue := godotCallBoolInt(o, "get_tab_disabled", tabIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Tabs) GetTabIcon(tabIdx int64) *Texture {
	log.Println("Calling Tabs.GetTabIcon()")

	returnValue := godotCallObjectInt(o, "get_tab_icon", tabIdx)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *Tabs) GetTabOffset() int64 {
	log.Println("Calling Tabs.GetTabOffset()")

	returnValue := godotCallInt(o, "get_tab_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns tab [Rect2] with local position and size.
*/
func (o *Tabs) GetTabRect(tabIdx int64) *Rect2 {
	log.Println("Calling Tabs.GetTabRect()")

	returnValue := godotCallRect2Int(o, "get_tab_rect", tabIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Tabs) GetTabTitle(tabIdx int64) string {
	log.Println("Calling Tabs.GetTabTitle()")

	returnValue := godotCallStringInt(o, "get_tab_title", tabIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Rearrange tab.
*/
func (o *Tabs) MoveTab(from int64, to int64) {
	log.Println("Calling Tabs.MoveTab()")

	godotCallVoidIntInt(o, "move_tab", from, to)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Tabs) RemoveTab(tabIdx int64) {
	log.Println("Calling Tabs.RemoveTab()")

	godotCallVoidInt(o, "remove_tab", tabIdx)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tabs) SetCurrentTab(tabIdx int64) {
	log.Println("Calling Tabs.SetCurrentTab()")

	godotCallVoidInt(o, "set_current_tab", tabIdx)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tabs) SetScrollingEnabled(enabled bool) {
	log.Println("Calling Tabs.SetScrollingEnabled()")

	godotCallVoidBool(o, "set_scrolling_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tabs) SetTabAlign(align int64) {
	log.Println("Calling Tabs.SetTabAlign()")

	godotCallVoidInt(o, "set_tab_align", align)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tabs) SetTabCloseDisplayPolicy(policy int64) {
	log.Println("Calling Tabs.SetTabCloseDisplayPolicy()")

	godotCallVoidInt(o, "set_tab_close_display_policy", policy)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Tabs) SetTabDisabled(tabIdx int64, disabled bool) {
	log.Println("Calling Tabs.SetTabDisabled()")

	godotCallVoidIntBool(o, "set_tab_disabled", tabIdx, disabled)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Tabs) SetTabIcon(tabIdx int64, icon *Texture) {
	log.Println("Calling Tabs.SetTabIcon()")

	godotCallVoidIntObject(o, "set_tab_icon", tabIdx, &icon.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Tabs) SetTabTitle(tabIdx int64, title string) {
	log.Println("Calling Tabs.SetTabTitle()")

	godotCallVoidIntString(o, "set_tab_title", tabIdx, title)
	log.Println("  Function successfully completed.")

}

/*
   TabsImplementer is an interface for Tabs objects.
*/
type TabsImplementer interface {
	Class
}

/*
   TextEdit is meant for editing large, multiline text. It also has facilities for editing code, such as syntax highlighting support and multiple levels of undo/redo.
*/
type TextEdit struct {
	Control
}

func (o *TextEdit) baseClass() string {
	return "TextEdit"
}

/*
   Undocumented
*/
func (o *TextEdit) X_ClickSelectionHeld() {
	log.Println("Calling TextEdit.X_ClickSelectionHeld()")

	godotCallVoid(o, "_click_selection_held")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) X_CursorChangedEmit() {
	log.Println("Calling TextEdit.X_CursorChangedEmit()")

	godotCallVoid(o, "_cursor_changed_emit")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling TextEdit.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) X_PushCurrentOp() {
	log.Println("Calling TextEdit.X_PushCurrentOp()")

	godotCallVoid(o, "_push_current_op")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) X_ScrollMoved(arg0 float64) {
	log.Println("Calling TextEdit.X_ScrollMoved()")

	godotCallVoidFloat(o, "_scroll_moved", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) X_TextChangedEmit() {
	log.Println("Calling TextEdit.X_TextChangedEmit()")

	godotCallVoid(o, "_text_changed_emit")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) X_ToggleDrawCaret() {
	log.Println("Calling TextEdit.X_ToggleDrawCaret()")

	godotCallVoid(o, "_toggle_draw_caret")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) X_VScrollInput() {
	log.Println("Calling TextEdit.X_VScrollInput()")

	godotCallVoid(o, "_v_scroll_input")
	log.Println("  Function successfully completed.")

}

/*
   Add color region (given the delimiters) and its colors.
*/
func (o *TextEdit) AddColorRegion(beginKey string, endKey string, color *Color, lineOnly bool) {
	log.Println("Calling TextEdit.AddColorRegion()")

	godotCallVoidStringStringColorBool(o, "add_color_region", beginKey, endKey, color, lineOnly)
	log.Println("  Function successfully completed.")

}

/*
   Add a keyword and its color.
*/
func (o *TextEdit) AddKeywordColor(keyword string, color *Color) {
	log.Println("Calling TextEdit.AddKeywordColor()")

	godotCallVoidStringColor(o, "add_keyword_color", keyword, color)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TextEdit) CanFold(line int64) bool {
	log.Println("Calling TextEdit.CanFold()")

	returnValue := godotCallBoolInt(o, "can_fold", line)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Clear all the syntax coloring information.
*/
func (o *TextEdit) ClearColors() {
	log.Println("Calling TextEdit.ClearColors()")

	godotCallVoid(o, "clear_colors")
	log.Println("  Function successfully completed.")

}

/*
   Clear the undo history.
*/
func (o *TextEdit) ClearUndoHistory() {
	log.Println("Calling TextEdit.ClearUndoHistory()")

	godotCallVoid(o, "clear_undo_history")
	log.Println("  Function successfully completed.")

}

/*
   Copy the current selection.
*/
func (o *TextEdit) Copy() {
	log.Println("Calling TextEdit.Copy()")

	godotCallVoid(o, "copy")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) CursorGetBlinkEnabled() bool {
	log.Println("Calling TextEdit.CursorGetBlinkEnabled()")

	returnValue := godotCallBool(o, "cursor_get_blink_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) CursorGetBlinkSpeed() float64 {
	log.Println("Calling TextEdit.CursorGetBlinkSpeed()")

	returnValue := godotCallFloat(o, "cursor_get_blink_speed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the column the editing cursor is at.
*/
func (o *TextEdit) CursorGetColumn() int64 {
	log.Println("Calling TextEdit.CursorGetColumn()")

	returnValue := godotCallInt(o, "cursor_get_column")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the line the editing cursor is at.
*/
func (o *TextEdit) CursorGetLine() int64 {
	log.Println("Calling TextEdit.CursorGetLine()")

	returnValue := godotCallInt(o, "cursor_get_line")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) CursorIsBlockMode() bool {
	log.Println("Calling TextEdit.CursorIsBlockMode()")

	returnValue := godotCallBool(o, "cursor_is_block_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) CursorSetBlinkEnabled(enable bool) {
	log.Println("Calling TextEdit.CursorSetBlinkEnabled()")

	godotCallVoidBool(o, "cursor_set_blink_enabled", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) CursorSetBlinkSpeed(blinkSpeed float64) {
	log.Println("Calling TextEdit.CursorSetBlinkSpeed()")

	godotCallVoidFloat(o, "cursor_set_blink_speed", blinkSpeed)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) CursorSetBlockMode(enable bool) {
	log.Println("Calling TextEdit.CursorSetBlockMode()")

	godotCallVoidBool(o, "cursor_set_block_mode", enable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TextEdit) CursorSetColumn(column int64, adjustViewport bool) {
	log.Println("Calling TextEdit.CursorSetColumn()")

	godotCallVoidIntBool(o, "cursor_set_column", column, adjustViewport)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TextEdit) CursorSetLine(line int64, adjustViewport bool, canBeHidden bool) {
	log.Println("Calling TextEdit.CursorSetLine()")

	godotCallVoidIntBoolBool(o, "cursor_set_line", line, adjustViewport, canBeHidden)
	log.Println("  Function successfully completed.")

}

/*
   Cut the current selection.
*/
func (o *TextEdit) Cut() {
	log.Println("Calling TextEdit.Cut()")

	godotCallVoid(o, "cut")
	log.Println("  Function successfully completed.")

}

/*
   Clears the current selection.
*/
func (o *TextEdit) Deselect() {
	log.Println("Calling TextEdit.Deselect()")

	godotCallVoid(o, "deselect")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TextEdit) FoldAllLines() {
	log.Println("Calling TextEdit.FoldAllLines()")

	godotCallVoid(o, "fold_all_lines")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TextEdit) FoldLine(line int64) {
	log.Println("Calling TextEdit.FoldLine()")

	godotCallVoidInt(o, "fold_line", line)
	log.Println("  Function successfully completed.")

}

/*
   Return the text of a specific line.
*/
func (o *TextEdit) GetLine(line int64) string {
	log.Println("Calling TextEdit.GetLine()")

	returnValue := godotCallStringInt(o, "get_line", line)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the amount of total lines in the text.
*/
func (o *TextEdit) GetLineCount() int64 {
	log.Println("Calling TextEdit.GetLineCount()")

	returnValue := godotCallInt(o, "get_line_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TextEdit) GetMenu() *PopupMenu {
	log.Println("Calling TextEdit.GetMenu()")

	returnValue := godotCallObject(o, "get_menu")
	log.Println("  Got return value: ", returnValue)

	var ret PopupMenu
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the selection begin column.
*/
func (o *TextEdit) GetSelectionFromColumn() int64 {
	log.Println("Calling TextEdit.GetSelectionFromColumn()")

	returnValue := godotCallInt(o, "get_selection_from_column")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the selection begin line.
*/
func (o *TextEdit) GetSelectionFromLine() int64 {
	log.Println("Calling TextEdit.GetSelectionFromLine()")

	returnValue := godotCallInt(o, "get_selection_from_line")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the text inside the selection.
*/
func (o *TextEdit) GetSelectionText() string {
	log.Println("Calling TextEdit.GetSelectionText()")

	returnValue := godotCallString(o, "get_selection_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the selection end column.
*/
func (o *TextEdit) GetSelectionToColumn() int64 {
	log.Println("Calling TextEdit.GetSelectionToColumn()")

	returnValue := godotCallInt(o, "get_selection_to_column")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the selection end line.
*/
func (o *TextEdit) GetSelectionToLine() int64 {
	log.Println("Calling TextEdit.GetSelectionToLine()")

	returnValue := godotCallInt(o, "get_selection_to_line")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) GetText() string {
	log.Println("Calling TextEdit.GetText()")

	returnValue := godotCallString(o, "get_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) GetVScrollSpeed() float64 {
	log.Println("Calling TextEdit.GetVScrollSpeed()")

	returnValue := godotCallFloat(o, "get_v_scroll_speed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TextEdit) GetWordUnderCursor() string {
	log.Println("Calling TextEdit.GetWordUnderCursor()")

	returnValue := godotCallString(o, "get_word_under_cursor")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Insert a given text at the cursor position.
*/
func (o *TextEdit) InsertTextAtCursor(text string) {
	log.Println("Calling TextEdit.InsertTextAtCursor()")

	godotCallVoidString(o, "insert_text_at_cursor", text)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) IsContextMenuEnabled() bool {
	log.Println("Calling TextEdit.IsContextMenuEnabled()")

	returnValue := godotCallBool(o, "is_context_menu_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TextEdit) IsFolded(line int64) bool {
	log.Println("Calling TextEdit.IsFolded()")

	returnValue := godotCallBoolInt(o, "is_folded", line)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) IsHidingEnabled() int64 {
	log.Println("Calling TextEdit.IsHidingEnabled()")

	returnValue := godotCallInt(o, "is_hiding_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) IsHighlightAllOccurrencesEnabled() bool {
	log.Println("Calling TextEdit.IsHighlightAllOccurrencesEnabled()")

	returnValue := godotCallBool(o, "is_highlight_all_occurrences_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) IsHighlightCurrentLineEnabled() bool {
	log.Println("Calling TextEdit.IsHighlightCurrentLineEnabled()")

	returnValue := godotCallBool(o, "is_highlight_current_line_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TextEdit) IsLineHidden(line int64) bool {
	log.Println("Calling TextEdit.IsLineHidden()")

	returnValue := godotCallBoolInt(o, "is_line_hidden", line)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) IsOverridingSelectedFontColor() bool {
	log.Println("Calling TextEdit.IsOverridingSelectedFontColor()")

	returnValue := godotCallBool(o, "is_overriding_selected_font_color")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) IsReadonly() bool {
	log.Println("Calling TextEdit.IsReadonly()")

	returnValue := godotCallBool(o, "is_readonly")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) IsRightClickMovingCaret() bool {
	log.Println("Calling TextEdit.IsRightClickMovingCaret()")

	returnValue := godotCallBool(o, "is_right_click_moving_caret")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return true if the selection is active.
*/
func (o *TextEdit) IsSelectionActive() bool {
	log.Println("Calling TextEdit.IsSelectionActive()")

	returnValue := godotCallBool(o, "is_selection_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) IsShowLineNumbersEnabled() bool {
	log.Println("Calling TextEdit.IsShowLineNumbersEnabled()")

	returnValue := godotCallBool(o, "is_show_line_numbers_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) IsSmoothScrollEnabled() bool {
	log.Println("Calling TextEdit.IsSmoothScrollEnabled()")

	returnValue := godotCallBool(o, "is_smooth_scroll_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) IsSyntaxColoringEnabled() bool {
	log.Println("Calling TextEdit.IsSyntaxColoringEnabled()")

	returnValue := godotCallBool(o, "is_syntax_coloring_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextEdit) IsWrapping() bool {
	log.Println("Calling TextEdit.IsWrapping()")

	returnValue := godotCallBool(o, "is_wrapping")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TextEdit) MenuOption(option int64) {
	log.Println("Calling TextEdit.MenuOption()")

	godotCallVoidInt(o, "menu_option", option)
	log.Println("  Function successfully completed.")

}

/*
   Paste the current selection.
*/
func (o *TextEdit) Paste() {
	log.Println("Calling TextEdit.Paste()")

	godotCallVoid(o, "paste")
	log.Println("  Function successfully completed.")

}

/*
   Perform redo operation.
*/
func (o *TextEdit) Redo() {
	log.Println("Calling TextEdit.Redo()")

	godotCallVoid(o, "redo")
	log.Println("  Function successfully completed.")

}

/*
   Perform a search inside the text. Search flags can be specified in the SEARCH_* enum.
*/
func (o *TextEdit) Search(key string, flags int64, fromLine int64, fromColumn int64) *PoolIntArray {
	log.Println("Calling TextEdit.Search()")

	returnValue := godotCallPoolIntArrayStringIntIntInt(o, "search", key, flags, fromLine, fromColumn)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Perform selection, from line/column to line/column.
*/
func (o *TextEdit) Select(fromLine int64, fromColumn int64, toLine int64, toColumn int64) {
	log.Println("Calling TextEdit.Select()")

	godotCallVoidIntIntIntInt(o, "select", fromLine, fromColumn, toLine, toColumn)
	log.Println("  Function successfully completed.")

}

/*
   Select all the text.
*/
func (o *TextEdit) SelectAll() {
	log.Println("Calling TextEdit.SelectAll()")

	godotCallVoid(o, "select_all")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetContextMenuEnabled(enable bool) {
	log.Println("Calling TextEdit.SetContextMenuEnabled()")

	godotCallVoidBool(o, "set_context_menu_enabled", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetHidingEnabled(enable int64) {
	log.Println("Calling TextEdit.SetHidingEnabled()")

	godotCallVoidInt(o, "set_hiding_enabled", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetHighlightAllOccurrences(enable bool) {
	log.Println("Calling TextEdit.SetHighlightAllOccurrences()")

	godotCallVoidBool(o, "set_highlight_all_occurrences", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetHighlightCurrentLine(enabled bool) {
	log.Println("Calling TextEdit.SetHighlightCurrentLine()")

	godotCallVoidBool(o, "set_highlight_current_line", enabled)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TextEdit) SetLineAsHidden(line int64, enable bool) {
	log.Println("Calling TextEdit.SetLineAsHidden()")

	godotCallVoidIntBool(o, "set_line_as_hidden", line, enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetOverrideSelectedFontColor(override bool) {
	log.Println("Calling TextEdit.SetOverrideSelectedFontColor()")

	godotCallVoidBool(o, "set_override_selected_font_color", override)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetReadonly(enable bool) {
	log.Println("Calling TextEdit.SetReadonly()")

	godotCallVoidBool(o, "set_readonly", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetRightClickMovesCaret(enable bool) {
	log.Println("Calling TextEdit.SetRightClickMovesCaret()")

	godotCallVoidBool(o, "set_right_click_moves_caret", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetShowLineNumbers(enable bool) {
	log.Println("Calling TextEdit.SetShowLineNumbers()")

	godotCallVoidBool(o, "set_show_line_numbers", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetSmoothScrollEnable(enable bool) {
	log.Println("Calling TextEdit.SetSmoothScrollEnable()")

	godotCallVoidBool(o, "set_smooth_scroll_enable", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetSyntaxColoring(enable bool) {
	log.Println("Calling TextEdit.SetSyntaxColoring()")

	godotCallVoidBool(o, "set_syntax_coloring", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetText(text string) {
	log.Println("Calling TextEdit.SetText()")

	godotCallVoidString(o, "set_text", text)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetVScrollSpeed(speed float64) {
	log.Println("Calling TextEdit.SetVScrollSpeed()")

	godotCallVoidFloat(o, "set_v_scroll_speed", speed)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextEdit) SetWrap(enable bool) {
	log.Println("Calling TextEdit.SetWrap()")

	godotCallVoidBool(o, "set_wrap", enable)
	log.Println("  Function successfully completed.")

}

/*
   Toggle the folding of the code block at the given line.
*/
func (o *TextEdit) ToggleFoldLine(line int64) {
	log.Println("Calling TextEdit.ToggleFoldLine()")

	godotCallVoidInt(o, "toggle_fold_line", line)
	log.Println("  Function successfully completed.")

}

/*
   Perform undo operation.
*/
func (o *TextEdit) Undo() {
	log.Println("Calling TextEdit.Undo()")

	godotCallVoid(o, "undo")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TextEdit) UnfoldLine(line int64) {
	log.Println("Calling TextEdit.UnfoldLine()")

	godotCallVoidInt(o, "unfold_line", line)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TextEdit) UnhideAllLines() {
	log.Println("Calling TextEdit.UnhideAllLines()")

	godotCallVoid(o, "unhide_all_lines")
	log.Println("  Function successfully completed.")

}

/*
   TextEditImplementer is an interface for TextEdit objects.
*/
type TextEditImplementer interface {
	Class
}

/*
   A texture works by registering an image in the video hardware, which then can be used in 3D models or 2D [Sprite] or GUI [Control].
*/
type Texture struct {
	Resource
}

func (o *Texture) baseClass() string {
	return "Texture"
}

/*

 */
func (o *Texture) Draw(canvasItem *RID, position *Vector2, modulate *Color, transpose bool, normalMap *Texture) {
	log.Println("Calling Texture.Draw()")

	godotCallVoidRidVector2ColorBoolObject(o, "draw", canvasItem, position, modulate, transpose, &normalMap.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Texture) DrawRect(canvasItem *RID, rect *Rect2, tile bool, modulate *Color, transpose bool, normalMap *Texture) {
	log.Println("Calling Texture.DrawRect()")

	godotCallVoidRidRect2BoolColorBoolObject(o, "draw_rect", canvasItem, rect, tile, modulate, transpose, &normalMap.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Texture) DrawRectRegion(canvasItem *RID, rect *Rect2, srcRect *Rect2, modulate *Color, transpose bool, normalMap *Texture, clipUv bool) {
	log.Println("Calling Texture.DrawRectRegion()")

	godotCallVoidRidRect2Rect2ColorBoolObjectBool(o, "draw_rect_region", canvasItem, rect, srcRect, modulate, transpose, &normalMap.Object, clipUv)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Texture) GetData() *Image {
	log.Println("Calling Texture.GetData()")

	returnValue := godotCallObject(o, "get_data")
	log.Println("  Got return value: ", returnValue)

	var ret Image
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Texture) GetFlags() int64 {
	log.Println("Calling Texture.GetFlags()")

	returnValue := godotCallInt(o, "get_flags")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the texture height.
*/
func (o *Texture) GetHeight() int64 {
	log.Println("Calling Texture.GetHeight()")

	returnValue := godotCallInt(o, "get_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the texture size.
*/
func (o *Texture) GetSize() *Vector2 {
	log.Println("Calling Texture.GetSize()")

	returnValue := godotCallVector2(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the texture width.
*/
func (o *Texture) GetWidth() int64 {
	log.Println("Calling Texture.GetWidth()")

	returnValue := godotCallInt(o, "get_width")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Texture) HasAlpha() bool {
	log.Println("Calling Texture.HasAlpha()")

	returnValue := godotCallBool(o, "has_alpha")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Texture) SetFlags(flags int64) {
	log.Println("Calling Texture.SetFlags()")

	godotCallVoidInt(o, "set_flags", flags)
	log.Println("  Function successfully completed.")

}

/*
   TextureImplementer is an interface for Texture objects.
*/
type TextureImplementer interface {
	Class
}

/*
   [code]TextureButton[/code] has the same functionality as [Button], except it uses sprites instead of Godot's [Theme] resource. It is faster to create, but it doesn't support localization like more complex Controls. The Normal state's texture is required. Others are optional.
*/
type TextureButton struct {
	BaseButton
}

func (o *TextureButton) baseClass() string {
	return "TextureButton"
}

/*
   Undocumented
*/
func (o *TextureButton) GetClickMask() *BitMap {
	log.Println("Calling TextureButton.GetClickMask()")

	returnValue := godotCallObject(o, "get_click_mask")
	log.Println("  Got return value: ", returnValue)

	var ret BitMap
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TextureButton) GetDisabledTexture() *Texture {
	log.Println("Calling TextureButton.GetDisabledTexture()")

	returnValue := godotCallObject(o, "get_disabled_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TextureButton) GetExpand() bool {
	log.Println("Calling TextureButton.GetExpand()")

	returnValue := godotCallBool(o, "get_expand")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextureButton) GetFocusedTexture() *Texture {
	log.Println("Calling TextureButton.GetFocusedTexture()")

	returnValue := godotCallObject(o, "get_focused_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TextureButton) GetHoverTexture() *Texture {
	log.Println("Calling TextureButton.GetHoverTexture()")

	returnValue := godotCallObject(o, "get_hover_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TextureButton) GetNormalTexture() *Texture {
	log.Println("Calling TextureButton.GetNormalTexture()")

	returnValue := godotCallObject(o, "get_normal_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TextureButton) GetPressedTexture() *Texture {
	log.Println("Calling TextureButton.GetPressedTexture()")

	returnValue := godotCallObject(o, "get_pressed_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TextureButton) GetStretchMode() int64 {
	log.Println("Calling TextureButton.GetStretchMode()")

	returnValue := godotCallInt(o, "get_stretch_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextureButton) SetClickMask(mask *BitMap) {
	log.Println("Calling TextureButton.SetClickMask()")

	godotCallVoidObject(o, "set_click_mask", &mask.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureButton) SetDisabledTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetDisabledTexture()")

	godotCallVoidObject(o, "set_disabled_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureButton) SetExpand(pExpand bool) {
	log.Println("Calling TextureButton.SetExpand()")

	godotCallVoidBool(o, "set_expand", pExpand)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureButton) SetFocusedTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetFocusedTexture()")

	godotCallVoidObject(o, "set_focused_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureButton) SetHoverTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetHoverTexture()")

	godotCallVoidObject(o, "set_hover_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureButton) SetNormalTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetNormalTexture()")

	godotCallVoidObject(o, "set_normal_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureButton) SetPressedTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetPressedTexture()")

	godotCallVoidObject(o, "set_pressed_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureButton) SetStretchMode(pMode int64) {
	log.Println("Calling TextureButton.SetStretchMode()")

	godotCallVoidInt(o, "set_stretch_mode", pMode)
	log.Println("  Function successfully completed.")

}

/*
   TextureButtonImplementer is an interface for TextureButton objects.
*/
type TextureButtonImplementer interface {
	Class
}

/*
   TextureProgress works like [ProgressBar] but it uses up to 3 textures instead of Godot's [Theme] resource. Works horizontally, vertically, and radially.
*/
type TextureProgress struct {
	Range
}

func (o *TextureProgress) baseClass() string {
	return "TextureProgress"
}

/*
   Undocumented
*/
func (o *TextureProgress) GetFillDegrees() float64 {
	log.Println("Calling TextureProgress.GetFillDegrees()")

	returnValue := godotCallFloat(o, "get_fill_degrees")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextureProgress) GetFillMode() int64 {
	log.Println("Calling TextureProgress.GetFillMode()")

	returnValue := godotCallInt(o, "get_fill_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextureProgress) GetNinePatchStretch() bool {
	log.Println("Calling TextureProgress.GetNinePatchStretch()")

	returnValue := godotCallBool(o, "get_nine_patch_stretch")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextureProgress) GetOverTexture() *Texture {
	log.Println("Calling TextureProgress.GetOverTexture()")

	returnValue := godotCallObject(o, "get_over_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TextureProgress) GetProgressTexture() *Texture {
	log.Println("Calling TextureProgress.GetProgressTexture()")

	returnValue := godotCallObject(o, "get_progress_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TextureProgress) GetRadialCenterOffset() *Vector2 {
	log.Println("Calling TextureProgress.GetRadialCenterOffset()")

	returnValue := godotCallVector2(o, "get_radial_center_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextureProgress) GetRadialInitialAngle() float64 {
	log.Println("Calling TextureProgress.GetRadialInitialAngle()")

	returnValue := godotCallFloat(o, "get_radial_initial_angle")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextureProgress) GetStretchMargin(margin int64) int64 {
	log.Println("Calling TextureProgress.GetStretchMargin()")

	returnValue := godotCallIntInt(o, "get_stretch_margin", margin)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextureProgress) GetUnderTexture() *Texture {
	log.Println("Calling TextureProgress.GetUnderTexture()")

	returnValue := godotCallObject(o, "get_under_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TextureProgress) SetFillDegrees(mode float64) {
	log.Println("Calling TextureProgress.SetFillDegrees()")

	godotCallVoidFloat(o, "set_fill_degrees", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureProgress) SetFillMode(mode int64) {
	log.Println("Calling TextureProgress.SetFillMode()")

	godotCallVoidInt(o, "set_fill_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureProgress) SetNinePatchStretch(stretch bool) {
	log.Println("Calling TextureProgress.SetNinePatchStretch()")

	godotCallVoidBool(o, "set_nine_patch_stretch", stretch)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureProgress) SetOverTexture(tex *Texture) {
	log.Println("Calling TextureProgress.SetOverTexture()")

	godotCallVoidObject(o, "set_over_texture", &tex.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureProgress) SetProgressTexture(tex *Texture) {
	log.Println("Calling TextureProgress.SetProgressTexture()")

	godotCallVoidObject(o, "set_progress_texture", &tex.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureProgress) SetRadialCenterOffset(mode *Vector2) {
	log.Println("Calling TextureProgress.SetRadialCenterOffset()")

	godotCallVoidVector2(o, "set_radial_center_offset", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureProgress) SetRadialInitialAngle(mode float64) {
	log.Println("Calling TextureProgress.SetRadialInitialAngle()")

	godotCallVoidFloat(o, "set_radial_initial_angle", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureProgress) SetStretchMargin(margin int64, value int64) {
	log.Println("Calling TextureProgress.SetStretchMargin()")

	godotCallVoidIntInt(o, "set_stretch_margin", margin, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureProgress) SetUnderTexture(tex *Texture) {
	log.Println("Calling TextureProgress.SetUnderTexture()")

	godotCallVoidObject(o, "set_under_texture", &tex.Object)
	log.Println("  Function successfully completed.")

}

/*
   TextureProgressImplementer is an interface for TextureProgress objects.
*/
type TextureProgressImplementer interface {
	Class
}

/*
   Use TextureRect to draw icons and sprites in your User Interfaces. To create panels and menu boxes, take a look at [NinePatchFrame]. Its Stretch Mode property controls the texture's scale and placement. It can scale, tile and stay centered inside its bounding rectangle. TextureRect is one of the 5 most common nodes to create game UI.
*/
type TextureRect struct {
	Control
}

func (o *TextureRect) baseClass() string {
	return "TextureRect"
}

/*
   Undocumented
*/
func (o *TextureRect) GetStretchMode() int64 {
	log.Println("Calling TextureRect.GetStretchMode()")

	returnValue := godotCallInt(o, "get_stretch_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextureRect) GetTexture() *Texture {
	log.Println("Calling TextureRect.GetTexture()")

	returnValue := godotCallObject(o, "get_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TextureRect) HasExpand() bool {
	log.Println("Calling TextureRect.HasExpand()")

	returnValue := godotCallBool(o, "has_expand")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TextureRect) SetExpand(enable bool) {
	log.Println("Calling TextureRect.SetExpand()")

	godotCallVoidBool(o, "set_expand", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureRect) SetStretchMode(stretchMode int64) {
	log.Println("Calling TextureRect.SetStretchMode()")

	godotCallVoidInt(o, "set_stretch_mode", stretchMode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TextureRect) SetTexture(texture *Texture) {
	log.Println("Calling TextureRect.SetTexture()")

	godotCallVoidObject(o, "set_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   TextureRectImplementer is an interface for TextureRect objects.
*/
type TextureRectImplementer interface {
	Class
}

/*
   Theme for skinning controls. Controls can be skinned individually, but for complex applications it's more efficient to just create a global theme that defines everything. This theme can be applied to any [Control], and it and its children will automatically use it. Theme resources can be alternatively loaded by writing them in a .theme file, see docs for more info.
*/
type Theme struct {
	Resource
}

func (o *Theme) baseClass() string {
	return "Theme"
}

/*
   Undocumented
*/
func (o *Theme) X_EmitThemeChanged() {
	log.Println("Calling Theme.X_EmitThemeChanged()")

	godotCallVoid(o, "_emit_theme_changed")
	log.Println("  Function successfully completed.")

}

/*
   Clears theme [Color] at [code]name[/code] if Theme has [code]type[/code].
*/
func (o *Theme) ClearColor(name string, aType string) {
	log.Println("Calling Theme.ClearColor()")

	godotCallVoidStringString(o, "clear_color", name, aType)
	log.Println("  Function successfully completed.")

}

/*
   Clears theme constant at [code]name[/code] if Theme has [code]type[/code].
*/
func (o *Theme) ClearConstant(name string, aType string) {
	log.Println("Calling Theme.ClearConstant()")

	godotCallVoidStringString(o, "clear_constant", name, aType)
	log.Println("  Function successfully completed.")

}

/*
   Clears [Font] at [code]name[/code] if Theme has [code]type[/code].
*/
func (o *Theme) ClearFont(name string, aType string) {
	log.Println("Calling Theme.ClearFont()")

	godotCallVoidStringString(o, "clear_font", name, aType)
	log.Println("  Function successfully completed.")

}

/*
   Clears icon at [code]name[/code] if Theme has [code]type[/code].
*/
func (o *Theme) ClearIcon(name string, aType string) {
	log.Println("Calling Theme.ClearIcon()")

	godotCallVoidStringString(o, "clear_icon", name, aType)
	log.Println("  Function successfully completed.")

}

/*
   Clears [StyleBox] at [code]name[/code] if Theme has [code]type[/code].
*/
func (o *Theme) ClearStylebox(name string, aType string) {
	log.Println("Calling Theme.ClearStylebox()")

	godotCallVoidStringString(o, "clear_stylebox", name, aType)
	log.Println("  Function successfully completed.")

}

/*
   Sets theme values to a copy of the default theme values.
*/
func (o *Theme) CopyDefaultTheme() {
	log.Println("Calling Theme.CopyDefaultTheme()")

	godotCallVoid(o, "copy_default_theme")
	log.Println("  Function successfully completed.")

}

/*
   Returns the [Color] at [code]name[/code] if Theme has [code]type[/code].
*/
func (o *Theme) GetColor(name string, aType string) *Color {
	log.Println("Calling Theme.GetColor()")

	returnValue := godotCallColorStringString(o, "get_color", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns all of the [Color]s as a [PoolStringArray] filled with each [Color]'s name, for use in [method get_color], if Theme has [code]type[/code].
*/
func (o *Theme) GetColorList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetColorList()")

	returnValue := godotCallPoolStringArrayString(o, "get_color_list", aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the constant at [code]name[/code] if Theme has [code]type[/code].
*/
func (o *Theme) GetConstant(name string, aType string) int64 {
	log.Println("Calling Theme.GetConstant()")

	returnValue := godotCallIntStringString(o, "get_constant", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns all of the constants as a [PoolStringArray] filled with each constant's name, for use in [method get_constant], if Theme has [code]type[/code].
*/
func (o *Theme) GetConstantList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetConstantList()")

	returnValue := godotCallPoolStringArrayString(o, "get_constant_list", aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Theme) GetDefaultFont() *Font {
	log.Println("Calling Theme.GetDefaultFont()")

	returnValue := godotCallObject(o, "get_default_font")
	log.Println("  Got return value: ", returnValue)

	var ret Font
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the [Font] at [code]name[/code] if Theme has [code]type[/code].
*/
func (o *Theme) GetFont(name string, aType string) *Font {
	log.Println("Calling Theme.GetFont()")

	returnValue := godotCallObjectStringString(o, "get_font", name, aType)
	log.Println("  Got return value: ", returnValue)

	var ret Font
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns all of the [Font]s as a [PoolStringArray] filled with each [Font]'s name, for use in [method get_font], if Theme has [code]type[/code].
*/
func (o *Theme) GetFontList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetFontList()")

	returnValue := godotCallPoolStringArrayString(o, "get_font_list", aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the icon [Texture] at [code]name[/code] if Theme has [code]type[/code].
*/
func (o *Theme) GetIcon(name string, aType string) *Texture {
	log.Println("Calling Theme.GetIcon()")

	returnValue := godotCallObjectStringString(o, "get_icon", name, aType)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns all of the icons as a [PoolStringArray] filled with each [Texture]'s name, for use in [method get_icon], if Theme has [code]type[/code].
*/
func (o *Theme) GetIconList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetIconList()")

	returnValue := godotCallPoolStringArrayString(o, "get_icon_list", aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the icon [StyleBox] at [code]name[/code] if Theme has [code]type[/code].
*/
func (o *Theme) GetStylebox(name string, aType string) *StyleBox {
	log.Println("Calling Theme.GetStylebox()")

	returnValue := godotCallObjectStringString(o, "get_stylebox", name, aType)
	log.Println("  Got return value: ", returnValue)

	var ret StyleBox
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns all of the [StyleBox]s as a [PoolStringArray] filled with each [StyleBox]'s name, for use in [method get_stylebox], if Theme has [code]type[/code].
*/
func (o *Theme) GetStyleboxList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetStyleboxList()")

	returnValue := godotCallPoolStringArrayString(o, "get_stylebox_list", aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns all of the [StyleBox] types as a [PoolStringArray] filled with each [StyleBox]'s type, for use in [method get_stylebox] and/or [method get_stylebox_list], if Theme has [code]type[/code].
*/
func (o *Theme) GetStyleboxTypes() *PoolStringArray {
	log.Println("Calling Theme.GetStyleboxTypes()")

	returnValue := godotCallPoolStringArray(o, "get_stylebox_types")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns all of the types in [code]type[/code] as a [PoolStringArray] for use in any of the get_* functions, if Theme has [code]type[/code].
*/
func (o *Theme) GetTypeList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetTypeList()")

	returnValue := godotCallPoolStringArrayString(o, "get_type_list", aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if [Color] with [code]name[/code] is in [code]type[/code]. Returns [code]false[/code] if Theme does not have [code]type[/code].
*/
func (o *Theme) HasColor(name string, aType string) bool {
	log.Println("Calling Theme.HasColor()")

	returnValue := godotCallBoolStringString(o, "has_color", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if constant with [code]name[/code] is in [code]type[/code]. Returns [code]false[/code] if Theme does not have [code]type[/code].
*/
func (o *Theme) HasConstant(name string, aType string) bool {
	log.Println("Calling Theme.HasConstant()")

	returnValue := godotCallBoolStringString(o, "has_constant", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if [Font] with [code]name[/code] is in [code]type[/code]. Returns [code]false[/code] if Theme does not have [code]type[/code].
*/
func (o *Theme) HasFont(name string, aType string) bool {
	log.Println("Calling Theme.HasFont()")

	returnValue := godotCallBoolStringString(o, "has_font", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if icon [Texture] with [code]name[/code] is in [code]type[/code]. Returns [code]false[/code] if Theme does not have [code]type[/code].
*/
func (o *Theme) HasIcon(name string, aType string) bool {
	log.Println("Calling Theme.HasIcon()")

	returnValue := godotCallBoolStringString(o, "has_icon", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if [StyleBox] with [code]name[/code] is in [code]type[/code]. Returns [code]false[/code] if Theme does not have [code]type[/code].
*/
func (o *Theme) HasStylebox(name string, aType string) bool {
	log.Println("Calling Theme.HasStylebox()")

	returnValue := godotCallBoolStringString(o, "has_stylebox", name, aType)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets Theme's [Color] to [code]color[/code] at [code]name[/code] in [code]type[/code]. Does nothing if Theme does not have [code]type[/code].
*/
func (o *Theme) SetColor(name string, aType string, color *Color) {
	log.Println("Calling Theme.SetColor()")

	godotCallVoidStringStringColor(o, "set_color", name, aType, color)
	log.Println("  Function successfully completed.")

}

/*
   Sets Theme's constant to [code]constant[/code] at [code]name[/code] in [code]type[/code]. Does nothing if Theme does not have [code]type[/code].
*/
func (o *Theme) SetConstant(name string, aType string, constant int64) {
	log.Println("Calling Theme.SetConstant()")

	godotCallVoidStringStringInt(o, "set_constant", name, aType, constant)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Theme) SetDefaultFont(font *Font) {
	log.Println("Calling Theme.SetDefaultFont()")

	godotCallVoidObject(o, "set_default_font", &font.Object)
	log.Println("  Function successfully completed.")

}

/*
   Sets Theme's [Font] to [code]font[/code] at [code]name[/code] in [code]type[/code]. Does nothing if Theme does not have [code]type[/code].
*/
func (o *Theme) SetFont(name string, aType string, font *Font) {
	log.Println("Calling Theme.SetFont()")

	godotCallVoidStringStringObject(o, "set_font", name, aType, &font.Object)
	log.Println("  Function successfully completed.")

}

/*
   Sets Theme's icon [Texture] to [code]texture[/code] at [code]name[/code] in [code]type[/code]. Does nothing if Theme does not have [code]type[/code].
*/
func (o *Theme) SetIcon(name string, aType string, texture *Texture) {
	log.Println("Calling Theme.SetIcon()")

	godotCallVoidStringStringObject(o, "set_icon", name, aType, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Sets Theme's [StyleBox] to [code]stylebox[/code] at [code]name[/code] in [code]type[/code]. Does nothing if Theme does not have [code]type[/code].
*/
func (o *Theme) SetStylebox(name string, aType string, texture *StyleBox) {
	log.Println("Calling Theme.SetStylebox()")

	godotCallVoidStringStringObject(o, "set_stylebox", name, aType, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   ThemeImplementer is an interface for Theme objects.
*/
type ThemeImplementer interface {
	Class
}

/*
   Node for 2D tile-based maps. Tilemaps use a [TileSet] which contain a list of tiles (textures plus optional collision, navigation, and/or occluder shapes) which are used to create grid-based maps.
*/
type TileMap struct {
	Node2D
}

func (o *TileMap) baseClass() string {
	return "TileMap"
}

/*
   Undocumented
*/
func (o *TileMap) X_ClearQuadrants() {
	log.Println("Calling TileMap.X_ClearQuadrants()")

	godotCallVoid(o, "_clear_quadrants")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) X_GetOldCellSize() int64 {
	log.Println("Calling TileMap.X_GetOldCellSize()")

	returnValue := godotCallInt(o, "_get_old_cell_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) X_GetTileData() *PoolIntArray {
	log.Println("Calling TileMap.X_GetTileData()")

	returnValue := godotCallPoolIntArray(o, "_get_tile_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) X_RecreateQuadrants() {
	log.Println("Calling TileMap.X_RecreateQuadrants()")

	godotCallVoid(o, "_recreate_quadrants")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) X_SetOldCellSize(size int64) {
	log.Println("Calling TileMap.X_SetOldCellSize()")

	godotCallVoidInt(o, "_set_old_cell_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) X_SetTileData(arg0 *PoolIntArray) {
	log.Println("Calling TileMap.X_SetTileData()")

	godotCallVoidPoolIntArray(o, "_set_tile_data", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) X_UpdateDirtyQuadrants() {
	log.Println("Calling TileMap.X_UpdateDirtyQuadrants()")

	godotCallVoid(o, "_update_dirty_quadrants")
	log.Println("  Function successfully completed.")

}

/*
   Clear all cells.
*/
func (o *TileMap) Clear() {
	log.Println("Calling TileMap.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Return the tile index of the referenced cell.
*/
func (o *TileMap) GetCell(x int64, y int64) int64 {
	log.Println("Calling TileMap.GetCell()")

	returnValue := godotCallIntIntInt(o, "get_cell", x, y)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetCellSize() *Vector2 {
	log.Println("Calling TileMap.GetCellSize()")

	returnValue := godotCallVector2(o, "get_cell_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the tile index of the cell referenced by a Vector2.
*/
func (o *TileMap) GetCellv(position *Vector2) int64 {
	log.Println("Calling TileMap.GetCellv()")

	returnValue := godotCallIntVector2(o, "get_cellv", position)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetClipUv() bool {
	log.Println("Calling TileMap.GetClipUv()")

	returnValue := godotCallBool(o, "get_clip_uv")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetCollisionBounce() float64 {
	log.Println("Calling TileMap.GetCollisionBounce()")

	returnValue := godotCallFloat(o, "get_collision_bounce")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetCollisionFriction() float64 {
	log.Println("Calling TileMap.GetCollisionFriction()")

	returnValue := godotCallFloat(o, "get_collision_friction")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetCollisionLayer() int64 {
	log.Println("Calling TileMap.GetCollisionLayer()")

	returnValue := godotCallInt(o, "get_collision_layer")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TileMap) GetCollisionLayerBit(bit int64) bool {
	log.Println("Calling TileMap.GetCollisionLayerBit()")

	returnValue := godotCallBoolInt(o, "get_collision_layer_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetCollisionMask() int64 {
	log.Println("Calling TileMap.GetCollisionMask()")

	returnValue := godotCallInt(o, "get_collision_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TileMap) GetCollisionMaskBit(bit int64) bool {
	log.Println("Calling TileMap.GetCollisionMaskBit()")

	returnValue := godotCallBoolInt(o, "get_collision_mask_bit", bit)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetCollisionUseKinematic() bool {
	log.Println("Calling TileMap.GetCollisionUseKinematic()")

	returnValue := godotCallBool(o, "get_collision_use_kinematic")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetCustomTransform() *Transform2D {
	log.Println("Calling TileMap.GetCustomTransform()")

	returnValue := godotCallTransform2D(o, "get_custom_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetHalfOffset() int64 {
	log.Println("Calling TileMap.GetHalfOffset()")

	returnValue := godotCallInt(o, "get_half_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetMode() int64 {
	log.Println("Calling TileMap.GetMode()")

	returnValue := godotCallInt(o, "get_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetOccluderLightMask() int64 {
	log.Println("Calling TileMap.GetOccluderLightMask()")

	returnValue := godotCallInt(o, "get_occluder_light_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetQuadrantSize() int64 {
	log.Println("Calling TileMap.GetQuadrantSize()")

	returnValue := godotCallInt(o, "get_quadrant_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetTileOrigin() int64 {
	log.Println("Calling TileMap.GetTileOrigin()")

	returnValue := godotCallInt(o, "get_tile_origin")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) GetTileset() *TileSet {
	log.Println("Calling TileMap.GetTileset()")

	returnValue := godotCallObject(o, "get_tileset")
	log.Println("  Got return value: ", returnValue)

	var ret TileSet
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return an array of all cells containing a tile from the tileset (i.e. a tile index different from -1).
*/
func (o *TileMap) GetUsedCells() *Array {
	log.Println("Calling TileMap.GetUsedCells()")

	returnValue := godotCallArray(o, "get_used_cells")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TileMap) GetUsedCellsById(id int64) *Array {
	log.Println("Calling TileMap.GetUsedCellsById()")

	returnValue := godotCallArrayInt(o, "get_used_cells_by_id", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TileMap) GetUsedRect() *Rect2 {
	log.Println("Calling TileMap.GetUsedRect()")

	returnValue := godotCallRect2(o, "get_used_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return whether the referenced cell is transposed, i.e. the X and Y axes are swapped (mirroring with regard to the (1,1) vector).
*/
func (o *TileMap) IsCellTransposed(x int64, y int64) bool {
	log.Println("Calling TileMap.IsCellTransposed()")

	returnValue := godotCallBoolIntInt(o, "is_cell_transposed", x, y)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return whether the referenced cell is flipped over the X axis.
*/
func (o *TileMap) IsCellXFlipped(x int64, y int64) bool {
	log.Println("Calling TileMap.IsCellXFlipped()")

	returnValue := godotCallBoolIntInt(o, "is_cell_x_flipped", x, y)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return whether the referenced cell is flipped over the Y axis.
*/
func (o *TileMap) IsCellYFlipped(x int64, y int64) bool {
	log.Println("Calling TileMap.IsCellYFlipped()")

	returnValue := godotCallBoolIntInt(o, "is_cell_y_flipped", x, y)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TileMap) IsYSortModeEnabled() bool {
	log.Println("Calling TileMap.IsYSortModeEnabled()")

	returnValue := godotCallBool(o, "is_y_sort_mode_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the absolute world position corresponding to the tilemap (grid-based) coordinates given as an argument. Optionally, the tilemap's potential half offset can be ignored.
*/
func (o *TileMap) MapToWorld(mapPosition *Vector2, ignoreHalfOfs bool) *Vector2 {
	log.Println("Calling TileMap.MapToWorld()")

	returnValue := godotCallVector2Vector2Bool(o, "map_to_world", mapPosition, ignoreHalfOfs)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Set the tile index for the cell referenced by its grid-based X and Y coordinates. A tile index of -1 clears the cell. Optionally, the tile can also be flipped over the X and Y coordinates, transposed, or be given autotile coordinates.
*/
func (o *TileMap) SetCell(x int64, y int64, tile int64, flipX bool, flipY bool, transpose bool, autotileCoord *Vector2) {
	log.Println("Calling TileMap.SetCell()")

	godotCallVoidIntIntIntBoolBoolBoolVector2(o, "set_cell", x, y, tile, flipX, flipY, transpose, autotileCoord)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetCellSize(size *Vector2) {
	log.Println("Calling TileMap.SetCellSize()")

	godotCallVoidVector2(o, "set_cell_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Set the tile index for the cell referenced by a Vector2 of grid-based coordinates. A tile index of -1 clears the cell. Optionally, the tile can also be flipped over the X and Y axes or transposed.
*/
func (o *TileMap) SetCellv(position *Vector2, tile int64, flipX bool, flipY bool, transpose bool) {
	log.Println("Calling TileMap.SetCellv()")

	godotCallVoidVector2IntBoolBoolBool(o, "set_cellv", position, tile, flipX, flipY, transpose)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetClipUv(enable bool) {
	log.Println("Calling TileMap.SetClipUv()")

	godotCallVoidBool(o, "set_clip_uv", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetCollisionBounce(value float64) {
	log.Println("Calling TileMap.SetCollisionBounce()")

	godotCallVoidFloat(o, "set_collision_bounce", value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetCollisionFriction(value float64) {
	log.Println("Calling TileMap.SetCollisionFriction()")

	godotCallVoidFloat(o, "set_collision_friction", value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetCollisionLayer(layer int64) {
	log.Println("Calling TileMap.SetCollisionLayer()")

	godotCallVoidInt(o, "set_collision_layer", layer)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TileMap) SetCollisionLayerBit(bit int64, value bool) {
	log.Println("Calling TileMap.SetCollisionLayerBit()")

	godotCallVoidIntBool(o, "set_collision_layer_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetCollisionMask(mask int64) {
	log.Println("Calling TileMap.SetCollisionMask()")

	godotCallVoidInt(o, "set_collision_mask", mask)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TileMap) SetCollisionMaskBit(bit int64, value bool) {
	log.Println("Calling TileMap.SetCollisionMaskBit()")

	godotCallVoidIntBool(o, "set_collision_mask_bit", bit, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetCollisionUseKinematic(useKinematic bool) {
	log.Println("Calling TileMap.SetCollisionUseKinematic()")

	godotCallVoidBool(o, "set_collision_use_kinematic", useKinematic)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetCustomTransform(customTransform *Transform2D) {
	log.Println("Calling TileMap.SetCustomTransform()")

	godotCallVoidTransform2D(o, "set_custom_transform", customTransform)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetHalfOffset(halfOffset int64) {
	log.Println("Calling TileMap.SetHalfOffset()")

	godotCallVoidInt(o, "set_half_offset", halfOffset)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetMode(mode int64) {
	log.Println("Calling TileMap.SetMode()")

	godotCallVoidInt(o, "set_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetOccluderLightMask(mask int64) {
	log.Println("Calling TileMap.SetOccluderLightMask()")

	godotCallVoidInt(o, "set_occluder_light_mask", mask)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetQuadrantSize(size int64) {
	log.Println("Calling TileMap.SetQuadrantSize()")

	godotCallVoidInt(o, "set_quadrant_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetTileOrigin(origin int64) {
	log.Println("Calling TileMap.SetTileOrigin()")

	godotCallVoidInt(o, "set_tile_origin", origin)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetTileset(tileset *TileSet) {
	log.Println("Calling TileMap.SetTileset()")

	godotCallVoidObject(o, "set_tileset", &tileset.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TileMap) SetYSortMode(enable bool) {
	log.Println("Calling TileMap.SetYSortMode()")

	godotCallVoidBool(o, "set_y_sort_mode", enable)
	log.Println("  Function successfully completed.")

}

/*
   Applies autotiling rules to the cell (and its adjacent cells) referenced by its grid-based X and Y coordinates.
*/
func (o *TileMap) UpdateBitmaskArea(position *Vector2) {
	log.Println("Calling TileMap.UpdateBitmaskArea()")

	godotCallVoidVector2(o, "update_bitmask_area", position)
	log.Println("  Function successfully completed.")

}

/*
   Applies autotiling rules to the cells in the given region (specified by grid-based X and Y coordinates). Calling with invalid (or missing) parameters applies autotiling rules for the entire TileMap.
*/
func (o *TileMap) UpdateBitmaskRegion(start *Vector2, end *Vector2) {
	log.Println("Calling TileMap.UpdateBitmaskRegion()")

	godotCallVoidVector2Vector2(o, "update_bitmask_region", start, end)
	log.Println("  Function successfully completed.")

}

/*
   Return the tilemap (grid-based) coordinates corresponding to the absolute world position given as an argument.
*/
func (o *TileMap) WorldToMap(worldPosition *Vector2) *Vector2 {
	log.Println("Calling TileMap.WorldToMap()")

	returnValue := godotCallVector2Vector2(o, "world_to_map", worldPosition)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   TileMapImplementer is an interface for TileMap objects.
*/
type TileMapImplementer interface {
	Class
}

/*
   A TileSet is a library of tiles for a [TileMap]. It contains a list of tiles, each consisting of a sprite and optional collision shapes. Tiles are referenced by a unique integer ID.
*/
type TileSet struct {
	Resource
}

func (o *TileSet) baseClass() string {
	return "TileSet"
}

/*

 */
func (o *TileSet) X_ForwardSubtileSelection(autotileId int64, bitmask int64, tilemap *Object, tileLocation *Vector2) *Vector2 {
	log.Println("Calling TileSet.X_ForwardSubtileSelection()")

	returnValue := godotCallVector2IntIntObjectVector2(o, "_forward_subtile_selection", autotileId, bitmask, tilemap, tileLocation)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TileSet) X_IsTileBound(drawnId int64, neighborId int64) bool {
	log.Println("Calling TileSet.X_IsTileBound()")

	returnValue := godotCallBoolIntInt(o, "_is_tile_bound", drawnId, neighborId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TileSet) AutotileGetBitmaskMode(id int64) int64 {
	log.Println("Calling TileSet.AutotileGetBitmaskMode()")

	returnValue := godotCallIntInt(o, "autotile_get_bitmask_mode", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TileSet) AutotileSetBitmaskMode(id int64, mode int64) {
	log.Println("Calling TileSet.AutotileSetBitmaskMode()")

	godotCallVoidIntInt(o, "autotile_set_bitmask_mode", id, mode)
	log.Println("  Function successfully completed.")

}

/*
   Clear all tiles.
*/
func (o *TileSet) Clear() {
	log.Println("Calling TileSet.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Create a new tile which will be referenced by the given ID.
*/
func (o *TileSet) CreateTile(id int64) {
	log.Println("Calling TileSet.CreateTile()")

	godotCallVoidInt(o, "create_tile", id)
	log.Println("  Function successfully completed.")

}

/*
   Find the first tile matching the given name.
*/
func (o *TileSet) FindTileByName(name string) int64 {
	log.Println("Calling TileSet.FindTileByName()")

	returnValue := godotCallIntString(o, "find_tile_by_name", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the ID following the last currently used ID, useful when creating a new tile.
*/
func (o *TileSet) GetLastUnusedTileId() int64 {
	log.Println("Calling TileSet.GetLastUnusedTileId()")

	returnValue := godotCallInt(o, "get_last_unused_tile_id")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return an array of all currently used tile IDs.
*/
func (o *TileSet) GetTilesIds() *Array {
	log.Println("Calling TileSet.GetTilesIds()")

	returnValue := godotCallArray(o, "get_tiles_ids")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Remove the tile referenced by the given ID.
*/
func (o *TileSet) RemoveTile(id int64) {
	log.Println("Calling TileSet.RemoveTile()")

	godotCallVoidInt(o, "remove_tile", id)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TileSet) TileAddShape(id int64, shape *Shape2D, shapeTransform *Transform2D, oneWay bool, autotileCoord *Vector2) {
	log.Println("Calling TileSet.TileAddShape()")

	godotCallVoidIntObjectTransform2DBoolVector2(o, "tile_add_shape", id, &shape.Object, shapeTransform, oneWay, autotileCoord)
	log.Println("  Function successfully completed.")

}

/*
   Return the light occluder of the tile.
*/
func (o *TileSet) TileGetLightOccluder(id int64) *OccluderPolygon2D {
	log.Println("Calling TileSet.TileGetLightOccluder()")

	returnValue := godotCallObjectInt(o, "tile_get_light_occluder", id)
	log.Println("  Got return value: ", returnValue)

	var ret OccluderPolygon2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the material of the tile.
*/
func (o *TileSet) TileGetMaterial(id int64) *ShaderMaterial {
	log.Println("Calling TileSet.TileGetMaterial()")

	returnValue := godotCallObjectInt(o, "tile_get_material", id)
	log.Println("  Got return value: ", returnValue)

	var ret ShaderMaterial
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the name of the tile.
*/
func (o *TileSet) TileGetName(id int64) string {
	log.Println("Calling TileSet.TileGetName()")

	returnValue := godotCallStringInt(o, "tile_get_name", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the navigation polygon of the tile.
*/
func (o *TileSet) TileGetNavigationPolygon(id int64) *NavigationPolygon {
	log.Println("Calling TileSet.TileGetNavigationPolygon()")

	returnValue := godotCallObjectInt(o, "tile_get_navigation_polygon", id)
	log.Println("  Got return value: ", returnValue)

	var ret NavigationPolygon
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the offset of the tile's navigation polygon.
*/
func (o *TileSet) TileGetNavigationPolygonOffset(id int64) *Vector2 {
	log.Println("Calling TileSet.TileGetNavigationPolygonOffset()")

	returnValue := godotCallVector2Int(o, "tile_get_navigation_polygon_offset", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TileSet) TileGetNormalMap(id int64) *Texture {
	log.Println("Calling TileSet.TileGetNormalMap()")

	returnValue := godotCallObjectInt(o, "tile_get_normal_map", id)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the offset of the tile's light occluder.
*/
func (o *TileSet) TileGetOccluderOffset(id int64) *Vector2 {
	log.Println("Calling TileSet.TileGetOccluderOffset()")

	returnValue := godotCallVector2Int(o, "tile_get_occluder_offset", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the tile sub-region in the texture.
*/
func (o *TileSet) TileGetRegion(id int64) *Rect2 {
	log.Println("Calling TileSet.TileGetRegion()")

	returnValue := godotCallRect2Int(o, "tile_get_region", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TileSet) TileGetShape(id int64, shapeId int64) *Shape2D {
	log.Println("Calling TileSet.TileGetShape()")

	returnValue := godotCallObjectIntInt(o, "tile_get_shape", id, shapeId)
	log.Println("  Got return value: ", returnValue)

	var ret Shape2D
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *TileSet) TileGetShapeCount(id int64) int64 {
	log.Println("Calling TileSet.TileGetShapeCount()")

	returnValue := godotCallIntInt(o, "tile_get_shape_count", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TileSet) TileGetShapeOneWay(id int64, shapeId int64) bool {
	log.Println("Calling TileSet.TileGetShapeOneWay()")

	returnValue := godotCallBoolIntInt(o, "tile_get_shape_one_way", id, shapeId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TileSet) TileGetShapeTransform(id int64, shapeId int64) *Transform2D {
	log.Println("Calling TileSet.TileGetShapeTransform()")

	returnValue := godotCallTransform2DIntInt(o, "tile_get_shape_transform", id, shapeId)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the array of shapes of the tile.
*/
func (o *TileSet) TileGetShapes(id int64) *Array {
	log.Println("Calling TileSet.TileGetShapes()")

	returnValue := godotCallArrayInt(o, "tile_get_shapes", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the texture of the tile.
*/
func (o *TileSet) TileGetTexture(id int64) *Texture {
	log.Println("Calling TileSet.TileGetTexture()")

	returnValue := godotCallObjectInt(o, "tile_get_texture", id)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the texture offset of the tile.
*/
func (o *TileSet) TileGetTextureOffset(id int64) *Vector2 {
	log.Println("Calling TileSet.TileGetTextureOffset()")

	returnValue := godotCallVector2Int(o, "tile_get_texture_offset", id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Set a light occluder for the tile.
*/
func (o *TileSet) TileSetLightOccluder(id int64, lightOccluder *OccluderPolygon2D) {
	log.Println("Calling TileSet.TileSetLightOccluder()")

	godotCallVoidIntObject(o, "tile_set_light_occluder", id, &lightOccluder.Object)
	log.Println("  Function successfully completed.")

}

/*
   Set the material of the tile.
*/
func (o *TileSet) TileSetMaterial(id int64, material *ShaderMaterial) {
	log.Println("Calling TileSet.TileSetMaterial()")

	godotCallVoidIntObject(o, "tile_set_material", id, &material.Object)
	log.Println("  Function successfully completed.")

}

/*
   Set the name of the tile, for descriptive purposes.
*/
func (o *TileSet) TileSetName(id int64, name string) {
	log.Println("Calling TileSet.TileSetName()")

	godotCallVoidIntString(o, "tile_set_name", id, name)
	log.Println("  Function successfully completed.")

}

/*
   Set a navigation polygon for the tile.
*/
func (o *TileSet) TileSetNavigationPolygon(id int64, navigationPolygon *NavigationPolygon) {
	log.Println("Calling TileSet.TileSetNavigationPolygon()")

	godotCallVoidIntObject(o, "tile_set_navigation_polygon", id, &navigationPolygon.Object)
	log.Println("  Function successfully completed.")

}

/*
   Set an offset for the tile's navigation polygon.
*/
func (o *TileSet) TileSetNavigationPolygonOffset(id int64, navigationPolygonOffset *Vector2) {
	log.Println("Calling TileSet.TileSetNavigationPolygonOffset()")

	godotCallVoidIntVector2(o, "tile_set_navigation_polygon_offset", id, navigationPolygonOffset)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TileSet) TileSetNormalMap(id int64, normalMap *Texture) {
	log.Println("Calling TileSet.TileSetNormalMap()")

	godotCallVoidIntObject(o, "tile_set_normal_map", id, &normalMap.Object)
	log.Println("  Function successfully completed.")

}

/*
   Set an offset for the tile's light occluder.
*/
func (o *TileSet) TileSetOccluderOffset(id int64, occluderOffset *Vector2) {
	log.Println("Calling TileSet.TileSetOccluderOffset()")

	godotCallVoidIntVector2(o, "tile_set_occluder_offset", id, occluderOffset)
	log.Println("  Function successfully completed.")

}

/*
   Set the tile sub-region in the texture. This is common in texture atlases.
*/
func (o *TileSet) TileSetRegion(id int64, region *Rect2) {
	log.Println("Calling TileSet.TileSetRegion()")

	godotCallVoidIntRect2(o, "tile_set_region", id, region)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TileSet) TileSetShape(id int64, shapeId int64, shape *Shape2D) {
	log.Println("Calling TileSet.TileSetShape()")

	godotCallVoidIntIntObject(o, "tile_set_shape", id, shapeId, &shape.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TileSet) TileSetShapeOneWay(id int64, shapeId int64, oneWay bool) {
	log.Println("Calling TileSet.TileSetShapeOneWay()")

	godotCallVoidIntIntBool(o, "tile_set_shape_one_way", id, shapeId, oneWay)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TileSet) TileSetShapeTransform(id int64, shapeId int64, shapeTransform *Transform2D) {
	log.Println("Calling TileSet.TileSetShapeTransform()")

	godotCallVoidIntIntTransform2D(o, "tile_set_shape_transform", id, shapeId, shapeTransform)
	log.Println("  Function successfully completed.")

}

/*
   Set an array of shapes for the tile, enabling physics to collide with it.
*/
func (o *TileSet) TileSetShapes(id int64, shapes *Array) {
	log.Println("Calling TileSet.TileSetShapes()")

	godotCallVoidIntArray(o, "tile_set_shapes", id, shapes)
	log.Println("  Function successfully completed.")

}

/*
   Set the texture of the tile.
*/
func (o *TileSet) TileSetTexture(id int64, texture *Texture) {
	log.Println("Calling TileSet.TileSetTexture()")

	godotCallVoidIntObject(o, "tile_set_texture", id, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Set the texture offset of the tile.
*/
func (o *TileSet) TileSetTextureOffset(id int64, textureOffset *Vector2) {
	log.Println("Calling TileSet.TileSetTextureOffset()")

	godotCallVoidIntVector2(o, "tile_set_texture_offset", id, textureOffset)
	log.Println("  Function successfully completed.")

}

/*
   TileSetImplementer is an interface for TileSet objects.
*/
type TileSetImplementer interface {
	Class
}

/*
   Counts down a specified interval and emits a signal on reaching 0. Can be set to repeat or "one shot" mode.
*/
type Timer struct {
	Node
}

func (o *Timer) baseClass() string {
	return "Timer"
}

/*
   Undocumented
*/
func (o *Timer) GetTimeLeft() float64 {
	log.Println("Calling Timer.GetTimeLeft()")

	returnValue := godotCallFloat(o, "get_time_left")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Timer) GetTimerProcessMode() int64 {
	log.Println("Calling Timer.GetTimerProcessMode()")

	returnValue := godotCallInt(o, "get_timer_process_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Timer) GetWaitTime() float64 {
	log.Println("Calling Timer.GetWaitTime()")

	returnValue := godotCallFloat(o, "get_wait_time")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Timer) HasAutostart() bool {
	log.Println("Calling Timer.HasAutostart()")

	returnValue := godotCallBool(o, "has_autostart")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Timer) IsOneShot() bool {
	log.Println("Calling Timer.IsOneShot()")

	returnValue := godotCallBool(o, "is_one_shot")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Timer) IsPaused() bool {
	log.Println("Calling Timer.IsPaused()")

	returnValue := godotCallBool(o, "is_paused")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the timer is stopped.
*/
func (o *Timer) IsStopped() bool {
	log.Println("Calling Timer.IsStopped()")

	returnValue := godotCallBool(o, "is_stopped")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Timer) SetAutostart(enable bool) {
	log.Println("Calling Timer.SetAutostart()")

	godotCallVoidBool(o, "set_autostart", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Timer) SetOneShot(enable bool) {
	log.Println("Calling Timer.SetOneShot()")

	godotCallVoidBool(o, "set_one_shot", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Timer) SetPaused(paused bool) {
	log.Println("Calling Timer.SetPaused()")

	godotCallVoidBool(o, "set_paused", paused)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Timer) SetTimerProcessMode(mode int64) {
	log.Println("Calling Timer.SetTimerProcessMode()")

	godotCallVoidInt(o, "set_timer_process_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Timer) SetWaitTime(timeSec float64) {
	log.Println("Calling Timer.SetWaitTime()")

	godotCallVoidFloat(o, "set_wait_time", timeSec)
	log.Println("  Function successfully completed.")

}

/*
   Starts the timer. This also resets the remaining time to [code]wait_time[/code]. Note: this method will not resume a paused timer. See [method set_paused].
*/
func (o *Timer) Start() {
	log.Println("Calling Timer.Start()")

	godotCallVoid(o, "start")
	log.Println("  Function successfully completed.")

}

/*
   Stop (cancel) the Timer.
*/
func (o *Timer) Stop() {
	log.Println("Calling Timer.Stop()")

	godotCallVoid(o, "stop")
	log.Println("  Function successfully completed.")

}

/*
   TimerImplementer is an interface for Timer objects.
*/
type TimerImplementer interface {
	Class
}

/*
   This is a helper class to generate a flat [Button] (see [method Button.set_flat]), creating a ToolButton is equivalent to: [codeblock] var btn = Button.new() btn.set_flat(true) [/codeblock]
*/
type ToolButton struct {
	Button
}

func (o *ToolButton) baseClass() string {
	return "ToolButton"
}

/*
   ToolButtonImplementer is an interface for ToolButton objects.
*/
type ToolButtonImplementer interface {
	Class
}

/*
   Button for touch screen devices. You can set it to be visible on all screens, or only on touch devices.
*/
type TouchScreenButton struct {
	Node2D
}

func (o *TouchScreenButton) baseClass() string {
	return "TouchScreenButton"
}

/*
   Undocumented
*/
func (o *TouchScreenButton) X_Input(arg0 *InputEvent) {
	log.Println("Calling TouchScreenButton.X_Input()")

	godotCallVoidObject(o, "_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TouchScreenButton) GetAction() string {
	log.Println("Calling TouchScreenButton.GetAction()")

	returnValue := godotCallString(o, "get_action")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TouchScreenButton) GetBitmask() *BitMap {
	log.Println("Calling TouchScreenButton.GetBitmask()")

	returnValue := godotCallObject(o, "get_bitmask")
	log.Println("  Got return value: ", returnValue)

	var ret BitMap
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TouchScreenButton) GetShape() *Shape2D {
	log.Println("Calling TouchScreenButton.GetShape()")

	returnValue := godotCallObject(o, "get_shape")
	log.Println("  Got return value: ", returnValue)

	var ret Shape2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TouchScreenButton) GetTexture() *Texture {
	log.Println("Calling TouchScreenButton.GetTexture()")

	returnValue := godotCallObject(o, "get_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TouchScreenButton) GetTexturePressed() *Texture {
	log.Println("Calling TouchScreenButton.GetTexturePressed()")

	returnValue := godotCallObject(o, "get_texture_pressed")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *TouchScreenButton) GetVisibilityMode() int64 {
	log.Println("Calling TouchScreenButton.GetVisibilityMode()")

	returnValue := godotCallInt(o, "get_visibility_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TouchScreenButton) IsPassbyPressEnabled() bool {
	log.Println("Calling TouchScreenButton.IsPassbyPressEnabled()")

	returnValue := godotCallBool(o, "is_passby_press_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if this button is currently pressed.
*/
func (o *TouchScreenButton) IsPressed() bool {
	log.Println("Calling TouchScreenButton.IsPressed()")

	returnValue := godotCallBool(o, "is_pressed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TouchScreenButton) IsShapeCentered() bool {
	log.Println("Calling TouchScreenButton.IsShapeCentered()")

	returnValue := godotCallBool(o, "is_shape_centered")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TouchScreenButton) IsShapeVisible() bool {
	log.Println("Calling TouchScreenButton.IsShapeVisible()")

	returnValue := godotCallBool(o, "is_shape_visible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TouchScreenButton) SetAction(action string) {
	log.Println("Calling TouchScreenButton.SetAction()")

	godotCallVoidString(o, "set_action", action)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TouchScreenButton) SetBitmask(bitmask *BitMap) {
	log.Println("Calling TouchScreenButton.SetBitmask()")

	godotCallVoidObject(o, "set_bitmask", &bitmask.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TouchScreenButton) SetPassbyPress(enabled bool) {
	log.Println("Calling TouchScreenButton.SetPassbyPress()")

	godotCallVoidBool(o, "set_passby_press", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TouchScreenButton) SetShape(shape *Shape2D) {
	log.Println("Calling TouchScreenButton.SetShape()")

	godotCallVoidObject(o, "set_shape", &shape.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TouchScreenButton) SetShapeCentered(bool bool) {
	log.Println("Calling TouchScreenButton.SetShapeCentered()")

	godotCallVoidBool(o, "set_shape_centered", bool)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TouchScreenButton) SetShapeVisible(bool bool) {
	log.Println("Calling TouchScreenButton.SetShapeVisible()")

	godotCallVoidBool(o, "set_shape_visible", bool)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TouchScreenButton) SetTexture(texture *Texture) {
	log.Println("Calling TouchScreenButton.SetTexture()")

	godotCallVoidObject(o, "set_texture", &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TouchScreenButton) SetTexturePressed(texturePressed *Texture) {
	log.Println("Calling TouchScreenButton.SetTexturePressed()")

	godotCallVoidObject(o, "set_texture_pressed", &texturePressed.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TouchScreenButton) SetVisibilityMode(mode int64) {
	log.Println("Calling TouchScreenButton.SetVisibilityMode()")

	godotCallVoidInt(o, "set_visibility_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   TouchScreenButtonImplementer is an interface for TouchScreenButton objects.
*/
type TouchScreenButtonImplementer interface {
	Class
}

/*
   Translations are resources that can be loaded/unloaded on demand. They map a string to another string.
*/
type Translation struct {
	Resource
}

func (o *Translation) baseClass() string {
	return "Translation"
}

/*
   Undocumented
*/
func (o *Translation) X_GetMessages() *PoolStringArray {
	log.Println("Calling Translation.X_GetMessages()")

	returnValue := godotCallPoolStringArray(o, "_get_messages")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Translation) X_SetMessages(arg0 *PoolStringArray) {
	log.Println("Calling Translation.X_SetMessages()")

	godotCallVoidPoolStringArray(o, "_set_messages", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Add a message for translation.
*/
func (o *Translation) AddMessage(srcMessage string, xlatedMessage string) {
	log.Println("Calling Translation.AddMessage()")

	godotCallVoidStringString(o, "add_message", srcMessage, xlatedMessage)
	log.Println("  Function successfully completed.")

}

/*
   Erase a message.
*/
func (o *Translation) EraseMessage(srcMessage string) {
	log.Println("Calling Translation.EraseMessage()")

	godotCallVoidString(o, "erase_message", srcMessage)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Translation) GetLocale() string {
	log.Println("Calling Translation.GetLocale()")

	returnValue := godotCallString(o, "get_locale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return a message for translation.
*/
func (o *Translation) GetMessage(srcMessage string) string {
	log.Println("Calling Translation.GetMessage()")

	returnValue := godotCallStringString(o, "get_message", srcMessage)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Translation) GetMessageCount() int64 {
	log.Println("Calling Translation.GetMessageCount()")

	returnValue := godotCallInt(o, "get_message_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return all the messages (keys).
*/
func (o *Translation) GetMessageList() *PoolStringArray {
	log.Println("Calling Translation.GetMessageList()")

	returnValue := godotCallPoolStringArray(o, "get_message_list")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Translation) SetLocale(locale string) {
	log.Println("Calling Translation.SetLocale()")

	godotCallVoidString(o, "set_locale", locale)
	log.Println("  Function successfully completed.")

}

/*
   TranslationImplementer is an interface for Translation objects.
*/
type TranslationImplementer interface {
	Class
}

func newSingletonTranslationServer() *translationServer {
	obj := &translationServer{}
	name := C.CString("TranslationServer")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*

 */
var TranslationServer = newSingletonTranslationServer()

/*

 */
type translationServer struct {
	Object
}

func (o *translationServer) baseClass() string {
	return "TranslationServer"
}

/*

 */
func (o *translationServer) AddTranslation(translation *Translation) {
	log.Println("Calling TranslationServer.AddTranslation()")

	godotCallVoidObject(o, "add_translation", &translation.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *translationServer) Clear() {
	log.Println("Calling TranslationServer.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *translationServer) GetLocale() string {
	log.Println("Calling TranslationServer.GetLocale()")

	returnValue := godotCallString(o, "get_locale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *translationServer) GetLocaleName(locale string) string {
	log.Println("Calling TranslationServer.GetLocaleName()")

	returnValue := godotCallStringString(o, "get_locale_name", locale)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *translationServer) RemoveTranslation(translation *Translation) {
	log.Println("Calling TranslationServer.RemoveTranslation()")

	godotCallVoidObject(o, "remove_translation", &translation.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *translationServer) SetLocale(locale string) {
	log.Println("Calling TranslationServer.SetLocale()")

	godotCallVoidString(o, "set_locale", locale)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *translationServer) Translate(message string) string {
	log.Println("Calling TranslationServer.Translate()")

	returnValue := godotCallStringString(o, "translate", message)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   This shows a tree of items that can be selected, expanded and collapsed. The tree can have multiple columns with custom controls like text editing, buttons and popups. It can be useful for structured displays and interactions. Trees are built via code, using [TreeItem] objects to create the structure. They have a single root but multiple roots can be simulated if a dummy hidden root is added. [codeblock] func _ready(): var tree = Tree.new() var root = tree.create_item() tree.set_hide_root(true) var child1 = tree.create_item(root) var child2 = tree.create_item(root) var subchild1 = tree.create_item(child1) subchild1.set_text(0, "Subchild1") [/codeblock]
*/
type Tree struct {
	Control
}

func (o *Tree) baseClass() string {
	return "Tree"
}

/*
   Undocumented
*/
func (o *Tree) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling Tree.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) X_PopupSelect(arg0 int64) {
	log.Println("Calling Tree.X_PopupSelect()")

	godotCallVoidInt(o, "_popup_select", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) X_RangeClickTimeout() {
	log.Println("Calling Tree.X_RangeClickTimeout()")

	godotCallVoid(o, "_range_click_timeout")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) X_ScrollMoved(arg0 float64) {
	log.Println("Calling Tree.X_ScrollMoved()")

	godotCallVoidFloat(o, "_scroll_moved", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) X_TextEditorEnter(arg0 string) {
	log.Println("Calling Tree.X_TextEditorEnter()")

	godotCallVoidString(o, "_text_editor_enter", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) X_TextEditorModalClose() {
	log.Println("Calling Tree.X_TextEditorModalClose()")

	godotCallVoid(o, "_text_editor_modal_close")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) X_ValueEditorChanged(arg0 float64) {
	log.Println("Calling Tree.X_ValueEditorChanged()")

	godotCallVoidFloat(o, "_value_editor_changed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Returns [code]true[/code] if the column titles are being shown.
*/
func (o *Tree) AreColumnTitlesVisible() bool {
	log.Println("Calling Tree.AreColumnTitlesVisible()")

	returnValue := godotCallBool(o, "are_column_titles_visible")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Clears the tree. This removes all items.
*/
func (o *Tree) Clear() {
	log.Println("Calling Tree.Clear()")

	godotCallVoid(o, "clear")
	log.Println("  Function successfully completed.")

}

/*
   Create an item in the tree and add it as the last child of [code]parent[/code]. If parent is not given, it will be added as the root's last child, or it'll the be the root itself if the tree is empty.
*/
func (o *Tree) CreateItem(parent *Object, idx int64) *Object {
	log.Println("Calling Tree.CreateItem()")

	returnValue := godotCallObjectObjectInt(o, "create_item", parent, idx)
	log.Println("  Got return value: ", returnValue)

	var ret Object
	ret.owner = returnValue.owner
	return &ret

}

/*
   Makes the currently selected item visible. This will scroll the tree to make sure the selected item is visible.
*/
func (o *Tree) EnsureCursorIsVisible() {
	log.Println("Calling Tree.EnsureCursorIsVisible()")

	godotCallVoid(o, "ensure_cursor_is_visible")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) GetAllowReselect() bool {
	log.Println("Calling Tree.GetAllowReselect()")

	returnValue := godotCallBool(o, "get_allow_reselect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tree) GetAllowRmbSelect() bool {
	log.Println("Calling Tree.GetAllowRmbSelect()")

	returnValue := godotCallBool(o, "get_allow_rmb_select")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the column index under the given point.
*/
func (o *Tree) GetColumnAtPosition(position *Vector2) int64 {
	log.Println("Calling Tree.GetColumnAtPosition()")

	returnValue := godotCallIntVector2(o, "get_column_at_position", position)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the column's title.
*/
func (o *Tree) GetColumnTitle(column int64) string {
	log.Println("Calling Tree.GetColumnTitle()")

	returnValue := godotCallStringInt(o, "get_column_title", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the column's width in pixels.
*/
func (o *Tree) GetColumnWidth(column int64) int64 {
	log.Println("Calling Tree.GetColumnWidth()")

	returnValue := godotCallIntInt(o, "get_column_width", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tree) GetColumns() int64 {
	log.Println("Calling Tree.GetColumns()")

	returnValue := godotCallInt(o, "get_columns")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the rectangle for custom popups. Helper to create custom cell controls that display a popup. See [method TreeItem.set_cell_mode].
*/
func (o *Tree) GetCustomPopupRect() *Rect2 {
	log.Println("Calling Tree.GetCustomPopupRect()")

	returnValue := godotCallRect2(o, "get_custom_popup_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tree) GetDropModeFlags() int64 {
	log.Println("Calling Tree.GetDropModeFlags()")

	returnValue := godotCallInt(o, "get_drop_mode_flags")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Tree) GetDropSectionAtPosition(position *Vector2) int64 {
	log.Println("Calling Tree.GetDropSectionAtPosition()")

	returnValue := godotCallIntVector2(o, "get_drop_section_at_position", position)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the currently edited item. This is only available for custom cell mode.
*/
func (o *Tree) GetEdited() *TreeItem {
	log.Println("Calling Tree.GetEdited()")

	returnValue := godotCallObject(o, "get_edited")
	log.Println("  Got return value: ", returnValue)

	var ret TreeItem
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the column for the currently edited item. This is only available for custom cell mode.
*/
func (o *Tree) GetEditedColumn() int64 {
	log.Println("Calling Tree.GetEditedColumn()")

	returnValue := godotCallInt(o, "get_edited_column")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the rectangle area for the specified item. If column is specified, only get the position and size of that column, otherwise get the rectangle containing all columns.
*/
func (o *Tree) GetItemAreaRect(item *Object, column int64) *Rect2 {
	log.Println("Calling Tree.GetItemAreaRect()")

	returnValue := godotCallRect2ObjectInt(o, "get_item_area_rect", item, column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the tree item at the specified position (relative to the tree origin position).
*/
func (o *Tree) GetItemAtPosition(position *Vector2) *TreeItem {
	log.Println("Calling Tree.GetItemAtPosition()")

	returnValue := godotCallObjectVector2(o, "get_item_at_position", position)
	log.Println("  Got return value: ", returnValue)

	var ret TreeItem
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the next selected item after the given one.
*/
func (o *Tree) GetNextSelected(from *Object) *TreeItem {
	log.Println("Calling Tree.GetNextSelected()")

	returnValue := godotCallObjectObject(o, "get_next_selected", from)
	log.Println("  Got return value: ", returnValue)

	var ret TreeItem
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the last pressed button's index.
*/
func (o *Tree) GetPressedButton() int64 {
	log.Println("Calling Tree.GetPressedButton()")

	returnValue := godotCallInt(o, "get_pressed_button")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the tree's root item.
*/
func (o *Tree) GetRoot() *TreeItem {
	log.Println("Calling Tree.GetRoot()")

	returnValue := godotCallObject(o, "get_root")
	log.Println("  Got return value: ", returnValue)

	var ret TreeItem
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the current scrolling position.
*/
func (o *Tree) GetScroll() *Vector2 {
	log.Println("Calling Tree.GetScroll()")

	returnValue := godotCallVector2(o, "get_scroll")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tree) GetSelectMode() int64 {
	log.Println("Calling Tree.GetSelectMode()")

	returnValue := godotCallInt(o, "get_select_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the currently selected item.
*/
func (o *Tree) GetSelected() *TreeItem {
	log.Println("Calling Tree.GetSelected()")

	returnValue := godotCallObject(o, "get_selected")
	log.Println("  Got return value: ", returnValue)

	var ret TreeItem
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the current selection's column.
*/
func (o *Tree) GetSelectedColumn() int64 {
	log.Println("Calling Tree.GetSelectedColumn()")

	returnValue := godotCallInt(o, "get_selected_column")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tree) IsFoldingHidden() bool {
	log.Println("Calling Tree.IsFoldingHidden()")

	returnValue := godotCallBool(o, "is_folding_hidden")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tree) IsRootHidden() bool {
	log.Println("Calling Tree.IsRootHidden()")

	returnValue := godotCallBool(o, "is_root_hidden")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tree) SetAllowReselect(allow bool) {
	log.Println("Calling Tree.SetAllowReselect()")

	godotCallVoidBool(o, "set_allow_reselect", allow)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) SetAllowRmbSelect(allow bool) {
	log.Println("Calling Tree.SetAllowRmbSelect()")

	godotCallVoidBool(o, "set_allow_rmb_select", allow)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the column will have the "Expand" flag of [Control].
*/
func (o *Tree) SetColumnExpand(column int64, expand bool) {
	log.Println("Calling Tree.SetColumnExpand()")

	godotCallVoidIntBool(o, "set_column_expand", column, expand)
	log.Println("  Function successfully completed.")

}

/*
   Set the minimum width of a column.
*/
func (o *Tree) SetColumnMinWidth(column int64, minWidth int64) {
	log.Println("Calling Tree.SetColumnMinWidth()")

	godotCallVoidIntInt(o, "set_column_min_width", column, minWidth)
	log.Println("  Function successfully completed.")

}

/*
   Set the title of a column.
*/
func (o *Tree) SetColumnTitle(column int64, title string) {
	log.Println("Calling Tree.SetColumnTitle()")

	godotCallVoidIntString(o, "set_column_title", column, title)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] column titles are visible.
*/
func (o *Tree) SetColumnTitlesVisible(visible bool) {
	log.Println("Calling Tree.SetColumnTitlesVisible()")

	godotCallVoidBool(o, "set_column_titles_visible", visible)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) SetColumns(amount int64) {
	log.Println("Calling Tree.SetColumns()")

	godotCallVoidInt(o, "set_columns", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) SetDropModeFlags(flags int64) {
	log.Println("Calling Tree.SetDropModeFlags()")

	godotCallVoidInt(o, "set_drop_mode_flags", flags)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) SetHideFolding(hide bool) {
	log.Println("Calling Tree.SetHideFolding()")

	godotCallVoidBool(o, "set_hide_folding", hide)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) SetHideRoot(enable bool) {
	log.Println("Calling Tree.SetHideRoot()")

	godotCallVoidBool(o, "set_hide_root", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tree) SetSelectMode(mode int64) {
	log.Println("Calling Tree.SetSelectMode()")

	godotCallVoidInt(o, "set_select_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   TreeImplementer is an interface for Tree objects.
*/
type TreeImplementer interface {
	Class
}

/*
   Control for a single item inside a [Tree]. May have child [code]TreeItem[/code]s and be styled as well as contain buttons.
*/
type TreeItem struct {
	Object
}

func (o *TreeItem) baseClass() string {
	return "TreeItem"
}

/*
   Adds a button with [Texture] [code]button[/code] at column [code]column[/code]. The [code]button_idx[/code] index is used to identify the button when calling other methods. If not specified, the next available index is used, which may be retrieved by calling [code]get_buton_count()[/code] immediately after this method. Optionally, the button can be [code]disabled[/code] and have a [code]tooltip[/code].
*/
func (o *TreeItem) AddButton(column int64, button *Texture, buttonIdx int64, disabled bool, tooltip string) {
	log.Println("Calling TreeItem.AddButton()")

	godotCallVoidIntObjectIntBoolString(o, "add_button", column, &button.Object, buttonIdx, disabled, tooltip)
	log.Println("  Function successfully completed.")

}

/*
   Resets the background color for the given column to default.
*/
func (o *TreeItem) ClearCustomBgColor(column int64) {
	log.Println("Calling TreeItem.ClearCustomBgColor()")

	godotCallVoidInt(o, "clear_custom_bg_color", column)
	log.Println("  Function successfully completed.")

}

/*
   Resets the color for the given column to default.
*/
func (o *TreeItem) ClearCustomColor(column int64) {
	log.Println("Calling TreeItem.ClearCustomColor()")

	godotCallVoidInt(o, "clear_custom_color", column)
	log.Println("  Function successfully completed.")

}

/*
   Deselects the given column.
*/
func (o *TreeItem) Deselect(column int64) {
	log.Println("Calling TreeItem.Deselect()")

	godotCallVoidInt(o, "deselect", column)
	log.Println("  Function successfully completed.")

}

/*
   Removes the button at index [code]button_idx[/code] in column [code]column[/code].
*/
func (o *TreeItem) EraseButton(column int64, buttonIdx int64) {
	log.Println("Calling TreeItem.EraseButton()")

	godotCallVoidIntInt(o, "erase_button", column, buttonIdx)
	log.Println("  Function successfully completed.")

}

/*
   Returns the [Texture] of the button at index [code]button_idx[/code] in column [code]column[/code].
*/
func (o *TreeItem) GetButton(column int64, buttonIdx int64) *Texture {
	log.Println("Calling TreeItem.GetButton()")

	returnValue := godotCallObjectIntInt(o, "get_button", column, buttonIdx)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the number of buttons in column [code]column[/code]. May be used to get the most recently added button's index, if no index was specified.
*/
func (o *TreeItem) GetButtonCount(column int64) int64 {
	log.Println("Calling TreeItem.GetButtonCount()")

	returnValue := godotCallIntInt(o, "get_button_count", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the column's cell mode. See [code]CELL_MODE_*[/code] constants.
*/
func (o *TreeItem) GetCellMode(column int64) int64 {
	log.Println("Calling TreeItem.GetCellMode()")

	returnValue := godotCallIntInt(o, "get_cell_mode", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the TreeItem's child items.
*/
func (o *TreeItem) GetChildren() *TreeItem {
	log.Println("Calling TreeItem.GetChildren()")

	returnValue := godotCallObject(o, "get_children")
	log.Println("  Got return value: ", returnValue)

	var ret TreeItem
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the custom background color of column [code]column[/code].
*/
func (o *TreeItem) GetCustomBgColor(column int64) *Color {
	log.Println("Calling TreeItem.GetCustomBgColor()")

	returnValue := godotCallColorInt(o, "get_custom_bg_color", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TreeItem) GetCustomMinimumHeight() int64 {
	log.Println("Calling TreeItem.GetCustomMinimumHeight()")

	returnValue := godotCallInt(o, "get_custom_minimum_height")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if [code]expand_right[/code] is set.
*/
func (o *TreeItem) GetExpandRight(column int64) bool {
	log.Println("Calling TreeItem.GetExpandRight()")

	returnValue := godotCallBoolInt(o, "get_expand_right", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the given column's icon [Texture]. Error if no icon is set.
*/
func (o *TreeItem) GetIcon(column int64) *Texture {
	log.Println("Calling TreeItem.GetIcon()")

	returnValue := godotCallObjectInt(o, "get_icon", column)
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the column's icon's maximum width.
*/
func (o *TreeItem) GetIconMaxWidth(column int64) int64 {
	log.Println("Calling TreeItem.GetIconMaxWidth()")

	returnValue := godotCallIntInt(o, "get_icon_max_width", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the icon [Texture] region as [Rect2].
*/
func (o *TreeItem) GetIconRegion(column int64) *Rect2 {
	log.Println("Calling TreeItem.GetIconRegion()")

	returnValue := godotCallRect2Int(o, "get_icon_region", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TreeItem) GetMetadata(column int64) *Variant {
	log.Println("Calling TreeItem.GetMetadata()")

	returnValue := godotCallVariantInt(o, "get_metadata", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the next TreeItem in the tree.
*/
func (o *TreeItem) GetNext() *TreeItem {
	log.Println("Calling TreeItem.GetNext()")

	returnValue := godotCallObject(o, "get_next")
	log.Println("  Got return value: ", returnValue)

	var ret TreeItem
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the next visible TreeItem in the tree.
*/
func (o *TreeItem) GetNextVisible() *TreeItem {
	log.Println("Calling TreeItem.GetNextVisible()")

	returnValue := godotCallObject(o, "get_next_visible")
	log.Println("  Got return value: ", returnValue)

	var ret TreeItem
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the parent TreeItem.
*/
func (o *TreeItem) GetParent() *TreeItem {
	log.Println("Calling TreeItem.GetParent()")

	returnValue := godotCallObject(o, "get_parent")
	log.Println("  Got return value: ", returnValue)

	var ret TreeItem
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the previous TreeItem in the tree.
*/
func (o *TreeItem) GetPrev() *TreeItem {
	log.Println("Calling TreeItem.GetPrev()")

	returnValue := godotCallObject(o, "get_prev")
	log.Println("  Got return value: ", returnValue)

	var ret TreeItem
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the previous visible TreeItem in the tree.
*/
func (o *TreeItem) GetPrevVisible() *TreeItem {
	log.Println("Calling TreeItem.GetPrevVisible()")

	returnValue := godotCallObject(o, "get_prev_visible")
	log.Println("  Got return value: ", returnValue)

	var ret TreeItem
	ret.owner = returnValue.owner
	return &ret

}

/*

 */
func (o *TreeItem) GetRange(column int64) float64 {
	log.Println("Calling TreeItem.GetRange()")

	returnValue := godotCallFloatInt(o, "get_range", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TreeItem) GetRangeConfig(column int64) *Dictionary {
	log.Println("Calling TreeItem.GetRangeConfig()")

	returnValue := godotCallDictionaryInt(o, "get_range_config", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the given column's text.
*/
func (o *TreeItem) GetText(column int64) string {
	log.Println("Calling TreeItem.GetText()")

	returnValue := godotCallStringInt(o, "get_text", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the given column's text alignment.
*/
func (o *TreeItem) GetTextAlign(column int64) int64 {
	log.Println("Calling TreeItem.GetTextAlign()")

	returnValue := godotCallIntInt(o, "get_text_align", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the given column's tooltip.
*/
func (o *TreeItem) GetTooltip(column int64) string {
	log.Println("Calling TreeItem.GetTooltip()")

	returnValue := godotCallStringInt(o, "get_tooltip", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the button at index [code]button_idx[/code] for the given column is disabled.
*/
func (o *TreeItem) IsButtonDisabled(column int64, buttonIdx int64) bool {
	log.Println("Calling TreeItem.IsButtonDisabled()")

	returnValue := godotCallBoolIntInt(o, "is_button_disabled", column, buttonIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if the given column is checked.
*/
func (o *TreeItem) IsChecked(column int64) bool {
	log.Println("Calling TreeItem.IsChecked()")

	returnValue := godotCallBoolInt(o, "is_checked", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TreeItem) IsCollapsed() bool {
	log.Println("Calling TreeItem.IsCollapsed()")

	returnValue := godotCallBool(o, "is_collapsed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *TreeItem) IsCustomSetAsButton(column int64) bool {
	log.Println("Calling TreeItem.IsCustomSetAsButton()")

	returnValue := godotCallBoolInt(o, "is_custom_set_as_button", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if column [code]column[/code] is editable.
*/
func (o *TreeItem) IsEditable(column int64) bool {
	log.Println("Calling TreeItem.IsEditable()")

	returnValue := godotCallBoolInt(o, "is_editable", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *TreeItem) IsFoldingDisabled() bool {
	log.Println("Calling TreeItem.IsFoldingDisabled()")

	returnValue := godotCallBool(o, "is_folding_disabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if column [code]column[/code] is selectable.
*/
func (o *TreeItem) IsSelectable(column int64) bool {
	log.Println("Calling TreeItem.IsSelectable()")

	returnValue := godotCallBoolInt(o, "is_selectable", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if column [code]column[/code] is selected.
*/
func (o *TreeItem) IsSelected(column int64) bool {
	log.Println("Calling TreeItem.IsSelected()")

	returnValue := godotCallBoolInt(o, "is_selected", column)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Moves this TreeItem to the bottom in the [Tree] hierarchy.
*/
func (o *TreeItem) MoveToBottom() {
	log.Println("Calling TreeItem.MoveToBottom()")

	godotCallVoid(o, "move_to_bottom")
	log.Println("  Function successfully completed.")

}

/*
   Moves this TreeItem to the top in the [Tree] hierarchy.
*/
func (o *TreeItem) MoveToTop() {
	log.Println("Calling TreeItem.MoveToTop()")

	godotCallVoid(o, "move_to_top")
	log.Println("  Function successfully completed.")

}

/*
   Removes the child TreeItem at index [code]index[/code].
*/
func (o *TreeItem) RemoveChild(child *Object) {
	log.Println("Calling TreeItem.RemoveChild()")

	godotCallVoidObject(o, "remove_child", child)
	log.Println("  Function successfully completed.")

}

/*
   Selects the column [code]column[/code].
*/
func (o *TreeItem) Select(column int64) {
	log.Println("Calling TreeItem.Select()")

	godotCallVoidInt(o, "select", column)
	log.Println("  Function successfully completed.")

}

/*
   Sets the given column's button [Texture] at index [code]button_idx[/code] to [code]button[/code].
*/
func (o *TreeItem) SetButton(column int64, buttonIdx int64, button *Texture) {
	log.Println("Calling TreeItem.SetButton()")

	godotCallVoidIntIntObject(o, "set_button", column, buttonIdx, &button.Object)
	log.Println("  Function successfully completed.")

}

/*
   Sets the given column's cell mode to [code]mode[/code]. See [code]CELL_MODE_*[/code] constants.
*/
func (o *TreeItem) SetCellMode(column int64, mode int64) {
	log.Println("Calling TreeItem.SetCellMode()")

	godotCallVoidIntInt(o, "set_cell_mode", column, mode)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the column [code]column[/code] is checked.
*/
func (o *TreeItem) SetChecked(column int64, checked bool) {
	log.Println("Calling TreeItem.SetChecked()")

	godotCallVoidIntBool(o, "set_checked", column, checked)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TreeItem) SetCollapsed(enable bool) {
	log.Println("Calling TreeItem.SetCollapsed()")

	godotCallVoidBool(o, "set_collapsed", enable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TreeItem) SetCustomAsButton(column int64, enable bool) {
	log.Println("Calling TreeItem.SetCustomAsButton()")

	godotCallVoidIntBool(o, "set_custom_as_button", column, enable)
	log.Println("  Function successfully completed.")

}

/*
   Sets the given column's custom background color and whether to just use it as an outline.
*/
func (o *TreeItem) SetCustomBgColor(column int64, color *Color, justOutline bool) {
	log.Println("Calling TreeItem.SetCustomBgColor()")

	godotCallVoidIntColorBool(o, "set_custom_bg_color", column, color, justOutline)
	log.Println("  Function successfully completed.")

}

/*
   Sets the given column's custom color.
*/
func (o *TreeItem) SetCustomColor(column int64, color *Color) {
	log.Println("Calling TreeItem.SetCustomColor()")

	godotCallVoidIntColor(o, "set_custom_color", column, color)
	log.Println("  Function successfully completed.")

}

/*
   Sets the given column's custom draw callback to [code]callback[/code] method on [code]object[/code].
*/
func (o *TreeItem) SetCustomDraw(column int64, object *Object, callback string) {
	log.Println("Calling TreeItem.SetCustomDraw()")

	godotCallVoidIntObjectString(o, "set_custom_draw", column, object, callback)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TreeItem) SetCustomMinimumHeight(height int64) {
	log.Println("Calling TreeItem.SetCustomMinimumHeight()")

	godotCallVoidInt(o, "set_custom_minimum_height", height)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *TreeItem) SetDisableFolding(disable bool) {
	log.Println("Calling TreeItem.SetDisableFolding()")

	godotCallVoidBool(o, "set_disable_folding", disable)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] column [code]column[/code] is editable.
*/
func (o *TreeItem) SetEditable(column int64, enabled bool) {
	log.Println("Calling TreeItem.SetEditable()")

	godotCallVoidIntBool(o, "set_editable", column, enabled)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] column [code]column[/code] is expanded to the right.
*/
func (o *TreeItem) SetExpandRight(column int64, enable bool) {
	log.Println("Calling TreeItem.SetExpandRight()")

	godotCallVoidIntBool(o, "set_expand_right", column, enable)
	log.Println("  Function successfully completed.")

}

/*
   Sets the given column's icon [Texture].
*/
func (o *TreeItem) SetIcon(column int64, texture *Texture) {
	log.Println("Calling TreeItem.SetIcon()")

	godotCallVoidIntObject(o, "set_icon", column, &texture.Object)
	log.Println("  Function successfully completed.")

}

/*
   Sets the given column's icon's maximum width.
*/
func (o *TreeItem) SetIconMaxWidth(column int64, width int64) {
	log.Println("Calling TreeItem.SetIconMaxWidth()")

	godotCallVoidIntInt(o, "set_icon_max_width", column, width)
	log.Println("  Function successfully completed.")

}

/*
   Sets the given column's icon's texture region.
*/
func (o *TreeItem) SetIconRegion(column int64, region *Rect2) {
	log.Println("Calling TreeItem.SetIconRegion()")

	godotCallVoidIntRect2(o, "set_icon_region", column, region)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TreeItem) SetMetadata(column int64, meta *Variant) {
	log.Println("Calling TreeItem.SetMetadata()")

	godotCallVoidIntVariant(o, "set_metadata", column, meta)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TreeItem) SetRange(column int64, value float64) {
	log.Println("Calling TreeItem.SetRange()")

	godotCallVoidIntFloat(o, "set_range", column, value)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TreeItem) SetRangeConfig(column int64, min float64, max float64, step float64, expr bool) {
	log.Println("Calling TreeItem.SetRangeConfig()")

	godotCallVoidIntFloatFloatFloatBool(o, "set_range_config", column, min, max, step, expr)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the given column is selectable.
*/
func (o *TreeItem) SetSelectable(column int64, selectable bool) {
	log.Println("Calling TreeItem.SetSelectable()")

	godotCallVoidIntBool(o, "set_selectable", column, selectable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *TreeItem) SetText(column int64, text string) {
	log.Println("Calling TreeItem.SetText()")

	godotCallVoidIntString(o, "set_text", column, text)
	log.Println("  Function successfully completed.")

}

/*
   Sets the given column's text alignment. See [code]ALIGN_*[/code] constants.
*/
func (o *TreeItem) SetTextAlign(column int64, textAlign int64) {
	log.Println("Calling TreeItem.SetTextAlign()")

	godotCallVoidIntInt(o, "set_text_align", column, textAlign)
	log.Println("  Function successfully completed.")

}

/*
   Sets the given column's tooltip text.
*/
func (o *TreeItem) SetTooltip(column int64, tooltip string) {
	log.Println("Calling TreeItem.SetTooltip()")

	godotCallVoidIntString(o, "set_tooltip", column, tooltip)
	log.Println("  Function successfully completed.")

}

/*
   TreeItemImplementer is an interface for TreeItem objects.
*/
type TreeItemImplementer interface {
	Class
}

/*

 */
type TriangleMesh struct {
	Reference
}

func (o *TriangleMesh) baseClass() string {
	return "TriangleMesh"
}

/*
   TriangleMeshImplementer is an interface for TriangleMesh objects.
*/
type TriangleMeshImplementer interface {
	Class
}

/*
   Node useful for animations with unknown start and end points, procedural animations, making one node follow another, and other simple behavior. Because it is easy to get it wrong, here is a quick usage example: [codeblock] var tween = get_node("Tween") tween.interpolate_property(get_node("Node2D_to_move"), "transform/origin", Vector2(0,0), Vector2(100,100), 1, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT) tween.start() [/codeblock] Some of the methods of this class require a property name. You can get the property name by hovering over the property in the inspector of the editor. Many of the methods accept [code]trans_type[/code] and [code]ease_type[/code]. The first accepts an TRANS_* constant, and refers to the way the timing of the animation is handled (you might want to see [code]http://easings.net/[/code] for some examples). The second accepts an EASE_* constant, and controls the where [code]trans_type[/code] is applied to the interpolation (in the beginning, the end, or both). If you don't know which transition and easing to pick, you can try different TRANS_* constants with EASE_IN_OUT, and use the one that looks best.
*/
type Tween struct {
	Node
}

func (o *Tween) baseClass() string {
	return "Tween"
}

/*
   Undocumented
*/
func (o *Tween) X_Remove(object *Object, key string, firstOnly bool) {
	log.Println("Calling Tween.X_Remove()")

	godotCallVoidObjectStringBool(o, "_remove", object, key, firstOnly)
	log.Println("  Function successfully completed.")

}

/*
   Follow [code]method[/code] of [code]object[/code] and apply the returned value on [code]target_method[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] later. Methods are animated by calling them with consequitive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) FollowMethod(object *Object, method string, initialVal *Variant, target *Object, targetMethod string, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.FollowMethod()")

	returnValue := godotCallBoolObjectStringVariantObjectStringFloatIntIntFloat(o, "follow_method", object, method, initialVal, target, targetMethod, duration, transType, easeType, delay)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Follow [code]property[/code] of [code]object[/code] and apply it on [code]target_property[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Note that [code]target:target_property[/code] would equal [code]object:property[/code] at the end of the tween. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) FollowProperty(object *Object, property *NodePath, initialVal *Variant, target *Object, targetProperty *NodePath, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.FollowProperty()")

	returnValue := godotCallBoolObjectNodePathVariantObjectNodePathFloatIntIntFloat(o, "follow_property", object, property, initialVal, target, targetProperty, duration, transType, easeType, delay)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the time needed for all tweens to end in seconds, measured from the start. Thus, if you have two tweens, one ending 10 seconds after the start and the other - 20 seconds, it would return 20 seconds, as by that time all tweens would have finished.
*/
func (o *Tween) GetRuntime() float64 {
	log.Println("Calling Tween.GetRuntime()")

	returnValue := godotCallFloat(o, "get_runtime")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tween) GetSpeedScale() float64 {
	log.Println("Calling Tween.GetSpeedScale()")

	returnValue := godotCallFloat(o, "get_speed_scale")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tween) GetTweenProcessMode() int64 {
	log.Println("Calling Tween.GetTweenProcessMode()")

	returnValue := godotCallInt(o, "get_tween_process_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Call [code]callback[/code] of [code]object[/code] after [code]duration[/code]. [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
*/
func (o *Tween) InterpolateCallback(object *Object, duration float64, callback string, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) bool {
	log.Println("Calling Tween.InterpolateCallback()")

	returnValue := godotCallBoolObjectFloatStringVariantVariantVariantVariantVariant(o, "interpolate_callback", object, duration, callback, arg1, arg2, arg3, arg4, arg5)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Call [code]callback[/code] of [code]object[/code] after [code]duration[/code] on the main thread (similar to [method Object.call_deferred]). [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
*/
func (o *Tween) InterpolateDeferredCallback(object *Object, duration float64, callback string, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) bool {
	log.Println("Calling Tween.InterpolateDeferredCallback()")

	returnValue := godotCallBoolObjectFloatStringVariantVariantVariantVariantVariant(o, "interpolate_deferred_callback", object, duration, callback, arg1, arg2, arg3, arg4, arg5)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Animate [code]method[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecutive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) InterpolateMethod(object *Object, method string, initialVal *Variant, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.InterpolateMethod()")

	returnValue := godotCallBoolObjectStringVariantVariantFloatIntIntFloat(o, "interpolate_method", object, method, initialVal, finalVal, duration, transType, easeType, delay)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Animate [code]property[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) InterpolateProperty(object *Object, property *NodePath, initialVal *Variant, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.InterpolateProperty()")

	returnValue := godotCallBoolObjectNodePathVariantVariantFloatIntIntFloat(o, "interpolate_property", object, property, initialVal, finalVal, duration, transType, easeType, delay)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns true if any tweens are currently running, and false otherwise. Note that this method doesn't consider tweens that have ended.
*/
func (o *Tween) IsActive() bool {
	log.Println("Calling Tween.IsActive()")

	returnValue := godotCallBool(o, "is_active")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Tween) IsRepeat() bool {
	log.Println("Calling Tween.IsRepeat()")

	returnValue := godotCallBool(o, "is_repeat")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Stop animating and completely remove a tween, given its object and property/method pair. Passing empty String as key will remove all tweens for given object.
*/
func (o *Tween) Remove(object *Object, key string) bool {
	log.Println("Calling Tween.Remove()")

	returnValue := godotCallBoolObjectString(o, "remove", object, key)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Stop animating and completely remove all tweens.
*/
func (o *Tween) RemoveAll() bool {
	log.Println("Calling Tween.RemoveAll()")

	returnValue := godotCallBool(o, "remove_all")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Resets a tween to the initial value (the one given, not the one before the tween), given its object and property/method pair. Passing empty String as key will reset all tweens for given object.
*/
func (o *Tween) Reset(object *Object, key string) bool {
	log.Println("Calling Tween.Reset()")

	returnValue := godotCallBoolObjectString(o, "reset", object, key)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Resets all tweens to their initial values (the ones given, not those before the tween).
*/
func (o *Tween) ResetAll() bool {
	log.Println("Calling Tween.ResetAll()")

	returnValue := godotCallBool(o, "reset_all")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Continue animating a stopped tween, given its object and property/method pair. Passing empty String as key will resume all tweens for given object.
*/
func (o *Tween) Resume(object *Object, key string) bool {
	log.Println("Calling Tween.Resume()")

	returnValue := godotCallBoolObjectString(o, "resume", object, key)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Continue animating all stopped tweens.
*/
func (o *Tween) ResumeAll() bool {
	log.Println("Calling Tween.ResumeAll()")

	returnValue := godotCallBool(o, "resume_all")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Seek the animation to the given [code]time[/code] in seconds.
*/
func (o *Tween) Seek(time float64) bool {
	log.Println("Calling Tween.Seek()")

	returnValue := godotCallBoolFloat(o, "seek", time)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Activate/deactivate the tween. You can use this for pausing animations, though [method stop_all] and [method resume_all] might be more fit for this.
*/
func (o *Tween) SetActive(active bool) {
	log.Println("Calling Tween.SetActive()")

	godotCallVoidBool(o, "set_active", active)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tween) SetRepeat(repeat bool) {
	log.Println("Calling Tween.SetRepeat()")

	godotCallVoidBool(o, "set_repeat", repeat)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tween) SetSpeedScale(speed float64) {
	log.Println("Calling Tween.SetSpeedScale()")

	godotCallVoidFloat(o, "set_speed_scale", speed)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tween) SetTweenProcessMode(mode int64) {
	log.Println("Calling Tween.SetTweenProcessMode()")

	godotCallVoidInt(o, "set_tween_process_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Start the tween node. You can define tweens both before and after this.
*/
func (o *Tween) Start() bool {
	log.Println("Calling Tween.Start()")

	returnValue := godotCallBool(o, "start")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Stop animating a tween, given its object and property/method pair. Passing empty String as key will stop all tweens for given object.
*/
func (o *Tween) Stop(object *Object, key string) bool {
	log.Println("Calling Tween.Stop()")

	returnValue := godotCallBoolObjectString(o, "stop", object, key)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Stop animating all tweens.
*/
func (o *Tween) StopAll() bool {
	log.Println("Calling Tween.StopAll()")

	returnValue := godotCallBool(o, "stop_all")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Animate [code]method[/code] of [code]object[/code] from the value returned by [code]initial.initial_method[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecutive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) TargetingMethod(object *Object, method string, initial *Object, initialMethod string, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.TargetingMethod()")

	returnValue := godotCallBoolObjectStringObjectStringVariantFloatIntIntFloat(o, "targeting_method", object, method, initial, initialMethod, finalVal, duration, transType, easeType, delay)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Animate [code]property[/code] of [code]object[/code] from the current value of the [code]initial_val[/code] property of [code]initial[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) TargetingProperty(object *Object, property *NodePath, initial *Object, initialVal *NodePath, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) bool {
	log.Println("Calling Tween.TargetingProperty()")

	returnValue := godotCallBoolObjectNodePathObjectNodePathVariantFloatIntIntFloat(o, "targeting_property", object, property, initial, initialVal, finalVal, duration, transType, easeType, delay)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the current time of the tween.
*/
func (o *Tween) Tell() float64 {
	log.Println("Calling Tween.Tell()")

	returnValue := godotCallFloat(o, "tell")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   TweenImplementer is an interface for Tween objects.
*/
type TweenImplementer interface {
	Class
}

/*
   Helper to manage UndoRedo in the editor or custom tools. It works by storing calls to functions in both 'do' an 'undo' lists. Common behavior is to create an action, then add do/undo calls to functions or property changes, then committing the action.
*/
type UndoRedo struct {
	Object
}

func (o *UndoRedo) baseClass() string {
	return "UndoRedo"
}

/*

 */
func (o *UndoRedo) AddDoMethod(object *Object, method string, varArgs ...interface{}) *Variant {
	log.Println("Calling UndoRedo.AddDoMethod()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantObjectStringVarargs(o, "add_do_method", object, method, varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Set a property with a custom value.
*/
func (o *UndoRedo) AddDoProperty(object *Object, property string, value *Variant) {
	log.Println("Calling UndoRedo.AddDoProperty()")

	godotCallVoidObjectStringVariant(o, "add_do_property", object, property, value)
	log.Println("  Function successfully completed.")

}

/*
   Add a 'do' reference that will be erased if the 'do' history is lost. This is useful mostly for new nodes created for the 'do' call. Do not use for resources.
*/
func (o *UndoRedo) AddDoReference(object *Object) {
	log.Println("Calling UndoRedo.AddDoReference()")

	godotCallVoidObject(o, "add_do_reference", object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *UndoRedo) AddUndoMethod(object *Object, method string, varArgs ...interface{}) *Variant {
	log.Println("Calling UndoRedo.AddUndoMethod()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantObjectStringVarargs(o, "add_undo_method", object, method, varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undo setting of a property with a custom value.
*/
func (o *UndoRedo) AddUndoProperty(object *Object, property string, value *Variant) {
	log.Println("Calling UndoRedo.AddUndoProperty()")

	godotCallVoidObjectStringVariant(o, "add_undo_property", object, property, value)
	log.Println("  Function successfully completed.")

}

/*
   Add an 'undo' reference that will be erased if the 'undo' history is lost. This is useful mostly for nodes removed with the 'do' call (not the 'undo' call!).
*/
func (o *UndoRedo) AddUndoReference(object *Object) {
	log.Println("Calling UndoRedo.AddUndoReference()")

	godotCallVoidObject(o, "add_undo_reference", object)
	log.Println("  Function successfully completed.")

}

/*
   Clear the undo/redo history and associated references.
*/
func (o *UndoRedo) ClearHistory() {
	log.Println("Calling UndoRedo.ClearHistory()")

	godotCallVoid(o, "clear_history")
	log.Println("  Function successfully completed.")

}

/*
   Commit the action. All 'do' methods/properties are called/set when this function is called.
*/
func (o *UndoRedo) CommitAction() {
	log.Println("Calling UndoRedo.CommitAction()")

	godotCallVoid(o, "commit_action")
	log.Println("  Function successfully completed.")

}

/*
   Create a new action. After this is called, do all your calls to [method add_do_method], [method add_undo_method], [method add_do_property] and [method add_undo_property].
*/
func (o *UndoRedo) CreateAction(name string, mergeMode int64) {
	log.Println("Calling UndoRedo.CreateAction()")

	godotCallVoidStringInt(o, "create_action", name, mergeMode)
	log.Println("  Function successfully completed.")

}

/*
   Get the name of the current action.
*/
func (o *UndoRedo) GetCurrentActionName() string {
	log.Println("Calling UndoRedo.GetCurrentActionName()")

	returnValue := godotCallString(o, "get_current_action_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the version, each time a new action is committed, the version number of the UndoRedo is increased automatically. This is useful mostly to check if something changed from a saved version.
*/
func (o *UndoRedo) GetVersion() int64 {
	log.Println("Calling UndoRedo.GetVersion()")

	returnValue := godotCallInt(o, "get_version")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *UndoRedo) Redo() {
	log.Println("Calling UndoRedo.Redo()")

	godotCallVoid(o, "redo")
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *UndoRedo) Undo() {
	log.Println("Calling UndoRedo.Undo()")

	godotCallVoid(o, "undo")
	log.Println("  Function successfully completed.")

}

/*
   UndoRedoImplementer is an interface for UndoRedo objects.
*/
type UndoRedoImplementer interface {
	Class
}

/*
   Vertical box container. See [BoxContainer].
*/
type VBoxContainer struct {
	BoxContainer
}

func (o *VBoxContainer) baseClass() string {
	return "VBoxContainer"
}

/*
   VBoxContainerImplementer is an interface for VBoxContainer objects.
*/
type VBoxContainerImplementer interface {
	Class
}

/*

 */
type VScrollBar struct {
	ScrollBar
}

func (o *VScrollBar) baseClass() string {
	return "VScrollBar"
}

/*
   VScrollBarImplementer is an interface for VScrollBar objects.
*/
type VScrollBarImplementer interface {
	Class
}

/*
   Vertical version of [Separator]. It is used to separate objects horizontally, though (but it looks vertical!).
*/
type VSeparator struct {
	Separator
}

func (o *VSeparator) baseClass() string {
	return "VSeparator"
}

/*
   VSeparatorImplementer is an interface for VSeparator objects.
*/
type VSeparatorImplementer interface {
	Class
}

/*
   Vertical slider. See [Slider]. This one goes from left (min) to right (max).
*/
type VSlider struct {
	Slider
}

func (o *VSlider) baseClass() string {
	return "VSlider"
}

/*
   VSliderImplementer is an interface for VSlider objects.
*/
type VSliderImplementer interface {
	Class
}

/*
   Vertical split container. See [SplitContainer]. This goes from left to right.
*/
type VSplitContainer struct {
	SplitContainer
}

func (o *VSplitContainer) baseClass() string {
	return "VSplitContainer"
}

/*
   VSplitContainerImplementer is an interface for VSplitContainer objects.
*/
type VSplitContainerImplementer interface {
	Class
}

/*
   This nodes implements all the physics logic needed to simulate a car. It is based on the raycast vehicle system commonly found in physics engines. You will need to add a [CollisionShape] for the main body of your vehicle and add [VehicleWheel] nodes for the wheels. You should also add a [MeshInstance] to this node for the 3D model of your car but this model should not include meshes for the wheels. You should control the vehicle by using the [member brake], [member engine_force], and [member steering] properties and not change the position or orientation of this node directly. Note that the origin point of your VehicleBody will determine the center of gravity of your vehicle so it is better to keep this low and move the [CollisionShape] and [MeshInstance] upwards.
*/
type VehicleBody struct {
	RigidBody
}

func (o *VehicleBody) baseClass() string {
	return "VehicleBody"
}

/*
   Undocumented
*/
func (o *VehicleBody) GetBrake() float64 {
	log.Println("Calling VehicleBody.GetBrake()")

	returnValue := godotCallFloat(o, "get_brake")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleBody) GetEngineForce() float64 {
	log.Println("Calling VehicleBody.GetEngineForce()")

	returnValue := godotCallFloat(o, "get_engine_force")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleBody) GetSteering() float64 {
	log.Println("Calling VehicleBody.GetSteering()")

	returnValue := godotCallFloat(o, "get_steering")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleBody) SetBrake(brake float64) {
	log.Println("Calling VehicleBody.SetBrake()")

	godotCallVoidFloat(o, "set_brake", brake)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleBody) SetEngineForce(engineForce float64) {
	log.Println("Calling VehicleBody.SetEngineForce()")

	godotCallVoidFloat(o, "set_engine_force", engineForce)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleBody) SetSteering(steering float64) {
	log.Println("Calling VehicleBody.SetSteering()")

	godotCallVoidFloat(o, "set_steering", steering)
	log.Println("  Function successfully completed.")

}

/*
   VehicleBodyImplementer is an interface for VehicleBody objects.
*/
type VehicleBodyImplementer interface {
	Class
}

/*
   This node needs to be used as a child node of [VehicleBody] and simulates the behaviour of one of its wheels. This node also acts as a collider to detect if the wheel is touching a surface.
*/
type VehicleWheel struct {
	Spatial
}

func (o *VehicleWheel) baseClass() string {
	return "VehicleWheel"
}

/*
   Undocumented
*/
func (o *VehicleWheel) GetDampingCompression() float64 {
	log.Println("Calling VehicleWheel.GetDampingCompression()")

	returnValue := godotCallFloat(o, "get_damping_compression")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleWheel) GetDampingRelaxation() float64 {
	log.Println("Calling VehicleWheel.GetDampingRelaxation()")

	returnValue := godotCallFloat(o, "get_damping_relaxation")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleWheel) GetFrictionSlip() float64 {
	log.Println("Calling VehicleWheel.GetFrictionSlip()")

	returnValue := godotCallFloat(o, "get_friction_slip")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleWheel) GetRadius() float64 {
	log.Println("Calling VehicleWheel.GetRadius()")

	returnValue := godotCallFloat(o, "get_radius")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleWheel) GetRollInfluence() float64 {
	log.Println("Calling VehicleWheel.GetRollInfluence()")

	returnValue := godotCallFloat(o, "get_roll_influence")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a value between 0.0 and 1.0 that indicates whether this wheel is skidding. 0.0 is not skidding, 1.0 means the wheel has lost grip.
*/
func (o *VehicleWheel) GetSkidinfo() float64 {
	log.Println("Calling VehicleWheel.GetSkidinfo()")

	returnValue := godotCallFloat(o, "get_skidinfo")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleWheel) GetSuspensionMaxForce() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionMaxForce()")

	returnValue := godotCallFloat(o, "get_suspension_max_force")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleWheel) GetSuspensionRestLength() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionRestLength()")

	returnValue := godotCallFloat(o, "get_suspension_rest_length")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleWheel) GetSuspensionStiffness() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionStiffness()")

	returnValue := godotCallFloat(o, "get_suspension_stiffness")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleWheel) GetSuspensionTravel() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionTravel()")

	returnValue := godotCallFloat(o, "get_suspension_travel")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns true if this wheel is in contact with a surface.
*/
func (o *VehicleWheel) IsInContact() bool {
	log.Println("Calling VehicleWheel.IsInContact()")

	returnValue := godotCallBool(o, "is_in_contact")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleWheel) IsUsedAsSteering() bool {
	log.Println("Calling VehicleWheel.IsUsedAsSteering()")

	returnValue := godotCallBool(o, "is_used_as_steering")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleWheel) IsUsedAsTraction() bool {
	log.Println("Calling VehicleWheel.IsUsedAsTraction()")

	returnValue := godotCallBool(o, "is_used_as_traction")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VehicleWheel) SetDampingCompression(length float64) {
	log.Println("Calling VehicleWheel.SetDampingCompression()")

	godotCallVoidFloat(o, "set_damping_compression", length)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleWheel) SetDampingRelaxation(length float64) {
	log.Println("Calling VehicleWheel.SetDampingRelaxation()")

	godotCallVoidFloat(o, "set_damping_relaxation", length)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleWheel) SetFrictionSlip(length float64) {
	log.Println("Calling VehicleWheel.SetFrictionSlip()")

	godotCallVoidFloat(o, "set_friction_slip", length)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleWheel) SetRadius(length float64) {
	log.Println("Calling VehicleWheel.SetRadius()")

	godotCallVoidFloat(o, "set_radius", length)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleWheel) SetRollInfluence(rollInfluence float64) {
	log.Println("Calling VehicleWheel.SetRollInfluence()")

	godotCallVoidFloat(o, "set_roll_influence", rollInfluence)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleWheel) SetSuspensionMaxForce(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionMaxForce()")

	godotCallVoidFloat(o, "set_suspension_max_force", length)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleWheel) SetSuspensionRestLength(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionRestLength()")

	godotCallVoidFloat(o, "set_suspension_rest_length", length)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleWheel) SetSuspensionStiffness(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionStiffness()")

	godotCallVoidFloat(o, "set_suspension_stiffness", length)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleWheel) SetSuspensionTravel(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionTravel()")

	godotCallVoidFloat(o, "set_suspension_travel", length)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleWheel) SetUseAsSteering(enable bool) {
	log.Println("Calling VehicleWheel.SetUseAsSteering()")

	godotCallVoidBool(o, "set_use_as_steering", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VehicleWheel) SetUseAsTraction(enable bool) {
	log.Println("Calling VehicleWheel.SetUseAsTraction()")

	godotCallVoidBool(o, "set_use_as_traction", enable)
	log.Println("  Function successfully completed.")

}

/*
   VehicleWheelImplementer is an interface for VehicleWheel objects.
*/
type VehicleWheelImplementer interface {
	Class
}

/*
   This control has the ability to play video streams. The only format accepted is the OGV Theora, so any other format must be converted before using in a project.
*/
type VideoPlayer struct {
	Control
}

func (o *VideoPlayer) baseClass() string {
	return "VideoPlayer"
}

/*
   Undocumented
*/
func (o *VideoPlayer) GetAudioTrack() int64 {
	log.Println("Calling VideoPlayer.GetAudioTrack()")

	returnValue := godotCallInt(o, "get_audio_track")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VideoPlayer) GetBufferingMsec() int64 {
	log.Println("Calling VideoPlayer.GetBufferingMsec()")

	returnValue := godotCallInt(o, "get_buffering_msec")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VideoPlayer) GetBus() string {
	log.Println("Calling VideoPlayer.GetBus()")

	returnValue := godotCallString(o, "get_bus")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VideoPlayer) GetStream() *VideoStream {
	log.Println("Calling VideoPlayer.GetStream()")

	returnValue := godotCallObject(o, "get_stream")
	log.Println("  Got return value: ", returnValue)

	var ret VideoStream
	ret.owner = returnValue.owner
	return &ret

}

/*
   Get the name of the video stream.
*/
func (o *VideoPlayer) GetStreamName() string {
	log.Println("Calling VideoPlayer.GetStreamName()")

	returnValue := godotCallString(o, "get_stream_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VideoPlayer) GetStreamPosition() float64 {
	log.Println("Calling VideoPlayer.GetStreamPosition()")

	returnValue := godotCallFloat(o, "get_stream_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the current frame of the video as a [Texture].
*/
func (o *VideoPlayer) GetVideoTexture() *Texture {
	log.Println("Calling VideoPlayer.GetVideoTexture()")

	returnValue := godotCallObject(o, "get_video_texture")
	log.Println("  Got return value: ", returnValue)

	var ret Texture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *VideoPlayer) GetVolume() float64 {
	log.Println("Calling VideoPlayer.GetVolume()")

	returnValue := godotCallFloat(o, "get_volume")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VideoPlayer) GetVolumeDb() float64 {
	log.Println("Calling VideoPlayer.GetVolumeDb()")

	returnValue := godotCallFloat(o, "get_volume_db")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VideoPlayer) HasAutoplay() bool {
	log.Println("Calling VideoPlayer.HasAutoplay()")

	returnValue := godotCallBool(o, "has_autoplay")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VideoPlayer) HasExpand() bool {
	log.Println("Calling VideoPlayer.HasExpand()")

	returnValue := godotCallBool(o, "has_expand")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VideoPlayer) IsPaused() bool {
	log.Println("Calling VideoPlayer.IsPaused()")

	returnValue := godotCallBool(o, "is_paused")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get whether or not the video is playing.
*/
func (o *VideoPlayer) IsPlaying() bool {
	log.Println("Calling VideoPlayer.IsPlaying()")

	returnValue := godotCallBool(o, "is_playing")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Start the video playback.
*/
func (o *VideoPlayer) Play() {
	log.Println("Calling VideoPlayer.Play()")

	godotCallVoid(o, "play")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VideoPlayer) SetAudioTrack(track int64) {
	log.Println("Calling VideoPlayer.SetAudioTrack()")

	godotCallVoidInt(o, "set_audio_track", track)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VideoPlayer) SetAutoplay(enabled bool) {
	log.Println("Calling VideoPlayer.SetAutoplay()")

	godotCallVoidBool(o, "set_autoplay", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VideoPlayer) SetBufferingMsec(msec int64) {
	log.Println("Calling VideoPlayer.SetBufferingMsec()")

	godotCallVoidInt(o, "set_buffering_msec", msec)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VideoPlayer) SetBus(bus string) {
	log.Println("Calling VideoPlayer.SetBus()")

	godotCallVoidString(o, "set_bus", bus)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VideoPlayer) SetExpand(enable bool) {
	log.Println("Calling VideoPlayer.SetExpand()")

	godotCallVoidBool(o, "set_expand", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VideoPlayer) SetPaused(paused bool) {
	log.Println("Calling VideoPlayer.SetPaused()")

	godotCallVoidBool(o, "set_paused", paused)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VideoPlayer) SetStream(stream *VideoStream) {
	log.Println("Calling VideoPlayer.SetStream()")

	godotCallVoidObject(o, "set_stream", &stream.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VideoPlayer) SetStreamPosition(position float64) {
	log.Println("Calling VideoPlayer.SetStreamPosition()")

	godotCallVoidFloat(o, "set_stream_position", position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VideoPlayer) SetVolume(volume float64) {
	log.Println("Calling VideoPlayer.SetVolume()")

	godotCallVoidFloat(o, "set_volume", volume)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VideoPlayer) SetVolumeDb(db float64) {
	log.Println("Calling VideoPlayer.SetVolumeDb()")

	godotCallVoidFloat(o, "set_volume_db", db)
	log.Println("  Function successfully completed.")

}

/*
   Stop the video playback.
*/
func (o *VideoPlayer) Stop() {
	log.Println("Calling VideoPlayer.Stop()")

	godotCallVoid(o, "stop")
	log.Println("  Function successfully completed.")

}

/*
   VideoPlayerImplementer is an interface for VideoPlayer objects.
*/
type VideoPlayerImplementer interface {
	Class
}

/*

 */
type VideoStream struct {
	Resource
}

func (o *VideoStream) baseClass() string {
	return "VideoStream"
}

/*
   VideoStreamImplementer is an interface for VideoStream objects.
*/
type VideoStreamImplementer interface {
	Class
}

/*
   Undocumented
*/
type VideoStreamTheora struct {
	VideoStream
}

func (o *VideoStreamTheora) baseClass() string {
	return "VideoStreamTheora"
}

/*
   Undocumented
*/
func (o *VideoStreamTheora) GetFile() string {
	log.Println("Calling VideoStreamTheora.GetFile()")

	returnValue := godotCallString(o, "get_file")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VideoStreamTheora) SetFile(file string) {
	log.Println("Calling VideoStreamTheora.SetFile()")

	godotCallVoidString(o, "set_file", file)
	log.Println("  Function successfully completed.")

}

/*
   VideoStreamTheoraImplementer is an interface for VideoStreamTheora objects.
*/
type VideoStreamTheoraImplementer interface {
	Class
}

/*
   Undocumented
*/
type VideoStreamWebm struct {
	VideoStream
}

func (o *VideoStreamWebm) baseClass() string {
	return "VideoStreamWebm"
}

/*
   Undocumented
*/
func (o *VideoStreamWebm) GetFile() string {
	log.Println("Calling VideoStreamWebm.GetFile()")

	returnValue := godotCallString(o, "get_file")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VideoStreamWebm) SetFile(file string) {
	log.Println("Calling VideoStreamWebm.SetFile()")

	godotCallVoidString(o, "set_file", file)
	log.Println("  Function successfully completed.")

}

/*
   VideoStreamWebmImplementer is an interface for VideoStreamWebm objects.
*/
type VideoStreamWebmImplementer interface {
	Class
}

/*
   A Viewport creates a different view into the screen, or a sub-view inside another viewport. Children 2D Nodes will display on it, and children Camera 3D nodes will render on it too. Optionally, a viewport can have its own 2D or 3D world, so they don't share what they draw with other viewports. If a viewport is a child of a [Control], it will automatically take up its same rect and position, otherwise they must be set manually. Viewports can also choose to be audio listeners, so they generate positional audio depending on a 2D or 3D camera child of it. Also, viewports can be assigned to different screens in case the devices have multiple screens. Finally, viewports can also behave as render targets, in which case they will not be visible unless the associated texture is used to draw.
*/
type Viewport struct {
	Node
}

func (o *Viewport) baseClass() string {
	return "Viewport"
}

/*
   Undocumented
*/
func (o *Viewport) X_GuiRemoveFocus() {
	log.Println("Calling Viewport.X_GuiRemoveFocus()")

	godotCallVoid(o, "_gui_remove_focus")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) X_GuiShowTooltip() {
	log.Println("Calling Viewport.X_GuiShowTooltip()")

	godotCallVoid(o, "_gui_show_tooltip")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) X_VpInput(arg0 *InputEvent) {
	log.Println("Calling Viewport.X_VpInput()")

	godotCallVoidObject(o, "_vp_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) X_VpInputText(text string) {
	log.Println("Calling Viewport.X_VpInputText()")

	godotCallVoidString(o, "_vp_input_text", text)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) X_VpUnhandledInput(arg0 *InputEvent) {
	log.Println("Calling Viewport.X_VpUnhandledInput()")

	godotCallVoidObject(o, "_vp_unhandled_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Return the 3D world of the viewport, or if no such present, the one of the parent viewport.
*/
func (o *Viewport) FindWorld() *World {
	log.Println("Calling Viewport.FindWorld()")

	returnValue := godotCallObject(o, "find_world")
	log.Println("  Got return value: ", returnValue)

	var ret World
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the 2D world of the viewport.
*/
func (o *Viewport) FindWorld2D() *World2D {
	log.Println("Calling Viewport.FindWorld2D()")

	returnValue := godotCallObject(o, "find_world_2d")
	log.Println("  Got return value: ", returnValue)

	var ret World2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Return the active 3D camera.
*/
func (o *Viewport) GetCamera() *Camera {
	log.Println("Calling Viewport.GetCamera()")

	returnValue := godotCallObject(o, "get_camera")
	log.Println("  Got return value: ", returnValue)

	var ret Camera
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Viewport) GetCanvasTransform() *Transform2D {
	log.Println("Calling Viewport.GetCanvasTransform()")

	returnValue := godotCallTransform2D(o, "get_canvas_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetClearMode() int64 {
	log.Println("Calling Viewport.GetClearMode()")

	returnValue := godotCallInt(o, "get_clear_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetDebugDraw() int64 {
	log.Println("Calling Viewport.GetDebugDraw()")

	returnValue := godotCallInt(o, "get_debug_draw")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the total transform of the viewport.
*/
func (o *Viewport) GetFinalTransform() *Transform2D {
	log.Println("Calling Viewport.GetFinalTransform()")

	returnValue := godotCallTransform2D(o, "get_final_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetGlobalCanvasTransform() *Transform2D {
	log.Println("Calling Viewport.GetGlobalCanvasTransform()")

	returnValue := godotCallTransform2D(o, "get_global_canvas_transform")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetHdr() bool {
	log.Println("Calling Viewport.GetHdr()")

	returnValue := godotCallBool(o, "get_hdr")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the mouse position, relative to the viewport.
*/
func (o *Viewport) GetMousePosition() *Vector2 {
	log.Println("Calling Viewport.GetMousePosition()")

	returnValue := godotCallVector2(o, "get_mouse_position")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetMsaa() int64 {
	log.Println("Calling Viewport.GetMsaa()")

	returnValue := godotCallInt(o, "get_msaa")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetPhysicsObjectPicking() bool {
	log.Println("Calling Viewport.GetPhysicsObjectPicking()")

	returnValue := godotCallBool(o, "get_physics_object_picking")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the specific information about the viewport from rendering pipeline.
*/
func (o *Viewport) GetRenderInfo(info int64) int64 {
	log.Println("Calling Viewport.GetRenderInfo()")

	returnValue := godotCallIntInt(o, "get_render_info", info)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetShadowAtlasQuadrantSubdiv(quadrant int64) int64 {
	log.Println("Calling Viewport.GetShadowAtlasQuadrantSubdiv()")

	returnValue := godotCallIntInt(o, "get_shadow_atlas_quadrant_subdiv", quadrant)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetShadowAtlasSize() int64 {
	log.Println("Calling Viewport.GetShadowAtlasSize()")

	returnValue := godotCallInt(o, "get_shadow_atlas_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetSize() *Vector2 {
	log.Println("Calling Viewport.GetSize()")

	returnValue := godotCallVector2(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the size override set with [method set_size_override].
*/
func (o *Viewport) GetSizeOverride() *Vector2 {
	log.Println("Calling Viewport.GetSizeOverride()")

	returnValue := godotCallVector2(o, "get_size_override")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the viewport's texture, for use with various objects that you want to texture with the viewport.
*/
func (o *Viewport) GetTexture() *ViewportTexture {
	log.Println("Calling Viewport.GetTexture()")

	returnValue := godotCallObject(o, "get_texture")
	log.Println("  Got return value: ", returnValue)

	var ret ViewportTexture
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Viewport) GetUpdateMode() int64 {
	log.Println("Calling Viewport.GetUpdateMode()")

	returnValue := godotCallInt(o, "get_update_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetUsage() int64 {
	log.Println("Calling Viewport.GetUsage()")

	returnValue := godotCallInt(o, "get_usage")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetVflip() bool {
	log.Println("Calling Viewport.GetVflip()")

	returnValue := godotCallBool(o, "get_vflip")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the viewport RID from the [VisualServer].
*/
func (o *Viewport) GetViewportRid() *RID {
	log.Println("Calling Viewport.GetViewportRid()")

	returnValue := godotCallRid(o, "get_viewport_rid")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Return the final, visible rect in global screen coordinates.
*/
func (o *Viewport) GetVisibleRect() *Rect2 {
	log.Println("Calling Viewport.GetVisibleRect()")

	returnValue := godotCallRect2(o, "get_visible_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) GetWorld() *World {
	log.Println("Calling Viewport.GetWorld()")

	returnValue := godotCallObject(o, "get_world")
	log.Println("  Got return value: ", returnValue)

	var ret World
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *Viewport) GetWorld2D() *World2D {
	log.Println("Calling Viewport.GetWorld2D()")

	returnValue := godotCallObject(o, "get_world_2d")
	log.Println("  Got return value: ", returnValue)

	var ret World2D
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the drag data from the GUI, that was previously returned by [method Control.get_drag_data].
*/
func (o *Viewport) GuiGetDragData() *Variant {
	log.Println("Calling Viewport.GuiGetDragData()")

	returnValue := godotCallVariant(o, "gui_get_drag_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns whether there are shown modals on-screen.
*/
func (o *Viewport) GuiHasModalStack() bool {
	log.Println("Calling Viewport.GuiHasModalStack()")

	returnValue := godotCallBool(o, "gui_has_modal_stack")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) HasTransparentBackground() bool {
	log.Println("Calling Viewport.HasTransparentBackground()")

	returnValue := godotCallBool(o, "has_transparent_background")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *Viewport) Input(localEvent *InputEvent) {
	log.Println("Calling Viewport.Input()")

	godotCallVoidObject(o, "input", &localEvent.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) Is3DDisabled() bool {
	log.Println("Calling Viewport.Is3DDisabled()")

	returnValue := godotCallBool(o, "is_3d_disabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) IsAudioListener() bool {
	log.Println("Calling Viewport.IsAudioListener()")

	returnValue := godotCallBool(o, "is_audio_listener")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) IsAudioListener2D() bool {
	log.Println("Calling Viewport.IsAudioListener2D()")

	returnValue := godotCallBool(o, "is_audio_listener_2d")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) IsInputDisabled() bool {
	log.Println("Calling Viewport.IsInputDisabled()")

	returnValue := godotCallBool(o, "is_input_disabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the enabled status of the size override set with [method set_size_override].
*/
func (o *Viewport) IsSizeOverrideEnabled() bool {
	log.Println("Calling Viewport.IsSizeOverrideEnabled()")

	returnValue := godotCallBool(o, "is_size_override_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the enabled status of the size stretch override set with [method set_size_override_stretch].
*/
func (o *Viewport) IsSizeOverrideStretchEnabled() bool {
	log.Println("Calling Viewport.IsSizeOverrideStretchEnabled()")

	returnValue := godotCallBool(o, "is_size_override_stretch_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) IsSnapControlsToPixelsEnabled() bool {
	log.Println("Calling Viewport.IsSnapControlsToPixelsEnabled()")

	returnValue := godotCallBool(o, "is_snap_controls_to_pixels_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) IsUsingOwnWorld() bool {
	log.Println("Calling Viewport.IsUsingOwnWorld()")

	returnValue := godotCallBool(o, "is_using_own_world")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *Viewport) SetAsAudioListener(enable bool) {
	log.Println("Calling Viewport.SetAsAudioListener()")

	godotCallVoidBool(o, "set_as_audio_listener", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetAsAudioListener2D(enable bool) {
	log.Println("Calling Viewport.SetAsAudioListener2D()")

	godotCallVoidBool(o, "set_as_audio_listener_2d", enable)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Viewport) SetAttachToScreenRect(rect *Rect2) {
	log.Println("Calling Viewport.SetAttachToScreenRect()")

	godotCallVoidRect2(o, "set_attach_to_screen_rect", rect)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetCanvasTransform(xform *Transform2D) {
	log.Println("Calling Viewport.SetCanvasTransform()")

	godotCallVoidTransform2D(o, "set_canvas_transform", xform)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetClearMode(mode int64) {
	log.Println("Calling Viewport.SetClearMode()")

	godotCallVoidInt(o, "set_clear_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetDebugDraw(debugDraw int64) {
	log.Println("Calling Viewport.SetDebugDraw()")

	godotCallVoidInt(o, "set_debug_draw", debugDraw)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetDisable3D(disable bool) {
	log.Println("Calling Viewport.SetDisable3D()")

	godotCallVoidBool(o, "set_disable_3d", disable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetDisableInput(disable bool) {
	log.Println("Calling Viewport.SetDisableInput()")

	godotCallVoidBool(o, "set_disable_input", disable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetGlobalCanvasTransform(xform *Transform2D) {
	log.Println("Calling Viewport.SetGlobalCanvasTransform()")

	godotCallVoidTransform2D(o, "set_global_canvas_transform", xform)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetHdr(enable bool) {
	log.Println("Calling Viewport.SetHdr()")

	godotCallVoidBool(o, "set_hdr", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetMsaa(msaa int64) {
	log.Println("Calling Viewport.SetMsaa()")

	godotCallVoidInt(o, "set_msaa", msaa)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetPhysicsObjectPicking(enable bool) {
	log.Println("Calling Viewport.SetPhysicsObjectPicking()")

	godotCallVoidBool(o, "set_physics_object_picking", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetShadowAtlasQuadrantSubdiv(quadrant int64, subdiv int64) {
	log.Println("Calling Viewport.SetShadowAtlasQuadrantSubdiv()")

	godotCallVoidIntInt(o, "set_shadow_atlas_quadrant_subdiv", quadrant, subdiv)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetShadowAtlasSize(size int64) {
	log.Println("Calling Viewport.SetShadowAtlasSize()")

	godotCallVoidInt(o, "set_shadow_atlas_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetSize(size *Vector2) {
	log.Println("Calling Viewport.SetSize()")

	godotCallVoidVector2(o, "set_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Set the size override of the viewport. If the enable parameter is true, it would use the override, otherwise it would use the default size. If the size parameter is equal to [code](-1, -1)[/code], it won't update the size.
*/
func (o *Viewport) SetSizeOverride(enable bool, size *Vector2, margin *Vector2) {
	log.Println("Calling Viewport.SetSizeOverride()")

	godotCallVoidBoolVector2Vector2(o, "set_size_override", enable, size, margin)
	log.Println("  Function successfully completed.")

}

/*
   Set whether the size override affects stretch as well.
*/
func (o *Viewport) SetSizeOverrideStretch(enabled bool) {
	log.Println("Calling Viewport.SetSizeOverrideStretch()")

	godotCallVoidBool(o, "set_size_override_stretch", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetSnapControlsToPixels(enabled bool) {
	log.Println("Calling Viewport.SetSnapControlsToPixels()")

	godotCallVoidBool(o, "set_snap_controls_to_pixels", enabled)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetTransparentBackground(enable bool) {
	log.Println("Calling Viewport.SetTransparentBackground()")

	godotCallVoidBool(o, "set_transparent_background", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetUpdateMode(mode int64) {
	log.Println("Calling Viewport.SetUpdateMode()")

	godotCallVoidInt(o, "set_update_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetUsage(usage int64) {
	log.Println("Calling Viewport.SetUsage()")

	godotCallVoidInt(o, "set_usage", usage)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetUseArvr(use bool) {
	log.Println("Calling Viewport.SetUseArvr()")

	godotCallVoidBool(o, "set_use_arvr", use)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetUseOwnWorld(enable bool) {
	log.Println("Calling Viewport.SetUseOwnWorld()")

	godotCallVoidBool(o, "set_use_own_world", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetVflip(enable bool) {
	log.Println("Calling Viewport.SetVflip()")

	godotCallVoidBool(o, "set_vflip", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetWorld(world *World) {
	log.Println("Calling Viewport.SetWorld()")

	godotCallVoidObject(o, "set_world", &world.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) SetWorld2D(world2D *World2D) {
	log.Println("Calling Viewport.SetWorld2D()")

	godotCallVoidObject(o, "set_world_2d", &world2D.Object)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Viewport) UnhandledInput(localEvent *InputEvent) {
	log.Println("Calling Viewport.UnhandledInput()")

	godotCallVoidObject(o, "unhandled_input", &localEvent.Object)
	log.Println("  Function successfully completed.")

}

/*
   Force update of the 2D and 3D worlds.
*/
func (o *Viewport) UpdateWorlds() {
	log.Println("Calling Viewport.UpdateWorlds()")

	godotCallVoid(o, "update_worlds")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Viewport) UseArvr() bool {
	log.Println("Calling Viewport.UseArvr()")

	returnValue := godotCallBool(o, "use_arvr")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Warp the mouse to a position, relative to the viewport.
*/
func (o *Viewport) WarpMouse(toPosition *Vector2) {
	log.Println("Calling Viewport.WarpMouse()")

	godotCallVoidVector2(o, "warp_mouse", toPosition)
	log.Println("  Function successfully completed.")

}

/*
   ViewportImplementer is an interface for Viewport objects.
*/
type ViewportImplementer interface {
	Class
}

/*

 */
type ViewportContainer struct {
	Container
}

func (o *ViewportContainer) baseClass() string {
	return "ViewportContainer"
}

/*
   Undocumented
*/
func (o *ViewportContainer) X_Input(event *InputEvent) {
	log.Println("Calling ViewportContainer.X_Input()")

	godotCallVoidObject(o, "_input", &event.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ViewportContainer) GetStretchShrink() int64 {
	log.Println("Calling ViewportContainer.GetStretchShrink()")

	returnValue := godotCallInt(o, "get_stretch_shrink")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ViewportContainer) IsStretchEnabled() bool {
	log.Println("Calling ViewportContainer.IsStretchEnabled()")

	returnValue := godotCallBool(o, "is_stretch_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ViewportContainer) SetStretch(enable bool) {
	log.Println("Calling ViewportContainer.SetStretch()")

	godotCallVoidBool(o, "set_stretch", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *ViewportContainer) SetStretchShrink(amount int64) {
	log.Println("Calling ViewportContainer.SetStretchShrink()")

	godotCallVoidInt(o, "set_stretch_shrink", amount)
	log.Println("  Function successfully completed.")

}

/*
   ViewportContainerImplementer is an interface for ViewportContainer objects.
*/
type ViewportContainerImplementer interface {
	Class
}

/*

 */
type ViewportTexture struct {
	Texture
}

func (o *ViewportTexture) baseClass() string {
	return "ViewportTexture"
}

/*
   Undocumented
*/
func (o *ViewportTexture) GetViewportPathInScene() *NodePath {
	log.Println("Calling ViewportTexture.GetViewportPathInScene()")

	returnValue := godotCallNodePath(o, "get_viewport_path_in_scene")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *ViewportTexture) SetViewportPathInScene(path *NodePath) {
	log.Println("Calling ViewportTexture.SetViewportPathInScene()")

	godotCallVoidNodePath(o, "set_viewport_path_in_scene", path)
	log.Println("  Function successfully completed.")

}

/*
   ViewportTextureImplementer is an interface for ViewportTexture objects.
*/
type ViewportTextureImplementer interface {
	Class
}

/*
   The VisibilityEnabler will disable [RigidBody] and [AnimationPlayer] nodes when they are not visible. It will only affect other nodes within the same scene as the VisibilityEnabler itself.
*/
type VisibilityEnabler struct {
	VisibilityNotifier
}

func (o *VisibilityEnabler) baseClass() string {
	return "VisibilityEnabler"
}

/*
   Undocumented
*/
func (o *VisibilityEnabler) X_NodeRemoved(arg0 *Object) {
	log.Println("Calling VisibilityEnabler.X_NodeRemoved()")

	godotCallVoidObject(o, "_node_removed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisibilityEnabler) IsEnablerEnabled(enabler int64) bool {
	log.Println("Calling VisibilityEnabler.IsEnablerEnabled()")

	returnValue := godotCallBoolInt(o, "is_enabler_enabled", enabler)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisibilityEnabler) SetEnabler(enabler int64, enabled bool) {
	log.Println("Calling VisibilityEnabler.SetEnabler()")

	godotCallVoidIntBool(o, "set_enabler", enabler, enabled)
	log.Println("  Function successfully completed.")

}

/*
   VisibilityEnablerImplementer is an interface for VisibilityEnabler objects.
*/
type VisibilityEnablerImplementer interface {
	Class
}

/*
   The VisibilityEnabler2D will disable [RigidBody2D], [AnimationPlayer], and other nodes when they are not visible. It will only affect other nodes within the same scene as the VisibilityEnabler2D itself.
*/
type VisibilityEnabler2D struct {
	VisibilityNotifier2D
}

func (o *VisibilityEnabler2D) baseClass() string {
	return "VisibilityEnabler2D"
}

/*
   Undocumented
*/
func (o *VisibilityEnabler2D) X_NodeRemoved(arg0 *Object) {
	log.Println("Calling VisibilityEnabler2D.X_NodeRemoved()")

	godotCallVoidObject(o, "_node_removed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisibilityEnabler2D) IsEnablerEnabled(enabler int64) bool {
	log.Println("Calling VisibilityEnabler2D.IsEnablerEnabled()")

	returnValue := godotCallBoolInt(o, "is_enabler_enabled", enabler)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisibilityEnabler2D) SetEnabler(enabler int64, enabled bool) {
	log.Println("Calling VisibilityEnabler2D.SetEnabler()")

	godotCallVoidIntBool(o, "set_enabler", enabler, enabled)
	log.Println("  Function successfully completed.")

}

/*
   VisibilityEnabler2DImplementer is an interface for VisibilityEnabler2D objects.
*/
type VisibilityEnabler2DImplementer interface {
	Class
}

/*
   The VisibilityNotifier detects when it is visible on the screen. It also notifies when its bounding rectangle enters or exits the screen or a [Camera]'s view.
*/
type VisibilityNotifier struct {
	Spatial
}

func (o *VisibilityNotifier) baseClass() string {
	return "VisibilityNotifier"
}

/*
   Undocumented
*/
func (o *VisibilityNotifier) GetAabb() *AABB {
	log.Println("Calling VisibilityNotifier.GetAabb()")

	returnValue := godotCallAabb(o, "get_aabb")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the bounding box is on the screen.
*/
func (o *VisibilityNotifier) IsOnScreen() bool {
	log.Println("Calling VisibilityNotifier.IsOnScreen()")

	returnValue := godotCallBool(o, "is_on_screen")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisibilityNotifier) SetAabb(rect *AABB) {
	log.Println("Calling VisibilityNotifier.SetAabb()")

	godotCallVoidAabb(o, "set_aabb", rect)
	log.Println("  Function successfully completed.")

}

/*
   VisibilityNotifierImplementer is an interface for VisibilityNotifier objects.
*/
type VisibilityNotifierImplementer interface {
	Class
}

/*
   The VisibilityNotifier2D detects when it is visible on the screen. It also notifies when its bounding rectangle enters or exits the screen or a viewport.
*/
type VisibilityNotifier2D struct {
	Node2D
}

func (o *VisibilityNotifier2D) baseClass() string {
	return "VisibilityNotifier2D"
}

/*
   Undocumented
*/
func (o *VisibilityNotifier2D) GetRect() *Rect2 {
	log.Println("Calling VisibilityNotifier2D.GetRect()")

	returnValue := godotCallRect2(o, "get_rect")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   If [code]true[/code] the bounding rectangle is on the screen.
*/
func (o *VisibilityNotifier2D) IsOnScreen() bool {
	log.Println("Calling VisibilityNotifier2D.IsOnScreen()")

	returnValue := godotCallBool(o, "is_on_screen")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisibilityNotifier2D) SetRect(rect *Rect2) {
	log.Println("Calling VisibilityNotifier2D.SetRect()")

	godotCallVoidRect2(o, "set_rect", rect)
	log.Println("  Function successfully completed.")

}

/*
   VisibilityNotifier2DImplementer is an interface for VisibilityNotifier2D objects.
*/
type VisibilityNotifier2DImplementer interface {
	Class
}

/*

 */
type VisualInstance struct {
	Spatial
}

func (o *VisualInstance) baseClass() string {
	return "VisualInstance"
}

/*
   Undocumented
*/
func (o *VisualInstance) X_GetVisualInstanceRid() *RID {
	log.Println("Calling VisualInstance.X_GetVisualInstanceRid()")

	returnValue := godotCallRid(o, "_get_visual_instance_rid")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the [AABB] (also known as the bounding box) for this VisualInstance.
*/
func (o *VisualInstance) GetAabb() *AABB {
	log.Println("Calling VisualInstance.GetAabb()")

	returnValue := godotCallAabb(o, "get_aabb")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualInstance) GetLayerMask() int64 {
	log.Println("Calling VisualInstance.GetLayerMask()")

	returnValue := godotCallInt(o, "get_layer_mask")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the transformed [AABB] (also known as the bounding box) for this VisualInstance. Transformed in this case means the [AABB] plus the position, rotation, and scale of the [Spatial]s [Transform]
*/
func (o *VisualInstance) GetTransformedAabb() *AABB {
	log.Println("Calling VisualInstance.GetTransformedAabb()")

	returnValue := godotCallAabb(o, "get_transformed_aabb")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the base of the VisualInstance, which changes how the engine handles the VisualInstance under the hood. It is recommended to only use set_base if you know what you're doing.
*/
func (o *VisualInstance) SetBase(base *RID) {
	log.Println("Calling VisualInstance.SetBase()")

	godotCallVoidRid(o, "set_base", base)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualInstance) SetLayerMask(mask int64) {
	log.Println("Calling VisualInstance.SetLayerMask()")

	godotCallVoidInt(o, "set_layer_mask", mask)
	log.Println("  Function successfully completed.")

}

/*
   VisualInstanceImplementer is an interface for VisualInstance objects.
*/
type VisualInstanceImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScript struct {
	Script
}

func (o *VisualScript) baseClass() string {
	return "VisualScript"
}

/*
   Undocumented
*/
func (o *VisualScript) X_GetData() *Dictionary {
	log.Println("Calling VisualScript.X_GetData()")

	returnValue := godotCallDictionary(o, "_get_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) X_NodePortsChanged(arg0 int64) {
	log.Println("Calling VisualScript.X_NodePortsChanged()")

	godotCallVoidInt(o, "_node_ports_changed", arg0)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) X_SetData(data *Dictionary) {
	log.Println("Calling VisualScript.X_SetData()")

	godotCallVoidDictionary(o, "_set_data", data)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) AddCustomSignal(name string) {
	log.Println("Calling VisualScript.AddCustomSignal()")

	godotCallVoidString(o, "add_custom_signal", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) AddFunction(name string) {
	log.Println("Calling VisualScript.AddFunction()")

	godotCallVoidString(o, "add_function", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) AddNode(function string, id int64, node *VisualScriptNode, position *Vector2) {
	log.Println("Calling VisualScript.AddNode()")

	godotCallVoidStringIntObjectVector2(o, "add_node", function, id, &node.Object, position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) AddVariable(name string, defaultValue *Variant, export bool) {
	log.Println("Calling VisualScript.AddVariable()")

	godotCallVoidStringVariantBool(o, "add_variable", name, defaultValue, export)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) CustomSignalAddArgument(name string, aType int64, argname string, index int64) {
	log.Println("Calling VisualScript.CustomSignalAddArgument()")

	godotCallVoidStringIntStringInt(o, "custom_signal_add_argument", name, aType, argname, index)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) CustomSignalGetArgumentCount(name string) int64 {
	log.Println("Calling VisualScript.CustomSignalGetArgumentCount()")

	returnValue := godotCallIntString(o, "custom_signal_get_argument_count", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) CustomSignalGetArgumentName(name string, argidx int64) string {
	log.Println("Calling VisualScript.CustomSignalGetArgumentName()")

	returnValue := godotCallStringStringInt(o, "custom_signal_get_argument_name", name, argidx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) CustomSignalGetArgumentType(name string, argidx int64) int64 {
	log.Println("Calling VisualScript.CustomSignalGetArgumentType()")

	returnValue := godotCallIntStringInt(o, "custom_signal_get_argument_type", name, argidx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) CustomSignalRemoveArgument(name string, argidx int64) {
	log.Println("Calling VisualScript.CustomSignalRemoveArgument()")

	godotCallVoidStringInt(o, "custom_signal_remove_argument", name, argidx)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) CustomSignalSetArgumentName(name string, argidx int64, argname string) {
	log.Println("Calling VisualScript.CustomSignalSetArgumentName()")

	godotCallVoidStringIntString(o, "custom_signal_set_argument_name", name, argidx, argname)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) CustomSignalSetArgumentType(name string, argidx int64, aType int64) {
	log.Println("Calling VisualScript.CustomSignalSetArgumentType()")

	godotCallVoidStringIntInt(o, "custom_signal_set_argument_type", name, argidx, aType)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) CustomSignalSwapArgument(name string, argidx int64, withidx int64) {
	log.Println("Calling VisualScript.CustomSignalSwapArgument()")

	godotCallVoidStringIntInt(o, "custom_signal_swap_argument", name, argidx, withidx)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) DataConnect(function string, fromNode int64, fromPort int64, toNode int64, toPort int64) {
	log.Println("Calling VisualScript.DataConnect()")

	godotCallVoidStringIntIntIntInt(o, "data_connect", function, fromNode, fromPort, toNode, toPort)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) DataDisconnect(function string, fromNode int64, fromPort int64, toNode int64, toPort int64) {
	log.Println("Calling VisualScript.DataDisconnect()")

	godotCallVoidStringIntIntIntInt(o, "data_disconnect", function, fromNode, fromPort, toNode, toPort)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) GetFunctionNodeId(name string) int64 {
	log.Println("Calling VisualScript.GetFunctionNodeId()")

	returnValue := godotCallIntString(o, "get_function_node_id", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) GetFunctionScroll(name string) *Vector2 {
	log.Println("Calling VisualScript.GetFunctionScroll()")

	returnValue := godotCallVector2String(o, "get_function_scroll", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) GetNode(function string, id int64) *VisualScriptNode {
	log.Println("Calling VisualScript.GetNode()")

	returnValue := godotCallObjectStringInt(o, "get_node", function, id)
	log.Println("  Got return value: ", returnValue)

	var ret VisualScriptNode
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *VisualScript) GetNodePosition(function string, id int64) *Vector2 {
	log.Println("Calling VisualScript.GetNodePosition()")

	returnValue := godotCallVector2StringInt(o, "get_node_position", function, id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) GetVariableDefaultValue(name string) *Variant {
	log.Println("Calling VisualScript.GetVariableDefaultValue()")

	returnValue := godotCallVariantString(o, "get_variable_default_value", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) GetVariableExport(name string) bool {
	log.Println("Calling VisualScript.GetVariableExport()")

	returnValue := godotCallBoolString(o, "get_variable_export", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) GetVariableInfo(name string) *Dictionary {
	log.Println("Calling VisualScript.GetVariableInfo()")

	returnValue := godotCallDictionaryString(o, "get_variable_info", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) HasCustomSignal(name string) bool {
	log.Println("Calling VisualScript.HasCustomSignal()")

	returnValue := godotCallBoolString(o, "has_custom_signal", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) HasDataConnection(function string, fromNode int64, fromPort int64, toNode int64, toPort int64) bool {
	log.Println("Calling VisualScript.HasDataConnection()")

	returnValue := godotCallBoolStringIntIntIntInt(o, "has_data_connection", function, fromNode, fromPort, toNode, toPort)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) HasFunction(name string) bool {
	log.Println("Calling VisualScript.HasFunction()")

	returnValue := godotCallBoolString(o, "has_function", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) HasNode(function string, id int64) bool {
	log.Println("Calling VisualScript.HasNode()")

	returnValue := godotCallBoolStringInt(o, "has_node", function, id)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) HasSequenceConnection(function string, fromNode int64, fromOutput int64, toNode int64) bool {
	log.Println("Calling VisualScript.HasSequenceConnection()")

	returnValue := godotCallBoolStringIntIntInt(o, "has_sequence_connection", function, fromNode, fromOutput, toNode)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) HasVariable(name string) bool {
	log.Println("Calling VisualScript.HasVariable()")

	returnValue := godotCallBoolString(o, "has_variable", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScript) RemoveCustomSignal(name string) {
	log.Println("Calling VisualScript.RemoveCustomSignal()")

	godotCallVoidString(o, "remove_custom_signal", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) RemoveFunction(name string) {
	log.Println("Calling VisualScript.RemoveFunction()")

	godotCallVoidString(o, "remove_function", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) RemoveNode(function string, id int64) {
	log.Println("Calling VisualScript.RemoveNode()")

	godotCallVoidStringInt(o, "remove_node", function, id)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) RemoveVariable(name string) {
	log.Println("Calling VisualScript.RemoveVariable()")

	godotCallVoidString(o, "remove_variable", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) RenameCustomSignal(name string, newName string) {
	log.Println("Calling VisualScript.RenameCustomSignal()")

	godotCallVoidStringString(o, "rename_custom_signal", name, newName)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) RenameFunction(name string, newName string) {
	log.Println("Calling VisualScript.RenameFunction()")

	godotCallVoidStringString(o, "rename_function", name, newName)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) RenameVariable(name string, newName string) {
	log.Println("Calling VisualScript.RenameVariable()")

	godotCallVoidStringString(o, "rename_variable", name, newName)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) SequenceConnect(function string, fromNode int64, fromOutput int64, toNode int64) {
	log.Println("Calling VisualScript.SequenceConnect()")

	godotCallVoidStringIntIntInt(o, "sequence_connect", function, fromNode, fromOutput, toNode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) SequenceDisconnect(function string, fromNode int64, fromOutput int64, toNode int64) {
	log.Println("Calling VisualScript.SequenceDisconnect()")

	godotCallVoidStringIntIntInt(o, "sequence_disconnect", function, fromNode, fromOutput, toNode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) SetFunctionScroll(name string, ofs *Vector2) {
	log.Println("Calling VisualScript.SetFunctionScroll()")

	godotCallVoidStringVector2(o, "set_function_scroll", name, ofs)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) SetInstanceBaseType(aType string) {
	log.Println("Calling VisualScript.SetInstanceBaseType()")

	godotCallVoidString(o, "set_instance_base_type", aType)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) SetNodePosition(function string, id int64, position *Vector2) {
	log.Println("Calling VisualScript.SetNodePosition()")

	godotCallVoidStringIntVector2(o, "set_node_position", function, id, position)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) SetVariableDefaultValue(name string, value *Variant) {
	log.Println("Calling VisualScript.SetVariableDefaultValue()")

	godotCallVoidStringVariant(o, "set_variable_default_value", name, value)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) SetVariableExport(name string, enable bool) {
	log.Println("Calling VisualScript.SetVariableExport()")

	godotCallVoidStringBool(o, "set_variable_export", name, enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScript) SetVariableInfo(name string, value *Dictionary) {
	log.Println("Calling VisualScript.SetVariableInfo()")

	godotCallVoidStringDictionary(o, "set_variable_info", name, value)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptImplementer is an interface for VisualScript objects.
*/
type VisualScriptImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptBasicTypeConstant struct {
	VisualScriptNode
}

func (o *VisualScriptBasicTypeConstant) baseClass() string {
	return "VisualScriptBasicTypeConstant"
}

/*
   Undocumented
*/
func (o *VisualScriptBasicTypeConstant) GetBasicType() int64 {
	log.Println("Calling VisualScriptBasicTypeConstant.GetBasicType()")

	returnValue := godotCallInt(o, "get_basic_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptBasicTypeConstant) GetBasicTypeConstant() string {
	log.Println("Calling VisualScriptBasicTypeConstant.GetBasicTypeConstant()")

	returnValue := godotCallString(o, "get_basic_type_constant")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptBasicTypeConstant) SetBasicType(name int64) {
	log.Println("Calling VisualScriptBasicTypeConstant.SetBasicType()")

	godotCallVoidInt(o, "set_basic_type", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptBasicTypeConstant) SetBasicTypeConstant(name string) {
	log.Println("Calling VisualScriptBasicTypeConstant.SetBasicTypeConstant()")

	godotCallVoidString(o, "set_basic_type_constant", name)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptBasicTypeConstantImplementer is an interface for VisualScriptBasicTypeConstant objects.
*/
type VisualScriptBasicTypeConstantImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptBuiltinFunc struct {
	VisualScriptNode
}

func (o *VisualScriptBuiltinFunc) baseClass() string {
	return "VisualScriptBuiltinFunc"
}

/*
   Undocumented
*/
func (o *VisualScriptBuiltinFunc) GetFunc() int64 {
	log.Println("Calling VisualScriptBuiltinFunc.GetFunc()")

	returnValue := godotCallInt(o, "get_func")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptBuiltinFunc) SetFunc(which int64) {
	log.Println("Calling VisualScriptBuiltinFunc.SetFunc()")

	godotCallVoidInt(o, "set_func", which)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptBuiltinFuncImplementer is an interface for VisualScriptBuiltinFunc objects.
*/
type VisualScriptBuiltinFuncImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptClassConstant struct {
	VisualScriptNode
}

func (o *VisualScriptClassConstant) baseClass() string {
	return "VisualScriptClassConstant"
}

/*
   Undocumented
*/
func (o *VisualScriptClassConstant) GetBaseType() string {
	log.Println("Calling VisualScriptClassConstant.GetBaseType()")

	returnValue := godotCallString(o, "get_base_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptClassConstant) GetClassConstant() string {
	log.Println("Calling VisualScriptClassConstant.GetClassConstant()")

	returnValue := godotCallString(o, "get_class_constant")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptClassConstant) SetBaseType(name string) {
	log.Println("Calling VisualScriptClassConstant.SetBaseType()")

	godotCallVoidString(o, "set_base_type", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptClassConstant) SetClassConstant(name string) {
	log.Println("Calling VisualScriptClassConstant.SetClassConstant()")

	godotCallVoidString(o, "set_class_constant", name)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptClassConstantImplementer is an interface for VisualScriptClassConstant objects.
*/
type VisualScriptClassConstantImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptComment struct {
	VisualScriptNode
}

func (o *VisualScriptComment) baseClass() string {
	return "VisualScriptComment"
}

/*
   Undocumented
*/
func (o *VisualScriptComment) GetDescription() string {
	log.Println("Calling VisualScriptComment.GetDescription()")

	returnValue := godotCallString(o, "get_description")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptComment) GetSize() *Vector2 {
	log.Println("Calling VisualScriptComment.GetSize()")

	returnValue := godotCallVector2(o, "get_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptComment) GetTitle() string {
	log.Println("Calling VisualScriptComment.GetTitle()")

	returnValue := godotCallString(o, "get_title")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptComment) SetDescription(description string) {
	log.Println("Calling VisualScriptComment.SetDescription()")

	godotCallVoidString(o, "set_description", description)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptComment) SetSize(size *Vector2) {
	log.Println("Calling VisualScriptComment.SetSize()")

	godotCallVoidVector2(o, "set_size", size)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptComment) SetTitle(title string) {
	log.Println("Calling VisualScriptComment.SetTitle()")

	godotCallVoidString(o, "set_title", title)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptCommentImplementer is an interface for VisualScriptComment objects.
*/
type VisualScriptCommentImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptCondition struct {
	VisualScriptNode
}

func (o *VisualScriptCondition) baseClass() string {
	return "VisualScriptCondition"
}

/*
   VisualScriptConditionImplementer is an interface for VisualScriptCondition objects.
*/
type VisualScriptConditionImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptConstant struct {
	VisualScriptNode
}

func (o *VisualScriptConstant) baseClass() string {
	return "VisualScriptConstant"
}

/*
   Undocumented
*/
func (o *VisualScriptConstant) GetConstantType() int64 {
	log.Println("Calling VisualScriptConstant.GetConstantType()")

	returnValue := godotCallInt(o, "get_constant_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptConstant) GetConstantValue() *Variant {
	log.Println("Calling VisualScriptConstant.GetConstantValue()")

	returnValue := godotCallVariant(o, "get_constant_value")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptConstant) SetConstantType(aType int64) {
	log.Println("Calling VisualScriptConstant.SetConstantType()")

	godotCallVoidInt(o, "set_constant_type", aType)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptConstant) SetConstantValue(value *Variant) {
	log.Println("Calling VisualScriptConstant.SetConstantValue()")

	godotCallVoidVariant(o, "set_constant_value", value)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptConstantImplementer is an interface for VisualScriptConstant objects.
*/
type VisualScriptConstantImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptConstructor struct {
	VisualScriptNode
}

func (o *VisualScriptConstructor) baseClass() string {
	return "VisualScriptConstructor"
}

/*
   Undocumented
*/
func (o *VisualScriptConstructor) GetConstructor() *Dictionary {
	log.Println("Calling VisualScriptConstructor.GetConstructor()")

	returnValue := godotCallDictionary(o, "get_constructor")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptConstructor) GetConstructorType() int64 {
	log.Println("Calling VisualScriptConstructor.GetConstructorType()")

	returnValue := godotCallInt(o, "get_constructor_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptConstructor) SetConstructor(constructor *Dictionary) {
	log.Println("Calling VisualScriptConstructor.SetConstructor()")

	godotCallVoidDictionary(o, "set_constructor", constructor)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptConstructor) SetConstructorType(aType int64) {
	log.Println("Calling VisualScriptConstructor.SetConstructorType()")

	godotCallVoidInt(o, "set_constructor_type", aType)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptConstructorImplementer is an interface for VisualScriptConstructor objects.
*/
type VisualScriptConstructorImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptCustomNode struct {
	VisualScriptNode
}

func (o *VisualScriptCustomNode) baseClass() string {
	return "VisualScriptCustomNode"
}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetCaption() string {
	log.Println("Calling VisualScriptCustomNode.X_GetCaption()")

	returnValue := godotCallString(o, "_get_caption")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetCategory() string {
	log.Println("Calling VisualScriptCustomNode.X_GetCategory()")

	returnValue := godotCallString(o, "_get_category")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetInputValuePortCount() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetInputValuePortCount()")

	returnValue := godotCallInt(o, "_get_input_value_port_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetInputValuePortName(idx int64) string {
	log.Println("Calling VisualScriptCustomNode.X_GetInputValuePortName()")

	returnValue := godotCallStringInt(o, "_get_input_value_port_name", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetInputValuePortType(idx int64) int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetInputValuePortType()")

	returnValue := godotCallIntInt(o, "_get_input_value_port_type", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetOutputSequencePortCount() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputSequencePortCount()")

	returnValue := godotCallInt(o, "_get_output_sequence_port_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetOutputSequencePortText(idx int64) string {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputSequencePortText()")

	returnValue := godotCallStringInt(o, "_get_output_sequence_port_text", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetOutputValuePortCount() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputValuePortCount()")

	returnValue := godotCallInt(o, "_get_output_value_port_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetOutputValuePortName(idx int64) string {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputValuePortName()")

	returnValue := godotCallStringInt(o, "_get_output_value_port_name", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetOutputValuePortType(idx int64) int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputValuePortType()")

	returnValue := godotCallIntInt(o, "_get_output_value_port_type", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetText() string {
	log.Println("Calling VisualScriptCustomNode.X_GetText()")

	returnValue := godotCallString(o, "_get_text")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_GetWorkingMemorySize() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetWorkingMemorySize()")

	returnValue := godotCallInt(o, "_get_working_memory_size")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_HasInputSequencePort() bool {
	log.Println("Calling VisualScriptCustomNode.X_HasInputSequencePort()")

	returnValue := godotCallBool(o, "_has_input_sequence_port")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_ScriptChanged() {
	log.Println("Calling VisualScriptCustomNode.X_ScriptChanged()")

	godotCallVoid(o, "_script_changed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptCustomNode) X_Step(inputs *Array, outputs *Array, startMode int64, workingMem *Array) *Variant {
	log.Println("Calling VisualScriptCustomNode.X_Step()")

	returnValue := godotCallVariantArrayArrayIntArray(o, "_step", inputs, outputs, startMode, workingMem)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   VisualScriptCustomNodeImplementer is an interface for VisualScriptCustomNode objects.
*/
type VisualScriptCustomNodeImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptDeconstruct struct {
	VisualScriptNode
}

func (o *VisualScriptDeconstruct) baseClass() string {
	return "VisualScriptDeconstruct"
}

/*
   Undocumented
*/
func (o *VisualScriptDeconstruct) X_GetElemCache() *Array {
	log.Println("Calling VisualScriptDeconstruct.X_GetElemCache()")

	returnValue := godotCallArray(o, "_get_elem_cache")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptDeconstruct) X_SetElemCache(cache *Array) {
	log.Println("Calling VisualScriptDeconstruct.X_SetElemCache()")

	godotCallVoidArray(o, "_set_elem_cache", cache)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptDeconstruct) GetDeconstructType() int64 {
	log.Println("Calling VisualScriptDeconstruct.GetDeconstructType()")

	returnValue := godotCallInt(o, "get_deconstruct_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptDeconstruct) SetDeconstructType(aType int64) {
	log.Println("Calling VisualScriptDeconstruct.SetDeconstructType()")

	godotCallVoidInt(o, "set_deconstruct_type", aType)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptDeconstructImplementer is an interface for VisualScriptDeconstruct objects.
*/
type VisualScriptDeconstructImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptEmitSignal struct {
	VisualScriptNode
}

func (o *VisualScriptEmitSignal) baseClass() string {
	return "VisualScriptEmitSignal"
}

/*
   Undocumented
*/
func (o *VisualScriptEmitSignal) GetSignal() string {
	log.Println("Calling VisualScriptEmitSignal.GetSignal()")

	returnValue := godotCallString(o, "get_signal")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptEmitSignal) SetSignal(name string) {
	log.Println("Calling VisualScriptEmitSignal.SetSignal()")

	godotCallVoidString(o, "set_signal", name)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptEmitSignalImplementer is an interface for VisualScriptEmitSignal objects.
*/
type VisualScriptEmitSignalImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptEngineSingleton struct {
	VisualScriptNode
}

func (o *VisualScriptEngineSingleton) baseClass() string {
	return "VisualScriptEngineSingleton"
}

/*
   Undocumented
*/
func (o *VisualScriptEngineSingleton) GetSingleton() string {
	log.Println("Calling VisualScriptEngineSingleton.GetSingleton()")

	returnValue := godotCallString(o, "get_singleton")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptEngineSingleton) SetSingleton(name string) {
	log.Println("Calling VisualScriptEngineSingleton.SetSingleton()")

	godotCallVoidString(o, "set_singleton", name)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptEngineSingletonImplementer is an interface for VisualScriptEngineSingleton objects.
*/
type VisualScriptEngineSingletonImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptExpression struct {
	VisualScriptNode
}

func (o *VisualScriptExpression) baseClass() string {
	return "VisualScriptExpression"
}

/*
   VisualScriptExpressionImplementer is an interface for VisualScriptExpression objects.
*/
type VisualScriptExpressionImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptFunction struct {
	VisualScriptNode
}

func (o *VisualScriptFunction) baseClass() string {
	return "VisualScriptFunction"
}

/*
   VisualScriptFunctionImplementer is an interface for VisualScriptFunction objects.
*/
type VisualScriptFunctionImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptFunctionCall struct {
	VisualScriptNode
}

func (o *VisualScriptFunctionCall) baseClass() string {
	return "VisualScriptFunctionCall"
}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) X_GetArgumentCache() *Dictionary {
	log.Println("Calling VisualScriptFunctionCall.X_GetArgumentCache()")

	returnValue := godotCallDictionary(o, "_get_argument_cache")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) X_SetArgumentCache(argumentCache *Dictionary) {
	log.Println("Calling VisualScriptFunctionCall.X_SetArgumentCache()")

	godotCallVoidDictionary(o, "_set_argument_cache", argumentCache)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptFunctionCall.GetBasePath()")

	returnValue := godotCallNodePath(o, "get_base_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) GetBaseScript() string {
	log.Println("Calling VisualScriptFunctionCall.GetBaseScript()")

	returnValue := godotCallString(o, "get_base_script")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) GetBaseType() string {
	log.Println("Calling VisualScriptFunctionCall.GetBaseType()")

	returnValue := godotCallString(o, "get_base_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) GetBasicType() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetBasicType()")

	returnValue := godotCallInt(o, "get_basic_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) GetCallMode() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetCallMode()")

	returnValue := godotCallInt(o, "get_call_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) GetFunction() string {
	log.Println("Calling VisualScriptFunctionCall.GetFunction()")

	returnValue := godotCallString(o, "get_function")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) GetRpcCallMode() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetRpcCallMode()")

	returnValue := godotCallInt(o, "get_rpc_call_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) GetSingleton() string {
	log.Println("Calling VisualScriptFunctionCall.GetSingleton()")

	returnValue := godotCallString(o, "get_singleton")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) GetUseDefaultArgs() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetUseDefaultArgs()")

	returnValue := godotCallInt(o, "get_use_default_args")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) GetValidate() bool {
	log.Println("Calling VisualScriptFunctionCall.GetValidate()")

	returnValue := godotCallBool(o, "get_validate")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptFunctionCall.SetBasePath()")

	godotCallVoidNodePath(o, "set_base_path", basePath)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) SetBaseScript(baseScript string) {
	log.Println("Calling VisualScriptFunctionCall.SetBaseScript()")

	godotCallVoidString(o, "set_base_script", baseScript)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptFunctionCall.SetBaseType()")

	godotCallVoidString(o, "set_base_type", baseType)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) SetBasicType(basicType int64) {
	log.Println("Calling VisualScriptFunctionCall.SetBasicType()")

	godotCallVoidInt(o, "set_basic_type", basicType)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptFunctionCall.SetCallMode()")

	godotCallVoidInt(o, "set_call_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) SetFunction(function string) {
	log.Println("Calling VisualScriptFunctionCall.SetFunction()")

	godotCallVoidString(o, "set_function", function)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) SetRpcCallMode(mode int64) {
	log.Println("Calling VisualScriptFunctionCall.SetRpcCallMode()")

	godotCallVoidInt(o, "set_rpc_call_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) SetSingleton(singleton string) {
	log.Println("Calling VisualScriptFunctionCall.SetSingleton()")

	godotCallVoidString(o, "set_singleton", singleton)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) SetUseDefaultArgs(amount int64) {
	log.Println("Calling VisualScriptFunctionCall.SetUseDefaultArgs()")

	godotCallVoidInt(o, "set_use_default_args", amount)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionCall) SetValidate(enable bool) {
	log.Println("Calling VisualScriptFunctionCall.SetValidate()")

	godotCallVoidBool(o, "set_validate", enable)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptFunctionCallImplementer is an interface for VisualScriptFunctionCall objects.
*/
type VisualScriptFunctionCallImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptFunctionState struct {
	Reference
}

func (o *VisualScriptFunctionState) baseClass() string {
	return "VisualScriptFunctionState"
}

/*
   Undocumented
*/
func (o *VisualScriptFunctionState) X_SignalCallback(varArgs ...interface{}) *Variant {
	log.Println("Calling VisualScriptFunctionState.X_SignalCallback()")

	varArgsArray := NewArray()
	for idx, varArg := range varArgs {
		// TODO: populate varargs array once Array methods implemented
		log.Println("Vararg idx=", idx, ": ", varArg)
	}

	returnValue := godotCallVariantVarargs(o, "_signal_callback", varArgsArray)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionState) ConnectToSignal(obj *Object, signals string, args *Array) {
	log.Println("Calling VisualScriptFunctionState.ConnectToSignal()")

	godotCallVoidObjectStringArray(o, "connect_to_signal", obj, signals, args)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionState) IsValid() bool {
	log.Println("Calling VisualScriptFunctionState.IsValid()")

	returnValue := godotCallBool(o, "is_valid")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptFunctionState) Resume(args *Array) *Variant {
	log.Println("Calling VisualScriptFunctionState.Resume()")

	returnValue := godotCallVariantArray(o, "resume", args)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   VisualScriptFunctionStateImplementer is an interface for VisualScriptFunctionState objects.
*/
type VisualScriptFunctionStateImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptGlobalConstant struct {
	VisualScriptNode
}

func (o *VisualScriptGlobalConstant) baseClass() string {
	return "VisualScriptGlobalConstant"
}

/*
   Undocumented
*/
func (o *VisualScriptGlobalConstant) GetGlobalConstant() int64 {
	log.Println("Calling VisualScriptGlobalConstant.GetGlobalConstant()")

	returnValue := godotCallInt(o, "get_global_constant")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptGlobalConstant) SetGlobalConstant(index int64) {
	log.Println("Calling VisualScriptGlobalConstant.SetGlobalConstant()")

	godotCallVoidInt(o, "set_global_constant", index)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptGlobalConstantImplementer is an interface for VisualScriptGlobalConstant objects.
*/
type VisualScriptGlobalConstantImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptIndexGet struct {
	VisualScriptNode
}

func (o *VisualScriptIndexGet) baseClass() string {
	return "VisualScriptIndexGet"
}

/*
   VisualScriptIndexGetImplementer is an interface for VisualScriptIndexGet objects.
*/
type VisualScriptIndexGetImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptIndexSet struct {
	VisualScriptNode
}

func (o *VisualScriptIndexSet) baseClass() string {
	return "VisualScriptIndexSet"
}

/*
   VisualScriptIndexSetImplementer is an interface for VisualScriptIndexSet objects.
*/
type VisualScriptIndexSetImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptInputAction struct {
	VisualScriptNode
}

func (o *VisualScriptInputAction) baseClass() string {
	return "VisualScriptInputAction"
}

/*
   Undocumented
*/
func (o *VisualScriptInputAction) GetActionMode() int64 {
	log.Println("Calling VisualScriptInputAction.GetActionMode()")

	returnValue := godotCallInt(o, "get_action_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptInputAction) GetActionName() string {
	log.Println("Calling VisualScriptInputAction.GetActionName()")

	returnValue := godotCallString(o, "get_action_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptInputAction) SetActionMode(mode int64) {
	log.Println("Calling VisualScriptInputAction.SetActionMode()")

	godotCallVoidInt(o, "set_action_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptInputAction) SetActionName(name string) {
	log.Println("Calling VisualScriptInputAction.SetActionName()")

	godotCallVoidString(o, "set_action_name", name)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptInputActionImplementer is an interface for VisualScriptInputAction objects.
*/
type VisualScriptInputActionImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptIterator struct {
	VisualScriptNode
}

func (o *VisualScriptIterator) baseClass() string {
	return "VisualScriptIterator"
}

/*
   VisualScriptIteratorImplementer is an interface for VisualScriptIterator objects.
*/
type VisualScriptIteratorImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptLocalVar struct {
	VisualScriptNode
}

func (o *VisualScriptLocalVar) baseClass() string {
	return "VisualScriptLocalVar"
}

/*
   Undocumented
*/
func (o *VisualScriptLocalVar) GetVarName() string {
	log.Println("Calling VisualScriptLocalVar.GetVarName()")

	returnValue := godotCallString(o, "get_var_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptLocalVar) GetVarType() int64 {
	log.Println("Calling VisualScriptLocalVar.GetVarType()")

	returnValue := godotCallInt(o, "get_var_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptLocalVar) SetVarName(name string) {
	log.Println("Calling VisualScriptLocalVar.SetVarName()")

	godotCallVoidString(o, "set_var_name", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptLocalVar) SetVarType(aType int64) {
	log.Println("Calling VisualScriptLocalVar.SetVarType()")

	godotCallVoidInt(o, "set_var_type", aType)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptLocalVarImplementer is an interface for VisualScriptLocalVar objects.
*/
type VisualScriptLocalVarImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptLocalVarSet struct {
	VisualScriptNode
}

func (o *VisualScriptLocalVarSet) baseClass() string {
	return "VisualScriptLocalVarSet"
}

/*
   Undocumented
*/
func (o *VisualScriptLocalVarSet) GetVarName() string {
	log.Println("Calling VisualScriptLocalVarSet.GetVarName()")

	returnValue := godotCallString(o, "get_var_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptLocalVarSet) GetVarType() int64 {
	log.Println("Calling VisualScriptLocalVarSet.GetVarType()")

	returnValue := godotCallInt(o, "get_var_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptLocalVarSet) SetVarName(name string) {
	log.Println("Calling VisualScriptLocalVarSet.SetVarName()")

	godotCallVoidString(o, "set_var_name", name)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptLocalVarSet) SetVarType(aType int64) {
	log.Println("Calling VisualScriptLocalVarSet.SetVarType()")

	godotCallVoidInt(o, "set_var_type", aType)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptLocalVarSetImplementer is an interface for VisualScriptLocalVarSet objects.
*/
type VisualScriptLocalVarSetImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptMathConstant struct {
	VisualScriptNode
}

func (o *VisualScriptMathConstant) baseClass() string {
	return "VisualScriptMathConstant"
}

/*
   Undocumented
*/
func (o *VisualScriptMathConstant) GetMathConstant() int64 {
	log.Println("Calling VisualScriptMathConstant.GetMathConstant()")

	returnValue := godotCallInt(o, "get_math_constant")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptMathConstant) SetMathConstant(which int64) {
	log.Println("Calling VisualScriptMathConstant.SetMathConstant()")

	godotCallVoidInt(o, "set_math_constant", which)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptMathConstantImplementer is an interface for VisualScriptMathConstant objects.
*/
type VisualScriptMathConstantImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptNode struct {
	Resource
}

func (o *VisualScriptNode) baseClass() string {
	return "VisualScriptNode"
}

/*
   Undocumented
*/
func (o *VisualScriptNode) X_GetDefaultInputValues() *Array {
	log.Println("Calling VisualScriptNode.X_GetDefaultInputValues()")

	returnValue := godotCallArray(o, "_get_default_input_values")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptNode) X_SetDefaultInputValues(values *Array) {
	log.Println("Calling VisualScriptNode.X_SetDefaultInputValues()")

	godotCallVoidArray(o, "_set_default_input_values", values)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptNode) GetDefaultInputValue(portIdx int64) *Variant {
	log.Println("Calling VisualScriptNode.GetDefaultInputValue()")

	returnValue := godotCallVariantInt(o, "get_default_input_value", portIdx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptNode) GetVisualScript() *VisualScript {
	log.Println("Calling VisualScriptNode.GetVisualScript()")

	returnValue := godotCallObject(o, "get_visual_script")
	log.Println("  Got return value: ", returnValue)

	var ret VisualScript
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *VisualScriptNode) PortsChangedNotify() {
	log.Println("Calling VisualScriptNode.PortsChangedNotify()")

	godotCallVoid(o, "ports_changed_notify")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptNode) SetDefaultInputValue(portIdx int64, value *Variant) {
	log.Println("Calling VisualScriptNode.SetDefaultInputValue()")

	godotCallVoidIntVariant(o, "set_default_input_value", portIdx, value)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptNodeImplementer is an interface for VisualScriptNode objects.
*/
type VisualScriptNodeImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptOperator struct {
	VisualScriptNode
}

func (o *VisualScriptOperator) baseClass() string {
	return "VisualScriptOperator"
}

/*
   Undocumented
*/
func (o *VisualScriptOperator) GetOperator() int64 {
	log.Println("Calling VisualScriptOperator.GetOperator()")

	returnValue := godotCallInt(o, "get_operator")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptOperator) GetTyped() int64 {
	log.Println("Calling VisualScriptOperator.GetTyped()")

	returnValue := godotCallInt(o, "get_typed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptOperator) SetOperator(op int64) {
	log.Println("Calling VisualScriptOperator.SetOperator()")

	godotCallVoidInt(o, "set_operator", op)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptOperator) SetTyped(aType int64) {
	log.Println("Calling VisualScriptOperator.SetTyped()")

	godotCallVoidInt(o, "set_typed", aType)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptOperatorImplementer is an interface for VisualScriptOperator objects.
*/
type VisualScriptOperatorImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptPreload struct {
	VisualScriptNode
}

func (o *VisualScriptPreload) baseClass() string {
	return "VisualScriptPreload"
}

/*
   Undocumented
*/
func (o *VisualScriptPreload) GetPreload() *Resource {
	log.Println("Calling VisualScriptPreload.GetPreload()")

	returnValue := godotCallObject(o, "get_preload")
	log.Println("  Got return value: ", returnValue)

	var ret Resource
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *VisualScriptPreload) SetPreload(resource *Resource) {
	log.Println("Calling VisualScriptPreload.SetPreload()")

	godotCallVoidObject(o, "set_preload", &resource.Object)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptPreloadImplementer is an interface for VisualScriptPreload objects.
*/
type VisualScriptPreloadImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptPropertyGet struct {
	VisualScriptNode
}

func (o *VisualScriptPropertyGet) baseClass() string {
	return "VisualScriptPropertyGet"
}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) X_GetTypeCache() int64 {
	log.Println("Calling VisualScriptPropertyGet.X_GetTypeCache()")

	returnValue := godotCallInt(o, "_get_type_cache")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) X_SetTypeCache(typeCache int64) {
	log.Println("Calling VisualScriptPropertyGet.X_SetTypeCache()")

	godotCallVoidInt(o, "_set_type_cache", typeCache)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptPropertyGet.GetBasePath()")

	returnValue := godotCallNodePath(o, "get_base_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) GetBaseScript() string {
	log.Println("Calling VisualScriptPropertyGet.GetBaseScript()")

	returnValue := godotCallString(o, "get_base_script")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) GetBaseType() string {
	log.Println("Calling VisualScriptPropertyGet.GetBaseType()")

	returnValue := godotCallString(o, "get_base_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) GetBasicType() int64 {
	log.Println("Calling VisualScriptPropertyGet.GetBasicType()")

	returnValue := godotCallInt(o, "get_basic_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) GetCallMode() int64 {
	log.Println("Calling VisualScriptPropertyGet.GetCallMode()")

	returnValue := godotCallInt(o, "get_call_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) GetIndex() string {
	log.Println("Calling VisualScriptPropertyGet.GetIndex()")

	returnValue := godotCallString(o, "get_index")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) GetProperty() string {
	log.Println("Calling VisualScriptPropertyGet.GetProperty()")

	returnValue := godotCallString(o, "get_property")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptPropertyGet.SetBasePath()")

	godotCallVoidNodePath(o, "set_base_path", basePath)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) SetBaseScript(baseScript string) {
	log.Println("Calling VisualScriptPropertyGet.SetBaseScript()")

	godotCallVoidString(o, "set_base_script", baseScript)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptPropertyGet.SetBaseType()")

	godotCallVoidString(o, "set_base_type", baseType)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) SetBasicType(basicType int64) {
	log.Println("Calling VisualScriptPropertyGet.SetBasicType()")

	godotCallVoidInt(o, "set_basic_type", basicType)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptPropertyGet.SetCallMode()")

	godotCallVoidInt(o, "set_call_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) SetIndex(index string) {
	log.Println("Calling VisualScriptPropertyGet.SetIndex()")

	godotCallVoidString(o, "set_index", index)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertyGet) SetProperty(property string) {
	log.Println("Calling VisualScriptPropertyGet.SetProperty()")

	godotCallVoidString(o, "set_property", property)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptPropertyGetImplementer is an interface for VisualScriptPropertyGet objects.
*/
type VisualScriptPropertyGetImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptPropertySet struct {
	VisualScriptNode
}

func (o *VisualScriptPropertySet) baseClass() string {
	return "VisualScriptPropertySet"
}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) X_GetTypeCache() *Dictionary {
	log.Println("Calling VisualScriptPropertySet.X_GetTypeCache()")

	returnValue := godotCallDictionary(o, "_get_type_cache")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) X_SetTypeCache(typeCache *Dictionary) {
	log.Println("Calling VisualScriptPropertySet.X_SetTypeCache()")

	godotCallVoidDictionary(o, "_set_type_cache", typeCache)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) GetAssignOp() int64 {
	log.Println("Calling VisualScriptPropertySet.GetAssignOp()")

	returnValue := godotCallInt(o, "get_assign_op")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptPropertySet.GetBasePath()")

	returnValue := godotCallNodePath(o, "get_base_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) GetBaseScript() string {
	log.Println("Calling VisualScriptPropertySet.GetBaseScript()")

	returnValue := godotCallString(o, "get_base_script")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) GetBaseType() string {
	log.Println("Calling VisualScriptPropertySet.GetBaseType()")

	returnValue := godotCallString(o, "get_base_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) GetBasicType() int64 {
	log.Println("Calling VisualScriptPropertySet.GetBasicType()")

	returnValue := godotCallInt(o, "get_basic_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) GetCallMode() int64 {
	log.Println("Calling VisualScriptPropertySet.GetCallMode()")

	returnValue := godotCallInt(o, "get_call_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) GetIndex() string {
	log.Println("Calling VisualScriptPropertySet.GetIndex()")

	returnValue := godotCallString(o, "get_index")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) GetProperty() string {
	log.Println("Calling VisualScriptPropertySet.GetProperty()")

	returnValue := godotCallString(o, "get_property")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) SetAssignOp(assignOp int64) {
	log.Println("Calling VisualScriptPropertySet.SetAssignOp()")

	godotCallVoidInt(o, "set_assign_op", assignOp)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptPropertySet.SetBasePath()")

	godotCallVoidNodePath(o, "set_base_path", basePath)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) SetBaseScript(baseScript string) {
	log.Println("Calling VisualScriptPropertySet.SetBaseScript()")

	godotCallVoidString(o, "set_base_script", baseScript)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptPropertySet.SetBaseType()")

	godotCallVoidString(o, "set_base_type", baseType)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) SetBasicType(basicType int64) {
	log.Println("Calling VisualScriptPropertySet.SetBasicType()")

	godotCallVoidInt(o, "set_basic_type", basicType)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptPropertySet.SetCallMode()")

	godotCallVoidInt(o, "set_call_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) SetIndex(index string) {
	log.Println("Calling VisualScriptPropertySet.SetIndex()")

	godotCallVoidString(o, "set_index", index)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptPropertySet) SetProperty(property string) {
	log.Println("Calling VisualScriptPropertySet.SetProperty()")

	godotCallVoidString(o, "set_property", property)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptPropertySetImplementer is an interface for VisualScriptPropertySet objects.
*/
type VisualScriptPropertySetImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptResourcePath struct {
	VisualScriptNode
}

func (o *VisualScriptResourcePath) baseClass() string {
	return "VisualScriptResourcePath"
}

/*
   Undocumented
*/
func (o *VisualScriptResourcePath) GetResourcePath() string {
	log.Println("Calling VisualScriptResourcePath.GetResourcePath()")

	returnValue := godotCallString(o, "get_resource_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptResourcePath) SetResourcePath(path string) {
	log.Println("Calling VisualScriptResourcePath.SetResourcePath()")

	godotCallVoidString(o, "set_resource_path", path)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptResourcePathImplementer is an interface for VisualScriptResourcePath objects.
*/
type VisualScriptResourcePathImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptReturn struct {
	VisualScriptNode
}

func (o *VisualScriptReturn) baseClass() string {
	return "VisualScriptReturn"
}

/*
   Undocumented
*/
func (o *VisualScriptReturn) GetReturnType() int64 {
	log.Println("Calling VisualScriptReturn.GetReturnType()")

	returnValue := godotCallInt(o, "get_return_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptReturn) IsReturnValueEnabled() bool {
	log.Println("Calling VisualScriptReturn.IsReturnValueEnabled()")

	returnValue := godotCallBool(o, "is_return_value_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptReturn) SetEnableReturnValue(enable bool) {
	log.Println("Calling VisualScriptReturn.SetEnableReturnValue()")

	godotCallVoidBool(o, "set_enable_return_value", enable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptReturn) SetReturnType(aType int64) {
	log.Println("Calling VisualScriptReturn.SetReturnType()")

	godotCallVoidInt(o, "set_return_type", aType)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptReturnImplementer is an interface for VisualScriptReturn objects.
*/
type VisualScriptReturnImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptSceneNode struct {
	VisualScriptNode
}

func (o *VisualScriptSceneNode) baseClass() string {
	return "VisualScriptSceneNode"
}

/*
   Undocumented
*/
func (o *VisualScriptSceneNode) GetNodePath() *NodePath {
	log.Println("Calling VisualScriptSceneNode.GetNodePath()")

	returnValue := godotCallNodePath(o, "get_node_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptSceneNode) SetNodePath(path *NodePath) {
	log.Println("Calling VisualScriptSceneNode.SetNodePath()")

	godotCallVoidNodePath(o, "set_node_path", path)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptSceneNodeImplementer is an interface for VisualScriptSceneNode objects.
*/
type VisualScriptSceneNodeImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptSceneTree struct {
	VisualScriptNode
}

func (o *VisualScriptSceneTree) baseClass() string {
	return "VisualScriptSceneTree"
}

/*
   VisualScriptSceneTreeImplementer is an interface for VisualScriptSceneTree objects.
*/
type VisualScriptSceneTreeImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptSelect struct {
	VisualScriptNode
}

func (o *VisualScriptSelect) baseClass() string {
	return "VisualScriptSelect"
}

/*
   Undocumented
*/
func (o *VisualScriptSelect) GetTyped() int64 {
	log.Println("Calling VisualScriptSelect.GetTyped()")

	returnValue := godotCallInt(o, "get_typed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptSelect) SetTyped(aType int64) {
	log.Println("Calling VisualScriptSelect.SetTyped()")

	godotCallVoidInt(o, "set_typed", aType)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptSelectImplementer is an interface for VisualScriptSelect objects.
*/
type VisualScriptSelectImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptSelf struct {
	VisualScriptNode
}

func (o *VisualScriptSelf) baseClass() string {
	return "VisualScriptSelf"
}

/*
   VisualScriptSelfImplementer is an interface for VisualScriptSelf objects.
*/
type VisualScriptSelfImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptSequence struct {
	VisualScriptNode
}

func (o *VisualScriptSequence) baseClass() string {
	return "VisualScriptSequence"
}

/*
   Undocumented
*/
func (o *VisualScriptSequence) GetSteps() int64 {
	log.Println("Calling VisualScriptSequence.GetSteps()")

	returnValue := godotCallInt(o, "get_steps")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptSequence) SetSteps(steps int64) {
	log.Println("Calling VisualScriptSequence.SetSteps()")

	godotCallVoidInt(o, "set_steps", steps)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptSequenceImplementer is an interface for VisualScriptSequence objects.
*/
type VisualScriptSequenceImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptSubCall struct {
	VisualScriptNode
}

func (o *VisualScriptSubCall) baseClass() string {
	return "VisualScriptSubCall"
}

/*
   Undocumented
*/
func (o *VisualScriptSubCall) X_Subcall(arguments *Variant) *Variant {
	log.Println("Calling VisualScriptSubCall.X_Subcall()")

	returnValue := godotCallVariantVariant(o, "_subcall", arguments)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   VisualScriptSubCallImplementer is an interface for VisualScriptSubCall objects.
*/
type VisualScriptSubCallImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptSwitch struct {
	VisualScriptNode
}

func (o *VisualScriptSwitch) baseClass() string {
	return "VisualScriptSwitch"
}

/*
   VisualScriptSwitchImplementer is an interface for VisualScriptSwitch objects.
*/
type VisualScriptSwitchImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptTypeCast struct {
	VisualScriptNode
}

func (o *VisualScriptTypeCast) baseClass() string {
	return "VisualScriptTypeCast"
}

/*
   Undocumented
*/
func (o *VisualScriptTypeCast) GetBaseScript() string {
	log.Println("Calling VisualScriptTypeCast.GetBaseScript()")

	returnValue := godotCallString(o, "get_base_script")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptTypeCast) GetBaseType() string {
	log.Println("Calling VisualScriptTypeCast.GetBaseType()")

	returnValue := godotCallString(o, "get_base_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptTypeCast) SetBaseScript(path string) {
	log.Println("Calling VisualScriptTypeCast.SetBaseScript()")

	godotCallVoidString(o, "set_base_script", path)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptTypeCast) SetBaseType(aType string) {
	log.Println("Calling VisualScriptTypeCast.SetBaseType()")

	godotCallVoidString(o, "set_base_type", aType)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptTypeCastImplementer is an interface for VisualScriptTypeCast objects.
*/
type VisualScriptTypeCastImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptVariableGet struct {
	VisualScriptNode
}

func (o *VisualScriptVariableGet) baseClass() string {
	return "VisualScriptVariableGet"
}

/*
   Undocumented
*/
func (o *VisualScriptVariableGet) GetVariable() string {
	log.Println("Calling VisualScriptVariableGet.GetVariable()")

	returnValue := godotCallString(o, "get_variable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptVariableGet) SetVariable(name string) {
	log.Println("Calling VisualScriptVariableGet.SetVariable()")

	godotCallVoidString(o, "set_variable", name)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptVariableGetImplementer is an interface for VisualScriptVariableGet objects.
*/
type VisualScriptVariableGetImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptVariableSet struct {
	VisualScriptNode
}

func (o *VisualScriptVariableSet) baseClass() string {
	return "VisualScriptVariableSet"
}

/*
   Undocumented
*/
func (o *VisualScriptVariableSet) GetVariable() string {
	log.Println("Calling VisualScriptVariableSet.GetVariable()")

	returnValue := godotCallString(o, "get_variable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptVariableSet) SetVariable(name string) {
	log.Println("Calling VisualScriptVariableSet.SetVariable()")

	godotCallVoidString(o, "set_variable", name)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptVariableSetImplementer is an interface for VisualScriptVariableSet objects.
*/
type VisualScriptVariableSetImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptWhile struct {
	VisualScriptNode
}

func (o *VisualScriptWhile) baseClass() string {
	return "VisualScriptWhile"
}

/*
   VisualScriptWhileImplementer is an interface for VisualScriptWhile objects.
*/
type VisualScriptWhileImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptYield struct {
	VisualScriptNode
}

func (o *VisualScriptYield) baseClass() string {
	return "VisualScriptYield"
}

/*
   Undocumented
*/
func (o *VisualScriptYield) GetWaitTime() float64 {
	log.Println("Calling VisualScriptYield.GetWaitTime()")

	returnValue := godotCallFloat(o, "get_wait_time")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptYield) GetYieldMode() int64 {
	log.Println("Calling VisualScriptYield.GetYieldMode()")

	returnValue := godotCallInt(o, "get_yield_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptYield) SetWaitTime(sec float64) {
	log.Println("Calling VisualScriptYield.SetWaitTime()")

	godotCallVoidFloat(o, "set_wait_time", sec)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptYield) SetYieldMode(mode int64) {
	log.Println("Calling VisualScriptYield.SetYieldMode()")

	godotCallVoidInt(o, "set_yield_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptYieldImplementer is an interface for VisualScriptYield objects.
*/
type VisualScriptYieldImplementer interface {
	Class
}

/*
   Undocumented
*/
type VisualScriptYieldSignal struct {
	VisualScriptNode
}

func (o *VisualScriptYieldSignal) baseClass() string {
	return "VisualScriptYieldSignal"
}

/*
   Undocumented
*/
func (o *VisualScriptYieldSignal) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptYieldSignal.GetBasePath()")

	returnValue := godotCallNodePath(o, "get_base_path")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptYieldSignal) GetBaseType() string {
	log.Println("Calling VisualScriptYieldSignal.GetBaseType()")

	returnValue := godotCallString(o, "get_base_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptYieldSignal) GetCallMode() int64 {
	log.Println("Calling VisualScriptYieldSignal.GetCallMode()")

	returnValue := godotCallInt(o, "get_call_mode")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptYieldSignal) GetSignal() string {
	log.Println("Calling VisualScriptYieldSignal.GetSignal()")

	returnValue := godotCallString(o, "get_signal")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *VisualScriptYieldSignal) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptYieldSignal.SetBasePath()")

	godotCallVoidNodePath(o, "set_base_path", basePath)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptYieldSignal) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptYieldSignal.SetBaseType()")

	godotCallVoidString(o, "set_base_type", baseType)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptYieldSignal) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptYieldSignal.SetCallMode()")

	godotCallVoidInt(o, "set_call_mode", mode)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *VisualScriptYieldSignal) SetSignal(signal string) {
	log.Println("Calling VisualScriptYieldSignal.SetSignal()")

	godotCallVoidString(o, "set_signal", signal)
	log.Println("  Function successfully completed.")

}

/*
   VisualScriptYieldSignalImplementer is an interface for VisualScriptYieldSignal objects.
*/
type VisualScriptYieldSignalImplementer interface {
	Class
}

func newSingletonVisualServer() *visualServer {
	obj := &visualServer{}
	name := C.CString("VisualServer")
	defer C.free(unsafe.Pointer(name))
	ptr := C.godot_global_get_singleton(name)
	obj.owner = (*C.godot_object)(ptr)
	return obj
}

/*
   Server for anything visible. The visual server is the API backend for everything visible. The whole scene system mounts on it to display. The visual server is completely opaque, the internals are entirely implementation specific and cannot be accessed.
*/
var VisualServer = newSingletonVisualServer()

/*
   Server for anything visible. The visual server is the API backend for everything visible. The whole scene system mounts on it to display. The visual server is completely opaque, the internals are entirely implementation specific and cannot be accessed.
*/
type visualServer struct {
	Object
}

func (o *visualServer) baseClass() string {
	return "VisualServer"
}

/*
   Sets images to be rendered in the window margin.
*/
func (o *visualServer) BlackBarsSetImages(left *RID, top *RID, right *RID, bottom *RID) {
	log.Println("Calling VisualServer.BlackBarsSetImages()")

	godotCallVoidRidRidRidRid(o, "black_bars_set_images", left, top, right, bottom)
	log.Println("  Function successfully completed.")

}

/*
   Sets margin size, where black bars (or images, if [method black_bars_set_images] was used) are rendered.
*/
func (o *visualServer) BlackBarsSetMargins(left int64, top int64, right int64, bottom int64) {
	log.Println("Calling VisualServer.BlackBarsSetMargins()")

	godotCallVoidIntIntIntInt(o, "black_bars_set_margins", left, top, right, bottom)
	log.Println("  Function successfully completed.")

}

/*
   Creates a canvas and returns the assigned [RID].
*/
func (o *visualServer) CanvasCreate() *RID {
	log.Println("Calling VisualServer.CanvasCreate()")

	returnValue := godotCallRid(o, "canvas_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Adds a circle command to the [CanvasItem]'s draw commands.
*/
func (o *visualServer) CanvasItemAddCircle(item *RID, pos *Vector2, radius float64, color *Color) {
	log.Println("Calling VisualServer.CanvasItemAddCircle()")

	godotCallVoidRidVector2FloatColor(o, "canvas_item_add_circle", item, pos, radius, color)
	log.Println("  Function successfully completed.")

}

/*
   If ignore is [code]true[/code], the VisualServer does not perform clipping.
*/
func (o *visualServer) CanvasItemAddClipIgnore(item *RID, ignore bool) {
	log.Println("Calling VisualServer.CanvasItemAddClipIgnore()")

	godotCallVoidRidBool(o, "canvas_item_add_clip_ignore", item, ignore)
	log.Println("  Function successfully completed.")

}

/*
   Adds a line command to the [CanvasItem]'s draw commands.
*/
func (o *visualServer) CanvasItemAddLine(item *RID, from *Vector2, to *Vector2, color *Color, width float64, antialiased bool) {
	log.Println("Calling VisualServer.CanvasItemAddLine()")

	godotCallVoidRidVector2Vector2ColorFloatBool(o, "canvas_item_add_line", item, from, to, color, width, antialiased)
	log.Println("  Function successfully completed.")

}

/*
   Adds a [Mesh] to the [CanvasItem]'s draw commands. Only affects its aabb at the moment.
*/
func (o *visualServer) CanvasItemAddMesh(item *RID, mesh *RID, skeleton *RID) {
	log.Println("Calling VisualServer.CanvasItemAddMesh()")

	godotCallVoidRidRidRid(o, "canvas_item_add_mesh", item, mesh, skeleton)
	log.Println("  Function successfully completed.")

}

/*
   Adds a [MultiMesh] to the [CanvasItem]'s draw commands. Only affects its aabb at the moment.
*/
func (o *visualServer) CanvasItemAddMultimesh(item *RID, mesh *RID, skeleton *RID) {
	log.Println("Calling VisualServer.CanvasItemAddMultimesh()")

	godotCallVoidRidRidRid(o, "canvas_item_add_multimesh", item, mesh, skeleton)
	log.Println("  Function successfully completed.")

}

/*
   Adds a nine patch image to the [CanvasItem]'s draw commands. See [NinePatchRect] for more explanation.
*/
func (o *visualServer) CanvasItemAddNinePatch(item *RID, rect *Rect2, source *Rect2, texture *RID, topleft *Vector2, bottomright *Vector2, xAxisMode int64, yAxisMode int64, drawCenter bool, modulate *Color, normalMap *RID) {
	log.Println("Calling VisualServer.CanvasItemAddNinePatch()")

	godotCallVoidRidRect2Rect2RidVector2Vector2IntIntBoolColorRid(o, "canvas_item_add_nine_patch", item, rect, source, texture, topleft, bottomright, xAxisMode, yAxisMode, drawCenter, modulate, normalMap)
	log.Println("  Function successfully completed.")

}

/*
   Adds a particles system to the [CanvasItem]'s draw commands.
*/
func (o *visualServer) CanvasItemAddParticles(item *RID, particles *RID, texture *RID, normalMap *RID, hFrames int64, vFrames int64) {
	log.Println("Calling VisualServer.CanvasItemAddParticles()")

	godotCallVoidRidRidRidRidIntInt(o, "canvas_item_add_particles", item, particles, texture, normalMap, hFrames, vFrames)
	log.Println("  Function successfully completed.")

}

/*
   Adds a polygon to the [CanvasItem]'s draw commands.
*/
func (o *visualServer) CanvasItemAddPolygon(item *RID, points *PoolVector2Array, colors *PoolColorArray, uvs *PoolVector2Array, texture *RID, normalMap *RID, antialiased bool) {
	log.Println("Calling VisualServer.CanvasItemAddPolygon()")

	godotCallVoidRidPoolVector2ArrayPoolColorArrayPoolVector2ArrayRidRidBool(o, "canvas_item_add_polygon", item, points, colors, uvs, texture, normalMap, antialiased)
	log.Println("  Function successfully completed.")

}

/*
   Adds a polyline, which is a line from multiple points with a width, to the [CanvasItem]'s draw commands.
*/
func (o *visualServer) CanvasItemAddPolyline(item *RID, points *PoolVector2Array, colors *PoolColorArray, width float64, antialiased bool) {
	log.Println("Calling VisualServer.CanvasItemAddPolyline()")

	godotCallVoidRidPoolVector2ArrayPoolColorArrayFloatBool(o, "canvas_item_add_polyline", item, points, colors, width, antialiased)
	log.Println("  Function successfully completed.")

}

/*
   Adds a primitive to the [CanvasItem]'s draw commands.
*/
func (o *visualServer) CanvasItemAddPrimitive(item *RID, points *PoolVector2Array, colors *PoolColorArray, uvs *PoolVector2Array, texture *RID, width float64, normalMap *RID) {
	log.Println("Calling VisualServer.CanvasItemAddPrimitive()")

	godotCallVoidRidPoolVector2ArrayPoolColorArrayPoolVector2ArrayRidFloatRid(o, "canvas_item_add_primitive", item, points, colors, uvs, texture, width, normalMap)
	log.Println("  Function successfully completed.")

}

/*
   Adds a rectangle to the [CanvasItem]'s draw commands.
*/
func (o *visualServer) CanvasItemAddRect(item *RID, rect *Rect2, color *Color) {
	log.Println("Calling VisualServer.CanvasItemAddRect()")

	godotCallVoidRidRect2Color(o, "canvas_item_add_rect", item, rect, color)
	log.Println("  Function successfully completed.")

}

/*
   Adds a [Transform2D] command to the [CanvasItem]'s draw commands. This sets the extra_matrix uniform when executed. This affects the later command's of the canvas item.
*/
func (o *visualServer) CanvasItemAddSetTransform(item *RID, transform *Transform2D) {
	log.Println("Calling VisualServer.CanvasItemAddSetTransform()")

	godotCallVoidRidTransform2D(o, "canvas_item_add_set_transform", item, transform)
	log.Println("  Function successfully completed.")

}

/*
   Adds a textured rect to the [CanvasItem]'s draw commands.
*/
func (o *visualServer) CanvasItemAddTextureRect(item *RID, rect *Rect2, texture *RID, tile bool, modulate *Color, transpose bool, normalMap *RID) {
	log.Println("Calling VisualServer.CanvasItemAddTextureRect()")

	godotCallVoidRidRect2RidBoolColorBoolRid(o, "canvas_item_add_texture_rect", item, rect, texture, tile, modulate, transpose, normalMap)
	log.Println("  Function successfully completed.")

}

/*
   Adds a texture rect with region setting to the [CanvasItem]'s draw commands.
*/
func (o *visualServer) CanvasItemAddTextureRectRegion(item *RID, rect *Rect2, texture *RID, srcRect *Rect2, modulate *Color, transpose bool, normalMap *RID, clipUv bool) {
	log.Println("Calling VisualServer.CanvasItemAddTextureRectRegion()")

	godotCallVoidRidRect2RidRect2ColorBoolRidBool(o, "canvas_item_add_texture_rect_region", item, rect, texture, srcRect, modulate, transpose, normalMap, clipUv)
	log.Println("  Function successfully completed.")

}

/*
   Adds a triangle array to the [CanvasItem]'s draw commands.
*/
func (o *visualServer) CanvasItemAddTriangleArray(item *RID, indices *PoolIntArray, points *PoolVector2Array, colors *PoolColorArray, uvs *PoolVector2Array, texture *RID, count int64, normalMap *RID) {
	log.Println("Calling VisualServer.CanvasItemAddTriangleArray()")

	godotCallVoidRidPoolIntArrayPoolVector2ArrayPoolColorArrayPoolVector2ArrayRidIntRid(o, "canvas_item_add_triangle_array", item, indices, points, colors, uvs, texture, count, normalMap)
	log.Println("  Function successfully completed.")

}

/*
   Clears the [CanvasItem] and removes all commands in it.
*/
func (o *visualServer) CanvasItemClear(item *RID) {
	log.Println("Calling VisualServer.CanvasItemClear()")

	godotCallVoidRid(o, "canvas_item_clear", item)
	log.Println("  Function successfully completed.")

}

/*
   Creates a new [CanvasItem] and returns its [RID].
*/
func (o *visualServer) CanvasItemCreate() *RID {
	log.Println("Calling VisualServer.CanvasItemCreate()")

	returnValue := godotCallRid(o, "canvas_item_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets clipping for the [CanvasItem].
*/
func (o *visualServer) CanvasItemSetClip(item *RID, clip bool) {
	log.Println("Calling VisualServer.CanvasItemSetClip()")

	godotCallVoidRidBool(o, "canvas_item_set_clip", item, clip)
	log.Println("  Function successfully completed.")

}

/*
   Sets the [CanvasItem] to copy a rect to the backbuffer.
*/
func (o *visualServer) CanvasItemSetCopyToBackbuffer(item *RID, enabled bool, rect *Rect2) {
	log.Println("Calling VisualServer.CanvasItemSetCopyToBackbuffer()")

	godotCallVoidRidBoolRect2(o, "canvas_item_set_copy_to_backbuffer", item, enabled, rect)
	log.Println("  Function successfully completed.")

}

/*
   Defines a custom drawing rectangle for the [CanvasItem].
*/
func (o *visualServer) CanvasItemSetCustomRect(item *RID, useCustomRect bool, rect *Rect2) {
	log.Println("Calling VisualServer.CanvasItemSetCustomRect()")

	godotCallVoidRidBoolRect2(o, "canvas_item_set_custom_rect", item, useCustomRect, rect)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *visualServer) CanvasItemSetDistanceFieldMode(item *RID, enabled bool) {
	log.Println("Calling VisualServer.CanvasItemSetDistanceFieldMode()")

	godotCallVoidRidBool(o, "canvas_item_set_distance_field_mode", item, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets [CanvasItem] to be drawn behind its parent.
*/
func (o *visualServer) CanvasItemSetDrawBehindParent(item *RID, enabled bool) {
	log.Println("Calling VisualServer.CanvasItemSetDrawBehindParent()")

	godotCallVoidRidBool(o, "canvas_item_set_draw_behind_parent", item, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets the index for the [CanvasItem].
*/
func (o *visualServer) CanvasItemSetDrawIndex(item *RID, index int64) {
	log.Println("Calling VisualServer.CanvasItemSetDrawIndex()")

	godotCallVoidRidInt(o, "canvas_item_set_draw_index", item, index)
	log.Println("  Function successfully completed.")

}

/*
   The light mask. See [LightOccluder2D] for more information on light masks.
*/
func (o *visualServer) CanvasItemSetLightMask(item *RID, mask int64) {
	log.Println("Calling VisualServer.CanvasItemSetLightMask()")

	godotCallVoidRidInt(o, "canvas_item_set_light_mask", item, mask)
	log.Println("  Function successfully completed.")

}

/*
   Sets a new material to the [CanvasItem].
*/
func (o *visualServer) CanvasItemSetMaterial(item *RID, material *RID) {
	log.Println("Calling VisualServer.CanvasItemSetMaterial()")

	godotCallVoidRidRid(o, "canvas_item_set_material", item, material)
	log.Println("  Function successfully completed.")

}

/*
   Sets the color that modulates the [CanvasItem] and its children.
*/
func (o *visualServer) CanvasItemSetModulate(item *RID, color *Color) {
	log.Println("Calling VisualServer.CanvasItemSetModulate()")

	godotCallVoidRidColor(o, "canvas_item_set_modulate", item, color)
	log.Println("  Function successfully completed.")

}

/*
   Sets the parent for the [CanvasItem].
*/
func (o *visualServer) CanvasItemSetParent(item *RID, parent *RID) {
	log.Println("Calling VisualServer.CanvasItemSetParent()")

	godotCallVoidRidRid(o, "canvas_item_set_parent", item, parent)
	log.Println("  Function successfully completed.")

}

/*
   Sets the color that modulates the [CanvasItem] without children.
*/
func (o *visualServer) CanvasItemSetSelfModulate(item *RID, color *Color) {
	log.Println("Calling VisualServer.CanvasItemSetSelfModulate()")

	godotCallVoidRidColor(o, "canvas_item_set_self_modulate", item, color)
	log.Println("  Function successfully completed.")

}

/*
   Sets if [CanvasItem]'s children should be sorted by y-position.
*/
func (o *visualServer) CanvasItemSetSortChildrenByY(item *RID, enabled bool) {
	log.Println("Calling VisualServer.CanvasItemSetSortChildrenByY()")

	godotCallVoidRidBool(o, "canvas_item_set_sort_children_by_y", item, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets the [CanvasItem]'s [Transform2D].
*/
func (o *visualServer) CanvasItemSetTransform(item *RID, transform *Transform2D) {
	log.Println("Calling VisualServer.CanvasItemSetTransform()")

	godotCallVoidRidTransform2D(o, "canvas_item_set_transform", item, transform)
	log.Println("  Function successfully completed.")

}

/*
   Sets if the [CanvasItem] uses its parent's material.
*/
func (o *visualServer) CanvasItemSetUseParentMaterial(item *RID, enabled bool) {
	log.Println("Calling VisualServer.CanvasItemSetUseParentMaterial()")

	godotCallVoidRidBool(o, "canvas_item_set_use_parent_material", item, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets if the canvas item (including its children) is visible.
*/
func (o *visualServer) CanvasItemSetVisible(item *RID, visible bool) {
	log.Println("Calling VisualServer.CanvasItemSetVisible()")

	godotCallVoidRidBool(o, "canvas_item_set_visible", item, visible)
	log.Println("  Function successfully completed.")

}

/*
   If this is enabled, the z-index of the parent will be added to the children's z-index.
*/
func (o *visualServer) CanvasItemSetZAsRelativeToParent(item *RID, enabled bool) {
	log.Println("Calling VisualServer.CanvasItemSetZAsRelativeToParent()")

	godotCallVoidRidBool(o, "canvas_item_set_z_as_relative_to_parent", item, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets the [CanvasItem]'s z-index, i.e. its draw order (lower indexes are drawn first).
*/
func (o *visualServer) CanvasItemSetZIndex(item *RID, zIndex int64) {
	log.Println("Calling VisualServer.CanvasItemSetZIndex()")

	godotCallVoidRidInt(o, "canvas_item_set_z_index", item, zIndex)
	log.Println("  Function successfully completed.")

}

/*
   Attaches the canvas light to the canvas. Removes it from its previous canvas.
*/
func (o *visualServer) CanvasLightAttachToCanvas(light *RID, canvas *RID) {
	log.Println("Calling VisualServer.CanvasLightAttachToCanvas()")

	godotCallVoidRidRid(o, "canvas_light_attach_to_canvas", light, canvas)
	log.Println("  Function successfully completed.")

}

/*
   Creates a canvas light.
*/
func (o *visualServer) CanvasLightCreate() *RID {
	log.Println("Calling VisualServer.CanvasLightCreate()")

	returnValue := godotCallRid(o, "canvas_light_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Attaches a light occluder to the canvas. Removes it from its previous canvas.
*/
func (o *visualServer) CanvasLightOccluderAttachToCanvas(occluder *RID, canvas *RID) {
	log.Println("Calling VisualServer.CanvasLightOccluderAttachToCanvas()")

	godotCallVoidRidRid(o, "canvas_light_occluder_attach_to_canvas", occluder, canvas)
	log.Println("  Function successfully completed.")

}

/*
   Creates a light occluder.
*/
func (o *visualServer) CanvasLightOccluderCreate() *RID {
	log.Println("Calling VisualServer.CanvasLightOccluderCreate()")

	returnValue := godotCallRid(o, "canvas_light_occluder_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Enables or disables light occluder.
*/
func (o *visualServer) CanvasLightOccluderSetEnabled(occluder *RID, enabled bool) {
	log.Println("Calling VisualServer.CanvasLightOccluderSetEnabled()")

	godotCallVoidRidBool(o, "canvas_light_occluder_set_enabled", occluder, enabled)
	log.Println("  Function successfully completed.")

}

/*
   The light mask. See [LightOccluder2D] for more information on light masks
*/
func (o *visualServer) CanvasLightOccluderSetLightMask(occluder *RID, mask int64) {
	log.Println("Calling VisualServer.CanvasLightOccluderSetLightMask()")

	godotCallVoidRidInt(o, "canvas_light_occluder_set_light_mask", occluder, mask)
	log.Println("  Function successfully completed.")

}

/*
   Sets a light occluder's polygon.
*/
func (o *visualServer) CanvasLightOccluderSetPolygon(occluder *RID, polygon *RID) {
	log.Println("Calling VisualServer.CanvasLightOccluderSetPolygon()")

	godotCallVoidRidRid(o, "canvas_light_occluder_set_polygon", occluder, polygon)
	log.Println("  Function successfully completed.")

}

/*
   Sets a light occluder's [Transform2D].
*/
func (o *visualServer) CanvasLightOccluderSetTransform(occluder *RID, transform *Transform2D) {
	log.Println("Calling VisualServer.CanvasLightOccluderSetTransform()")

	godotCallVoidRidTransform2D(o, "canvas_light_occluder_set_transform", occluder, transform)
	log.Println("  Function successfully completed.")

}

/*
   Sets the color for a light.
*/
func (o *visualServer) CanvasLightSetColor(light *RID, color *Color) {
	log.Println("Calling VisualServer.CanvasLightSetColor()")

	godotCallVoidRidColor(o, "canvas_light_set_color", light, color)
	log.Println("  Function successfully completed.")

}

/*
   Enables or disables a canvas light.
*/
func (o *visualServer) CanvasLightSetEnabled(light *RID, enabled bool) {
	log.Println("Calling VisualServer.CanvasLightSetEnabled()")

	godotCallVoidRidBool(o, "canvas_light_set_enabled", light, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets a canvas light's energy.
*/
func (o *visualServer) CanvasLightSetEnergy(light *RID, energy float64) {
	log.Println("Calling VisualServer.CanvasLightSetEnergy()")

	godotCallVoidRidFloat(o, "canvas_light_set_energy", light, energy)
	log.Println("  Function successfully completed.")

}

/*
   Sets a canvas light's height.
*/
func (o *visualServer) CanvasLightSetHeight(light *RID, height float64) {
	log.Println("Calling VisualServer.CanvasLightSetHeight()")

	godotCallVoidRidFloat(o, "canvas_light_set_height", light, height)
	log.Println("  Function successfully completed.")

}

/*
   The light mask. See [LightOccluder2D] for more information on light masks
*/
func (o *visualServer) CanvasLightSetItemCullMask(light *RID, mask int64) {
	log.Println("Calling VisualServer.CanvasLightSetItemCullMask()")

	godotCallVoidRidInt(o, "canvas_light_set_item_cull_mask", light, mask)
	log.Println("  Function successfully completed.")

}

/*
   The shadow mask. binary about which layers this canvas light affects which canvas item's shadows. See [LightOccluder2D] for more information on light masks.
*/
func (o *visualServer) CanvasLightSetItemShadowCullMask(light *RID, mask int64) {
	log.Println("Calling VisualServer.CanvasLightSetItemShadowCullMask()")

	godotCallVoidRidInt(o, "canvas_light_set_item_shadow_cull_mask", light, mask)
	log.Println("  Function successfully completed.")

}

/*
   The layer range that gets rendered with this light.
*/
func (o *visualServer) CanvasLightSetLayerRange(light *RID, minLayer int64, maxLayer int64) {
	log.Println("Calling VisualServer.CanvasLightSetLayerRange()")

	godotCallVoidRidIntInt(o, "canvas_light_set_layer_range", light, minLayer, maxLayer)
	log.Println("  Function successfully completed.")

}

/*
   The mode of the light, see CANVAS_LIGHT_MODE_* constants.
*/
func (o *visualServer) CanvasLightSetMode(light *RID, mode int64) {
	log.Println("Calling VisualServer.CanvasLightSetMode()")

	godotCallVoidRidInt(o, "canvas_light_set_mode", light, mode)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *visualServer) CanvasLightSetScale(light *RID, scale float64) {
	log.Println("Calling VisualServer.CanvasLightSetScale()")

	godotCallVoidRidFloat(o, "canvas_light_set_scale", light, scale)
	log.Println("  Function successfully completed.")

}

/*
   Sets the width of the shadow buffer, size gets scaled to the next power of two for this.
*/
func (o *visualServer) CanvasLightSetShadowBufferSize(light *RID, size int64) {
	log.Println("Calling VisualServer.CanvasLightSetShadowBufferSize()")

	godotCallVoidRidInt(o, "canvas_light_set_shadow_buffer_size", light, size)
	log.Println("  Function successfully completed.")

}

/*
   Sets the color of the canvas light's shadow.
*/
func (o *visualServer) CanvasLightSetShadowColor(light *RID, color *Color) {
	log.Println("Calling VisualServer.CanvasLightSetShadowColor()")

	godotCallVoidRidColor(o, "canvas_light_set_shadow_color", light, color)
	log.Println("  Function successfully completed.")

}

/*
   Enables or disables the canvas light's shadow.
*/
func (o *visualServer) CanvasLightSetShadowEnabled(light *RID, enabled bool) {
	log.Println("Calling VisualServer.CanvasLightSetShadowEnabled()")

	godotCallVoidRidBool(o, "canvas_light_set_shadow_enabled", light, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets the canvas light's shadow's filter, see CANVAS_LIGHT_SHADOW_FILTER_* constants.
*/
func (o *visualServer) CanvasLightSetShadowFilter(light *RID, filter int64) {
	log.Println("Calling VisualServer.CanvasLightSetShadowFilter()")

	godotCallVoidRidInt(o, "canvas_light_set_shadow_filter", light, filter)
	log.Println("  Function successfully completed.")

}

/*
   Sets the length of the shadow's gradient.
*/
func (o *visualServer) CanvasLightSetShadowGradientLength(light *RID, length float64) {
	log.Println("Calling VisualServer.CanvasLightSetShadowGradientLength()")

	godotCallVoidRidFloat(o, "canvas_light_set_shadow_gradient_length", light, length)
	log.Println("  Function successfully completed.")

}

/*
   Smoothens the shadow. The lower, the more smooth.
*/
func (o *visualServer) CanvasLightSetShadowSmooth(light *RID, smooth float64) {
	log.Println("Calling VisualServer.CanvasLightSetShadowSmooth()")

	godotCallVoidRidFloat(o, "canvas_light_set_shadow_smooth", light, smooth)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *visualServer) CanvasLightSetTexture(light *RID, texture *RID) {
	log.Println("Calling VisualServer.CanvasLightSetTexture()")

	godotCallVoidRidRid(o, "canvas_light_set_texture", light, texture)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *visualServer) CanvasLightSetTextureOffset(light *RID, offset *Vector2) {
	log.Println("Calling VisualServer.CanvasLightSetTextureOffset()")

	godotCallVoidRidVector2(o, "canvas_light_set_texture_offset", light, offset)
	log.Println("  Function successfully completed.")

}

/*
   Sets the canvas light's [Transform2D].
*/
func (o *visualServer) CanvasLightSetTransform(light *RID, transform *Transform2D) {
	log.Println("Calling VisualServer.CanvasLightSetTransform()")

	godotCallVoidRidTransform2D(o, "canvas_light_set_transform", light, transform)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *visualServer) CanvasLightSetZRange(light *RID, minZ int64, maxZ int64) {
	log.Println("Calling VisualServer.CanvasLightSetZRange()")

	godotCallVoidRidIntInt(o, "canvas_light_set_z_range", light, minZ, maxZ)
	log.Println("  Function successfully completed.")

}

/*
   Creates a new light occluder polygon.
*/
func (o *visualServer) CanvasOccluderPolygonCreate() *RID {
	log.Println("Calling VisualServer.CanvasOccluderPolygonCreate()")

	returnValue := godotCallRid(o, "canvas_occluder_polygon_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets an occluder polygons cull mode. See CANVAS_OCCLUDER_POLYGON_CULL_MODE_* constants.
*/
func (o *visualServer) CanvasOccluderPolygonSetCullMode(occluderPolygon *RID, mode int64) {
	log.Println("Calling VisualServer.CanvasOccluderPolygonSetCullMode()")

	godotCallVoidRidInt(o, "canvas_occluder_polygon_set_cull_mode", occluderPolygon, mode)
	log.Println("  Function successfully completed.")

}

/*
   Sets the shape of the occluder polygon.
*/
func (o *visualServer) CanvasOccluderPolygonSetShape(occluderPolygon *RID, shape *PoolVector2Array, closed bool) {
	log.Println("Calling VisualServer.CanvasOccluderPolygonSetShape()")

	godotCallVoidRidPoolVector2ArrayBool(o, "canvas_occluder_polygon_set_shape", occluderPolygon, shape, closed)
	log.Println("  Function successfully completed.")

}

/*
   Sets the shape of the occluder polygon as lines.
*/
func (o *visualServer) CanvasOccluderPolygonSetShapeAsLines(occluderPolygon *RID, shape *PoolVector2Array) {
	log.Println("Calling VisualServer.CanvasOccluderPolygonSetShapeAsLines()")

	godotCallVoidRidPoolVector2Array(o, "canvas_occluder_polygon_set_shape_as_lines", occluderPolygon, shape)
	log.Println("  Function successfully completed.")

}

/*
   A copy of the canvas item will be drawn with a local offset of the mirroring [Vector2].
*/
func (o *visualServer) CanvasSetItemMirroring(canvas *RID, item *RID, mirroring *Vector2) {
	log.Println("Calling VisualServer.CanvasSetItemMirroring()")

	godotCallVoidRidRidVector2(o, "canvas_set_item_mirroring", canvas, item, mirroring)
	log.Println("  Function successfully completed.")

}

/*
   Modulates all colors in the given canvas.
*/
func (o *visualServer) CanvasSetModulate(canvas *RID, color *Color) {
	log.Println("Calling VisualServer.CanvasSetModulate()")

	godotCallVoidRidColor(o, "canvas_set_modulate", canvas, color)
	log.Println("  Function successfully completed.")

}

/*
   Draws a frame.
*/
func (o *visualServer) Draw(swapBuffers bool) {
	log.Println("Calling VisualServer.Draw()")

	godotCallVoidBool(o, "draw", swapBuffers)
	log.Println("  Function successfully completed.")

}

/*
   Removes buffers and clears testcubes.
*/
func (o *visualServer) Finish() {
	log.Println("Calling VisualServer.Finish()")

	godotCallVoid(o, "finish")
	log.Println("  Function successfully completed.")

}

/*
   Draws a frame. Same as [method draw].
*/
func (o *visualServer) ForceDraw(swapBuffers bool) {
	log.Println("Calling VisualServer.ForceDraw()")

	godotCallVoidBool(o, "force_draw", swapBuffers)
	log.Println("  Function successfully completed.")

}

/*
   Synchronizes threads.
*/
func (o *visualServer) ForceSync() {
	log.Println("Calling VisualServer.ForceSync()")

	godotCallVoid(o, "force_sync")
	log.Println("  Function successfully completed.")

}

/*
   Tries to free an object in the VisualServer.
*/
func (o *visualServer) FreeRid(rid *RID) {
	log.Println("Calling VisualServer.FreeRid()")

	godotCallVoidRid(o, "free_rid", rid)
	log.Println("  Function successfully completed.")

}

/*
   Returns a certain information, see RENDER_INFO_* for options.
*/
func (o *visualServer) GetRenderInfo(info int64) int64 {
	log.Println("Calling VisualServer.GetRenderInfo()")

	returnValue := godotCallIntInt(o, "get_render_info", info)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the id of the test cube. Creates one if none exists.
*/
func (o *visualServer) GetTestCube() *RID {
	log.Println("Calling VisualServer.GetTestCube()")

	returnValue := godotCallRid(o, "get_test_cube")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the id of the test texture. Creates one if none exists.
*/
func (o *visualServer) GetTestTexture() *RID {
	log.Println("Calling VisualServer.GetTestTexture()")

	returnValue := godotCallRid(o, "get_test_texture")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the id of a white texture. Creates one if none exists.
*/
func (o *visualServer) GetWhiteTexture() *RID {
	log.Println("Calling VisualServer.GetWhiteTexture()")

	returnValue := godotCallRid(o, "get_white_texture")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns [code]true[/code] if changes have been made to the VisualServer's data. [method draw] is usually called if this happens.
*/
func (o *visualServer) HasChanged() bool {
	log.Println("Calling VisualServer.HasChanged()")

	returnValue := godotCallBool(o, "has_changed")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*

 */
func (o *visualServer) HasFeature(feature int64) bool {
	log.Println("Calling VisualServer.HasFeature()")

	returnValue := godotCallBoolInt(o, "has_feature", feature)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns true, if the OS supports a certain feature. Features might be s3tc, etc, etc2 and pvrtc,
*/
func (o *visualServer) HasOsFeature(feature string) bool {
	log.Println("Calling VisualServer.HasOsFeature()")

	returnValue := godotCallBoolString(o, "has_os_feature", feature)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Initializes the visual server.
*/
func (o *visualServer) Init() {
	log.Println("Calling VisualServer.Init()")

	godotCallVoid(o, "init")
	log.Println("  Function successfully completed.")

}

/*
   Returns a mesh of a sphere with the given amount of horizontal and vertical subdivisions.
*/
func (o *visualServer) MakeSphereMesh(latitudes int64, longitudes int64, radius float64) *RID {
	log.Println("Calling VisualServer.MakeSphereMesh()")

	returnValue := godotCallRidIntIntFloat(o, "make_sphere_mesh", latitudes, longitudes, radius)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns an empty material.
*/
func (o *visualServer) MaterialCreate() *RID {
	log.Println("Calling VisualServer.MaterialCreate()")

	returnValue := godotCallRid(o, "material_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the value of a certain material's parameter.
*/
func (o *visualServer) MaterialGetParam(material *RID, parameter string) *Variant {
	log.Println("Calling VisualServer.MaterialGetParam()")

	returnValue := godotCallVariantRidString(o, "material_get_param", material, parameter)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the shader of a certain material's shader. Returns an empty RID if the material doesn't have a shader.
*/
func (o *visualServer) MaterialGetShader(shaderMaterial *RID) *RID {
	log.Println("Calling VisualServer.MaterialGetShader()")

	returnValue := godotCallRidRid(o, "material_get_shader", shaderMaterial)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets a materials line width.
*/
func (o *visualServer) MaterialSetLineWidth(material *RID, width float64) {
	log.Println("Calling VisualServer.MaterialSetLineWidth()")

	godotCallVoidRidFloat(o, "material_set_line_width", material, width)
	log.Println("  Function successfully completed.")

}

/*
   Sets an objects next material.
*/
func (o *visualServer) MaterialSetNextPass(material *RID, nextMaterial *RID) {
	log.Println("Calling VisualServer.MaterialSetNextPass()")

	godotCallVoidRidRid(o, "material_set_next_pass", material, nextMaterial)
	log.Println("  Function successfully completed.")

}

/*
   Sets a materials parameter.
*/
func (o *visualServer) MaterialSetParam(material *RID, parameter string, value *Variant) {
	log.Println("Calling VisualServer.MaterialSetParam()")

	godotCallVoidRidStringVariant(o, "material_set_param", material, parameter, value)
	log.Println("  Function successfully completed.")

}

/*
   Sets a material's render priority.
*/
func (o *visualServer) MaterialSetRenderPriority(material *RID, priority int64) {
	log.Println("Calling VisualServer.MaterialSetRenderPriority()")

	godotCallVoidRidInt(o, "material_set_render_priority", material, priority)
	log.Println("  Function successfully completed.")

}

/*
   Sets a shader material's shader.
*/
func (o *visualServer) MaterialSetShader(shaderMaterial *RID, shader *RID) {
	log.Println("Calling VisualServer.MaterialSetShader()")

	godotCallVoidRidRid(o, "material_set_shader", shaderMaterial, shader)
	log.Println("  Function successfully completed.")

}

/*
   Adds a surface generated from the Arrays to a mesh. See PRIMITIVE_TYPE_* constants for types.
*/
func (o *visualServer) MeshAddSurfaceFromArrays(mesh *RID, primtive int64, arrays *Array, blendShapes *Array, compressFormat int64) {
	log.Println("Calling VisualServer.MeshAddSurfaceFromArrays()")

	godotCallVoidRidIntArrayArrayInt(o, "mesh_add_surface_from_arrays", mesh, primtive, arrays, blendShapes, compressFormat)
	log.Println("  Function successfully completed.")

}

/*
   Removes all surfaces from a mesh.
*/
func (o *visualServer) MeshClear(mesh *RID) {
	log.Println("Calling VisualServer.MeshClear()")

	godotCallVoidRid(o, "mesh_clear", mesh)
	log.Println("  Function successfully completed.")

}

/*
   Creates a new mesh.
*/
func (o *visualServer) MeshCreate() *RID {
	log.Println("Calling VisualServer.MeshCreate()")

	returnValue := godotCallRid(o, "mesh_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a mesh's blend shape count.
*/
func (o *visualServer) MeshGetBlendShapeCount(mesh *RID) int64 {
	log.Println("Calling VisualServer.MeshGetBlendShapeCount()")

	returnValue := godotCallIntRid(o, "mesh_get_blend_shape_count", mesh)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a mesh's blend shape mode.
*/
func (o *visualServer) MeshGetBlendShapeMode(mesh *RID) int64 {
	log.Println("Calling VisualServer.MeshGetBlendShapeMode()")

	returnValue := godotCallIntRid(o, "mesh_get_blend_shape_mode", mesh)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a mesh's custom aabb.
*/
func (o *visualServer) MeshGetCustomAabb(mesh *RID) *AABB {
	log.Println("Calling VisualServer.MeshGetCustomAabb()")

	returnValue := godotCallAabbRid(o, "mesh_get_custom_aabb", mesh)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a mesh's number of surfaces.
*/
func (o *visualServer) MeshGetSurfaceCount(mesh *RID) int64 {
	log.Println("Calling VisualServer.MeshGetSurfaceCount()")

	returnValue := godotCallIntRid(o, "mesh_get_surface_count", mesh)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Removes a mesh's surface.
*/
func (o *visualServer) MeshRemoveSurface(mesh *RID, index int64) {
	log.Println("Calling VisualServer.MeshRemoveSurface()")

	godotCallVoidRidInt(o, "mesh_remove_surface", mesh, index)
	log.Println("  Function successfully completed.")

}

/*
   Sets a mesh's blend shape count.
*/
func (o *visualServer) MeshSetBlendShapeCount(mesh *RID, amount int64) {
	log.Println("Calling VisualServer.MeshSetBlendShapeCount()")

	godotCallVoidRidInt(o, "mesh_set_blend_shape_count", mesh, amount)
	log.Println("  Function successfully completed.")

}

/*
   Sets a mesh's blend shape mode.
*/
func (o *visualServer) MeshSetBlendShapeMode(mesh *RID, mode int64) {
	log.Println("Calling VisualServer.MeshSetBlendShapeMode()")

	godotCallVoidRidInt(o, "mesh_set_blend_shape_mode", mesh, mode)
	log.Println("  Function successfully completed.")

}

/*
   Sets a mesh's custom aabb.
*/
func (o *visualServer) MeshSetCustomAabb(mesh *RID, aabb *AABB) {
	log.Println("Calling VisualServer.MeshSetCustomAabb()")

	godotCallVoidRidAabb(o, "mesh_set_custom_aabb", mesh, aabb)
	log.Println("  Function successfully completed.")

}

/*
   Returns a mesh's surface's aabb.
*/
func (o *visualServer) MeshSurfaceGetAabb(mesh *RID, surface int64) *AABB {
	log.Println("Calling VisualServer.MeshSurfaceGetAabb()")

	returnValue := godotCallAabbRidInt(o, "mesh_surface_get_aabb", mesh, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a mesh's surface's vertex buffer.
*/
func (o *visualServer) MeshSurfaceGetArray(mesh *RID, surface int64) *PoolByteArray {
	log.Println("Calling VisualServer.MeshSurfaceGetArray()")

	returnValue := godotCallPoolByteArrayRidInt(o, "mesh_surface_get_array", mesh, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a mesh's surface's amount of indices.
*/
func (o *visualServer) MeshSurfaceGetArrayIndexLen(mesh *RID, surface int64) int64 {
	log.Println("Calling VisualServer.MeshSurfaceGetArrayIndexLen()")

	returnValue := godotCallIntRidInt(o, "mesh_surface_get_array_index_len", mesh, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a mesh's surface's amount of vertices.
*/
func (o *visualServer) MeshSurfaceGetArrayLen(mesh *RID, surface int64) int64 {
	log.Println("Calling VisualServer.MeshSurfaceGetArrayLen()")

	returnValue := godotCallIntRidInt(o, "mesh_surface_get_array_len", mesh, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a mesh's surface's buffer arrays.
*/
func (o *visualServer) MeshSurfaceGetArrays(mesh *RID, surface int64) *Array {
	log.Println("Calling VisualServer.MeshSurfaceGetArrays()")

	returnValue := godotCallArrayRidInt(o, "mesh_surface_get_arrays", mesh, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a mesh's surface's arrays for blend shapes
*/
func (o *visualServer) MeshSurfaceGetBlendShapeArrays(mesh *RID, surface int64) *Array {
	log.Println("Calling VisualServer.MeshSurfaceGetBlendShapeArrays()")

	returnValue := godotCallArrayRidInt(o, "mesh_surface_get_blend_shape_arrays", mesh, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the format of a mesh's surface.
*/
func (o *visualServer) MeshSurfaceGetFormat(mesh *RID, surface int64) int64 {
	log.Println("Calling VisualServer.MeshSurfaceGetFormat()")

	returnValue := godotCallIntRidInt(o, "mesh_surface_get_format", mesh, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a mesh's surface's index buffer.
*/
func (o *visualServer) MeshSurfaceGetIndexArray(mesh *RID, surface int64) *PoolByteArray {
	log.Println("Calling VisualServer.MeshSurfaceGetIndexArray()")

	returnValue := godotCallPoolByteArrayRidInt(o, "mesh_surface_get_index_array", mesh, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a mesh's surface's material.
*/
func (o *visualServer) MeshSurfaceGetMaterial(mesh *RID, surface int64) *RID {
	log.Println("Calling VisualServer.MeshSurfaceGetMaterial()")

	returnValue := godotCallRidRidInt(o, "mesh_surface_get_material", mesh, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the primitive type of a mesh's surface.
*/
func (o *visualServer) MeshSurfaceGetPrimitiveType(mesh *RID, surface int64) int64 {
	log.Println("Calling VisualServer.MeshSurfaceGetPrimitiveType()")

	returnValue := godotCallIntRidInt(o, "mesh_surface_get_primitive_type", mesh, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the aabb of a mesh's surface's skeleton.
*/
func (o *visualServer) MeshSurfaceGetSkeletonAabb(mesh *RID, surface int64) *Array {
	log.Println("Calling VisualServer.MeshSurfaceGetSkeletonAabb()")

	returnValue := godotCallArrayRidInt(o, "mesh_surface_get_skeleton_aabb", mesh, surface)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets a mesh's surface's material.
*/
func (o *visualServer) MeshSurfaceSetMaterial(mesh *RID, surface int64, material *RID) {
	log.Println("Calling VisualServer.MeshSurfaceSetMaterial()")

	godotCallVoidRidIntRid(o, "mesh_surface_set_material", mesh, surface, material)
	log.Println("  Function successfully completed.")

}

/*
   Schedules a callback to the corresponding named 'method' on 'where' after a frame has been drawn. The callback method must use only 1 argument which will be called with 'userdata'.
*/
func (o *visualServer) RequestFrameDrawnCallback(where *Object, method string, userdata *Variant) {
	log.Println("Calling VisualServer.RequestFrameDrawnCallback()")

	godotCallVoidObjectStringVariant(o, "request_frame_drawn_callback", where, method, userdata)
	log.Println("  Function successfully completed.")

}

/*
   Sets a boot image. The color defines the background color and if scale is [code]true[/code], the image will be scaled to fit the screen size.
*/
func (o *visualServer) SetBootImage(image *Image, color *Color, scale bool) {
	log.Println("Calling VisualServer.SetBootImage()")

	godotCallVoidObjectColorBool(o, "set_boot_image", &image.Object, color, scale)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *visualServer) SetDebugGenerateWireframes(generate bool) {
	log.Println("Calling VisualServer.SetDebugGenerateWireframes()")

	godotCallVoidBool(o, "set_debug_generate_wireframes", generate)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *visualServer) SetDefaultClearColor(color *Color) {
	log.Println("Calling VisualServer.SetDefaultClearColor()")

	godotCallVoidColor(o, "set_default_clear_color", color)
	log.Println("  Function successfully completed.")

}

/*
   Creates an empty shader.
*/
func (o *visualServer) ShaderCreate() *RID {
	log.Println("Calling VisualServer.ShaderCreate()")

	returnValue := godotCallRid(o, "shader_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a shader's code.
*/
func (o *visualServer) ShaderGetCode(shader *RID) string {
	log.Println("Calling VisualServer.ShaderGetCode()")

	returnValue := godotCallStringRid(o, "shader_get_code", shader)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a default texture from a shader searched by name.
*/
func (o *visualServer) ShaderGetDefaultTextureParam(shader *RID, name string) *RID {
	log.Println("Calling VisualServer.ShaderGetDefaultTextureParam()")

	returnValue := godotCallRidRidString(o, "shader_get_default_texture_param", shader, name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the parameters of a shader.
*/
func (o *visualServer) ShaderGetParamList(shader *RID) *Array {
	log.Println("Calling VisualServer.ShaderGetParamList()")

	returnValue := godotCallArrayRid(o, "shader_get_param_list", shader)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets a shader's code.
*/
func (o *visualServer) ShaderSetCode(shader *RID, code string) {
	log.Println("Calling VisualServer.ShaderSetCode()")

	godotCallVoidRidString(o, "shader_set_code", shader, code)
	log.Println("  Function successfully completed.")

}

/*
   Sets a shader's default texture. Overwrites the texture given by name.
*/
func (o *visualServer) ShaderSetDefaultTextureParam(shader *RID, name string, texture *RID) {
	log.Println("Calling VisualServer.ShaderSetDefaultTextureParam()")

	godotCallVoidRidStringRid(o, "shader_set_default_texture_param", shader, name, texture)
	log.Println("  Function successfully completed.")

}

/*
   Creates an empty sky.
*/
func (o *visualServer) SkyCreate() *RID {
	log.Println("Calling VisualServer.SkyCreate()")

	returnValue := godotCallRid(o, "sky_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets a sky's texture.
*/
func (o *visualServer) SkySetTexture(sky *RID, cubeMap *RID, radianceSize int64) {
	log.Println("Calling VisualServer.SkySetTexture()")

	godotCallVoidRidRidInt(o, "sky_set_texture", sky, cubeMap, radianceSize)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *visualServer) Sync() {
	log.Println("Calling VisualServer.Sync()")

	godotCallVoid(o, "sync")
	log.Println("  Function successfully completed.")

}

/*
   Allocates space for a texture's image or video.
*/
func (o *visualServer) TextureAllocate(texture *RID, width int64, height int64, format int64, flags int64) {
	log.Println("Calling VisualServer.TextureAllocate()")

	godotCallVoidRidIntIntIntInt(o, "texture_allocate", texture, width, height, format, flags)
	log.Println("  Function successfully completed.")

}

/*
   Creates an empty texture.
*/
func (o *visualServer) TextureCreate() *RID {
	log.Println("Calling VisualServer.TextureCreate()")

	returnValue := godotCallRid(o, "texture_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Creates a texture, allocates the space for an image, and fills in the image.
*/
func (o *visualServer) TextureCreateFromImage(image *Image, flags int64) *RID {
	log.Println("Calling VisualServer.TextureCreateFromImage()")

	returnValue := godotCallRidObjectInt(o, "texture_create_from_image", &image.Object, flags)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a list of all the textures and their information.
*/
func (o *visualServer) TextureDebugUsage() *Array {
	log.Println("Calling VisualServer.TextureDebugUsage()")

	returnValue := godotCallArray(o, "texture_debug_usage")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns a copy of a texture's image unless it's a CubeMap, in which case it returns the [RID] of the image at one of the cubes sides.
*/
func (o *visualServer) TextureGetData(texture *RID, cubeSide int64) *Image {
	log.Println("Calling VisualServer.TextureGetData()")

	returnValue := godotCallObjectRidInt(o, "texture_get_data", texture, cubeSide)
	log.Println("  Got return value: ", returnValue)

	var ret Image
	ret.owner = returnValue.owner
	return &ret

}

/*
   Returns the flags of a texture.
*/
func (o *visualServer) TextureGetFlags(texture *RID) int64 {
	log.Println("Calling VisualServer.TextureGetFlags()")

	returnValue := godotCallIntRid(o, "texture_get_flags", texture)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the format of the texture's image.
*/
func (o *visualServer) TextureGetFormat(texture *RID) int64 {
	log.Println("Calling VisualServer.TextureGetFormat()")

	returnValue := godotCallIntRid(o, "texture_get_format", texture)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the texture's height.
*/
func (o *visualServer) TextureGetHeight(texture *RID) int64 {
	log.Println("Calling VisualServer.TextureGetHeight()")

	returnValue := godotCallIntRid(o, "texture_get_height", texture)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the texture's path.
*/
func (o *visualServer) TextureGetPath(texture *RID) string {
	log.Println("Calling VisualServer.TextureGetPath()")

	returnValue := godotCallStringRid(o, "texture_get_path", texture)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the opengl id of the texture's image.
*/
func (o *visualServer) TextureGetTexid(texture *RID) int64 {
	log.Println("Calling VisualServer.TextureGetTexid()")

	returnValue := godotCallIntRid(o, "texture_get_texid", texture)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the texture's width.
*/
func (o *visualServer) TextureGetWidth(texture *RID) int64 {
	log.Println("Calling VisualServer.TextureGetWidth()")

	returnValue := godotCallIntRid(o, "texture_get_width", texture)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Sets the texture's image data. If it's a CubeMap, it sets the image data at a cube side.
*/
func (o *visualServer) TextureSetData(texture *RID, image *Image, cubeSide int64) {
	log.Println("Calling VisualServer.TextureSetData()")

	godotCallVoidRidObjectInt(o, "texture_set_data", texture, &image.Object, cubeSide)
	log.Println("  Function successfully completed.")

}

/*
   Sets the texture's flags. See [enum TextureFlags] for options
*/
func (o *visualServer) TextureSetFlags(texture *RID, flags int64) {
	log.Println("Calling VisualServer.TextureSetFlags()")

	godotCallVoidRidInt(o, "texture_set_flags", texture, flags)
	log.Println("  Function successfully completed.")

}

/*
   Sets the texture's path.
*/
func (o *visualServer) TextureSetPath(texture *RID, path string) {
	log.Println("Calling VisualServer.TextureSetPath()")

	godotCallVoidRidString(o, "texture_set_path", texture, path)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code], sets internal processes to shrink all image data to half the size.
*/
func (o *visualServer) TextureSetShrinkAllX2OnSetData(shrink bool) {
	log.Println("Calling VisualServer.TextureSetShrinkAllX2OnSetData()")

	godotCallVoidBool(o, "texture_set_shrink_all_x2_on_set_data", shrink)
	log.Println("  Function successfully completed.")

}

/*
   Overwrites the texture's width and height.
*/
func (o *visualServer) TextureSetSizeOverride(texture *RID, width int64, height int64) {
	log.Println("Calling VisualServer.TextureSetSizeOverride()")

	godotCallVoidRidIntInt(o, "texture_set_size_override", texture, width, height)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code], the image will be stored in the texture's images array if overwritten.
*/
func (o *visualServer) TexturesKeepOriginal(enable bool) {
	log.Println("Calling VisualServer.TexturesKeepOriginal()")

	godotCallVoidBool(o, "textures_keep_original", enable)
	log.Println("  Function successfully completed.")

}

/*
   Sets a viewport's camera.
*/
func (o *visualServer) ViewportAttachCamera(viewport *RID, camera *RID) {
	log.Println("Calling VisualServer.ViewportAttachCamera()")

	godotCallVoidRidRid(o, "viewport_attach_camera", viewport, camera)
	log.Println("  Function successfully completed.")

}

/*
   Sets a viewport's canvas.
*/
func (o *visualServer) ViewportAttachCanvas(viewport *RID, canvas *RID) {
	log.Println("Calling VisualServer.ViewportAttachCanvas()")

	godotCallVoidRidRid(o, "viewport_attach_canvas", viewport, canvas)
	log.Println("  Function successfully completed.")

}

/*
   Attaches a viewport to a screen.
*/
func (o *visualServer) ViewportAttachToScreen(viewport *RID, rect *Rect2, screen int64) {
	log.Println("Calling VisualServer.ViewportAttachToScreen()")

	godotCallVoidRidRect2Int(o, "viewport_attach_to_screen", viewport, rect, screen)
	log.Println("  Function successfully completed.")

}

/*
   Creates an empty viewport.
*/
func (o *visualServer) ViewportCreate() *RID {
	log.Println("Calling VisualServer.ViewportCreate()")

	returnValue := godotCallRid(o, "viewport_create")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Detaches the viewport from the screen.
*/
func (o *visualServer) ViewportDetach(viewport *RID) {
	log.Println("Calling VisualServer.ViewportDetach()")

	godotCallVoidRid(o, "viewport_detach", viewport)
	log.Println("  Function successfully completed.")

}

/*
   Returns a viewport's render info. for options see VIEWPORT_RENDER_INFO* constants.
*/
func (o *visualServer) ViewportGetRenderInfo(viewport *RID, info int64) int64 {
	log.Println("Calling VisualServer.ViewportGetRenderInfo()")

	returnValue := godotCallIntRidInt(o, "viewport_get_render_info", viewport, info)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Returns the viewport's last rendered frame.
*/
func (o *visualServer) ViewportGetTexture(viewport *RID) *RID {
	log.Println("Calling VisualServer.ViewportGetTexture()")

	returnValue := godotCallRidRid(o, "viewport_get_texture", viewport)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Detaches a viewport from a canvas and vice versa.
*/
func (o *visualServer) ViewportRemoveCanvas(viewport *RID, canvas *RID) {
	log.Println("Calling VisualServer.ViewportRemoveCanvas()")

	godotCallVoidRidRid(o, "viewport_remove_canvas", viewport, canvas)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code], sets the viewport active, else sets it inactive.
*/
func (o *visualServer) ViewportSetActive(viewport *RID, active bool) {
	log.Println("Calling VisualServer.ViewportSetActive()")

	godotCallVoidRidBool(o, "viewport_set_active", viewport, active)
	log.Println("  Function successfully completed.")

}

/*
   Sets the renderlayer for a viewport's canvas.
*/
func (o *visualServer) ViewportSetCanvasLayer(viewport *RID, canvas *RID, layer int64) {
	log.Println("Calling VisualServer.ViewportSetCanvasLayer()")

	godotCallVoidRidRidInt(o, "viewport_set_canvas_layer", viewport, canvas, layer)
	log.Println("  Function successfully completed.")

}

/*
   Sets the transformation of a viewport's canvas.
*/
func (o *visualServer) ViewportSetCanvasTransform(viewport *RID, canvas *RID, offset *Transform2D) {
	log.Println("Calling VisualServer.ViewportSetCanvasTransform()")

	godotCallVoidRidRidTransform2D(o, "viewport_set_canvas_transform", viewport, canvas, offset)
	log.Println("  Function successfully completed.")

}

/*
   Sets the clear mode of a viewport. See VIEWPORT_CLEAR_MODE_* constants for options.
*/
func (o *visualServer) ViewportSetClearMode(viewport *RID, clearMode int64) {
	log.Println("Calling VisualServer.ViewportSetClearMode()")

	godotCallVoidRidInt(o, "viewport_set_clear_mode", viewport, clearMode)
	log.Println("  Function successfully completed.")

}

/*
   Sets the debug draw mode of a viewport. See VIEWPORT_DEBUG_DRAW_* constants for options.
*/
func (o *visualServer) ViewportSetDebugDraw(viewport *RID, draw int64) {
	log.Println("Calling VisualServer.ViewportSetDebugDraw()")

	godotCallVoidRidInt(o, "viewport_set_debug_draw", viewport, draw)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] a viewport's 3D rendering should be disabled.
*/
func (o *visualServer) ViewportSetDisable3D(viewport *RID, disabled bool) {
	log.Println("Calling VisualServer.ViewportSetDisable3D()")

	godotCallVoidRidBool(o, "viewport_set_disable_3d", viewport, disabled)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] rendering of a viewport's environment should be disabled.
*/
func (o *visualServer) ViewportSetDisableEnvironment(viewport *RID, disabled bool) {
	log.Println("Calling VisualServer.ViewportSetDisableEnvironment()")

	godotCallVoidRidBool(o, "viewport_set_disable_environment", viewport, disabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets the viewport's global transformation matrix.
*/
func (o *visualServer) ViewportSetGlobalCanvasTransform(viewport *RID, transform *Transform2D) {
	log.Println("Calling VisualServer.ViewportSetGlobalCanvasTransform()")

	godotCallVoidRidTransform2D(o, "viewport_set_global_canvas_transform", viewport, transform)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the viewport should render to hdr.
*/
func (o *visualServer) ViewportSetHdr(viewport *RID, enabled bool) {
	log.Println("Calling VisualServer.ViewportSetHdr()")

	godotCallVoidRidBool(o, "viewport_set_hdr", viewport, enabled)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the viewport's canvas should not be rendered.
*/
func (o *visualServer) ViewportSetHideCanvas(viewport *RID, hidden bool) {
	log.Println("Calling VisualServer.ViewportSetHideCanvas()")

	godotCallVoidRidBool(o, "viewport_set_hide_canvas", viewport, hidden)
	log.Println("  Function successfully completed.")

}

/*

 */
func (o *visualServer) ViewportSetHideScenario(viewport *RID, hidden bool) {
	log.Println("Calling VisualServer.ViewportSetHideScenario()")

	godotCallVoidRidBool(o, "viewport_set_hide_scenario", viewport, hidden)
	log.Println("  Function successfully completed.")

}

/*
   Sets the anti-aliasing mode. see [enum ViewportMSAA] for options.
*/
func (o *visualServer) ViewportSetMsaa(viewport *RID, msaa int64) {
	log.Println("Calling VisualServer.ViewportSetMsaa()")

	godotCallVoidRidInt(o, "viewport_set_msaa", viewport, msaa)
	log.Println("  Function successfully completed.")

}

/*
   Sets the viewport's parent to another viewport.
*/
func (o *visualServer) ViewportSetParentViewport(viewport *RID, parentViewport *RID) {
	log.Println("Calling VisualServer.ViewportSetParentViewport()")

	godotCallVoidRidRid(o, "viewport_set_parent_viewport", viewport, parentViewport)
	log.Println("  Function successfully completed.")

}

/*
   Sets a viewport's scenario. The scenario contains information about the [enum ScenarioDebugMode], environment information, reflection atlas etc.
*/
func (o *visualServer) ViewportSetScenario(viewport *RID, scenario *RID) {
	log.Println("Calling VisualServer.ViewportSetScenario()")

	godotCallVoidRidRid(o, "viewport_set_scenario", viewport, scenario)
	log.Println("  Function successfully completed.")

}

/*
   Sets the shadow atlas quadrant's subdivision.
*/
func (o *visualServer) ViewportSetShadowAtlasQuadrantSubdivision(viewport *RID, quadrant int64, subdivision int64) {
	log.Println("Calling VisualServer.ViewportSetShadowAtlasQuadrantSubdivision()")

	godotCallVoidRidIntInt(o, "viewport_set_shadow_atlas_quadrant_subdivision", viewport, quadrant, subdivision)
	log.Println("  Function successfully completed.")

}

/*
   Sets the size of the shadow atlas's images.
*/
func (o *visualServer) ViewportSetShadowAtlasSize(viewport *RID, size int64) {
	log.Println("Calling VisualServer.ViewportSetShadowAtlasSize()")

	godotCallVoidRidInt(o, "viewport_set_shadow_atlas_size", viewport, size)
	log.Println("  Function successfully completed.")

}

/*
   Sets the viewport's width and height.
*/
func (o *visualServer) ViewportSetSize(viewport *RID, width int64, height int64) {
	log.Println("Calling VisualServer.ViewportSetSize()")

	godotCallVoidRidIntInt(o, "viewport_set_size", viewport, width, height)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the viewport should render its background as transparent.
*/
func (o *visualServer) ViewportSetTransparentBackground(viewport *RID, enabled bool) {
	log.Println("Calling VisualServer.ViewportSetTransparentBackground()")

	godotCallVoidRidBool(o, "viewport_set_transparent_background", viewport, enabled)
	log.Println("  Function successfully completed.")

}

/*
   Sets when the viewport should be updated. See VIEWPORT_UPDATE_MODE_* constants for options.
*/
func (o *visualServer) ViewportSetUpdateMode(viewport *RID, updateMode int64) {
	log.Println("Calling VisualServer.ViewportSetUpdateMode()")

	godotCallVoidRidInt(o, "viewport_set_update_mode", viewport, updateMode)
	log.Println("  Function successfully completed.")

}

/*
   Sets what should be rendered in the viewport. See VIEWPORT_USAGE_* constants for options.
*/
func (o *visualServer) ViewportSetUsage(viewport *RID, usage int64) {
	log.Println("Calling VisualServer.ViewportSetUsage()")

	godotCallVoidRidInt(o, "viewport_set_usage", viewport, usage)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the viewport should use augmented or virtual reality technologies. See [ARVRInterface].
*/
func (o *visualServer) ViewportSetUseArvr(viewport *RID, useArvr bool) {
	log.Println("Calling VisualServer.ViewportSetUseArvr()")

	godotCallVoidRidBool(o, "viewport_set_use_arvr", viewport, useArvr)
	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the viewport's rendering should be flipped vertically.
*/
func (o *visualServer) ViewportSetVflip(viewport *RID, enabled bool) {
	log.Println("Calling VisualServer.ViewportSetVflip()")

	godotCallVoidRidBool(o, "viewport_set_vflip", viewport, enabled)
	log.Println("  Function successfully completed.")

}

/*
   A weakref can hold a [Reference], without contributing to the reference counter. A weakref can be created from an [Object] using [method @GDScript.weakref]. If this object is not a reference, weakref still works, however, it does not have any effect on the object. Weakrefs are useful in cases where multiple classes have variables that refer to each other. Without weakrefs, using these classes could lead to memory leaks, since both references keep each other from being released. Making part of the variables a weakref can prevent this cyclic dependency, and allows the references to be released.
*/
type WeakRef struct {
	Reference
}

func (o *WeakRef) baseClass() string {
	return "WeakRef"
}

/*
   Returns the [Object] this weakref is referring to.
*/
func (o *WeakRef) GetRef() *Variant {
	log.Println("Calling WeakRef.GetRef()")

	returnValue := godotCallVariant(o, "get_ref")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   WeakRefImplementer is an interface for WeakRef objects.
*/
type WeakRefImplementer interface {
	Class
}

/*
   Windowdialog is the base class for all window-based dialogs. It's a by-default toplevel [Control] that draws a window decoration and allows motion and resizing.
*/
type WindowDialog struct {
	Popup
}

func (o *WindowDialog) baseClass() string {
	return "WindowDialog"
}

/*
   Undocumented
*/
func (o *WindowDialog) X_Closed() {
	log.Println("Calling WindowDialog.X_Closed()")

	godotCallVoid(o, "_closed")
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *WindowDialog) X_GuiInput(arg0 *InputEvent) {
	log.Println("Calling WindowDialog.X_GuiInput()")

	godotCallVoidObject(o, "_gui_input", &arg0.Object)
	log.Println("  Function successfully completed.")

}

/*
   Return the close [TextureButton].
*/
func (o *WindowDialog) GetCloseButton() *TextureButton {
	log.Println("Calling WindowDialog.GetCloseButton()")

	returnValue := godotCallObject(o, "get_close_button")
	log.Println("  Got return value: ", returnValue)

	var ret TextureButton
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *WindowDialog) GetResizable() bool {
	log.Println("Calling WindowDialog.GetResizable()")

	returnValue := godotCallBool(o, "get_resizable")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *WindowDialog) GetTitle() string {
	log.Println("Calling WindowDialog.GetTitle()")

	returnValue := godotCallString(o, "get_title")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *WindowDialog) SetResizable(resizable bool) {
	log.Println("Calling WindowDialog.SetResizable()")

	godotCallVoidBool(o, "set_resizable", resizable)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *WindowDialog) SetTitle(title string) {
	log.Println("Calling WindowDialog.SetTitle()")

	godotCallVoidString(o, "set_title", title)
	log.Println("  Function successfully completed.")

}

/*
   WindowDialogImplementer is an interface for WindowDialog objects.
*/
type WindowDialogImplementer interface {
	Class
}

/*
   Class that has everything pertaining to a world. A physics space, a visual scenario and a sound space. Spatial nodes register their resources into the current world.
*/
type World struct {
	Resource
}

func (o *World) baseClass() string {
	return "World"
}

/*
   Undocumented
*/
func (o *World) GetDirectSpaceState() *PhysicsDirectSpaceState {
	log.Println("Calling World.GetDirectSpaceState()")

	returnValue := godotCallObject(o, "get_direct_space_state")
	log.Println("  Got return value: ", returnValue)

	var ret PhysicsDirectSpaceState
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *World) GetEnvironment() *Environment {
	log.Println("Calling World.GetEnvironment()")

	returnValue := godotCallObject(o, "get_environment")
	log.Println("  Got return value: ", returnValue)

	var ret Environment
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *World) GetFallbackEnvironment() *Environment {
	log.Println("Calling World.GetFallbackEnvironment()")

	returnValue := godotCallObject(o, "get_fallback_environment")
	log.Println("  Got return value: ", returnValue)

	var ret Environment
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *World) GetScenario() *RID {
	log.Println("Calling World.GetScenario()")

	returnValue := godotCallRid(o, "get_scenario")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *World) GetSpace() *RID {
	log.Println("Calling World.GetSpace()")

	returnValue := godotCallRid(o, "get_space")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *World) SetEnvironment(env *Environment) {
	log.Println("Calling World.SetEnvironment()")

	godotCallVoidObject(o, "set_environment", &env.Object)
	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *World) SetFallbackEnvironment(env *Environment) {
	log.Println("Calling World.SetFallbackEnvironment()")

	godotCallVoidObject(o, "set_fallback_environment", &env.Object)
	log.Println("  Function successfully completed.")

}

/*
   WorldImplementer is an interface for World objects.
*/
type WorldImplementer interface {
	Class
}

/*
   Class that has everything pertaining to a 2D world. A physics space, a visual scenario and a sound space. 2D nodes register their resources into the current 2D world.
*/
type World2D struct {
	Resource
}

func (o *World2D) baseClass() string {
	return "World2D"
}

/*
   Undocumented
*/
func (o *World2D) GetCanvas() *RID {
	log.Println("Calling World2D.GetCanvas()")

	returnValue := godotCallRid(o, "get_canvas")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *World2D) GetDirectSpaceState() *Physics2DDirectSpaceState {
	log.Println("Calling World2D.GetDirectSpaceState()")

	returnValue := godotCallObject(o, "get_direct_space_state")
	log.Println("  Got return value: ", returnValue)

	var ret Physics2DDirectSpaceState
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *World2D) GetSpace() *RID {
	log.Println("Calling World2D.GetSpace()")

	returnValue := godotCallRid(o, "get_space")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   World2DImplementer is an interface for World2D objects.
*/
type World2DImplementer interface {
	Class
}

/*
   The [code]WorldEnvironment[/code] node is used to configure the default [Environment] for the scene. The parameters defined in the [code]WorldEnvironment[/code] can be overridden by an [Environment] node set on the current [Camera]. Additionally, only one [code]WorldEnvironment[/code] may be instanced in a given scene at a time. The [code]WorldEnvironment[/code] allows the user to specify default lighting parameters (e.g. ambient lighting), various post-processing effects (e.g. SSAO, DOF, Tonemapping), and how to draw the background (e.g. solid color, skybox). Usually, these are added in order to improve the realism/color balance of the scene.
*/
type WorldEnvironment struct {
	Node
}

func (o *WorldEnvironment) baseClass() string {
	return "WorldEnvironment"
}

/*
   Undocumented
*/
func (o *WorldEnvironment) GetEnvironment() *Environment {
	log.Println("Calling WorldEnvironment.GetEnvironment()")

	returnValue := godotCallObject(o, "get_environment")
	log.Println("  Got return value: ", returnValue)

	var ret Environment
	ret.owner = returnValue.owner
	return &ret

}

/*
   Undocumented
*/
func (o *WorldEnvironment) SetEnvironment(env *Environment) {
	log.Println("Calling WorldEnvironment.SetEnvironment()")

	godotCallVoidObject(o, "set_environment", &env.Object)
	log.Println("  Function successfully completed.")

}

/*
   WorldEnvironmentImplementer is an interface for WorldEnvironment objects.
*/
type WorldEnvironmentImplementer interface {
	Class
}

/*
   This class can serve as base to make custom XML parsers. Since XML is a very flexible standard, this interface is low level so it can be applied to any possible schema.
*/
type XMLParser struct {
	Reference
}

func (o *XMLParser) baseClass() string {
	return "XMLParser"
}

/*
   Get the amount of attributes in the current element.
*/
func (o *XMLParser) GetAttributeCount() int64 {
	log.Println("Calling XMLParser.GetAttributeCount()")

	returnValue := godotCallInt(o, "get_attribute_count")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the name of the attribute specified by the index in [code]idx[/code] argument.
*/
func (o *XMLParser) GetAttributeName(idx int64) string {
	log.Println("Calling XMLParser.GetAttributeName()")

	returnValue := godotCallStringInt(o, "get_attribute_name", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the value of the attribute specified by the index in [code]idx[/code] argument.
*/
func (o *XMLParser) GetAttributeValue(idx int64) string {
	log.Println("Calling XMLParser.GetAttributeValue()")

	returnValue := godotCallStringInt(o, "get_attribute_value", idx)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the current line in the parsed file (currently not implemented).
*/
func (o *XMLParser) GetCurrentLine() int64 {
	log.Println("Calling XMLParser.GetCurrentLine()")

	returnValue := godotCallInt(o, "get_current_line")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the value of a certain attribute of the current element by name. This will raise an error if the element has no such attribute.
*/
func (o *XMLParser) GetNamedAttributeValue(name string) string {
	log.Println("Calling XMLParser.GetNamedAttributeValue()")

	returnValue := godotCallStringString(o, "get_named_attribute_value", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the value of a certain attribute of the current element by name. This will return an empty [String] if the attribute is not found.
*/
func (o *XMLParser) GetNamedAttributeValueSafe(name string) string {
	log.Println("Calling XMLParser.GetNamedAttributeValueSafe()")

	returnValue := godotCallStringString(o, "get_named_attribute_value_safe", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the contents of a text node. This will raise an error in any other type of node.
*/
func (o *XMLParser) GetNodeData() string {
	log.Println("Calling XMLParser.GetNodeData()")

	returnValue := godotCallString(o, "get_node_data")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the name of the current element node. This will raise an error if the current node type is not [code]NODE_ELEMENT[/code] nor [code]NODE_ELEMENT_END[/code]
*/
func (o *XMLParser) GetNodeName() string {
	log.Println("Calling XMLParser.GetNodeName()")

	returnValue := godotCallString(o, "get_node_name")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the byte offset of the current node since the beginning of the file or buffer.
*/
func (o *XMLParser) GetNodeOffset() int64 {
	log.Println("Calling XMLParser.GetNodeOffset()")

	returnValue := godotCallInt(o, "get_node_offset")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Get the type of the current node. Compare with [code]NODE_*[/code] constants.
*/
func (o *XMLParser) GetNodeType() int64 {
	log.Println("Calling XMLParser.GetNodeType()")

	returnValue := godotCallInt(o, "get_node_type")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Check whether or not the current element has a certain attribute.
*/
func (o *XMLParser) HasAttribute(name string) bool {
	log.Println("Calling XMLParser.HasAttribute()")

	returnValue := godotCallBoolString(o, "has_attribute", name)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Check whether the current element is empty (this only works for completely empty tags, e.g. <element \>).
*/
func (o *XMLParser) IsEmpty() bool {
	log.Println("Calling XMLParser.IsEmpty()")

	returnValue := godotCallBool(o, "is_empty")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Open a XML file for parsing. This returns an error code.
*/
func (o *XMLParser) Open(file string) int64 {
	log.Println("Calling XMLParser.Open()")

	returnValue := godotCallIntString(o, "open", file)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Open a XML raw buffer for parsing. This returns an error code.
*/
func (o *XMLParser) OpenBuffer(buffer *PoolByteArray) int64 {
	log.Println("Calling XMLParser.OpenBuffer()")

	returnValue := godotCallIntPoolByteArray(o, "open_buffer", buffer)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Read the next node of the file. This returns an error code.
*/
func (o *XMLParser) Read() int64 {
	log.Println("Calling XMLParser.Read()")

	returnValue := godotCallInt(o, "read")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Move the buffer cursor to a certain offset (since the beginning) and read the next node there. This returns an error code.
*/
func (o *XMLParser) Seek(position int64) int64 {
	log.Println("Calling XMLParser.Seek()")

	returnValue := godotCallIntInt(o, "seek", position)
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Skips the current section. If the node contains other elements, they will be ignored and the cursor will go to the closing of the current element.
*/
func (o *XMLParser) SkipSection() {
	log.Println("Calling XMLParser.SkipSection()")

	godotCallVoid(o, "skip_section")
	log.Println("  Function successfully completed.")

}

/*
   XMLParserImplementer is an interface for XMLParser objects.
*/
type XMLParserImplementer interface {
	Class
}

/*
   Sort all child nodes based on their Y positions. The child node must inherit from [CanvasItem] for it to be sorted. Nodes that have a higher Y position will be drawn later, so they will appear on top of nodes that have a lower Y position.
*/
type YSort struct {
	Node2D
}

func (o *YSort) baseClass() string {
	return "YSort"
}

/*
   Undocumented
*/
func (o *YSort) IsSortEnabled() bool {
	log.Println("Calling YSort.IsSortEnabled()")

	returnValue := godotCallBool(o, "is_sort_enabled")
	log.Println("  Got return value: ", returnValue)

	return returnValue

}

/*
   Undocumented
*/
func (o *YSort) SetSortEnabled(enabled bool) {
	log.Println("Calling YSort.SetSortEnabled()")

	godotCallVoidBool(o, "set_sort_enabled", enabled)
	log.Println("  Function successfully completed.")

}

/*
   YSortImplementer is an interface for YSort objects.
*/
type YSortImplementer interface {
	Class
}
