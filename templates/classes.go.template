package godot

{{ $view := . -}}
{{ $view.Header }}

/*
#include <stdio.h>
#include <stdlib.h>
#include <gdnative/gdnative.h>
#include <nativescript/godot_nativescript.h>
*/
import "C"

import (
    {{ if $view.Debug }}"log"{{end}}
	"unsafe"
)

// Class is an interface for any objects that can have Godot
// inheritance.
type Class interface {
	baseClass() string
	setOwner(object *C.godot_object)
	getOwner() *C.godot_object
}

{{ range $i, $class := $view.APIs -}}
    {{ if $view.IsValidClass $class.Name $class.BaseClass -}}
        {{ if $class.Singleton -}}
            func newSingleton{{ $view.GoClassName $class.Name }}() *{{ $view.SetClassName $class.Name $class.Singleton}} {
                obj := &{{ $view.SetClassName $class.Name $class.Singleton }}{}
				name := C.CString("{{ $class.Name }}")
				defer C.free(unsafe.Pointer(name))
                ptr := C.godot_global_get_singleton(name)
                obj.owner = (*C.godot_object)(ptr)
                return obj
            }
            /*
            {{ $view.ClassDoc $class.Name }}
            */
            var {{ $view.GoClassName $class.Name }} = newSingleton{{ $view.GoClassName $class.Name }}()
        {{ end }}
        /*
        {{ $view.ClassDoc $class.Name }}
        */
        type {{ $view.SetClassName $class.Name $class.Singleton }} struct {
            {{ $view.SetBaseClassName $class.BaseClass }}
            {{ if eq $class.Name "Object" }}
                owner *C.godot_object
            {{ end }}
        }

        func (o *{{ $view.SetClassName $class.Name $class.Singleton }}) baseClass() string {
            return "{{ $class.Name }}"
        }

        {{ if $class.Methods }}
            {{ range $j, $method := $class.Methods }}
                /*
                {{ $view.MethodDoc $class.Name $method.Name }}
                */
                func (o *{{ $view.SetClassName $class.Name $class.Singleton }}) {{ $view.GoMethodName $method.Name }}({{ range $k, $arg := $method.Arguments }}{{ $view.GoArgName $arg.Name }} {{ $view.GoValue $arg.Type }},{{ end }} {{ if $method.HasVarargs }}varArgs ...interface{}{{end}}) {{ $view.GoValue $method.ReturnType }} {
                    {{ if $view.Debug }}log.Println("Calling {{ $class.Name }}.{{ $view.GoMethodName $method.Name }}()"){{end}}

                    {{ if $method.HasVarargs }}
                    {{ $view.VarargsArrayName }} := NewArray()
                    //for idx, varArg := range varArgs {
                    //    // TODO: populate varargs array once Array methods implemented
                    //    log.Println("Vararg idx=", idx, ": ", varArg)
                    //}
                    {{ end }}
                    {{ if ne $method.ReturnType "void" }}
                        returnValue := {{ $view.GodotCall $method }}
                        {{ if $view.Debug }}log.Println("  Got return value: ", returnValue){{end}}

                        {{ if $view.IsClassType $method.ReturnType }}
                            var ret {{ $method.ReturnType }}
                            ret.owner = returnValue.owner
                            return &ret
                        {{ else }}
                            return returnValue
                        {{ end}}
                    {{else}}
                        {{ $view.GodotCall $method }}
                        {{ if $view.Debug }}log.Println("  Function successfully completed."){{end}}
                    {{ end }}
                }
            {{ end }}
        {{ end }}

        {{ if eq $class.Name "Object" }}
            // SetOwner will internally set the Godot object inside the struct.
            // This is used to call parent methods.
            func (o *Object) setOwner(object *C.godot_object) {
                o.owner = object
            }
            
            func (o *Object) getOwner() *C.godot_object {
                return o.owner
            }
        {{ end }}
        {{ if eq $class.Singleton false -}} 
            /*
            {{ $class.Name }}Implementer is an interface for {{ $class.Name }} objects.
            */
            type {{ $class.Name }}Implementer interface {
                    Class
            }
        {{ end -}}
    {{ end -}}
{{ end }}
